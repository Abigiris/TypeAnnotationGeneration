{
    "adversarialnlp-master/setup.py": {},
    "adversarialnlp-master/adversarialnlp/run.py": {},
    "adversarialnlp-master/adversarialnlp/version.py": {},
    "adversarialnlp-master/adversarialnlp/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/commands/test_install.py": {
        "_get_module_root": {
            "name": "_get_module_root",
            "location": 46,
            "return": [],
            "arguments": {}
        },
        "_run_test": {
            "name": "_run_test",
            "location": 50,
            "return": [],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "TestInstall.add_subparser": {
            "name": "add_subparser",
            "location": 31,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/commands/__init__.py": {
        "main": {
            "name": "main",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "prog": [
                    "str"
                ],
                "subcommand_overrides": [
                    "Dict[(str, Subcommand)]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/common/file_utils.py": {
        "built": {
            "name": "built",
            "location": 74,
            "return": [],
            "arguments": {
                "path": [],
                "version_string": []
            }
        },
        "mark_done": {
            "name": "mark_done",
            "location": 93,
            "return": [],
            "arguments": {
                "path": [],
                "fnames": [],
                "version_string": []
            }
        },
        "download": {
            "name": "download",
            "location": 105,
            "return": [],
            "arguments": {
                "url": [],
                "path": [],
                "fname": [],
                "redownload": []
            }
        },
        "make_dir": {
            "name": "make_dir",
            "location": 180,
            "return": [],
            "arguments": {
                "path": []
            }
        },
        "move": {
            "name": "move",
            "location": 187,
            "return": [],
            "arguments": {
                "path1": [],
                "path2": []
            }
        },
        "remove_dir": {
            "name": "remove_dir",
            "location": 192,
            "return": [],
            "arguments": {
                "path": []
            }
        },
        "untar": {
            "name": "untar",
            "location": 197,
            "return": [],
            "arguments": {
                "path": [],
                "fname": [],
                "deleteTar": []
            }
        },
        "cat": {
            "name": "cat",
            "location": 211,
            "return": [],
            "arguments": {
                "file1": [],
                "file2": [],
                "outfile": [],
                "deleteFiles": []
            }
        },
        "_get_confirm_token": {
            "name": "_get_confirm_token",
            "location": 222,
            "return": [],
            "arguments": {
                "response": []
            }
        },
        "download_from_google_drive": {
            "name": "download_from_google_drive",
            "location": 228,
            "return": [],
            "arguments": {
                "gd_id": [],
                "destination": []
            }
        },
        "download_files": {
            "name": "download_files",
            "location": 249,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "fnames": [
                    "List[Union[(str, Path)]]"
                ],
                "local_folder": [
                    "str"
                ],
                "version": [
                    "str"
                ],
                "paths": [
                    "Union[(List[str], str)]"
                ]
            }
        },
        "ProgressLogger.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [],
            "arguments": {
                "self": [],
                "throttle": [],
                "should_humanize": []
            }
        },
        "ProgressLogger.humanize": {
            "name": "humanize",
            "location": 37,
            "return": [],
            "arguments": {
                "self": [],
                "num": [],
                "suffix": []
            }
        },
        "ProgressLogger.log": {
            "name": "log",
            "location": 47,
            "return": [],
            "arguments": {
                "self": [],
                "curr": [],
                "total": [],
                "width": [],
                "force": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/common/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/generator.py": {
        "Generator.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [],
            "arguments": {
                "self": [],
                "default_seeds": [
                    "Iterable"
                ],
                "quiet": [
                    "bool"
                ]
            }
        },
        "Generator.generate_from_seed": {
            "name": "generate_from_seed",
            "location": 60,
            "return": [],
            "arguments": {
                "self": [],
                "seed": [
                    "any"
                ]
            }
        },
        "Generator.__call__": {
            "name": "__call__",
            "location": 65,
            "return": [
                "Iterable"
            ],
            "arguments": {
                "self": [],
                "seeds": [
                    "Iterable"
                ],
                "num_epochs": [
                    "int"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/addsent/addsent_generator.py": {
        "AddSentGenerator.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [],
            "arguments": {
                "self": [],
                "alteration_strategy": [
                    "str"
                ],
                "prepend": [
                    "bool"
                ],
                "use_answer_placeholder": [
                    "bool"
                ],
                "default_seeds": [
                    "Iterable"
                ],
                "quiet": [
                    "bool"
                ]
            }
        },
        "AddSentGenerator.close": {
            "name": "close",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AddSentGenerator._annotate": {
            "name": "_annotate",
            "location": 89,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "annotators": [
                    "str"
                ]
            }
        },
        "AddSentGenerator._alter_question": {
            "name": "_alter_question",
            "location": 96,
            "return": [],
            "arguments": {
                "self": [],
                "question": [],
                "tokens": [],
                "const_parse": []
            }
        },
        "AddSentGenerator.generate_from_seed": {
            "name": "generate_from_seed",
            "location": 155,
            "return": [],
            "arguments": {
                "self": [],
                "seed": [
                    "Tuple"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/corenlp.py": {
        "StanfordCoreNLP.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [],
            "arguments": {
                "self": [],
                "path_or_host": [],
                "port": [],
                "memory": [],
                "lang": [],
                "timeout": [],
                "quiet": [],
                "logging_level": [],
                "max_retries": []
            }
        },
        "StanfordCoreNLP.__enter__": {
            "name": "__enter__",
            "location": 130,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "StanfordCoreNLP.__exit__": {
            "name": "__exit__",
            "location": 133,
            "return": [],
            "arguments": {
                "self": [],
                "exc_type": [],
                "exc_val": [],
                "exc_tb": []
            }
        },
        "StanfordCoreNLP.close": {
            "name": "close",
            "location": 136,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "StanfordCoreNLP.annotate": {
            "name": "annotate",
            "location": 159,
            "return": [],
            "arguments": {
                "self": [],
                "text": [],
                "properties": []
            }
        },
        "StanfordCoreNLP.tregex": {
            "name": "tregex",
            "location": 167,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": [],
                "pattern": []
            }
        },
        "StanfordCoreNLP.tokensregex": {
            "name": "tokensregex",
            "location": 172,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": [],
                "pattern": []
            }
        },
        "StanfordCoreNLP.semgrex": {
            "name": "semgrex",
            "location": 177,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": [],
                "pattern": []
            }
        },
        "StanfordCoreNLP.word_tokenize": {
            "name": "word_tokenize",
            "location": 182,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": [],
                "span": []
            }
        },
        "StanfordCoreNLP.pos_tag": {
            "name": "pos_tag",
            "location": 194,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        },
        "StanfordCoreNLP.ner": {
            "name": "ner",
            "location": 204,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        },
        "StanfordCoreNLP.parse": {
            "name": "parse",
            "location": 214,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        },
        "StanfordCoreNLP.dependency_parse": {
            "name": "dependency_parse",
            "location": 218,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        },
        "StanfordCoreNLP.coref": {
            "name": "coref",
            "location": 223,
            "return": [],
            "arguments": {
                "self": [],
                "text": []
            }
        },
        "StanfordCoreNLP.switch_language": {
            "name": "switch_language",
            "location": 234,
            "return": [],
            "arguments": {
                "self": [],
                "language": []
            }
        },
        "StanfordCoreNLP._request": {
            "name": "_request",
            "location": 238,
            "return": [],
            "arguments": {
                "self": [],
                "url": [],
                "annotators": [],
                "data": []
            }
        },
        "StanfordCoreNLP._check_args": {
            "name": "_check_args",
            "location": 253,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "StanfordCoreNLP._check_language": {
            "name": "_check_language",
            "location": 258,
            "return": [],
            "arguments": {
                "self": [],
                "lang": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/squad_reader.py": {
        "squad_reader": {
            "name": "squad_reader",
            "location": 10,
            "return": [
                "Iterator[List[Tuple[(str, str)]]]"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/utils.py": {
        "rejoin": {
            "name": "rejoin",
            "location": 108,
            "return": [
                "str"
            ],
            "arguments": {
                "tokens": [
                    "List[Dict[(str, str)]]"
                ],
                "sep": [
                    "str"
                ]
            }
        },
        "get_tokens_for_answers": {
            "name": "get_tokens_for_answers",
            "location": 125,
            "return": [
                "Tuple[(int, List)]"
            ],
            "arguments": {
                "answer_objs": [
                    "List[Tuple[(int, Dict)]]"
                ],
                "corenlp_obj": [
                    "Dict"
                ]
            }
        },
        "get_determiner_for_answers": {
            "name": "get_determiner_for_answers",
            "location": 148,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "answer_objs": [
                    "List[Dict]"
                ]
            }
        },
        "compress_whnp": {
            "name": "compress_whnp",
            "location": 157,
            "return": [],
            "arguments": {
                "tree": [],
                "inside_whnp": []
            }
        },
        "read_const_parse": {
            "name": "read_const_parse",
            "location": 195,
            "return": [],
            "arguments": {
                "parse_str": []
            }
        },
        "ConstituencyParse.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [],
            "arguments": {
                "self": [],
                "tag": [],
                "children": [],
                "word": [],
                "index": []
            }
        },
        "ConstituencyParse._recursive_parse_corenlp": {
            "name": "_recursive_parse_corenlp",
            "location": 20,
            "return": [],
            "arguments": {
                "cls": [],
                "tokens": [],
                "i": [],
                "j": []
            }
        },
        "ConstituencyParse.from_corenlp": {
            "name": "from_corenlp",
            "location": 41,
            "return": [],
            "arguments": {
                "cls": [],
                "s": []
            }
        },
        "ConstituencyParse.is_singleton": {
            "name": "is_singleton",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse.print_tree": {
            "name": "print_tree",
            "location": 58,
            "return": [],
            "arguments": {
                "self": [],
                "indent": []
            }
        },
        "ConstituencyParse.get_phrase": {
            "name": "get_phrase",
            "location": 67,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse.get_start_index": {
            "name": "get_start_index",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse.get_end_index": {
            "name": "get_end_index",
            "location": 84,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse._recursive_replace_words": {
            "name": "_recursive_replace_words",
            "location": 90,
            "return": [],
            "arguments": {
                "cls": [],
                "tree": [],
                "new_words": [],
                "i": []
            }
        },
        "ConstituencyParse.replace_words": {
            "name": "replace_words",
            "location": 101,
            "return": [],
            "arguments": {
                "cls": [],
                "tree": [],
                "new_words": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/alteration_rules.py": {
        "alter_special": {
            "name": "alter_special",
            "location": 18,
            "return": [],
            "arguments": {
                "token": []
            }
        },
        "alter_nearby": {
            "name": "alter_nearby",
            "location": 24,
            "return": [],
            "arguments": {
                "pos_list": [],
                "ignore_pos": [],
                "is_ner": []
            }
        },
        "alter_entity_glove": {
            "name": "alter_entity_glove",
            "location": 48,
            "return": [],
            "arguments": {
                "token": [],
                "nearby_word_dict": []
            }
        },
        "alter_entity_type": {
            "name": "alter_entity_type",
            "location": 62,
            "return": [],
            "arguments": {
                "token": []
            }
        },
        "alter_wordnet_antonyms": {
            "name": "alter_wordnet_antonyms",
            "location": 88,
            "return": [],
            "arguments": {
                "token": []
            }
        },
        "alter_nearby.func": {
            "name": "func",
            "location": 25,
            "return": [],
            "arguments": {
                "token": [],
                "nearby_word_dict": [],
                "postag_dict": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/answer_rules.py": {
        "ans_number": {
            "name": "ans_number",
            "location": 8,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_date": {
            "name": "ans_date",
            "location": 78,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_entity_full": {
            "name": "ans_entity_full",
            "location": 104,
            "return": [],
            "arguments": {
                "ner_tag": [],
                "new_ans": []
            }
        },
        "ans_abbrev": {
            "name": "ans_abbrev",
            "location": 112,
            "return": [],
            "arguments": {
                "new_ans": []
            }
        },
        "ans_match_wh": {
            "name": "ans_match_wh",
            "location": 120,
            "return": [],
            "arguments": {
                "wh_word": [],
                "new_ans": []
            }
        },
        "ans_pos": {
            "name": "ans_pos",
            "location": 128,
            "return": [],
            "arguments": {
                "pos": [],
                "new_ans": [],
                "end": [],
                "add_dt": []
            }
        },
        "ans_catch_all": {
            "name": "ans_catch_all",
            "location": 142,
            "return": [],
            "arguments": {
                "new_ans": []
            }
        },
        "ans_entity_full.func": {
            "name": "func",
            "location": 106,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_abbrev.func": {
            "name": "func",
            "location": 113,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_match_wh.func": {
            "name": "func",
            "location": 122,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_pos.func": {
            "name": "func",
            "location": 130,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": [],
                "determiner": []
            }
        },
        "ans_catch_all.func": {
            "name": "func",
            "location": 143,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/conversion_rules.py": {
        "_check_match": {
            "name": "_check_match",
            "location": 25,
            "return": [],
            "arguments": {
                "node": [],
                "pattern_tok": []
            }
        },
        "_recursive_match_pattern": {
            "name": "_recursive_match_pattern",
            "location": 41,
            "return": [],
            "arguments": {
                "pattern_toks": [],
                "stack": [],
                "matches": []
            }
        },
        "match_pattern": {
            "name": "match_pattern",
            "location": 65,
            "return": [],
            "arguments": {
                "pattern": [],
                "const_parse": []
            }
        },
        "run_postprocessing": {
            "name": "run_postprocessing",
            "location": 78,
            "return": [],
            "arguments": {
                "s": [],
                "rules": [],
                "all_args": []
            }
        },
        "convert_whp": {
            "name": "convert_whp",
            "location": 97,
            "return": [],
            "arguments": {
                "node": [],
                "q": [],
                "a": [],
                "tokens": [],
                "quiet": []
            }
        },
        "fix_style": {
            "name": "fix_style",
            "location": 111,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "ConversionRule.convert": {
            "name": "convert",
            "location": 120,
            "return": [],
            "arguments": {
                "self": [],
                "q": [],
                "a": [],
                "tokens": [],
                "const_parse": [],
                "run_fix_style": []
            }
        },
        "ConstituencyRule.__init__": {
            "name": "__init__",
            "location": 125,
            "return": [],
            "arguments": {
                "self": [],
                "in_pattern": [],
                "out_pattern": [],
                "postproc": []
            }
        },
        "ConstituencyRule.convert": {
            "name": "convert",
            "location": 135,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [],
                "a": [],
                "tokens": [],
                "const_parse": [],
                "run_fix_style": []
            }
        },
        "ConstituencyRule.gen_output": {
            "name": "gen_output",
            "location": 175,
            "return": [],
            "arguments": {
                "self": [],
                "fmt_args": []
            }
        },
        "ReplaceRule.__init__": {
            "name": "__init__",
            "location": 181,
            "return": [],
            "arguments": {
                "self": [],
                "target": [],
                "replacement": [],
                "start": []
            }
        },
        "ReplaceRule.convert": {
            "name": "convert",
            "location": 187,
            "return": [],
            "arguments": {
                "self": [],
                "q": [],
                "a": [],
                "tokens": [],
                "const_parse": [],
                "run_fix_style": []
            }
        },
        "FindWHPRule._recursive_convert": {
            "name": "_recursive_convert",
            "location": 205,
            "return": [],
            "arguments": {
                "self": [],
                "node": [],
                "q": [],
                "a": [],
                "tokens": [],
                "found_whp": []
            }
        },
        "FindWHPRule.convert": {
            "name": "convert",
            "location": 224,
            "return": [],
            "arguments": {
                "self": [],
                "q": [],
                "a": [],
                "tokens": [],
                "const_parse": [],
                "run_fix_style": []
            }
        },
        "AnswerRule.convert": {
            "name": "convert",
            "location": 235,
            "return": [],
            "arguments": {
                "self": [],
                "q": [],
                "a": [],
                "tokens": [],
                "const_parse": [],
                "run_fix_style": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/swag/activitynet_captions_reader.py": {
        "ActivityNetCaptionsDatasetReader.__init__": {
            "name": "__init__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool"
                ],
                "tokenizer": [
                    "Tokenizer"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ]
            }
        },
        "ActivityNetCaptionsDatasetReader._read": {
            "name": "_read",
            "location": 64,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "ActivityNetCaptionsDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 75,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "video_id": [
                    "str"
                ],
                "first_sentence": [
                    "str"
                ],
                "second_sentence": [
                    "str"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/openai_transformer_model.py": {
        "OpenAITransformerLanguageModel.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "openai_token_embedder": [
                    "OpenaiTransformerEmbedder"
                ],
                "remove_bos_eos": [
                    "bool"
                ]
            }
        },
        "OpenAITransformerLanguageModel._get_target_token_embedding": {
            "name": "_get_target_token_embedding",
            "location": 38,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "token_embeddings": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ],
                "direction": [
                    "int"
                ]
            }
        },
        "OpenAITransformerLanguageModel._compute_loss": {
            "name": "_compute_loss",
            "location": 51,
            "return": [
                "Tuple[(torch.Tensor, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "lm_embeddings": [
                    "torch.Tensor"
                ],
                "token_embeddings": [
                    "torch.Tensor"
                ],
                "forward_targets": [
                    "torch.Tensor"
                ],
                "backward_targets": [
                    "torch.Tensor"
                ]
            }
        },
        "OpenAITransformerLanguageModel.forward": {
            "name": "forward",
            "location": 89,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "source": [
                    "Dict[(str, torch.LongTensor)]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/simple_bilm.py": {
        "_de_duplicate_generations": {
            "name": "_de_duplicate_generations",
            "location": 23,
            "return": [],
            "arguments": {
                "generations": []
            }
        },
        "StackedLstm.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "use_highway": [
                    "bool"
                ],
                "use_input_projection_bias": [
                    "bool"
                ],
                "go_forward": [
                    "bool"
                ]
            }
        },
        "StackedLstm.forward": {
            "name": "forward",
            "location": 97,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ],
                "initial_state": [
                    "Optional[Tuple[(torch.Tensor, torch.Tensor)]]"
                ]
            }
        },
        "SimpleBiLM.__init__": {
            "name": "__init__",
            "location": 139,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "embedding_dropout_probability": [
                    "float"
                ],
                "input_size": [],
                "hidden_size": []
            }
        },
        "SimpleBiLM.embed_words": {
            "name": "embed_words",
            "location": 174,
            "return": [],
            "arguments": {
                "self": [],
                "words": []
            }
        },
        "SimpleBiLM.timestep_to_ids": {
            "name": "timestep_to_ids",
            "location": 190,
            "return": [],
            "arguments": {
                "self": [],
                "timestep_tokenized": [
                    "List[str]"
                ]
            }
        },
        "SimpleBiLM.batch_to_ids": {
            "name": "batch_to_ids",
            "location": 194,
            "return": [],
            "arguments": {
                "self": [],
                "stories_tokenized": [
                    "List[List[str]]"
                ]
            }
        },
        "SimpleBiLM.conditional_generation": {
            "name": "conditional_generation",
            "location": 209,
            "return": [],
            "arguments": {
                "self": [],
                "context": [
                    "List[str]"
                ],
                "gt_completion": [
                    "List[str]"
                ],
                "batch_size": [
                    "int"
                ],
                "max_gen_length": [
                    "int"
                ],
                "same_length_as_gt": [
                    "bool"
                ],
                "first_is_gold": [
                    "bool"
                ]
            }
        },
        "SimpleBiLM._chunked_logsoftmaxes": {
            "name": "_chunked_logsoftmaxes",
            "location": 280,
            "return": [],
            "arguments": {
                "self": [],
                "activation": [],
                "word_targets": [],
                "chunk_size": []
            }
        },
        "SimpleBiLM.forward": {
            "name": "forward",
            "location": 302,
            "return": [
                "Dict[(str, Union[(torch.Tensor, List[torch.Tensor])])]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "torch.Tensor"
                ],
                "use_forward": [
                    "bool"
                ],
                "use_reverse": [
                    "bool"
                ],
                "compute_logprobs": [
                    "bool"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/swag_generator.py": {
        "SwagGenerator.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [],
            "arguments": {
                "self": [],
                "default_seeds": [
                    "Iterable"
                ],
                "quiet": [
                    "bool"
                ]
            }
        },
        "SwagGenerator._find_VP": {
            "name": "_find_VP",
            "location": 77,
            "return": [
                "List[Tuple[(str, any)]]"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "JsonDict"
                ]
            }
        },
        "SwagGenerator._split_on_final_vp": {
            "name": "_split_on_final_vp",
            "location": 112,
            "return": [
                "(List[str], List[str])"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "Instance"
                ]
            }
        },
        "SwagGenerator.generate_from_seed": {
            "name": "generate_from_seed",
            "location": 125,
            "return": [],
            "arguments": {
                "self": [],
                "seed": [
                    "Tuple"
                ]
            }
        },
        "SwagGenerator._find_VP._recurse_on_children": {
            "name": "_recurse_on_children",
            "location": 81,
            "return": [],
            "arguments": {}
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/utils.py": {
        "optimistic_restore": {
            "name": "optimistic_restore",
            "location": 6,
            "return": [],
            "arguments": {
                "network": [],
                "state_dict": []
            }
        },
        "pairwise": {
            "name": "pairwise",
            "location": 27,
            "return": [],
            "arguments": {
                "iterable": []
            }
        },
        "n2w_1k": {
            "name": "n2w_1k",
            "location": 33,
            "return": [],
            "arguments": {
                "num": [],
                "use_ordinal": []
            }
        },
        "postprocess": {
            "name": "postprocess",
            "location": 38,
            "return": [],
            "arguments": {
                "sentence": []
            }
        },
        "remove_allcaps": {
            "name": "remove_allcaps",
            "location": 69,
            "return": [],
            "arguments": {
                "sent": []
            }
        },
        "remove_allcaps._sanitize": {
            "name": "_sanitize",
            "location": 76,
            "return": [],
            "arguments": {
                "word": [],
                "is_first": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/pruners/pruner.py": {
        "Pruner.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/pruners/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/tests/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/tests/dataset_readers/activitynet_captions_test.py": {
        "TestActivityNetCaptionsReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 11,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/tests/dataset_readers/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/tests/generators/addsent_generator_test.py": {
        "TestSwagGenerator.test_yield_one_epoch_generation_over_the_data_once": {
            "name": "test_yield_one_epoch_generation_over_the_data_once",
            "location": 55,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/tests/generators/swag_generator_test.py": {
        "GeneratorTest.setUp": {
            "name": "setUp",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "GeneratorTest.create_instance": {
            "name": "create_instance",
            "location": 44,
            "return": [],
            "arguments": {
                "self": [],
                "first_sentence": [
                    "List[str]"
                ],
                "second_sentence": [
                    "List[str]"
                ]
            }
        },
        "GeneratorTest.assert_instances_are_correct": {
            "name": "assert_instances_are_correct",
            "location": 51,
            "return": [],
            "arguments": {
                "self": [],
                "candidate_instances": []
            }
        },
        "TestSwagGenerator.test_yield_one_epoch_generation_over_the_data_once": {
            "name": "test_yield_one_epoch_generation_over_the_data_once",
            "location": 63,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "GeneratorTest.setUp.LazyIterable.__iter__": {
            "name": "__iter__",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/tests/generators/__init__.py": {},
    "adversarialnlp-master/docs/conf.py": {},
    "adversarialnlp-master/tutorials/usage.py": {}
}
{
    "alibi-master/setup.py": {
        "readme": {
            "name": "readme",
            "location": 4,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/exceptions.py": {
        "AlibiException.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/saving.py": {
        "load_explainer": {
            "name": "load_explainer",
            "location": 42,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": []
            }
        },
        "save_explainer": {
            "name": "save_explainer",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'Explainer'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_simple_save": {
            "name": "_simple_save",
            "location": 109,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'Explainer'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_simple_load": {
            "name": "_simple_load",
            "location": 117,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [],
                "meta": []
            }
        },
        "_load_IntegratedGradients": {
            "name": "_load_IntegratedGradients",
            "location": 124,
            "return": [
                "'IntegratedGradients'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "'Union[tensorflow.keras.Model]'"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "_save_IntegratedGradients": {
            "name": "_save_IntegratedGradients",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'IntegratedGradients'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_load_AnchorImage": {
            "name": "_load_AnchorImage",
            "location": 150,
            "return": [
                "'AnchorImage'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Callable"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "_save_AnchorImage": {
            "name": "_save_AnchorImage",
            "location": 164,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'AnchorImage'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_load_AnchorText": {
            "name": "_load_AnchorText",
            "location": 179,
            "return": [
                "'AnchorText'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Callable"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "_save_AnchorText": {
            "name": "_save_AnchorText",
            "location": 211,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'AnchorText'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_save_KernelShap": {
            "name": "_save_KernelShap",
            "location": 235,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'KernelShap'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_save_TreelShap": {
            "name": "_save_TreelShap",
            "location": 240,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'TreeShap'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_save_CounterfactualRL": {
            "name": "_save_CounterfactualRL",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'CounterfactualRL'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_helper_load_CounterfactualRL": {
            "name": "_helper_load_CounterfactualRL",
            "location": 306,
            "return": [],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Callable"
                ],
                "explainer": []
            }
        },
        "_load_CounterfactualRL": {
            "name": "_load_CounterfactualRL",
            "location": 326,
            "return": [
                "'CounterfactualRL'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Callable"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "_save_CounterfactualRLTabular": {
            "name": "_save_CounterfactualRLTabular",
            "location": 351,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'CounterfactualRL'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_load_CounterfactualRLTabular": {
            "name": "_load_CounterfactualRLTabular",
            "location": 355,
            "return": [
                "'CounterfactualRLTabular'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Callable"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "_save_SimilarityExplainer": {
            "name": "_save_SimilarityExplainer",
            "location": 380,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "'GradientSimilarity'"
                ],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_load_SimilarityExplainer": {
            "name": "_load_SimilarityExplainer",
            "location": 390,
            "return": [
                "'GradientSimilarity'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "_save_ProtoSelect": {
            "name": "_save_ProtoSelect",
            "location": 401,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "_load_ProtoSelect": {
            "name": "_load_ProtoSelect",
            "location": 405,
            "return": [
                "'ProtoSelect'"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "meta": [
                    "dict"
                ]
            }
        },
        "NumpyEncoder.default": {
            "name": "default",
            "location": 410,
            "return": [],
            "arguments": {
                "self": [],
                "obj": []
            }
        }
    },
    "alibi-master/alibi/version.py": {},
    "alibi-master/alibi/__init__.py": {},
    "alibi-master/alibi/api/defaults.py": {},
    "alibi-master/alibi/api/interfaces.py": {
        "default_meta": {
            "name": "default_meta",
            "location": 19,
            "return": [
                "dict"
            ],
            "arguments": {}
        },
        "AlibiPrettyPrinter.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AlibiPrettyPrinter._pprint_dict": {
            "name": "_pprint_dict",
            "location": 42,
            "return": [],
            "arguments": {
                "self": [],
                "object": [],
                "stream": [],
                "indent": [],
                "allowance": [],
                "context": [],
                "level": []
            }
        },
        "Base.__attrs_post_init__": {
            "name": "__attrs_post_init__",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Base._update_metadata": {
            "name": "_update_metadata",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dict": [
                    "dict"
                ],
                "params": [
                    "bool"
                ]
            }
        },
        "Explainer.explain": {
            "name": "explain",
            "location": 109,
            "return": [
                "'Explanation'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Any"
                ]
            }
        },
        "Explainer.load": {
            "name": "load",
            "location": 113,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "cls": [],
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Any"
                ]
            }
        },
        "Explainer.reset_predictor": {
            "name": "reset_predictor",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Any"
                ]
            }
        },
        "Explainer.save": {
            "name": "save",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "Summariser.summarise": {
            "name": "summarise",
            "location": 159,
            "return": [
                "'Explanation'"
            ],
            "arguments": {
                "self": [],
                "num_prototypes": [
                    "int"
                ]
            }
        },
        "Summariser.load": {
            "name": "load",
            "location": 163,
            "return": [
                "'Summariser'"
            ],
            "arguments": {
                "cls": [],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "Summariser.save": {
            "name": "save",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "FitMixin.fit": {
            "name": "fit",
            "location": 172,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Any"
                ]
            }
        },
        "Explanation.__attrs_post_init__": {
            "name": "__attrs_post_init__",
            "location": 184,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Explanation.to_json": {
            "name": "to_json",
            "location": 191,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Explanation.from_json": {
            "name": "from_json",
            "location": 202,
            "return": [
                "'Explanation'"
            ],
            "arguments": {
                "cls": [],
                "jsonrepr": []
            }
        },
        "Explanation.__getitem__": {
            "name": "__getitem__",
            "location": 223,
            "return": [],
            "arguments": {
                "self": [],
                "item": []
            }
        }
    },
    "alibi-master/alibi/api/__init__.py": {},
    "alibi-master/alibi/api/tests/test_interfaces.py": {
        "test_incomplete_explainer": {
            "name": "test_incomplete_explainer",
            "location": 50,
            "return": [],
            "arguments": {}
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 55,
            "return": [],
            "arguments": {}
        },
        "test_explainer_with_init": {
            "name": "test_explainer_with_init",
            "location": 61,
            "return": [],
            "arguments": {}
        },
        "test_explainer_valid_meta": {
            "name": "test_explainer_valid_meta",
            "location": 67,
            "return": [],
            "arguments": {}
        },
        "test_incomplete_fitexplainer": {
            "name": "test_incomplete_fitexplainer",
            "location": 72,
            "return": [],
            "arguments": {}
        },
        "test_fitexplainer": {
            "name": "test_fitexplainer",
            "location": 77,
            "return": [],
            "arguments": {}
        },
        "test_explanation": {
            "name": "test_explanation",
            "location": 83,
            "return": [],
            "arguments": {}
        },
        "test_serialize_deserialize_explanation": {
            "name": "test_serialize_deserialize_explanation",
            "location": 95,
            "return": [],
            "arguments": {}
        },
        "test__update_metadata": {
            "name": "test__update_metadata",
            "location": 103,
            "return": [],
            "arguments": {
                "data_dict": []
            }
        },
        "test__update_metatada_params": {
            "name": "test__update_metatada_params",
            "location": 111,
            "return": [],
            "arguments": {
                "data_dict": []
            }
        },
        "SimpleExplainer.explain": {
            "name": "explain",
            "location": 23,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "SimpleExplainerWithInit.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleExplainerWithInit.explain": {
            "name": "explain",
            "location": 33,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "IncompleteFitExplainer.explain": {
            "name": "explain",
            "location": 38,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "SimpleFitExplainer.fit": {
            "name": "fit",
            "location": 43,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "SimpleFitExplainer.explain": {
            "name": "explain",
            "location": 46,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/api/tests/__init__.py": {},
    "alibi-master/alibi/confidence/model_linearity.py": {
        "_linear_superposition": {
            "name": "_linear_superposition",
            "location": 13,
            "return": [],
            "arguments": {
                "alphas": [],
                "vecs": [],
                "shape": []
            }
        },
        "_calculate_global_linearity": {
            "name": "_calculate_global_linearity",
            "location": 34,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable"
                ],
                "input_shape": [
                    "Tuple"
                ],
                "X_samples": [
                    "np.ndarray"
                ],
                "model_type": [
                    "str"
                ],
                "alphas": [
                    "np.ndarray"
                ]
            }
        },
        "_calculate_pairwise_linearity": {
            "name": "_calculate_pairwise_linearity",
            "location": 106,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable"
                ],
                "x": [
                    "np.ndarray"
                ],
                "input_shape": [
                    "Tuple"
                ],
                "X_samples": [
                    "np.ndarray"
                ],
                "model_type": [
                    "str"
                ],
                "alphas": [
                    "np.ndarray"
                ]
            }
        },
        "_sample_knn": {
            "name": "_sample_knn",
            "location": 187,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ],
                "X_train": [
                    "np.ndarray"
                ],
                "nb_samples": [
                    "int"
                ]
            }
        },
        "_sample_grid": {
            "name": "_sample_grid",
            "location": 222,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ],
                "feature_range": [
                    "np.ndarray"
                ],
                "epsilon": [
                    "float"
                ],
                "nb_samples": [
                    "int"
                ],
                "res": [
                    "int"
                ]
            }
        },
        "_linearity_measure": {
            "name": "_linearity_measure",
            "location": 263,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable"
                ],
                "x": [
                    "np.ndarray"
                ],
                "X_train": [
                    "Optional[np.ndarray]"
                ],
                "feature_range": [
                    "Optional[Union[(List, np.ndarray)]]"
                ],
                "method": [
                    "Optional[str]"
                ],
                "epsilon": [
                    "float"
                ],
                "nb_samples": [
                    "int"
                ],
                "res": [
                    "int"
                ],
                "alphas": [
                    "Optional[np.ndarray]"
                ],
                "model_type": [
                    "str"
                ],
                "agg": [
                    "str"
                ]
            }
        },
        "infer_feature_range": {
            "name": "infer_feature_range",
            "location": 336,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X_train": [
                    "np.ndarray"
                ]
            }
        },
        "linearity_measure": {
            "name": "linearity_measure",
            "location": 444,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable"
                ],
                "x": [
                    "np.ndarray"
                ],
                "feature_range": [
                    "Optional[Union[(List, np.ndarray)]]"
                ],
                "method": [
                    "str"
                ],
                "X_train": [
                    "Optional[np.ndarray]"
                ],
                "epsilon": [
                    "float"
                ],
                "nb_samples": [
                    "int"
                ],
                "res": [
                    "int"
                ],
                "alphas": [
                    "Optional[np.ndarray]"
                ],
                "agg": [
                    "str"
                ],
                "model_type": [
                    "str"
                ]
            }
        },
        "LinearityMeasure.__init__": {
            "name": "__init__",
            "location": 354,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "method": [
                    "str"
                ],
                "epsilon": [
                    "float"
                ],
                "nb_samples": [
                    "int"
                ],
                "res": [
                    "int"
                ],
                "alphas": [
                    "Optional[np.ndarray]"
                ],
                "model_type": [
                    "str"
                ],
                "agg": [
                    "str"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "LinearityMeasure.fit": {
            "name": "fit",
            "location": 392,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X_train": [
                    "np.ndarray"
                ]
            }
        },
        "LinearityMeasure.score": {
            "name": "score",
            "location": 406,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "predict_fn": [
                    "Callable"
                ],
                "x": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/confidence/trustscore.py": {
        "TrustScore.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k_filter": [
                    "int"
                ],
                "alpha": [
                    "float"
                ],
                "filter_type": [
                    "Optional[str]"
                ],
                "leaf_size": [
                    "int"
                ],
                "metric": [
                    "str"
                ],
                "dist_filter_type": [
                    "str"
                ]
            }
        },
        "TrustScore.filter_by_distance_knn": {
            "name": "filter_by_distance_knn",
            "location": 47,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "TrustScore.filter_by_probability_knn": {
            "name": "filter_by_probability_knn",
            "location": 71,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "TrustScore.fit": {
            "name": "fit",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "classes": [
                    "Optional[int]"
                ]
            }
        },
        "TrustScore.score": {
            "name": "score",
            "location": 149,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "k": [
                    "int"
                ],
                "dist_type": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/confidence/__init__.py": {},
    "alibi-master/alibi/confidence/tests/test_model_linearity.py": {
        "test_linear_superposition": {
            "name": "test_linear_superposition",
            "location": 13,
            "return": [],
            "arguments": {
                "input_shape": [],
                "nb_instances": []
            }
        },
        "test_sample_knn": {
            "name": "test_sample_knn",
            "location": 33,
            "return": [],
            "arguments": {
                "nb_instances": [],
                "nb_samples": []
            }
        },
        "test_sample_grid": {
            "name": "test_sample_grid",
            "location": 49,
            "return": [],
            "arguments": {
                "nb_instances": [],
                "nb_samples": [],
                "input_shape": []
            }
        },
        "test_linearity_measure_class": {
            "name": "test_linearity_measure_class",
            "location": 66,
            "return": [],
            "arguments": {
                "method": [],
                "epsilon": [],
                "res": [],
                "nb_instances": [],
                "agg": []
            }
        },
        "test_linearity_measure_reg": {
            "name": "test_linearity_measure_reg",
            "location": 96,
            "return": [],
            "arguments": {
                "method": [],
                "epsilon": [],
                "res": [],
                "nb_instances": [],
                "agg": []
            }
        },
        "test_LinearityMeasure_class": {
            "name": "test_LinearityMeasure_class",
            "location": 157,
            "return": [],
            "arguments": {
                "method": [],
                "epsilon": [],
                "res": [],
                "nb_instances": [],
                "agg": []
            }
        },
        "test_LinearityMeasure_reg": {
            "name": "test_LinearityMeasure_reg",
            "location": 182,
            "return": [],
            "arguments": {
                "method": [],
                "epsilon": [],
                "res": [],
                "nb_instances": [],
                "agg": []
            }
        },
        "test_linearity_measure_class.predict_fn": {
            "name": "predict_fn",
            "location": 76,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_linearity_measure_reg.predict_fn_svr": {
            "name": "predict_fn_svr",
            "location": 107,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_linearity_measure_reg.predict_fn": {
            "name": "predict_fn",
            "location": 110,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_linearity_measure_reg.predict_fn_multi": {
            "name": "predict_fn_multi",
            "location": 141,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_LinearityMeasure_class.predict_fn": {
            "name": "predict_fn",
            "location": 167,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_LinearityMeasure_reg.predict_fn": {
            "name": "predict_fn",
            "location": 191,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_LinearityMeasure_reg.predict_fn_multi": {
            "name": "predict_fn_multi",
            "location": 198,
            "return": [],
            "arguments": {
                "x": []
            }
        }
    },
    "alibi-master/alibi/confidence/tests/test_trustscore.py": {
        "test_trustscore": {
            "name": "test_trustscore",
            "location": 10,
            "return": [],
            "arguments": {
                "filter_type": []
            }
        }
    },
    "alibi-master/alibi/confidence/tests/__init__.py": {},
    "alibi-master/alibi/datasets/default.py": {
        "fetch_imagenet_10": {
            "name": "fetch_imagenet_10",
            "location": 32,
            "return": [
                "Dict"
            ],
            "arguments": {
                "url_id": [
                    "int"
                ]
            }
        },
        "load_cats": {
            "name": "load_cats",
            "location": 75,
            "return": [
                "Union[(Bunch, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "target_size": [
                    "tuple"
                ],
                "return_X_y": [
                    "bool"
                ]
            }
        },
        "fetch_imagenet": {
            "name": "fetch_imagenet",
            "location": 123,
            "return": [
                "None"
            ],
            "arguments": {
                "category": [
                    "str"
                ],
                "nb_images": [
                    "int"
                ],
                "target_size": [
                    "tuple"
                ],
                "min_std": [
                    "float"
                ],
                "seed": [
                    "int"
                ],
                "return_X_y": [
                    "bool"
                ]
            }
        },
        "fetch_movie_sentiment": {
            "name": "fetch_movie_sentiment",
            "location": 130,
            "return": [
                "Union[(Bunch, Tuple[(list, list)])]"
            ],
            "arguments": {
                "return_X_y": [
                    "bool"
                ],
                "url_id": [
                    "int"
                ]
            }
        },
        "fetch_adult": {
            "name": "fetch_adult",
            "location": 176,
            "return": [
                "Union[(Bunch, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "features_drop": [
                    "Optional[list]"
                ],
                "return_X_y": [
                    "bool"
                ],
                "url_id": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/datasets/tensorflow.py": {
        "fetch_fashion_mnist": {
            "name": "fetch_fashion_mnist",
            "location": 9,
            "return": [
                "Union[(Bunch, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "return_X_y": [
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/datasets/__init__.py": {},
    "alibi-master/alibi/datasets/tests/test_datasets.py": {
        "test_adult": {
            "name": "test_adult",
            "location": 13,
            "return": [],
            "arguments": {
                "return_X_y": []
            }
        },
        "test_movie_sentiment": {
            "name": "test_movie_sentiment",
            "location": 36,
            "return": [],
            "arguments": {
                "return_X_y": []
            }
        },
        "test_cats": {
            "name": "test_cats",
            "location": 55,
            "return": [],
            "arguments": {
                "return_X_y": [],
                "target_size": []
            }
        }
    },
    "alibi-master/alibi/datasets/tests/__init__.py": {},
    "alibi-master/alibi/explainers/ale.py": {
        "get_quantiles": {
            "name": "get_quantiles",
            "location": 261,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "values": [
                    "np.ndarray"
                ],
                "num_quantiles": [
                    "int"
                ],
                "interpolation": []
            }
        },
        "bisect_fun": {
            "name": "bisect_fun",
            "location": 282,
            "return": [
                "int"
            ],
            "arguments": {
                "fun": [
                    "Callable"
                ],
                "target": [
                    "float"
                ],
                "lo": [
                    "int"
                ],
                "hi": [
                    "int"
                ]
            }
        },
        "minimum_satisfied": {
            "name": "minimum_satisfied",
            "location": 315,
            "return": [
                "int"
            ],
            "arguments": {
                "values": [
                    "np.ndarray"
                ],
                "min_bin_points": [
                    "int"
                ],
                "n": [
                    "int"
                ]
            }
        },
        "adaptive_grid": {
            "name": "adaptive_grid",
            "location": 341,
            "return": [
                "Tuple[(np.ndarray, int)]"
            ],
            "arguments": {
                "values": [
                    "np.ndarray"
                ],
                "min_bin_points": [
                    "int"
                ]
            }
        },
        "ale_num": {
            "name": "ale_num",
            "location": 385,
            "return": [
                "Tuple[(np.ndarray, ...)]"
            ],
            "arguments": {
                "predictor": [
                    "Callable"
                ],
                "X": [
                    "np.ndarray"
                ],
                "feature": [
                    "int"
                ],
                "feature_grid_points": [
                    "Optional[np.ndarray]"
                ],
                "min_bin_points": [
                    "int"
                ],
                "check_feature_resolution": [
                    "bool"
                ],
                "low_resolution_threshold": [
                    "int"
                ],
                "extrapolate_constant": [
                    "bool"
                ],
                "extrapolate_constant_perc": [
                    "float"
                ],
                "extrapolate_constant_min": [
                    "float"
                ]
            }
        },
        "plot_ale": {
            "name": "plot_ale",
            "location": 539,
            "return": [
                "'np.ndarray'"
            ],
            "arguments": {
                "exp": [
                    "Explanation"
                ],
                "features": [
                    "Union[(List[Union[(int, str)]], Literal['all'])]"
                ],
                "targets": [
                    "Union[(List[Union[(int, str)]], Literal['all'])]"
                ],
                "n_cols": [
                    "int"
                ],
                "sharey": [
                    "str"
                ],
                "constant": [
                    "bool"
                ],
                "ax": [
                    "Union[('plt.Axes', np.ndarray, None)]"
                ],
                "line_kw": [
                    "Optional[dict]"
                ],
                "fig_kw": [
                    "Optional[dict]"
                ]
            }
        },
        "_plot_one_ale_num": {
            "name": "_plot_one_ale_num",
            "location": 678,
            "return": [
                "'plt.Axes'"
            ],
            "arguments": {
                "exp": [
                    "Explanation"
                ],
                "feature": [
                    "int"
                ],
                "targets": [
                    "List[int]"
                ],
                "constant": [
                    "bool"
                ],
                "ax": [
                    "'plt.Axes'"
                ],
                "legend": [
                    "bool"
                ],
                "line_kw": [
                    "dict"
                ]
            }
        },
        "ALE.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "feature_names": [
                    "Optional[List[str]]"
                ],
                "target_names": [
                    "Optional[List[str]]"
                ],
                "check_feature_resolution": [
                    "bool"
                ],
                "low_resolution_threshold": [
                    "int"
                ],
                "extrapolate_constant": [
                    "bool"
                ],
                "extrapolate_constant_perc": [
                    "float"
                ],
                "extrapolate_constant_min": [
                    "float"
                ]
            }
        },
        "ALE.explain": {
            "name": "explain",
            "location": 97,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "features": [
                    "Optional[List[int]]"
                ],
                "min_bin_points": [
                    "int"
                ],
                "grid_points": [
                    "Optional[Dict[(int, np.ndarray)]]"
                ]
            }
        },
        "ALE._build_explanation": {
            "name": "_build_explanation",
            "location": 222,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "ale_values": [
                    "List[np.ndarray]"
                ],
                "ale0": [
                    "List[np.ndarray]"
                ],
                "constant_value": [
                    "float"
                ],
                "feature_values": [
                    "List[np.ndarray]"
                ],
                "feature_deciles": [
                    "List[np.ndarray]"
                ],
                "feature_names": [
                    "np.ndarray"
                ]
            }
        },
        "ALE.reset_predictor": {
            "name": "reset_predictor",
            "location": 249,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "adaptive_grid.minimum_not_satisfied": {
            "name": "minimum_not_satisfied",
            "location": 370,
            "return": [
                "int"
            ],
            "arguments": {
                "values": [
                    "np.ndarray"
                ],
                "min_bin_points": [
                    "int"
                ],
                "n": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cem.py": {
        "CEM.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predict": [
                    "Union[(Callable[([np.ndarray], np.ndarray)], tf.keras.Model)]"
                ],
                "mode": [
                    "str"
                ],
                "shape": [
                    "tuple"
                ],
                "kappa": [
                    "float"
                ],
                "beta": [
                    "float"
                ],
                "feature_range": [
                    "tuple"
                ],
                "gamma": [
                    "float"
                ],
                "ae_model": [
                    "Optional[tf.keras.Model]"
                ],
                "learning_rate_init": [
                    "float"
                ],
                "max_iterations": [
                    "int"
                ],
                "c_init": [
                    "float"
                ],
                "c_steps": [
                    "int"
                ],
                "eps": [
                    "tuple"
                ],
                "clip": [
                    "tuple"
                ],
                "update_num_grad": [
                    "int"
                ],
                "no_info_val": [
                    "Optional[Union[(float, np.ndarray)]]"
                ],
                "write_dir": [
                    "Optional[str]"
                ],
                "sess": [
                    "Optional[tf.Session]"
                ]
            }
        },
        "CEM.fit": {
            "name": "fit",
            "location": 299,
            "return": [
                "'CEM'"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "np.ndarray"
                ],
                "no_info_type": [
                    "str"
                ]
            }
        },
        "CEM.loss_fn": {
            "name": "loss_fn",
            "location": 328,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "pred_proba": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "CEM.perturb": {
            "name": "perturb",
            "location": 358,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "eps": [
                    "Union[(float, np.ndarray)]"
                ],
                "proba": [
                    "bool"
                ]
            }
        },
        "CEM.get_gradients": {
            "name": "get_gradients",
            "location": 392,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "CEM.attack": {
            "name": "attack",
            "location": 447,
            "return": [
                "Tuple[(np.ndarray, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "CEM.explain": {
            "name": "explain",
            "location": 657,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "Optional[np.ndarray]"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "CEM.reset_predictor": {
            "name": "reset_predictor",
            "location": 721,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Union[(Callable, tf.keras.Model)]"
                ]
            }
        },
        "CEM.get_gradients.f": {
            "name": "f",
            "location": 413,
            "return": [],
            "arguments": {
                "preds_pert": []
            }
        },
        "CEM.get_gradients.g": {
            "name": "g",
            "location": 416,
            "return": [],
            "arguments": {
                "preds_pert": []
            }
        },
        "CEM.attack.compare": {
            "name": "compare",
            "location": 475,
            "return": [
                "bool"
            ],
            "arguments": {
                "x": [
                    "Union[(float, int, np.ndarray)]"
                ],
                "y": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cfproto.py": {
        "CounterFactualProto": {
            "name": "CounterFactualProto",
            "location": 22,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predict": [
                    "Union[(Callable[([np.ndarray], np.ndarray)], tf.keras.Model)]"
                ],
                "shape": [
                    "tuple"
                ],
                "kappa": [
                    "float"
                ],
                "beta": [
                    "float"
                ],
                "feature_range": [
                    "Tuple[(Union[(float, np.ndarray)], Union[(float, np.ndarray)])]"
                ],
                "gamma": [
                    "float"
                ],
                "ae_model": [
                    "Optional[tf.keras.Model]"
                ],
                "enc_model": [
                    "Optional[tf.keras.Model]"
                ],
                "theta": [
                    "float"
                ],
                "cat_vars": [
                    "Optional[Dict[(int, int)]]"
                ],
                "ohe": [
                    "bool"
                ],
                "use_kdtree": [
                    "bool"
                ],
                "learning_rate_init": [
                    "float"
                ],
                "max_iterations": [
                    "int"
                ],
                "c_init": [
                    "float"
                ],
                "c_steps": [
                    "int"
                ],
                "eps": [
                    "tuple"
                ],
                "clip": [
                    "tuple"
                ],
                "update_num_grad": [
                    "int"
                ],
                "write_dir": [
                    "Optional[str]"
                ],
                "sess": [
                    "Optional[tf.Session]"
                ]
            }
        },
        "CounterfactualProto.fit": {
            "name": "fit",
            "location": 662,
            "return": [
                "'CounterfactualProto'"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "np.ndarray"
                ],
                "trustscore_kwargs": [
                    "Optional[dict]"
                ],
                "d_type": [
                    "str"
                ],
                "w": [
                    "Optional[float]"
                ],
                "disc_perc": [
                    "Sequence[Union[(int, float)]]"
                ],
                "standardize_cat_vars": [
                    "bool"
                ],
                "smooth": [
                    "float"
                ],
                "center": [
                    "bool"
                ],
                "update_feature_range": [
                    "bool"
                ]
            }
        },
        "CounterfactualProto.loss_fn": {
            "name": "loss_fn",
            "location": 819,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "pred_proba": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "CounterfactualProto.get_gradients": {
            "name": "get_gradients",
            "location": 844,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "grads_shape": [
                    "tuple"
                ],
                "cat_vars_ord": [
                    "dict"
                ]
            }
        },
        "CounterfactualProto.score": {
            "name": "score",
            "location": 916,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "adv_class": [
                    "int"
                ],
                "orig_class": [
                    "int"
                ],
                "eps": [
                    "float"
                ]
            }
        },
        "CounterfactualProto.attack": {
            "name": "attack",
            "location": 951,
            "return": [
                "Tuple[(np.ndarray, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "target_class": [
                    "Optional[list]"
                ],
                "k": [
                    "Optional[int]"
                ],
                "k_type": [
                    "str"
                ],
                "threshold": [
                    "float"
                ],
                "verbose": [
                    "bool"
                ],
                "print_every": [
                    "int"
                ],
                "log_every": [
                    "int"
                ]
            }
        },
        "CounterfactualProto.explain": {
            "name": "explain",
            "location": 1275,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "Optional[np.ndarray]"
                ],
                "target_class": [
                    "Optional[list]"
                ],
                "k": [
                    "Optional[int]"
                ],
                "k_type": [
                    "str"
                ],
                "threshold": [
                    "float"
                ],
                "verbose": [
                    "bool"
                ],
                "print_every": [
                    "int"
                ],
                "log_every": [
                    "int"
                ]
            }
        },
        "CounterfactualProto.reset_predictor": {
            "name": "reset_predictor",
            "location": 1385,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Union[(Callable, tf.keras.Model)]"
                ]
            }
        },
        "CounterfactualProto.get_gradients.f": {
            "name": "f",
            "location": 878,
            "return": [],
            "arguments": {
                "preds_pert": []
            }
        },
        "CounterfactualProto.get_gradients.g": {
            "name": "g",
            "location": 881,
            "return": [],
            "arguments": {
                "preds_pert": []
            }
        },
        "CounterfactualProto.attack.compare": {
            "name": "compare",
            "location": 993,
            "return": [
                "bool"
            ],
            "arguments": {
                "x": [
                    "Union[(float, int, np.ndarray)]"
                ],
                "y": [
                    "int"
                ]
            }
        },
        "CounterfactualProto.__init__.is_eq": {
            "name": "is_eq",
            "location": 230,
            "return": [],
            "arguments": {
                "col": [],
                "cat_cols": []
            }
        },
        "CounterfactualProto.__init__.cond_loop": {
            "name": "cond_loop",
            "location": 249,
            "return": [],
            "arguments": {
                "icol": [],
                "iohe": [],
                "icat": [],
                "adv_to_map": [],
                "adv_map": [],
                "map_cols": []
            }
        },
        "CounterfactualProto.__init__.body_ord_to_num": {
            "name": "body_ord_to_num",
            "location": 268,
            "return": [],
            "arguments": {
                "icol": [],
                "iohe": [],
                "icat": [],
                "adv_to_map": [],
                "adv_map": [],
                "map_cols": []
            }
        },
        "CounterfactualProto.__init__.body_num_to_ord": {
            "name": "body_num_to_ord",
            "location": 308,
            "return": [],
            "arguments": {
                "icol": [],
                "iohe": [],
                "icat": [],
                "adv_to_map": [],
                "adv_map": [],
                "map_cols": []
            }
        },
        "CounterfactualProto.__init__.body_ohe_to_num": {
            "name": "body_ohe_to_num",
            "location": 343,
            "return": [],
            "arguments": {
                "icol": [],
                "iohe": [],
                "icat": [],
                "adv_to_map": [],
                "adv_map": [],
                "map_cols": []
            }
        },
        "CounterfactualProto.__init__.body_num_to_ohe": {
            "name": "body_num_to_ohe",
            "location": 387,
            "return": [],
            "arguments": {
                "icol": [],
                "iohe": [],
                "icat": [],
                "adv_to_map": [],
                "adv_map": [],
                "map_cols": []
            }
        },
        "CounterfactualProto.__init__.apply_map": {
            "name": "apply_map",
            "location": 437,
            "return": [],
            "arguments": {
                "adv_to_map": [],
                "to_num": []
            }
        },
        "CounterfactualProto.__init__.body_ord_to_num.true_fn": {
            "name": "true_fn",
            "location": 287,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_ord_to_num.false_fn": {
            "name": "false_fn",
            "location": 295,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ord.true_fn": {
            "name": "true_fn",
            "location": 327,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ord.false_fn": {
            "name": "false_fn",
            "location": 330,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_ohe_to_num.true_fn": {
            "name": "true_fn",
            "location": 369,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_ohe_to_num.false_fn": {
            "name": "false_fn",
            "location": 373,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ohe.true_fn": {
            "name": "true_fn",
            "location": 407,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ohe.false_fn": {
            "name": "false_fn",
            "location": 412,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ohe.while_ohe": {
            "name": "while_ohe",
            "location": 418,
            "return": [],
            "arguments": {
                "i_ohe": [],
                "i_ohe_cat": [],
                "adv_ohe": []
            }
        },
        "CounterfactualProto.__init__.body_num_to_ohe.body_ohe": {
            "name": "body_ohe",
            "location": 421,
            "return": [],
            "arguments": {
                "i_ohe": [],
                "i_ohe_cat": [],
                "adv_ohe": []
            }
        }
    },
    "alibi-master/alibi/explainers/cfrl_base.py": {
        "NormalActionNoise.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mu": [
                    "float"
                ],
                "sigma": [
                    "float"
                ]
            }
        },
        "NormalActionNoise.__call__": {
            "name": "__call__",
            "location": 51,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "NormalActionNoise.__repr__": {
            "name": "__repr__",
            "location": 66,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ReplayBuffer.__init__": {
            "name": "__init__",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "size": [
                    "int"
                ]
            }
        },
        "ReplayBuffer.append": {
            "name": "append",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y_m": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "Z": [
                    "np.ndarray"
                ],
                "Z_cf_tilde": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ],
                "R_tilde": [
                    "np.ndarray"
                ]
            }
        },
        "ReplayBuffer.sample": {
            "name": "sample",
            "location": 172,
            "return": [
                "Dict[(str, Optional[np.ndarray])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CounterfactualRL.__init__": {
            "name": "__init__",
            "location": 332,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "encoder": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "decoder": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "coeff_sparsity": [
                    "float"
                ],
                "coeff_consistency": [
                    "float"
                ],
                "latent_dim": [
                    "Optional[int]"
                ],
                "backend": [
                    "str"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "CounterfactualRL._serialize_params": {
            "name": "_serialize_params",
            "location": 411,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "params": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "CounterfactualRL._get_name": {
            "name": "_get_name",
            "location": 445,
            "return": [
                "str"
            ],
            "arguments": {
                "a": [
                    "Any"
                ]
            }
        },
        "CounterfactualRL._verify_backend": {
            "name": "_verify_backend",
            "location": 468,
            "return": [],
            "arguments": {
                "backend": [
                    "str"
                ]
            }
        },
        "CounterfactualRL._select_backend": {
            "name": "_select_backend",
            "location": 488,
            "return": [],
            "arguments": {
                "self": [],
                "backend": [
                    "str"
                ]
            }
        },
        "CounterfactualRL._validate_kwargs": {
            "name": "_validate_kwargs",
            "location": 501,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ],
                "encoder": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "decoder": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "latent_dim": [
                    "Optional[int]"
                ],
                "coeff_sparsity": [
                    "float"
                ],
                "coeff_consistency": [
                    "float"
                ],
                "backend": [
                    "str"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "CounterfactualRL.load": {
            "name": "load",
            "location": 603,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "cls": [],
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "predictor": [
                    "Any"
                ]
            }
        },
        "CounterfactualRL.reset_predictor": {
            "name": "reset_predictor",
            "location": 606,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Any"
                ]
            }
        },
        "CounterfactualRL.save": {
            "name": "save",
            "location": 618,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "CounterfactualRL.fit": {
            "name": "fit",
            "location": 621,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "CounterfactualRL._validate_target": {
            "name": "_validate_target",
            "location": 750,
            "return": [],
            "arguments": {
                "Y_t": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "CounterfactualRL._validate_condition": {
            "name": "_validate_condition",
            "location": 766,
            "return": [],
            "arguments": {
                "C": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "CounterfactualRL._is_classification": {
            "name": "_is_classification",
            "location": 779,
            "return": [
                "bool"
            ],
            "arguments": {
                "pred": [
                    "np.ndarray"
                ]
            }
        },
        "CounterfactualRL.explain": {
            "name": "explain",
            "location": 794,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "CounterfactualRL._compute_counterfactual": {
            "name": "_compute_counterfactual",
            "location": 870,
            "return": [
                "Dict[(str, Optional[np.ndarray])]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "CounterfactualRL._build_explanation": {
            "name": "_build_explanation",
            "location": 960,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y_m": [
                    "np.ndarray"
                ],
                "X_cf": [
                    "np.ndarray"
                ],
                "Y_m_cf": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "Postprocessing.__call__": {
            "name": "__call__",
            "location": 1009,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X_cf": [
                    "Any"
                ],
                "X": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "Callback.__call__": {
            "name": "__call__",
            "location": 1039,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "step": [
                    "int"
                ],
                "update": [
                    "int"
                ],
                "model": [
                    "CounterfactualRL"
                ],
                "sample": [
                    "Dict[(str, np.ndarray)]"
                ],
                "losses": [
                    "Dict[(str, float)]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cfrl_tabular.py": {
        "SampleTabularPostprocessing.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [],
            "arguments": {
                "self": [],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "stats": [
                    "Dict[(int, Dict[(str, float)])]"
                ]
            }
        },
        "SampleTabularPostprocessing.__call__": {
            "name": "__call__",
            "location": 54,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "self": [],
                "X_cf": [
                    "List[np.ndarray]"
                ],
                "X": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "ConcatTabularPostprocessing.__call__": {
            "name": "__call__",
            "location": 82,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X_cf": [
                    "List[np.ndarray]"
                ],
                "X": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "CounterfactualRLTabular.__init__": {
            "name": "__init__",
            "location": 109,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "encoder": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "decoder": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "encoder_preprocessor": [
                    "Callable"
                ],
                "decoder_inv_preprocessor": [
                    "Callable"
                ],
                "coeff_sparsity": [
                    "float"
                ],
                "coeff_consistency": [
                    "float"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "immutable_features": [
                    "Optional[List[str]]"
                ],
                "ranges": [
                    "Optional[Dict[(str, Tuple[(int, int)])]]"
                ],
                "weight_num": [
                    "float"
                ],
                "weight_cat": [
                    "float"
                ],
                "latent_dim": [
                    "Optional[int]"
                ],
                "backend": [
                    "str"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "CounterfactualRLTabular._select_backend": {
            "name": "_select_backend",
            "location": 229,
            "return": [],
            "arguments": {
                "self": [],
                "backend": []
            }
        },
        "CounterfactualRLTabular._validate_input": {
            "name": "_validate_input",
            "location": 240,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "CounterfactualRLTabular.fit": {
            "name": "fit",
            "location": 259,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "CounterfactualRLTabular.explain": {
            "name": "explain",
            "location": 281,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[List[Dict[(str, List[Union[(str, float)]])]]]"
                ],
                "batch_size": [
                    "int"
                ],
                "diversity": [
                    "bool"
                ],
                "num_samples": [
                    "int"
                ],
                "patience": [
                    "int"
                ],
                "tolerance": [
                    "float"
                ]
            }
        },
        "CounterfactualRLTabular._diversity": {
            "name": "_diversity",
            "location": 390,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[List[Dict[(str, List[Union[(str, float)]])]]]"
                ],
                "num_samples": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ],
                "patience": [
                    "int"
                ],
                "tolerance": [
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/counterfactual.py": {
        "_define_func": {
            "name": "_define_func",
            "location": 15,
            "return": [
                "Tuple[(Callable, Union[(str, int)])]"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable"
                ],
                "pred_class": [
                    "int"
                ],
                "target_class": [
                    "Union[(str, int)]"
                ]
            }
        },
        "CounterFactual": {
            "name": "CounterFactual",
            "location": 64,
            "return": [],
            "arguments": {}
        },
        "_define_func.func": {
            "name": "func",
            "location": 39,
            "return": [],
            "arguments": {
                "X": []
            }
        },
        "Counterfactual.__init__": {
            "name": "__init__",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predict_fn": [
                    "Union[(Callable[([np.ndarray], np.ndarray)], tf.keras.Model)]"
                ],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "distance_fn": [
                    "str"
                ],
                "target_proba": [
                    "float"
                ],
                "target_class": [
                    "Union[(str, int)]"
                ],
                "max_iter": [
                    "int"
                ],
                "early_stop": [
                    "int"
                ],
                "lam_init": [
                    "float"
                ],
                "max_lam_steps": [
                    "int"
                ],
                "tol": [
                    "float"
                ],
                "learning_rate_init": [],
                "feature_range": [
                    "Union[(Tuple, str)]"
                ],
                "eps": [
                    "Union[(float, np.ndarray)]"
                ],
                "init": [
                    "str"
                ],
                "decay": [
                    "bool"
                ],
                "write_dir": [
                    "Optional[str]"
                ],
                "debug": [
                    "bool"
                ],
                "sess": [
                    "Optional[tf.Session]"
                ]
            }
        },
        "Counterfactual._initialize": {
            "name": "_initialize",
            "location": 291,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "Counterfactual.fit": {
            "name": "fit",
            "location": 302,
            "return": [
                "'Counterfactual'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "y": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "Counterfactual.explain": {
            "name": "explain",
            "location": 325,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "Counterfactual._prob_condition": {
            "name": "_prob_condition",
            "location": 378,
            "return": [],
            "arguments": {
                "self": [],
                "X_current": []
            }
        },
        "Counterfactual._update_exp": {
            "name": "_update_exp",
            "location": 381,
            "return": [],
            "arguments": {
                "self": [],
                "i": [],
                "l_step": [],
                "lam": [],
                "cf_found": [],
                "X_current": []
            }
        },
        "Counterfactual._write_tb": {
            "name": "_write_tb",
            "location": 410,
            "return": [],
            "arguments": {
                "self": [],
                "lam": [],
                "lam_lb": [],
                "lam_ub": [],
                "cf_found": [],
                "X_current": []
            }
        },
        "Counterfactual._bisect_lambda": {
            "name": "_bisect_lambda",
            "location": 451,
            "return": [],
            "arguments": {
                "self": [],
                "cf_found": [],
                "l_step": [],
                "lam": [],
                "lam_lb": [],
                "lam_ub": []
            }
        },
        "Counterfactual._minimize_loss": {
            "name": "_minimize_loss",
            "location": 478,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "X_init": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "Counterfactual.reset_predictor": {
            "name": "reset_predictor",
            "location": 631,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Union[(Callable, tf.keras.Model)]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/integrated_gradients.py": {
        "_compute_convergence_delta": {
            "name": "_compute_convergence_delta",
            "location": 19,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "model": [
                    "Union[tf.keras.models.Model]"
                ],
                "input_dtypes": [
                    "List[tf.DType]"
                ],
                "attributions": [
                    "List[np.ndarray]"
                ],
                "start_point": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ],
                "end_point": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ],
                "_is_list": [
                    "bool"
                ]
            }
        },
        "_select_target": {
            "name": "_select_target",
            "location": 98,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "preds": [
                    "tf.Tensor"
                ],
                "targets": [
                    "Union[(None, tf.Tensor, np.ndarray, list)]"
                ]
            }
        },
        "_run_forward": {
            "name": "_run_forward",
            "location": 129,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "model": [
                    "Union[tf.keras.models.Model]"
                ],
                "x": [
                    "Union[(List[tf.Tensor], List[np.ndarray], tf.Tensor, np.ndarray)]"
                ],
                "target": [
                    "Union[(None, tf.Tensor, np.ndarray, list)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ]
            }
        },
        "_run_forward_from_layer": {
            "name": "_run_forward_from_layer",
            "location": 163,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "model": [
                    "tf.keras.models.Model"
                ],
                "layer": [
                    "tf.keras.layers.Layer"
                ],
                "orig_call": [
                    "Callable"
                ],
                "orig_dummy_input": [
                    "Union[(list, np.ndarray)]"
                ],
                "x": [
                    "tf.Tensor"
                ],
                "target": [
                    "Union[(None, tf.Tensor, np.ndarray, list)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "run_from_layer_inputs": [
                    "bool"
                ],
                "select_target": [
                    "bool"
                ]
            }
        },
        "_run_forward_to_layer": {
            "name": "_run_forward_to_layer",
            "location": 243,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "model": [
                    "tf.keras.models.Model"
                ],
                "layer": [
                    "tf.keras.layers.Layer"
                ],
                "orig_call": [
                    "Callable"
                ],
                "x": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "run_to_layer_inputs": [
                    "bool"
                ]
            }
        },
        "_forward_input_baseline": {
            "name": "_forward_input_baseline",
            "location": 309,
            "return": [
                "Tuple[(Union[(list, tf.Tensor)], Union[(list, tf.Tensor)])]"
            ],
            "arguments": {
                "X": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ],
                "bls": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ],
                "model": [
                    "tf.keras.Model"
                ],
                "layer": [
                    "tf.keras.layers.Layer"
                ],
                "orig_call": [
                    "Callable"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "forward_to_inputs": [
                    "bool"
                ]
            }
        },
        "_gradients_input": {
            "name": "_gradients_input",
            "location": 370,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "model": [
                    "Union[tf.keras.models.Model]"
                ],
                "x": [
                    "List[tf.Tensor]"
                ],
                "target": [
                    "Union[(None, tf.Tensor)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ]
            }
        },
        "_gradients_layer": {
            "name": "_gradients_layer",
            "location": 405,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "model": [
                    "Union[tf.keras.models.Model]"
                ],
                "layer": [
                    "Union[tf.keras.layers.Layer]"
                ],
                "orig_call": [
                    "Callable"
                ],
                "orig_dummy_input": [
                    "Union[(list, np.ndarray)]"
                ],
                "x": [
                    "Union[(List[tf.Tensor], tf.Tensor)]"
                ],
                "target": [
                    "Union[(None, tf.Tensor)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "compute_layer_inputs_gradients": [
                    "bool"
                ]
            }
        },
        "_format_baseline": {
            "name": "_format_baseline",
            "location": 507,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "baselines": [
                    "Union[(None, int, float, np.ndarray)]"
                ]
            }
        },
        "_format_target": {
            "name": "_format_target",
            "location": 536,
            "return": [
                "Union[(None, np.ndarray)]"
            ],
            "arguments": {
                "target": [
                    "Union[(None, int, list, np.ndarray)]"
                ],
                "nb_samples": [
                    "int"
                ]
            }
        },
        "_check_target": {
            "name": "_check_target",
            "location": 566,
            "return": [
                "None"
            ],
            "arguments": {
                "output_shape": [
                    "Tuple"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ],
                "nb_samples": [
                    "int"
                ]
            }
        },
        "_get_target_from_target_fn": {
            "name": "_get_target_from_target_fn",
            "location": 631,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "target_fn": [
                    "Callable"
                ],
                "model": [
                    "tf.keras.Model"
                ],
                "X": [
                    "Union[(np.ndarray, List[np.ndarray])]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ]
            }
        },
        "_sum_integral_terms": {
            "name": "_sum_integral_terms",
            "location": 675,
            "return": [
                "Union[(tf.Tensor, np.ndarray)]"
            ],
            "arguments": {
                "step_sizes": [
                    "list"
                ],
                "grads": [
                    "Union[(tf.Tensor, np.ndarray)]"
                ]
            }
        },
        "_calculate_sum_int": {
            "name": "_calculate_sum_int",
            "location": 705,
            "return": [
                "Union[(tf.Tensor, np.ndarray)]"
            ],
            "arguments": {
                "batches": [
                    "List[List[tf.Tensor]]"
                ],
                "model": [
                    "Union[tf.keras.Model]"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ],
                "target_paths": [
                    "np.ndarray"
                ],
                "n_steps": [
                    "int"
                ],
                "nb_samples": [
                    "int"
                ],
                "step_sizes": [
                    "List[float]"
                ],
                "j": [
                    "int"
                ]
            }
        },
        "_validate_output": {
            "name": "_validate_output",
            "location": 756,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "tf.keras.Model"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "_compute_convergence_delta._sum_rows": {
            "name": "_sum_rows",
            "location": 63,
            "return": [],
            "arguments": {
                "inp": []
            }
        },
        "_run_forward_from_layer.feed_layer": {
            "name": "feed_layer",
            "location": 206,
            "return": [],
            "arguments": {
                "layer": []
            }
        },
        "_run_forward_to_layer.take_layer": {
            "name": "take_layer",
            "location": 275,
            "return": [],
            "arguments": {
                "layer": []
            }
        },
        "_gradients_layer.watch_layer": {
            "name": "watch_layer",
            "location": 442,
            "return": [],
            "arguments": {
                "layer": [],
                "tape": []
            }
        },
        "IntegratedGradients.__init__": {
            "name": "__init__",
            "location": 784,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "tf.keras.Model"
                ],
                "layer": [
                    "Optional[tf.keras.layers.Layer]"
                ],
                "target_fn": [
                    "Optional[Callable]"
                ],
                "method": [
                    "str"
                ],
                "n_steps": [
                    "int"
                ],
                "internal_batch_size": [
                    "int"
                ]
            }
        },
        "IntegratedGradients.explain": {
            "name": "explain",
            "location": 854,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, List[np.ndarray])]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "baselines": [
                    "Optional[Union[(int, float, np.ndarray, List[int], List[float], List[np.ndarray])]]"
                ],
                "target": [
                    "Optional[Union[(int, list, np.ndarray)]]"
                ],
                "attribute_to_layer_inputs": [
                    "bool"
                ]
            }
        },
        "IntegratedGradients._build_explanation": {
            "name": "_build_explanation",
            "location": 1071,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "baselines": [
                    "List[np.ndarray]"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ],
                "attributions": [
                    "Union[(List[np.ndarray], List[tf.Tensor])]"
                ],
                "deltas": [
                    "np.ndarray"
                ]
            }
        },
        "IntegratedGradients.reset_predictor": {
            "name": "reset_predictor",
            "location": 1094,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Union[tf.keras.Model]"
                ]
            }
        },
        "IntegratedGradients._compute_attributions_list_input": {
            "name": "_compute_attributions_list_input",
            "location": 1106,
            "return": [
                "List"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "List[np.ndarray]"
                ],
                "baselines": [
                    "Union[(List[int], List[float], List[np.ndarray])]"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ],
                "step_sizes": [
                    "List[float]"
                ],
                "alphas": [
                    "List[float]"
                ],
                "nb_samples": [
                    "int"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "compute_layer_inputs_gradients": [
                    "bool"
                ]
            }
        },
        "IntegratedGradients._compute_attributions_tensor_input": {
            "name": "_compute_attributions_tensor_input",
            "location": 1231,
            "return": [
                "List"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ],
                "baselines": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ],
                "target": [
                    "Optional[np.ndarray]"
                ],
                "step_sizes": [
                    "List[float]"
                ],
                "alphas": [
                    "List[float]"
                ],
                "nb_samples": [
                    "int"
                ],
                "forward_kwargs": [
                    "Optional[dict]"
                ],
                "compute_layer_inputs_gradients": [
                    "bool"
                ]
            }
        },
        "_run_forward_from_layer.feed_layer.decorator": {
            "name": "decorator",
            "location": 212,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "_run_forward_to_layer.take_layer.decorator": {
            "name": "decorator",
            "location": 281,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "_gradients_layer.watch_layer.decorator": {
            "name": "decorator",
            "location": 452,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "_run_forward_from_layer.feed_layer.decorator.wrapper": {
            "name": "wrapper",
            "location": 213,
            "return": [],
            "arguments": {}
        },
        "_run_forward_to_layer.take_layer.decorator.wrapper": {
            "name": "wrapper",
            "location": 282,
            "return": [],
            "arguments": {}
        },
        "_gradients_layer.watch_layer.decorator.wrapper": {
            "name": "wrapper",
            "location": 453,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/shap_wrappers.py": {
        "rank_by_importance": {
            "name": "rank_by_importance",
            "location": 33,
            "return": [
                "Dict"
            ],
            "arguments": {
                "shap_values": [
                    "List[np.ndarray]"
                ],
                "feature_names": [
                    "Union[(List[str], Tuple[str], None)]"
                ]
            }
        },
        "sum_categories": {
            "name": "sum_categories",
            "location": 109,
            "return": [],
            "arguments": {
                "values": [
                    "np.ndarray"
                ],
                "start_idx": [
                    "Sequence[int]"
                ],
                "enc_feat_dim": [
                    "Sequence[int]"
                ]
            }
        },
        "sum_categories._get_slices": {
            "name": "_get_slices",
            "location": 158,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "start": [
                    "Sequence[int]"
                ],
                "dim": [
                    "Sequence[int]"
                ],
                "arr_trailing_dim": [
                    "int"
                ]
            }
        },
        "sum_categories._reduction": {
            "name": "_reduction",
            "location": 197,
            "return": [],
            "arguments": {
                "arr": [],
                "axis": [],
                "indices": []
            }
        },
        "KernelExplainerWrapper.__init__": {
            "name": "__init__",
            "location": 239,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "KernelExplainerWrapper.get_explanation": {
            "name": "get_explanation",
            "location": 252,
            "return": [
                "Union[(Tuple[(int, np.ndarray)], Tuple[(int, List[np.ndarray])], np.ndarray, List[np.ndarray])]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(Tuple[(int, np.ndarray)], np.ndarray)]"
                ]
            }
        },
        "KernelExplainerWrapper.return_attribute": {
            "name": "return_attribute",
            "location": 276,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "KernelShap.__init__": {
            "name": "__init__",
            "location": 289,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "link": [
                    "str"
                ],
                "feature_names": [
                    "Optional[Union[(List[str], Tuple[str])]]"
                ],
                "categorical_names": [
                    "Optional[Dict[(int, List[str])]]"
                ],
                "task": [
                    "str"
                ],
                "seed": [
                    "Optional[int]"
                ],
                "distributed_opts": [
                    "Optional[Dict]"
                ]
            }
        },
        "KernelShap._check_inputs": {
            "name": "_check_inputs",
            "location": 373,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(shap_utils.Data, pd.DataFrame, np.ndarray, sparse.spmatrix)]"
                ],
                "group_names": [
                    "Union[(Tuple, List, None)]"
                ],
                "groups": [
                    "Optional[List[Union[(Tuple[int], List[int])]]]"
                ],
                "weights": [
                    "Union[(Union[(List[float], Tuple[float])], np.ndarray, None)]"
                ]
            }
        },
        "KernelShap._summarise_background": {
            "name": "_summarise_background",
            "location": 507,
            "return": [
                "Union[(shap_utils.Data, pd.DataFrame, np.ndarray, sparse.spmatrix)]"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(shap_utils.Data, pd.DataFrame, np.ndarray, sparse.spmatrix)]"
                ],
                "n_background_samples": [
                    "int"
                ]
            }
        },
        "KernelShap._get_data": {
            "name": "_get_data",
            "location": 549,
            "return": [],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(shap_utils.Data, pd.DataFrame, np.ndarray, sparse.spmatrix)]"
                ],
                "group_names": [
                    "Sequence"
                ],
                "groups": [
                    "List[Sequence[int]]"
                ],
                "weights": [
                    "Sequence[Union[(float, int)]]"
                ]
            }
        },
        "KernelShap._": {
            "name": "_",
            "location": 658,
            "return": [
                "Union[(shap_utils.Data, pd.core.frame.Series)]"
            ],
            "arguments": {
                "self": [],
                "background_data": []
            }
        },
        "KernelShap.fit": {
            "name": "fit",
            "location": 676,
            "return": [
                "'KernelShap'"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(np.ndarray, sparse.spmatrix, pd.DataFrame, shap_utils.Data)]"
                ],
                "summarise_background": [
                    "Union[(bool, str)]"
                ],
                "n_background_samples": [
                    "int"
                ],
                "group_names": [
                    "Union[(Tuple[str], List[str], None)]"
                ],
                "groups": [
                    "Optional[List[Union[(Tuple[int], List[int])]]]"
                ],
                "weights": [
                    "Union[(Union[(List[float], Tuple[float])], np.ndarray, None)]"
                ]
            }
        },
        "KernelShap.explain": {
            "name": "explain",
            "location": 787,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, pd.DataFrame, sparse.spmatrix)]"
                ],
                "summarise_result": [
                    "bool"
                ],
                "cat_vars_start_idx": [
                    "Optional[Sequence[int]]"
                ],
                "cat_vars_enc_dim": [
                    "Optional[Sequence[int]]"
                ]
            }
        },
        "KernelShap._build_explanation": {
            "name": "_build_explanation",
            "location": 876,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, pd.DataFrame, sparse.spmatrix)]"
                ],
                "shap_values": [
                    "List[np.ndarray]"
                ],
                "expected_value": [
                    "List[float]"
                ]
            }
        },
        "KernelShap._check_result_summarisation": {
            "name": "_check_result_summarisation",
            "location": 955,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "summarise_result": [
                    "bool"
                ],
                "cat_vars_start_idx": [
                    "Sequence[int]"
                ],
                "cat_vars_enc_dim": [
                    "Sequence[int]"
                ]
            }
        },
        "KernelShap.reset_predictor": {
            "name": "reset_predictor",
            "location": 985,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "TreeShap.__init__": {
            "name": "__init__",
            "location": 1009,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "Any"
                ],
                "model_output": [
                    "str"
                ],
                "feature_names": [
                    "Optional[Union[(List[str], Tuple[str])]]"
                ],
                "categorical_names": [
                    "Optional[Dict[(int, List[str])]]"
                ],
                "task": [
                    "str"
                ],
                "seed": [
                    "Optional[int]"
                ]
            }
        },
        "TreeShap.fit": {
            "name": "fit",
            "location": 1107,
            "return": [
                "'TreeShap'"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(np.ndarray, pd.DataFrame, None)]"
                ],
                "summarise_background": [
                    "Union[(bool, str)]"
                ],
                "n_background_samples": [
                    "int"
                ]
            }
        },
        "TreeShap._check_inputs": {
            "name": "_check_inputs",
            "location": 1192,
            "return": [
                "None"
            ],
            "arguments": {
                "background_data": [
                    "Union[(pd.DataFrame, np.ndarray)]"
                ]
            }
        },
        "TreeShap._summarise_background": {
            "name": "_summarise_background",
            "location": 1210,
            "return": [
                "Union[(np.ndarray, pd.DataFrame, shap_utils.DenseData)]"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(pd.DataFrame, np.ndarray)]"
                ],
                "n_background_samples": [
                    "int"
                ]
            }
        },
        "TreeShap.explain": {
            "name": "explain",
            "location": 1231,
            "return": [
                "'Explanation'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, pd.DataFrame, 'catboost.Pool')]"
                ],
                "y": [
                    "Optional[np.ndarray]"
                ],
                "interactions": [
                    "bool"
                ],
                "approximate": [
                    "bool"
                ],
                "check_additivity": [
                    "bool"
                ],
                "tree_limit": [
                    "Optional[int]"
                ],
                "summarise_result": [
                    "bool"
                ],
                "cat_vars_start_idx": [
                    "Optional[Sequence[int]]"
                ],
                "cat_vars_enc_dim": [
                    "Optional[Sequence[int]]"
                ]
            }
        },
        "TreeShap._xgboost_interactions": {
            "name": "_xgboost_interactions",
            "location": 1347,
            "return": [
                "Union[(np.ndarray, List[np.ndarray])]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, pd.DataFrame)]"
                ]
            }
        },
        "TreeShap._check_interactions": {
            "name": "_check_interactions",
            "location": 1362,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "approximate": [
                    "bool"
                ],
                "background_data": [
                    "Union[(np.ndarray, pd.DataFrame, None)]"
                ],
                "y": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "TreeShap._check_explainer_setup": {
            "name": "_check_explainer_setup",
            "location": 1407,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[(np.ndarray, pd.DataFrame, None)]"
                ],
                "model_output": [
                    "str"
                ],
                "y": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "TreeShap._build_explanation": {
            "name": "_build_explanation",
            "location": 1457,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(np.ndarray, pd.DataFrame, 'catboost.Pool')]"
                ],
                "shap_output": [
                    "List[np.ndarray]"
                ],
                "expected_value": [
                    "List[float]"
                ]
            }
        },
        "TreeShap._check_result_summarisation": {
            "name": "_check_result_summarisation",
            "location": 1579,
            "return": [],
            "arguments": {
                "self": [],
                "summarise_result": [
                    "bool"
                ],
                "cat_vars_start_idx": [
                    "Sequence[int]"
                ],
                "cat_vars_enc_dim": [
                    "Sequence[int]"
                ]
            }
        },
        "TreeShap.reset_predictor": {
            "name": "reset_predictor",
            "location": 1601,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Any"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/__init__.py": {},
    "alibi-master/alibi/explainers/anchors/anchor_base.py": {
        "AnchorBaseBeam.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "samplers": [
                    "List[Callable]"
                ]
            }
        },
        "AnchorBaseBeam._init_state": {
            "name": "_init_state",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int"
                ],
                "coverage_data": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorBaseBeam._sort": {
            "name": "_sort",
            "location": 67,
            "return": [
                "tuple"
            ],
            "arguments": {
                "x": [
                    "tuple"
                ],
                "allow_duplicates": []
            }
        },
        "AnchorBaseBeam.dup_bernoulli": {
            "name": "dup_bernoulli",
            "location": 89,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "p": [
                    "np.ndarray"
                ],
                "level": [
                    "np.ndarray"
                ],
                "n_iter": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.dlow_bernoulli": {
            "name": "dlow_bernoulli",
            "location": 121,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "p": [
                    "np.ndarray"
                ],
                "level": [
                    "np.ndarray"
                ],
                "n_iter": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.compute_beta": {
            "name": "compute_beta",
            "location": 153,
            "return": [
                "float"
            ],
            "arguments": {
                "n_features": [
                    "int"
                ],
                "t": [
                    "int"
                ],
                "delta": [
                    "float"
                ]
            }
        },
        "AnchorBaseBeam._get_coverage_samples": {
            "name": "_get_coverage_samples",
            "location": 175,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "coverage_samples": [
                    "int"
                ],
                "samplers": [
                    "Optional[List[Callable]]"
                ]
            }
        },
        "AnchorBaseBeam.select_critical_arms": {
            "name": "select_critical_arms",
            "location": 197,
            "return": [],
            "arguments": {
                "self": [],
                "means": [
                    "np.ndarray"
                ],
                "ub": [
                    "np.ndarray"
                ],
                "lb": [
                    "np.ndarray"
                ],
                "n_samples": [
                    "np.ndarray"
                ],
                "delta": [
                    "float"
                ],
                "top_n": [
                    "int"
                ],
                "t": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.kllucb": {
            "name": "kllucb",
            "location": 249,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "list"
                ],
                "init_stats": [
                    "dict"
                ],
                "epsilon": [
                    "float"
                ],
                "delta": [
                    "float"
                ],
                "batch_size": [
                    "int"
                ],
                "top_n": [
                    "int"
                ],
                "verbose": [
                    "bool"
                ],
                "verbose_every": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.draw_samples": {
            "name": "draw_samples",
            "location": 332,
            "return": [
                "Tuple[(tuple, tuple)]"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "list"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.propose_anchors": {
            "name": "propose_anchors",
            "location": 361,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "previous_best": [
                    "list"
                ]
            }
        },
        "AnchorBaseBeam.update_state": {
            "name": "update_state",
            "location": 419,
            "return": [
                "Tuple[(int, int)]"
            ],
            "arguments": {
                "self": [],
                "covered_true": [
                    "np.ndarray"
                ],
                "covered_false": [
                    "np.ndarray"
                ],
                "labels": [
                    "np.ndarray"
                ],
                "samples": [
                    "Tuple[(np.ndarray, float)]"
                ],
                "anchor": [
                    "tuple"
                ]
            }
        },
        "AnchorBaseBeam.get_init_stats": {
            "name": "get_init_stats",
            "location": 475,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "list"
                ],
                "coverages": []
            }
        },
        "AnchorBaseBeam.get_anchor_metadata": {
            "name": "get_anchor_metadata",
            "location": 505,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "features": [
                    "tuple"
                ],
                "success": [],
                "batch_size": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.to_sample": {
            "name": "to_sample",
            "location": 578,
            "return": [],
            "arguments": {
                "means": [
                    "np.ndarray"
                ],
                "ubs": [
                    "np.ndarray"
                ],
                "lbs": [
                    "np.ndarray"
                ],
                "desired_confidence": [
                    "float"
                ],
                "epsilon_stop": [
                    "float"
                ]
            }
        },
        "AnchorBaseBeam.anchor_beam": {
            "name": "anchor_beam",
            "location": 605,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "delta": [
                    "float"
                ],
                "epsilon": [
                    "float"
                ],
                "desired_confidence": [
                    "float"
                ],
                "beam_size": [
                    "int"
                ],
                "epsilon_stop": [
                    "float"
                ],
                "min_samples_start": [
                    "int"
                ],
                "max_anchor_size": [
                    "Optional[int]"
                ],
                "stop_on_first": [
                    "bool"
                ],
                "batch_size": [
                    "int"
                ],
                "coverage_samples": [
                    "int"
                ],
                "verbose": [
                    "bool"
                ],
                "verbose_every": [
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.get_init_stats.array_factory": {
            "name": "array_factory",
            "location": 492,
            "return": [],
            "arguments": {
                "size": [
                    "tuple"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_explanation.py": {
        "AnchorExplanation.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "exp_type": [
                    "str"
                ],
                "exp_map": [
                    "dict"
                ]
            }
        },
        "AnchorExplanation.names": {
            "name": "names",
            "location": 22,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.features": {
            "name": "features",
            "location": 41,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.precision": {
            "name": "precision",
            "location": 60,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.coverage": {
            "name": "coverage",
            "location": 82,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.examples": {
            "name": "examples",
            "location": 104,
            "return": [
                "Union[(list, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "only_different_prediction": [
                    "bool"
                ],
                "only_same_prediction": [
                    "bool"
                ],
                "partial_index": [
                    "Optional[int]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_image.py": {
        "scale_image": {
            "name": "scale_image",
            "location": 27,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "image": [
                    "np.ndarray"
                ],
                "scale": [
                    "tuple"
                ]
            }
        },
        "AnchorImageSampler.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ],
                "segmentation_fn": [
                    "Callable"
                ],
                "custom_segmentation": [
                    "bool"
                ],
                "image": [
                    "np.ndarray"
                ],
                "images_background": [
                    "Optional[np.ndarray]"
                ],
                "p_sample": [
                    "float"
                ],
                "n_covered_ex": [
                    "int"
                ]
            }
        },
        "AnchorImageSampler.__call__": {
            "name": "__call__",
            "location": 92,
            "return": [
                "List[Union[(np.ndarray, float, int)]]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "Tuple[(int, tuple)]"
                ],
                "num_samples": [
                    "int"
                ],
                "compute_labels": [
                    "bool"
                ]
            }
        },
        "AnchorImageSampler.compare_labels": {
            "name": "compare_labels",
            "location": 152,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorImageSampler._choose_superpixels": {
            "name": "_choose_superpixels",
            "location": 169,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int"
                ],
                "p_sample": [
                    "float"
                ]
            }
        },
        "AnchorImageSampler.perturbation": {
            "name": "perturbation",
            "location": 198,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "AnchorImageSampler.generate_superpixels": {
            "name": "generate_superpixels",
            "location": 268,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorImageSampler._preprocess_img": {
            "name": "_preprocess_img",
            "location": 286,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorImage.__init__": {
            "name": "__init__",
            "location": 310,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "image_shape": [
                    "tuple"
                ],
                "dtype": [
                    "Type[np.generic]"
                ],
                "segmentation_fn": [
                    "Any"
                ],
                "segmentation_kwargs": [
                    "Optional[dict]"
                ],
                "images_background": [
                    "Optional[np.ndarray]"
                ],
                "seed": [
                    "Optional[int]"
                ]
            }
        },
        "AnchorImage.generate_superpixels": {
            "name": "generate_superpixels",
            "location": 404,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorImage._preprocess_img": {
            "name": "_preprocess_img",
            "location": 422,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorImage.explain": {
            "name": "explain",
            "location": 444,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ],
                "p_sample": [
                    "float"
                ],
                "threshold": [
                    "float"
                ],
                "delta": [
                    "float"
                ],
                "tau": [
                    "float"
                ],
                "batch_size": [
                    "int"
                ],
                "coverage_samples": [
                    "int"
                ],
                "beam_size": [
                    "int"
                ],
                "stop_on_first": [
                    "bool"
                ],
                "max_anchor_size": [
                    "Optional[int]"
                ],
                "min_samples_start": [
                    "int"
                ],
                "n_covered_ex": [
                    "int"
                ],
                "binary_cache_size": [
                    "int"
                ],
                "cache_margin": [
                    "int"
                ],
                "verbose": [
                    "bool"
                ],
                "verbose_every": [
                    "int"
                ]
            }
        },
        "AnchorImage._build_explanation": {
            "name": "_build_explanation",
            "location": 554,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ],
                "result": [
                    "dict"
                ],
                "predicted_label": [
                    "int"
                ],
                "params": [
                    "dict"
                ],
                "sampler": [
                    "AnchorImageSampler"
                ]
            }
        },
        "AnchorImage.overlay_mask": {
            "name": "overlay_mask",
            "location": 603,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "np.ndarray"
                ],
                "segments": [
                    "np.ndarray"
                ],
                "mask_features": [
                    "list"
                ],
                "scale": [
                    "tuple"
                ]
            }
        },
        "AnchorImage._transform_predictor": {
            "name": "_transform_predictor",
            "location": 633,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "AnchorImage.reset_predictor": {
            "name": "reset_predictor",
            "location": 654,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_tabular.py": {
        "TabularSampler.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ],
                "disc_perc": [
                    "Tuple[(Union[(int, float)], ...)]"
                ],
                "numerical_features": [
                    "List[int]"
                ],
                "categorical_features": [
                    "List[int]"
                ],
                "feature_names": [
                    "list"
                ],
                "feature_values": [
                    "dict"
                ],
                "n_covered_ex": [
                    "int"
                ],
                "seed": [
                    "Optional[int]"
                ]
            }
        },
        "TabularSampler.deferred_init": {
            "name": "deferred_init",
            "location": 69,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "Union[(np.ndarray, Any)]"
                ],
                "d_train_data": [
                    "Union[(np.ndarray, Any)]"
                ]
            }
        },
        "TabularSampler._set_data": {
            "name": "_set_data",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "Union[(np.ndarray, Any)]"
                ],
                "d_train_data": [
                    "Union[(np.ndarray, Any)]"
                ]
            }
        },
        "TabularSampler._set_discretizer": {
            "name": "_set_discretizer",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "disc_perc": [
                    "Tuple[(Union[(int, float)], ...)]"
                ]
            }
        },
        "TabularSampler._set_numerical_feats_stats": {
            "name": "_set_numerical_feats_stats",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TabularSampler.set_instance_label": {
            "name": "set_instance_label",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "TabularSampler.set_n_covered": {
            "name": "set_n_covered",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_covered": [
                    "int"
                ]
            }
        },
        "TabularSampler._get_data_index": {
            "name": "_get_data_index",
            "location": 151,
            "return": [
                "Dict[(int, DefaultDict[(int, np.ndarray)])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TabularSampler.__call__": {
            "name": "__call__",
            "location": 171,
            "return": [
                "Union[(List[Union[(np.ndarray, np.ndarray, np.ndarray, np.ndarray, float, int)]], List[np.ndarray])]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "Tuple[(int, tuple)]"
                ],
                "num_samples": [
                    "int"
                ],
                "compute_labels": []
            }
        },
        "TabularSampler.compare_labels": {
            "name": "compare_labels",
            "location": 233,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "np.ndarray"
                ]
            }
        },
        "TabularSampler.perturbation": {
            "name": "perturbation",
            "location": 250,
            "return": [
                "Tuple[(np.ndarray, np.ndarray, float)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "TabularSampler.handle_unk_features": {
            "name": "handle_unk_features",
            "location": 323,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "allowed_bins": [
                    "Dict[(int, Set[int])]"
                ],
                "num_samples": [
                    "int"
                ],
                "samples": [
                    "np.ndarray"
                ],
                "unk_feature_values": [
                    "List[Tuple[(int, str, Union[(Any, int)])]]"
                ]
            }
        },
        "TabularSampler.replace_features": {
            "name": "replace_features",
            "location": 355,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "np.ndarray"
                ],
                "allowed_rows": [
                    "Dict[(int, Any)]"
                ],
                "uniq_feat_ids": [
                    "List[int]"
                ],
                "partial_anchor_rows": [
                    "List[np.ndarray]"
                ],
                "nb_partial_anchors": [
                    "np.ndarray"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "TabularSampler.get_features_index": {
            "name": "get_features_index",
            "location": 437,
            "return": [
                "Tuple[(Dict[(int, Set[int])], Dict[(int, Any)], List[Tuple[(int, str, Union[(Any, int)])]])]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ]
            }
        },
        "TabularSampler.build_lookups": {
            "name": "build_lookups",
            "location": 499,
            "return": [
                "List[Dict]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorTabular.__init__": {
            "name": "__init__",
            "location": 584,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "categorical_names": [
                    "Optional[Dict[(int, List[str])]]"
                ],
                "dtype": [
                    "Type[np.generic]"
                ],
                "ohe": [
                    "bool"
                ],
                "seed": [
                    "Optional[int]"
                ]
            }
        },
        "AnchorTabular.fit": {
            "name": "fit",
            "location": 650,
            "return": [
                "'AnchorTabular'"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "np.ndarray"
                ],
                "disc_perc": [
                    "Tuple[(Union[(int, float)], ...)]"
                ]
            }
        },
        "AnchorTabular._build_sampling_lookups": {
            "name": "_build_sampling_lookups",
            "location": 691,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorTabular.explain": {
            "name": "explain",
            "location": 705,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "threshold": [
                    "float"
                ],
                "delta": [
                    "float"
                ],
                "tau": [
                    "float"
                ],
                "batch_size": [
                    "int"
                ],
                "coverage_samples": [
                    "int"
                ],
                "beam_size": [
                    "int"
                ],
                "stop_on_first": [
                    "bool"
                ],
                "max_anchor_size": [
                    "Optional[int]"
                ],
                "min_samples_start": [
                    "int"
                ],
                "n_covered_ex": [
                    "int"
                ],
                "binary_cache_size": [
                    "int"
                ],
                "cache_margin": [
                    "int"
                ],
                "verbose": [
                    "bool"
                ],
                "verbose_every": [
                    "int"
                ]
            }
        },
        "AnchorTabular._build_explanation": {
            "name": "_build_explanation",
            "location": 810,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "result": [
                    "dict"
                ],
                "predicted_label": [
                    "int"
                ],
                "params": [
                    "dict"
                ]
            }
        },
        "AnchorTabular.add_names_to_exp": {
            "name": "add_names_to_exp",
            "location": 857,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "explanation": [
                    "dict"
                ]
            }
        },
        "AnchorTabular.predictor": {
            "name": "predictor",
            "location": 932,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Optional[Callable]"
                ]
            }
        },
        "AnchorTabular._transform_predictor": {
            "name": "_transform_predictor",
            "location": 953,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "AnchorTabular._transform_ohe_predictor": {
            "name": "_transform_ohe_predictor",
            "location": 976,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "AnchorTabular.reset_predictor": {
            "name": "reset_predictor",
            "location": 981,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_tabular_distributed.py": {
        "DistributedAnchorBaseBeam.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "samplers": [
                    "List[Callable]"
                ]
            }
        },
        "DistributedAnchorBaseBeam._get_coverage_samples": {
            "name": "_get_coverage_samples",
            "location": 28,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "coverage_samples": [
                    "int"
                ],
                "samplers": [
                    "List[Callable]"
                ]
            }
        },
        "DistributedAnchorBaseBeam.draw_samples": {
            "name": "draw_samples",
            "location": 48,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "list"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "RemoteSampler.__init__": {
            "name": "__init__",
            "location": 93,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RemoteSampler.__call__": {
            "name": "__call__",
            "location": 97,
            "return": [
                "List"
            ],
            "arguments": {
                "self": [],
                "anchors_batch": [
                    "Union[(Tuple[(int, tuple)], List[Tuple[(int, tuple)]])]"
                ],
                "num_samples": [
                    "int"
                ],
                "compute_labels": [
                    "bool"
                ]
            }
        },
        "RemoteSampler.set_instance_label": {
            "name": "set_instance_label",
            "location": 121,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "RemoteSampler.set_n_covered": {
            "name": "set_n_covered",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_covered": [
                    "int"
                ]
            }
        },
        "RemoteSampler._get_sampler": {
            "name": "_get_sampler",
            "location": 153,
            "return": [
                "TabularSampler"
            ],
            "arguments": {
                "self": []
            }
        },
        "RemoteSampler.build_lookups": {
            "name": "build_lookups",
            "location": 163,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "DistributedAnchorTabular.__init__": {
            "name": "__init__",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "categorical_names": [
                    "Optional[Dict[(int, List[str])]]"
                ],
                "dtype": [
                    "Type[np.generic]"
                ],
                "ohe": [
                    "bool"
                ],
                "seed": [
                    "Optional[int]"
                ]
            }
        },
        "DistributedAnchorTabular.fit": {
            "name": "fit",
            "location": 195,
            "return": [
                "'AnchorTabular'"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "np.ndarray"
                ],
                "disc_perc": [
                    "tuple"
                ]
            }
        },
        "DistributedAnchorTabular._build_sampling_lookups": {
            "name": "_build_sampling_lookups",
            "location": 249,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "DistributedAnchorTabular.explain": {
            "name": "explain",
            "location": 262,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "threshold": [
                    "float"
                ],
                "delta": [
                    "float"
                ],
                "tau": [
                    "float"
                ],
                "batch_size": [
                    "int"
                ],
                "coverage_samples": [
                    "int"
                ],
                "beam_size": [
                    "int"
                ],
                "stop_on_first": [
                    "bool"
                ],
                "max_anchor_size": [
                    "Optional[int]"
                ],
                "min_samples_start": [
                    "int"
                ],
                "n_covered_ex": [
                    "int"
                ],
                "binary_cache_size": [
                    "int"
                ],
                "cache_margin": [
                    "int"
                ],
                "verbose": [
                    "bool"
                ],
                "verbose_every": [
                    "int"
                ]
            }
        },
        "DistributedAnchorTabular.reset_predictor": {
            "name": "reset_predictor",
            "location": 332,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_text.py": {
        "AnchorText.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable[([List[str]], np.ndarray)]"
                ],
                "sampling_strategy": [
                    "str"
                ],
                "nlp": [
                    "Optional['spacy.language.Language']"
                ],
                "language_model": [
                    "Union[('LanguageModel', None)]"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "AnchorText._validate_kwargs": {
            "name": "_validate_kwargs",
            "location": 202,
            "return": [
                "Tuple[(dict, dict)]"
            ],
            "arguments": {
                "self": [],
                "sampling_strategy": [
                    "str"
                ],
                "nlp": [
                    "Optional['spacy.language.Language']"
                ],
                "language_model": [
                    "Optional['LanguageModel']"
                ]
            }
        },
        "AnchorText.sampler": {
            "name": "sampler",
            "location": 259,
            "return": [
                "Union[(List[Union[(np.ndarray, np.ndarray, np.ndarray, np.ndarray, float, int)]], List[np.ndarray])]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "Tuple[(int, tuple)]"
                ],
                "num_samples": [
                    "int"
                ],
                "compute_labels": [
                    "bool"
                ]
            }
        },
        "AnchorText.compare_labels": {
            "name": "compare_labels",
            "location": 313,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "np.ndarray"
                ]
            }
        },
        "AnchorText.explain": {
            "name": "explain",
            "location": 330,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "threshold": [
                    "float"
                ],
                "delta": [
                    "float"
                ],
                "tau": [
                    "float"
                ],
                "batch_size": [
                    "int"
                ],
                "coverage_samples": [
                    "int"
                ],
                "beam_size": [
                    "int"
                ],
                "stop_on_first": [
                    "bool"
                ],
                "max_anchor_size": [
                    "Optional[int]"
                ],
                "min_samples_start": [
                    "int"
                ],
                "n_covered_ex": [
                    "int"
                ],
                "binary_cache_size": [
                    "int"
                ],
                "cache_margin": [
                    "int"
                ],
                "verbose": [
                    "bool"
                ],
                "verbose_every": [
                    "int"
                ]
            }
        },
        "AnchorText._build_explanation": {
            "name": "_build_explanation",
            "location": 457,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "result": [
                    "dict"
                ],
                "predicted_label": [
                    "int"
                ],
                "params": [
                    "dict"
                ]
            }
        },
        "AnchorText._transform_predictor": {
            "name": "_transform_predictor",
            "location": 493,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "AnchorText.reset_predictor": {
            "name": "reset_predictor",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable"
                ]
            }
        },
        "AnchorText._seed": {
            "name": "_seed",
            "location": 525,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/language_model_text_sampler.py": {
        "LanguageModelSampler.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "LanguageModel"
                ],
                "perturb_opts": [
                    "dict"
                ]
            }
        },
        "LanguageModelSampler.get_sample_ids": {
            "name": "get_sample_ids",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "punctuation": [
                    "str"
                ],
                "stopwords": [
                    "Optional[List[str]]"
                ]
            }
        },
        "LanguageModelSampler.set_text": {
            "name": "set_text",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "LanguageModelSampler.__call__": {
            "name": "__call__",
            "location": 139,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "LanguageModelSampler.perturb_sentence": {
            "name": "perturb_sentence",
            "location": 159,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ],
                "sample_proba": [
                    "float"
                ],
                "top_n": [
                    "int"
                ],
                "batch_size_lm": [
                    "int"
                ],
                "filling": [
                    "str"
                ]
            }
        },
        "LanguageModelSampler.create_mask": {
            "name": "create_mask",
            "location": 222,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ],
                "sample_proba": [
                    "float"
                ],
                "filling": [
                    "str"
                ],
                "frac_mask_templates": [
                    "float"
                ]
            }
        },
        "LanguageModelSampler._append_tail": {
            "name": "_append_tail",
            "location": 309,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "raw": [
                    "np.ndarray"
                ]
            }
        },
        "LanguageModelSampler._joiner": {
            "name": "_joiner",
            "location": 333,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "np.ndarray"
                ],
                "dtype": [
                    "Optional[Type[np.generic]]"
                ]
            }
        },
        "LanguageModelSampler.fill_mask": {
            "name": "fill_mask",
            "location": 356,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "raw": [
                    "np.ndarray"
                ],
                "data": [
                    "np.ndarray"
                ],
                "num_samples": [
                    "int"
                ],
                "top_n": [
                    "int"
                ],
                "batch_size_lm": [
                    "int"
                ],
                "filling": [
                    "str"
                ]
            }
        },
        "LanguageModelSampler._remove_subwords": {
            "name": "_remove_subwords",
            "location": 403,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "raw": [
                    "np.ndarray"
                ],
                "row": [
                    "int"
                ],
                "col": [
                    "int"
                ],
                "punctuation": [
                    "str"
                ]
            }
        },
        "LanguageModelSampler._perturb_instances_parallel": {
            "name": "_perturb_instances_parallel",
            "location": 439,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int"
                ],
                "raw": [
                    "np.ndarray"
                ],
                "data": [
                    "np.ndarray"
                ],
                "top_n": [
                    "int"
                ],
                "batch_size_lm": [
                    "int"
                ],
                "temperature": [
                    "float"
                ],
                "use_proba": [
                    "bool"
                ]
            }
        },
        "LanguageModelSampler._perturb_instance_ar": {
            "name": "_perturb_instance_ar",
            "location": 539,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int"
                ],
                "raw": [
                    "np.ndarray"
                ],
                "data": [
                    "np.ndarray"
                ],
                "top_n": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ],
                "temperature": [
                    "float"
                ],
                "use_proba": [
                    "bool"
                ]
            }
        },
        "LanguageModelSampler.set_data_type": {
            "name": "set_data_type",
            "location": 635,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LanguageModelSampler.seed": {
            "name": "seed",
            "location": 663,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/text_samplers.py": {
        "load_spacy_lexeme_prob": {
            "name": "load_spacy_lexeme_prob",
            "location": 84,
            "return": [
                "'spacy.language.Language'"
            ],
            "arguments": {
                "nlp": [
                    "'spacy.language.Language'"
                ]
            }
        },
        "Neighbors.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nlp_obj": [
                    "'spacy.language.Language'"
                ],
                "n_similar": [
                    "int"
                ],
                "w_prob": [
                    "float"
                ]
            }
        },
        "Neighbors.neighbors": {
            "name": "neighbors",
            "location": 39,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "str"
                ],
                "tag": [
                    "str"
                ],
                "top_n": [
                    "int"
                ]
            }
        },
        "AnchorTextSampler.set_text": {
            "name": "set_text",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "AnchorTextSampler.__call__": {
            "name": "__call__",
            "location": 126,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "AnchorTextSampler._joiner": {
            "name": "_joiner",
            "location": 129,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "np.ndarray"
                ],
                "dtype": [
                    "Optional[Type[np.generic]]"
                ]
            }
        },
        "UnknownSampler.__init__": {
            "name": "__init__",
            "location": 153,
            "return": [],
            "arguments": {
                "self": [],
                "nlp": [
                    "'spacy.language.Language'"
                ],
                "perturb_opts": [
                    "Dict"
                ]
            }
        },
        "UnknownSampler.set_text": {
            "name": "set_text",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "UnknownSampler.__call__": {
            "name": "__call__",
            "location": 191,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "UnknownSampler.set_data_type": {
            "name": "set_data_type",
            "location": 235,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimilaritySampler.__init__": {
            "name": "__init__",
            "location": 250,
            "return": [],
            "arguments": {
                "self": [],
                "nlp": [
                    "'spacy.language.Language'"
                ],
                "perturb_opts": [
                    "Dict"
                ]
            }
        },
        "SimilaritySampler.set_text": {
            "name": "set_text",
            "location": 278,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "SimilaritySampler.find_similar_words": {
            "name": "find_similar_words",
            "location": 299,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimilaritySampler.__call__": {
            "name": "__call__",
            "location": 310,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "tuple"
                ],
                "num_samples": [
                    "int"
                ]
            }
        },
        "SimilaritySampler.perturb_sentence_similarity": {
            "name": "perturb_sentence_similarity",
            "location": 331,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "present": [
                    "tuple"
                ],
                "n": [
                    "int"
                ],
                "sample_proba": [
                    "float"
                ],
                "forbidden": [
                    "frozenset"
                ],
                "forbidden_tags": [
                    "frozenset"
                ],
                "forbidden_words": [
                    "frozenset"
                ],
                "temperature": [
                    "float"
                ],
                "pos": [
                    "frozenset"
                ],
                "use_proba": [
                    "bool"
                ]
            }
        },
        "SimilaritySampler.set_data_type": {
            "name": "set_data_type",
            "location": 413,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/__init__.py": {},
    "alibi-master/alibi/explainers/backends/cfrl_base.py": {
        "identity_function": {
            "name": "identity_function",
            "location": 11,
            "return": [
                "Any"
            ],
            "arguments": {
                "X": [
                    "Any"
                ]
            }
        },
        "generate_empty_condition": {
            "name": "generate_empty_condition",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "X": [
                    "Any"
                ]
            }
        },
        "get_classification_reward": {
            "name": "get_classification_reward",
            "location": 40,
            "return": [],
            "arguments": {
                "Y_pred": [
                    "np.ndarray"
                ],
                "Y_true": [
                    "np.ndarray"
                ]
            }
        },
        "get_hard_distribution": {
            "name": "get_hard_distribution",
            "location": 68,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "Y": [
                    "np.ndarray"
                ],
                "num_classes": [
                    "Optional[int]"
                ]
            }
        },
        "CounterfactualRLDataset.predict_batches": {
            "name": "predict_batches",
            "location": 102,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "predictor": [
                    "Callable"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "CounterfactualRLDataset.__len__": {
            "name": "__len__",
            "location": 138,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CounterfactualRLDataset.__getitem__": {
            "name": "__getitem__",
            "location": 142,
            "return": [],
            "arguments": {
                "self": [],
                "item": []
            }
        }
    },
    "alibi-master/alibi/explainers/backends/cfrl_tabular.py": {
        "get_conditional_dim": {
            "name": "get_conditional_dim",
            "location": 19,
            "return": [
                "int"
            ],
            "arguments": {
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ]
            }
        },
        "split_ohe": {
            "name": "split_ohe",
            "location": 40,
            "return": [
                "Tuple[(List, List)]"
            ],
            "arguments": {
                "X_ohe": [
                    "'Union[np.ndarray, torch.Tensor, tf.Tensor]'"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ]
            }
        },
        "generate_numerical_condition": {
            "name": "generate_numerical_condition",
            "location": 86,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X_ohe": [
                    "np.ndarray"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "ranges": [
                    "Dict[(str, List[float])]"
                ],
                "immutable_features": [
                    "List[str]"
                ],
                "conditional": [
                    "bool"
                ]
            }
        },
        "generate_categorical_condition": {
            "name": "generate_categorical_condition",
            "location": 161,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X_ohe": [
                    "np.ndarray"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List)]"
                ],
                "immutable_features": [
                    "List[str]"
                ],
                "conditional": [
                    "bool"
                ]
            }
        },
        "generate_condition": {
            "name": "generate_condition",
            "location": 225,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X_ohe": [
                    "np.ndarray"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "ranges": [
                    "Dict[(str, List[float])]"
                ],
                "immutable_features": [
                    "List[str]"
                ],
                "conditional": [
                    "bool"
                ]
            }
        },
        "sample_numerical": {
            "name": "sample_numerical",
            "location": 286,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "X_hat_num_split": [
                    "List[np.ndarray]"
                ],
                "X_ohe_num_split": [
                    "List[np.ndarray]"
                ],
                "C_num_split": [
                    "Optional[List[np.ndarray]]"
                ],
                "stats": [
                    "Dict[(int, Dict[(str, float)])]"
                ]
            }
        },
        "sample_categorical": {
            "name": "sample_categorical",
            "location": 337,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "X_hat_cat_split": [
                    "List[np.ndarray]"
                ],
                "C_cat_split": [
                    "Optional[List[np.ndarray]]"
                ]
            }
        },
        "sample": {
            "name": "sample",
            "location": 372,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "X_hat_split": [
                    "List[np.ndarray]"
                ],
                "X_ohe": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "stats": [
                    "Dict[(int, Dict[(str, float)])]"
                ]
            }
        },
        "get_he_preprocessor": {
            "name": "get_he_preprocessor",
            "location": 425,
            "return": [
                "Tuple[(Callable[([np.ndarray], np.ndarray)], Callable[([np.ndarray], np.ndarray)])]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "feature_types": [
                    "Optional[Dict[(str, type)]]"
                ]
            }
        },
        "get_statistics": {
            "name": "get_statistics",
            "location": 532,
            "return": [
                "Dict[(int, Dict[(str, float)])]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "preprocessor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ]
            }
        },
        "get_numerical_conditional_vector": {
            "name": "get_numerical_conditional_vector",
            "location": 569,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "condition": [
                    "Dict[(str, List[Union[(float, str)]])]"
                ],
                "preprocessor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "stats": [
                    "Dict[(int, Dict[(str, float)])]"
                ],
                "ranges": [
                    "Optional[Dict[(str, List[float])]]"
                ],
                "immutable_features": [
                    "Optional[List[str]]"
                ],
                "diverse": []
            }
        },
        "get_categorical_conditional_vector": {
            "name": "get_categorical_conditional_vector",
            "location": 687,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "condition": [
                    "Dict[(str, List[Union[(float, str)]])]"
                ],
                "preprocessor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "immutable_features": [
                    "Optional[List[str]]"
                ],
                "diverse": []
            }
        },
        "get_conditional_vector": {
            "name": "get_conditional_vector",
            "location": 766,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "condition": [
                    "Dict[(str, List[Union[(float, str)]])]"
                ],
                "preprocessor": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "stats": [
                    "Dict[(int, Dict[(str, float)])]"
                ],
                "ranges": [
                    "Optional[Dict[(str, List[float])]]"
                ],
                "immutable_features": [
                    "Optional[List[str]]"
                ],
                "diverse": []
            }
        },
        "apply_category_mapping": {
            "name": "apply_category_mapping",
            "location": 858,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ]
            }
        },
        "get_he_preprocessor.get_inv_preprocessor": {
            "name": "get_inv_preprocessor",
            "location": 481,
            "return": [],
            "arguments": {
                "X_ohe": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/__init__.py": {},
    "alibi-master/alibi/explainers/backends/pytorch/cfrl_base.py": {
        "get_device": {
            "name": "get_device",
            "location": 104,
            "return": [
                "torch.device"
            ],
            "arguments": {}
        },
        "get_optimizer": {
            "name": "get_optimizer",
            "location": 115,
            "return": [
                "torch.optim.Optimizer"
            ],
            "arguments": {
                "model": [
                    "nn.Module"
                ],
                "lr": [
                    "float"
                ]
            }
        },
        "get_actor": {
            "name": "get_actor",
            "location": 126,
            "return": [
                "nn.Module"
            ],
            "arguments": {
                "hidden_dim": [
                    "int"
                ],
                "output_dim": [
                    "int"
                ]
            }
        },
        "get_critic": {
            "name": "get_critic",
            "location": 144,
            "return": [
                "nn.Module"
            ],
            "arguments": {
                "hidden_dim": [
                    "int"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 160,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "X_hat_cf": [
                    "torch.Tensor"
                ],
                "X": [
                    "torch.Tensor"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 178,
            "return": [],
            "arguments": {
                "Z_cf_pred": [
                    "torch.Tensor"
                ],
                "Z_cf_tgt": [
                    "torch.Tensor"
                ]
            }
        },
        "data_generator": {
            "name": "data_generator",
            "location": 196,
            "return": [],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "encoder_preprocessor": [
                    "Callable"
                ],
                "predictor": [
                    "Callable"
                ],
                "conditional_func": [
                    "Callable"
                ],
                "batch_size": [
                    "int"
                ],
                "shuffle": [
                    "bool"
                ],
                "num_workers": [
                    "int"
                ]
            }
        },
        "encode": {
            "name": "encode",
            "location": 238,
            "return": [],
            "arguments": {
                "X": [
                    "torch.Tensor"
                ],
                "encoder": [
                    "nn.Module"
                ],
                "device": [
                    "torch.device"
                ]
            }
        },
        "decode": {
            "name": "decode",
            "location": 260,
            "return": [],
            "arguments": {
                "Z": [
                    "torch.Tensor"
                ],
                "decoder": [
                    "nn.Module"
                ],
                "device": [
                    "torch.device"
                ]
            }
        },
        "generate_cf": {
            "name": "generate_cf",
            "location": 282,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "Z": [
                    "torch.Tensor"
                ],
                "Y_m": [
                    "torch.Tensor"
                ],
                "Y_t": [
                    "torch.Tensor"
                ],
                "C": [
                    "Optional[torch.Tensor]"
                ],
                "encoder": [
                    "nn.Module"
                ],
                "decoder": [
                    "nn.Module"
                ],
                "actor": [
                    "nn.Module"
                ],
                "device": [
                    "torch.device"
                ]
            }
        },
        "add_noise": {
            "name": "add_noise",
            "location": 337,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "Z_cf": [
                    "torch.Tensor"
                ],
                "noise": [
                    "'NormalActionNoise'"
                ],
                "act_low": [
                    "float"
                ],
                "act_high": [
                    "float"
                ],
                "step": [
                    "int"
                ],
                "exploration_steps": [
                    "int"
                ],
                "device": [
                    "torch.device"
                ]
            }
        },
        "update_actor_critic": {
            "name": "update_actor_critic",
            "location": 385,
            "return": [],
            "arguments": {
                "encoder": [
                    "nn.Module"
                ],
                "decoder": [
                    "nn.Module"
                ],
                "critic": [
                    "nn.Module"
                ],
                "actor": [
                    "nn.Module"
                ],
                "optimizer_critic": [
                    "torch.optim.Optimizer"
                ],
                "optimizer_actor": [
                    "torch.optim.Optimizer"
                ],
                "sparsity_loss": [
                    "Callable"
                ],
                "consistency_loss": [
                    "Callable"
                ],
                "coeff_sparsity": [
                    "float"
                ],
                "coeff_consistency": [
                    "float"
                ],
                "X": [
                    "np.ndarray"
                ],
                "X_cf": [
                    "np.ndarray"
                ],
                "Z": [
                    "np.ndarray"
                ],
                "Z_cf_tilde": [
                    "np.ndarray"
                ],
                "Y_m": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ],
                "R_tilde": [
                    "np.ndarray"
                ],
                "device": [
                    "torch.device"
                ]
            }
        },
        "to_numpy": {
            "name": "to_numpy",
            "location": 533,
            "return": [
                "Optional[Union[(List, np.ndarray)]]"
            ],
            "arguments": {
                "X": [
                    "Optional[Union[(List, np.ndarray, torch.Tensor)]]"
                ]
            }
        },
        "to_tensor": {
            "name": "to_tensor",
            "location": 561,
            "return": [
                "Optional[torch.Tensor]"
            ],
            "arguments": {
                "X": [
                    "Union[(np.ndarray, torch.Tensor)]"
                ],
                "device": [
                    "torch.device"
                ]
            }
        },
        "save_model": {
            "name": "save_model",
            "location": 578,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "model": [
                    "nn.Module"
                ]
            }
        },
        "load_model": {
            "name": "load_model",
            "location": 592,
            "return": [
                "nn.Module"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "set_seed": {
            "name": "set_seed",
            "location": 610,
            "return": [],
            "arguments": {
                "seed": [
                    "int"
                ]
            }
        },
        "PtCounterfactualRLDataset.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "preprocessor": [
                    "Callable"
                ],
                "predictor": [
                    "Callable"
                ],
                "conditional_func": [
                    "Callable"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "PtCounterfactualRLDataset.__len__": {
            "name": "__len__",
            "location": 77,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PtCounterfactualRLDataset.__getitem__": {
            "name": "__getitem__",
            "location": 80,
            "return": [
                "Dict[(str, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "idx": []
            }
        }
    },
    "alibi-master/alibi/explainers/backends/pytorch/cfrl_tabular.py": {
        "sample_differentiable": {
            "name": "sample_differentiable",
            "location": 24,
            "return": [
                "List[torch.Tensor]"
            ],
            "arguments": {
                "X_hat_split": [
                    "List[torch.Tensor]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ]
            }
        },
        "l0_ohe": {
            "name": "l0_ohe",
            "location": 63,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "input": [
                    "torch.Tensor"
                ],
                "target": [
                    "torch.Tensor"
                ],
                "reduction": [
                    "str"
                ]
            }
        },
        "l1_loss": {
            "name": "l1_loss",
            "location": 98,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "input": [
                    "torch.Tensor"
                ],
                "target": [
                    "torch.Tensor"
                ],
                "reduction": [
                    "str"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 118,
            "return": [],
            "arguments": {
                "X_hat_split": [
                    "List[torch.Tensor]"
                ],
                "X_ohe": [
                    "torch.Tensor"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "weight_num": [
                    "float"
                ],
                "weight_cat": [
                    "float"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 174,
            "return": [],
            "arguments": {
                "Z_cf_pred": [
                    "torch.Tensor"
                ],
                "Z_cf_tgt": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/pytorch/__init__.py": {},
    "alibi-master/alibi/explainers/backends/tensorflow/cfrl_base.py": {
        "get_optimizer": {
            "name": "get_optimizer",
            "location": 115,
            "return": [
                "keras.optimizers.Optimizer"
            ],
            "arguments": {
                "model": [
                    "Optional[keras.layers.Layer]"
                ],
                "lr": [
                    "float"
                ]
            }
        },
        "get_actor": {
            "name": "get_actor",
            "location": 133,
            "return": [
                "keras.layers.Layer"
            ],
            "arguments": {
                "hidden_dim": [
                    "int"
                ],
                "output_dim": [
                    "int"
                ]
            }
        },
        "get_critic": {
            "name": "get_critic",
            "location": 151,
            "return": [
                "keras.layers.Layer"
            ],
            "arguments": {
                "hidden_dim": [
                    "int"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 167,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "X_hat_cf": [
                    "tf.Tensor"
                ],
                "X": [
                    "tf.Tensor"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 185,
            "return": [],
            "arguments": {
                "Z_cf_pred": [
                    "tf.Tensor"
                ],
                "Z_cf_tgt": [
                    "tf.Tensor"
                ]
            }
        },
        "data_generator": {
            "name": "data_generator",
            "location": 203,
            "return": [],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "encoder_preprocessor": [
                    "Callable"
                ],
                "predictor": [
                    "Callable"
                ],
                "conditional_func": [
                    "Callable"
                ],
                "batch_size": [
                    "int"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "encode": {
            "name": "encode",
            "location": 239,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "X": [
                    "Union[(tf.Tensor, np.ndarray)]"
                ],
                "encoder": [
                    "keras.Model"
                ]
            }
        },
        "decode": {
            "name": "decode",
            "location": 259,
            "return": [],
            "arguments": {
                "Z": [
                    "Union[(tf.Tensor, np.ndarray)]"
                ],
                "decoder": [
                    "keras.Model"
                ]
            }
        },
        "generate_cf": {
            "name": "generate_cf",
            "location": 279,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "Z": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ],
                "Y_m": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ],
                "Y_t": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ],
                "C": [
                    "Optional[Union[(np.ndarray, tf.Tensor)]]"
                ],
                "actor": [
                    "keras.Model"
                ]
            }
        },
        "add_noise": {
            "name": "add_noise",
            "location": 322,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "Z_cf": [
                    "Union[(tf.Tensor, np.ndarray)]"
                ],
                "noise": [
                    "'NormalActionNoise'"
                ],
                "act_low": [
                    "float"
                ],
                "act_high": [
                    "float"
                ],
                "step": [
                    "int"
                ],
                "exploration_steps": [
                    "int"
                ]
            }
        },
        "initialize_optimizer": {
            "name": "initialize_optimizer",
            "location": 369,
            "return": [
                "None"
            ],
            "arguments": {
                "optimizer": [
                    "keras.optimizers.Optimizer"
                ],
                "model": [
                    "keras.Model"
                ]
            }
        },
        "initialize_optimizers": {
            "name": "initialize_optimizers",
            "location": 388,
            "return": [
                "None"
            ],
            "arguments": {
                "optimizer_actor": [],
                "optimizer_critic": [],
                "actor": [],
                "critic": []
            }
        },
        "initialize_actor_critic": {
            "name": "initialize_actor_critic",
            "location": 409,
            "return": [],
            "arguments": {
                "actor": [],
                "critic": [],
                "Z": [],
                "Z_cf_tilde": [],
                "Y_m": [],
                "Y_t": [],
                "C": []
            }
        },
        "update_actor_critic": {
            "name": "update_actor_critic",
            "location": 457,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "encoder": [
                    "keras.Model"
                ],
                "decoder": [
                    "keras.Model"
                ],
                "critic": [
                    "keras.Model"
                ],
                "actor": [
                    "keras.Model"
                ],
                "optimizer_critic": [
                    "keras.optimizers.Optimizer"
                ],
                "optimizer_actor": [
                    "keras.optimizers.Optimizer"
                ],
                "sparsity_loss": [
                    "Callable"
                ],
                "consistency_loss": [
                    "Callable"
                ],
                "coeff_sparsity": [
                    "float"
                ],
                "coeff_consistency": [
                    "float"
                ],
                "X": [
                    "np.ndarray"
                ],
                "X_cf": [
                    "np.ndarray"
                ],
                "Z": [
                    "np.ndarray"
                ],
                "Z_cf_tilde": [
                    "np.ndarray"
                ],
                "Y_m": [
                    "np.ndarray"
                ],
                "Y_t": [
                    "np.ndarray"
                ],
                "C": [
                    "Optional[np.ndarray]"
                ],
                "R_tilde": [
                    "np.ndarray"
                ]
            }
        },
        "to_numpy": {
            "name": "to_numpy",
            "location": 590,
            "return": [
                "Optional[Union[(List, np.ndarray)]]"
            ],
            "arguments": {
                "X": [
                    "Optional[Union[(List, np.ndarray, tf.Tensor)]]"
                ]
            }
        },
        "to_tensor": {
            "name": "to_tensor",
            "location": 617,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "X": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ]
            }
        },
        "save_model": {
            "name": "save_model",
            "location": 641,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ],
                "model": [
                    "keras.layers.Layer"
                ]
            }
        },
        "load_model": {
            "name": "load_model",
            "location": 655,
            "return": [
                "keras.Model"
            ],
            "arguments": {
                "path": [
                    "Union[(str, os.PathLike)]"
                ]
            }
        },
        "set_seed": {
            "name": "set_seed",
            "location": 671,
            "return": [],
            "arguments": {
                "seed": [
                    "int"
                ]
            }
        },
        "TfCounterfactualRLDataset.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "preprocessor": [
                    "Callable"
                ],
                "predictor": [
                    "Callable"
                ],
                "conditional_func": [
                    "Callable"
                ],
                "batch_size": [
                    "int"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "TfCounterfactualRLDataset.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TfCounterfactualRLDataset.__len__": {
            "name": "__len__",
            "location": 88,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TfCounterfactualRLDataset.__getitem__": {
            "name": "__getitem__",
            "location": 91,
            "return": [
                "Dict[(str, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "idx": []
            }
        }
    },
    "alibi-master/alibi/explainers/backends/tensorflow/cfrl_tabular.py": {
        "sample_differentiable": {
            "name": "sample_differentiable",
            "location": 23,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "X_hat_split": [
                    "List[tf.Tensor]"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ]
            }
        },
        "l0_ohe": {
            "name": "l0_ohe",
            "location": 62,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "input": [
                    "tf.Tensor"
                ],
                "target": [
                    "tf.Tensor"
                ],
                "reduction": [
                    "str"
                ]
            }
        },
        "l1_loss": {
            "name": "l1_loss",
            "location": 97,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "input": [
                    "tf.Tensor"
                ],
                "target": [],
                "reduction": [
                    "str"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 128,
            "return": [],
            "arguments": {
                "X_hat_split": [
                    "List[tf.Tensor]"
                ],
                "X_ohe": [
                    "tf.Tensor"
                ],
                "category_map": [
                    "Dict[(int, List[str])]"
                ],
                "weight_num": [
                    "float"
                ],
                "weight_cat": [
                    "float"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 185,
            "return": [],
            "arguments": {
                "Z_cf_pred": [
                    "tf.Tensor"
                ],
                "Z_cf_tgt": [
                    "Union[(np.ndarray, tf.Tensor)]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/tensorflow/__init__.py": {},
    "alibi-master/alibi/explainers/similarity/base.py": {
        "BaseSimilarityExplainer.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "loss_fn": [
                    "'Union[Callable[[tensorflow.Tensor, tensorflow.Tensor], tensorflow.Tensor],\\n                                   Callable[[torch.Tensor, torch.Tensor], torch.Tensor]]'"
                ],
                "sim_fn": [
                    "Callable[([np.ndarray, np.ndarray], np.ndarray)]"
                ],
                "precompute_grads": [
                    "bool"
                ],
                "backend": [
                    "Framework"
                ],
                "device": [
                    "'Union[int, str, torch.device, None]'"
                ],
                "meta": [
                    "Optional[dict]"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "BaseSimilarityExplainer.fit": {
            "name": "fit",
            "location": 65,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "self": [],
                "X_train": [
                    "np.ndarray"
                ],
                "Y_train": [
                    "np.ndarray"
                ]
            }
        },
        "BaseSimilarityExplainer._verify_fit": {
            "name": "_verify_fit",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseSimilarityExplainer._match_shape_to_data": {
            "name": "_match_shape_to_data",
            "location": 109,
            "return": [
                "'Union[np.ndarray, tensorflow.Tensor, torch.Tensor]'"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "'Union[np.ndarray, tensorflow.Tensor, torch.Tensor]'"
                ],
                "target_type": [
                    "Literal[('X', 'Y')]"
                ]
            }
        },
        "BaseSimilarityExplainer._compute_adhoc_similarity": {
            "name": "_compute_adhoc_similarity",
            "location": 142,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "grad_X": [
                    "np.ndarray"
                ]
            }
        },
        "BaseSimilarityExplainer._compute_grad": {
            "name": "_compute_grad",
            "location": 158,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "'Union[np.ndarray, tensorflow.Tensor, torch.Tensor]'"
                ],
                "Y": [
                    "'Union[np.ndarray, tensorflow.Tensor, torch.Tensor]'"
                ]
            }
        },
        "BaseSimilarityExplainer.reset_predictor": {
            "name": "reset_predictor",
            "location": 168,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/grad.py": {
        "get_options_string": {
            "name": "get_options_string",
            "location": 27,
            "return": [
                "str"
            ],
            "arguments": {
                "enum": [
                    "Type[Enum]"
                ]
            }
        },
        "GradientSimilarity.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [
                    "'Union[tensorflow.keras.Model, torch.nn.Module]'"
                ],
                "loss_fn": [
                    "'Union[Callable[[tensorflow.Tensor, tensorflow.Tensor], tensorflow.Tensor],\\n                                   Callable[[torch.Tensor, torch.Tensor], torch.Tensor]]'"
                ],
                "sim_fn": [
                    "Literal[('grad_dot', 'grad_cos', 'grad_asym_dot')]"
                ],
                "task": [
                    "Literal[('classification', 'regression')]"
                ],
                "precompute_grads": [
                    "bool"
                ],
                "backend": [
                    "Literal[('tensorflow', 'pytorch')]"
                ],
                "device": [
                    "'Union[int, str, torch.device, None]'"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "GradientSimilarity.fit": {
            "name": "fit",
            "location": 137,
            "return": [
                "'Explainer'"
            ],
            "arguments": {
                "self": [],
                "X_train": [
                    "np.ndarray"
                ],
                "Y_train": [
                    "np.ndarray"
                ]
            }
        },
        "GradientSimilarity._preprocess_args": {
            "name": "_preprocess_args",
            "location": 161,
            "return": [
                "'Union[Tuple[torch.Tensor, torch.Tensor], Tuple[tensorflow.Tensor, tensorflow.Tensor]]'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "'Union[np.ndarray, tensorflow.Tensor, torch.Tensor]'"
                ],
                "Y": [
                    "'Optional[Union[np.ndarray, tensorflow.Tensor, torch.Tensor]]'"
                ]
            }
        },
        "GradientSimilarity.explain": {
            "name": "explain",
            "location": 201,
            "return": [
                "'Explanation'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "'Union[np.ndarray, tensorflow.Tensor, torch.Tensor]'"
                ],
                "Y": [
                    "'Optional[Union[np.ndarray, tensorflow.Tensor, torch.Tensor]]'"
                ]
            }
        },
        "GradientSimilarity._build_explanation": {
            "name": "_build_explanation",
            "location": 255,
            "return": [
                "'Explanation'"
            ],
            "arguments": {
                "self": [],
                "scores": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/metrics.py": {
        "dot": {
            "name": "dot",
            "location": 6,
            "return": [
                "Union[(float, np.ndarray)]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "cos": {
            "name": "cos",
            "location": 27,
            "return": [
                "Union[(float, np.ndarray)]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "eps": [
                    "float"
                ]
            }
        },
        "asym_dot": {
            "name": "asym_dot",
            "location": 51,
            "return": [
                "Union[(float, np.ndarray)]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "eps": [
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/__init__.py": {},
    "alibi-master/alibi/explainers/similarity/backends/__init__.py": {
        "_select_backend": {
            "name": "_select_backend",
            "location": 14,
            "return": [
                "Union[(Type['_TensorFlowBackend'], Type['_PytorchBackend'])]"
            ],
            "arguments": {
                "backend": [
                    "Framework"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/backends/pytorch/base.py": {
        "_PytorchBackend.get_grads": {
            "name": "get_grads",
            "location": 18,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "model": [
                    "nn.Module"
                ],
                "X": [
                    "torch.Tensor"
                ],
                "Y": [
                    "torch.Tensor"
                ],
                "loss_fn": [
                    "Callable[([torch.Tensor, torch.Tensor], torch.Tensor)]"
                ]
            }
        },
        "_PytorchBackend.to_tensor": {
            "name": "to_tensor",
            "location": 57,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "_PytorchBackend.set_device": {
            "name": "set_device",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "Union[(str, int, torch.device, None)]"
                ]
            }
        },
        "_PytorchBackend.to_numpy": {
            "name": "to_numpy",
            "location": 79,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "torch.Tensor"
                ]
            }
        },
        "_PytorchBackend.argmax": {
            "name": "argmax",
            "location": 84,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "X": [
                    "torch.Tensor"
                ],
                "dim": []
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/backends/pytorch/__init__.py": {},
    "alibi-master/alibi/explainers/similarity/backends/tensorflow/base.py": {
        "_TensorFlowBackend.get_grads": {
            "name": "get_grads",
            "location": 18,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "model": [
                    "keras.Model"
                ],
                "X": [
                    "tf.Tensor"
                ],
                "Y": [
                    "tf.Tensor"
                ],
                "loss_fn": [
                    "Callable[([tf.Tensor, tf.Tensor], tf.Tensor)]"
                ]
            }
        },
        "_TensorFlowBackend.to_tensor": {
            "name": "to_tensor",
            "location": 57,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "_TensorFlowBackend.set_device": {
            "name": "set_device",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "Union[(str, None)]"
                ]
            }
        },
        "_TensorFlowBackend.to_numpy": {
            "name": "to_numpy",
            "location": 73,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "X": [
                    "tf.Tensor"
                ]
            }
        },
        "_TensorFlowBackend.argmax": {
            "name": "argmax",
            "location": 78,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "X": [
                    "tf.Tensor"
                ],
                "dim": []
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/backends/tensorflow/__init__.py": {},
    "alibi-master/alibi/explainers/tests/conftest.py": {
        "models": {
            "name": "models",
            "location": 32,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "mnist_data": {
            "name": "mnist_data",
            "location": 44,
            "return": [],
            "arguments": {}
        },
        "boston_data": {
            "name": "boston_data",
            "location": 49,
            "return": [],
            "arguments": {}
        },
        "iris_data": {
            "name": "iris_data",
            "location": 54,
            "return": [],
            "arguments": {}
        },
        "adult_data": {
            "name": "adult_data",
            "location": 66,
            "return": [],
            "arguments": {}
        },
        "movie_sentiment_data": {
            "name": "movie_sentiment_data",
            "location": 78,
            "return": [],
            "arguments": {}
        },
        "rf_classifier": {
            "name": "rf_classifier",
            "location": 92,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "lr_classifier": {
            "name": "lr_classifier",
            "location": 123,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "lr_regressor": {
            "name": "lr_regressor",
            "location": 151,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "at_defaults": {
            "name": "at_defaults",
            "location": 177,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "at_iris_explainer": {
            "name": "at_iris_explainer",
            "location": 200,
            "return": [],
            "arguments": {
                "iris_data": [],
                "rf_classifier": [],
                "request": []
            }
        },
        "at_adult_explainer": {
            "name": "at_adult_explainer",
            "location": 218,
            "return": [],
            "arguments": {
                "adult_data": [],
                "rf_classifier": [],
                "request": []
            }
        },
        "mock_kernel_shap_explainer": {
            "name": "mock_kernel_shap_explainer",
            "location": 241,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "mock_ale_explainer": {
            "name": "mock_ale_explainer",
            "location": 254,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "mock_tree_shap_explainer": {
            "name": "mock_tree_shap_explainer",
            "location": 266,
            "return": [],
            "arguments": {
                "monkeypatch": [],
                "request": []
            }
        },
        "no_warnings": {
            "name": "no_warnings",
            "location": 290,
            "return": [],
            "arguments": {
                "caplog": []
            }
        },
        "no_errors": {
            "name": "no_errors",
            "location": 302,
            "return": [],
            "arguments": {
                "caplog": []
            }
        },
        "pytest_configure": {
            "name": "pytest_configure",
            "location": 314,
            "return": [],
            "arguments": {
                "config": []
            }
        },
        "pytest_collection_modifyitems": {
            "name": "pytest_collection_modifyitems",
            "location": 320,
            "return": [],
            "arguments": {
                "config": [],
                "items": []
            }
        },
        "disable_tf2": {
            "name": "disable_tf2",
            "location": 337,
            "return": [],
            "arguments": {}
        },
        "lang_model": {
            "name": "lang_model",
            "location": 351,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "nlp": {
            "name": "nlp",
            "location": 367,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/tests/test_ale.py": {
        "test_ale_num_linear_regression": {
            "name": "test_ale_num_linear_regression",
            "location": 15,
            "return": [],
            "arguments": {
                "min_bin_points": [],
                "lr_regressor": [],
                "dataset": []
            }
        },
        "test_ale_num_logistic_regression": {
            "name": "test_ale_num_logistic_regression",
            "location": 35,
            "return": [],
            "arguments": {
                "min_bin_points": [],
                "lr_classifier": [],
                "dataset": []
            }
        },
        "test_get_quantiles": {
            "name": "test_get_quantiles",
            "location": 52,
            "return": [],
            "arguments": {
                "input_dim": [],
                "batch_size": [],
                "num_points": []
            }
        },
        "test_adaptive_grid": {
            "name": "test_adaptive_grid",
            "location": 60,
            "return": [],
            "arguments": {
                "batch_size": [],
                "min_bin_points": []
            }
        },
        "uncollect_if_n_features_more_than_input_dim": {
            "name": "uncollect_if_n_features_more_than_input_dim",
            "location": 73,
            "return": [],
            "arguments": {}
        },
        "test_explain": {
            "name": "test_explain",
            "location": 91,
            "return": [],
            "arguments": {
                "mock_ale_explainer": [],
                "features": [],
                "input_dim": [],
                "batch_size": [],
                "custom_grid": [],
                "num_grid_points": []
            }
        },
        "test_constant_feature": {
            "name": "test_constant_feature",
            "location": 141,
            "return": [],
            "arguments": {
                "extrapolate_constant": [],
                "extrapolate_constant_perc": [],
                "extrapolate_constant_min": [],
                "constant_value": [],
                "feature": [],
                "custom_grid": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_base.py": {
        "test_anchor_base_beam": {
            "name": "test_anchor_base_beam",
            "location": 15,
            "return": [],
            "arguments": {
                "rf_classifier": [],
                "at_defaults": [],
                "at_iris_explainer": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_image.py": {
        "test_scale_image": {
            "name": "test_scale_image",
            "location": 12,
            "return": [],
            "arguments": {}
        },
        "predict_fn": {
            "name": "predict_fn",
            "location": 25,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_sampler": {
            "name": "test_sampler",
            "location": 51,
            "return": [],
            "arguments": {
                "predict_fn": [],
                "models": [],
                "mnist_data": []
            }
        },
        "test_anchor_image": {
            "name": "test_anchor_image",
            "location": 107,
            "return": [],
            "arguments": {
                "predict_fn": [],
                "models": [],
                "mnist_data": [],
                "images_background": []
            }
        },
        "test_anchor_image_fails_init_torch_float64": {
            "name": "test_anchor_image_fails_init_torch_float64",
            "location": 169,
            "return": [],
            "arguments": {
                "predict_fn": [],
                "models": []
            }
        },
        "bad_predictor": {
            "name": "bad_predictor",
            "location": 174,
            "return": [
                "list"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ]
            }
        },
        "test_anchor_image_fails_init_bad_image_shape_predictor_call": {
            "name": "test_anchor_image_fails_init_bad_image_shape_predictor_call",
            "location": 186,
            "return": [],
            "arguments": {}
        },
        "test_anchor_image_fails_bad_predictor_return_type": {
            "name": "test_anchor_image_fails_bad_predictor_return_type",
            "location": 194,
            "return": [],
            "arguments": {}
        },
        "predict_fn.func": {
            "name": "func",
            "location": 33,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "image": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_tabular.py": {
        "uncollect_if_test_explainer": {
            "name": "uncollect_if_test_explainer",
            "location": 15,
            "return": [],
            "arguments": {}
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 53,
            "return": [],
            "arguments": {
                "n_explainer_runs": [],
                "at_defaults": [],
                "rf_classifier": [],
                "explainer": [],
                "test_instance_idx": [],
                "caplog": []
            }
        },
        "uncollect_if_test_sampler": {
            "name": "uncollect_if_test_sampler",
            "location": 91,
            "return": [],
            "arguments": {}
        },
        "test_distributed_anchor_tabular": {
            "name": "test_distributed_anchor_tabular",
            "location": 117,
            "return": [],
            "arguments": {
                "ncpu": [],
                "predict_type": [],
                "at_defaults": [],
                "iris_data": [],
                "rf_classifier": [],
                "test_instance_idx": []
            }
        },
        "test_sampler": {
            "name": "test_sampler",
            "location": 210,
            "return": [],
            "arguments": {
                "test_instance_idx": [],
                "anchors": [],
                "nb_samples": [],
                "dataset": [],
                "rf_classifier": [],
                "explainer": []
            }
        },
        "bad_predictor": {
            "name": "bad_predictor",
            "location": 313,
            "return": [
                "list"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ]
            }
        },
        "test_anchor_tabular_fails_init_bad_feature_names_predictor_call": {
            "name": "test_anchor_tabular_fails_init_bad_feature_names_predictor_call",
            "location": 325,
            "return": [],
            "arguments": {}
        },
        "test_anchor_tabular_fails_bad_predictor_return_type": {
            "name": "test_anchor_tabular_fails_bad_predictor_return_type",
            "location": 333,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_text.py": {
        "uncollect_if_test_explainer": {
            "name": "uncollect_if_test_explainer",
            "location": 17,
            "return": [],
            "arguments": {}
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 54,
            "return": [],
            "arguments": {
                "text": [],
                "n_punctuation_marks": [],
                "n_unique_words": [],
                "lr_classifier": [],
                "predict_type": [],
                "anchor": [],
                "use_proba": [],
                "sampling_strategy": [],
                "filling": [],
                "threshold": [],
                "lang_model": [],
                "nlp": []
            }
        },
        "test_neighbors": {
            "name": "test_neighbors",
            "location": 140,
            "return": [],
            "arguments": {
                "nlp": []
            }
        },
        "test_lm_punctuation": {
            "name": "test_lm_punctuation",
            "location": 160,
            "return": [],
            "arguments": {
                "text": [],
                "min_num": [],
                "lang_model": []
            }
        },
        "test_lm_stopwords": {
            "name": "test_lm_stopwords",
            "location": 191,
            "return": [],
            "arguments": {
                "text": [],
                "stopwords": [],
                "lang_model": []
            }
        },
        "test_lm_precision": {
            "name": "test_lm_precision",
            "location": 228,
            "return": [],
            "arguments": {
                "lang_model": [],
                "lr_classifier": [],
                "movie_sentiment_data": [],
                "punctuation": [],
                "stopwords": []
            }
        },
        "test_lm_stopwords_punctuation": {
            "name": "test_lm_stopwords_punctuation",
            "location": 279,
            "return": [],
            "arguments": {
                "lang_model": [],
                "punctuation": [],
                "stopwords": [],
                "filling": [],
                "movie_sentiment_data": [],
                "sample_proba": [],
                "nlp": []
            }
        },
        "test_lm_split": {
            "name": "test_lm_split",
            "location": 348,
            "return": [],
            "arguments": {
                "lang_model": [],
                "head_gt": [],
                "num_tokens": []
            }
        },
        "test_lm_mask": {
            "name": "test_lm_mask",
            "location": 368,
            "return": [],
            "arguments": {
                "lang_model": [],
                "num_tokens": [],
                "sample_proba": [],
                "filling": []
            }
        },
        "test_lm_sample_punctuation": {
            "name": "test_lm_sample_punctuation",
            "location": 408,
            "return": [],
            "arguments": {
                "lang_model": [],
                "punctuation": [],
                "filling": [],
                "movie_sentiment_data": [],
                "sample_proba": []
            }
        },
        "bad_predictor_return_type": {
            "name": "bad_predictor_return_type",
            "location": 453,
            "return": [
                "list"
            ],
            "arguments": {
                "x": [
                    "List[str]"
                ]
            }
        },
        "bad_predictor_input_type": {
            "name": "bad_predictor_input_type",
            "location": 462,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ]
            }
        },
        "test_anchor_text_fails_init_bad_predictor_input_type_call": {
            "name": "test_anchor_text_fails_init_bad_predictor_input_type_call",
            "location": 471,
            "return": [],
            "arguments": {}
        },
        "test_anchor_text_fails_wrong_predictor_return_type": {
            "name": "test_anchor_text_fails_wrong_predictor_return_type",
            "location": 476,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/tests/test_cem.py": {
        "test_cem": {
            "name": "test_cem",
            "location": 10,
            "return": [],
            "arguments": {
                "disable_tf2": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_cfproto.py": {
        "tf_keras_iris_explainer": {
            "name": "tf_keras_iris_explainer",
            "location": 10,
            "return": [],
            "arguments": {
                "request": [],
                "models": [],
                "iris_data": []
            }
        },
        "test_tf_keras_iris_explainer": {
            "name": "test_tf_keras_iris_explainer",
            "location": 42,
            "return": [],
            "arguments": {
                "disable_tf2": [],
                "iris_data": [],
                "tf_keras_iris_explainer": [],
                "use_kdtree": [],
                "k": []
            }
        },
        "tf_keras_adult_explainer": {
            "name": "tf_keras_adult_explainer",
            "location": 86,
            "return": [],
            "arguments": {
                "request": [],
                "models": [],
                "adult_data": []
            }
        },
        "test_tf_keras_adult_explainer": {
            "name": "test_tf_keras_adult_explainer",
            "location": 107,
            "return": [],
            "arguments": {
                "disable_tf2": [],
                "adult_data": [],
                "tf_keras_adult_explainer": [],
                "use_kdtree": [],
                "k": [],
                "d_type": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_cfrl.py": {
        "test_he_preprocessor": {
            "name": "test_he_preprocessor",
            "location": 19,
            "return": [],
            "arguments": {
                "dataset": []
            }
        },
        "test_split_ohe": {
            "name": "test_split_ohe",
            "location": 45,
            "return": [],
            "arguments": {
                "dataset": []
            }
        },
        "test_get_numerical_condition": {
            "name": "test_get_numerical_condition",
            "location": 75,
            "return": [],
            "arguments": {
                "dataset": []
            }
        },
        "test_get_categorical_condition": {
            "name": "test_get_categorical_condition",
            "location": 120,
            "return": [],
            "arguments": {
                "dataset": []
            }
        },
        "test_sample": {
            "name": "test_sample",
            "location": 165,
            "return": [],
            "arguments": {
                "dataset": [],
                "seed": []
            }
        },
        "test_hard_distribution": {
            "name": "test_hard_distribution",
            "location": 229,
            "return": [],
            "arguments": {
                "Y_shape": [],
                "num_classes": []
            }
        },
        "tf_keras_iris_explainer": {
            "name": "tf_keras_iris_explainer",
            "location": 242,
            "return": [],
            "arguments": {
                "models": [],
                "iris_data": [],
                "rf_classifier": []
            }
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 303,
            "return": [],
            "arguments": {
                "tf_keras_iris_explainer": [],
                "iris_data": []
            }
        },
        "test_sample_differentiable": {
            "name": "test_sample_differentiable",
            "location": 326,
            "return": [],
            "arguments": {
                "dataset": [],
                "backend": []
            }
        },
        "test_l0_loss": {
            "name": "test_l0_loss",
            "location": 376,
            "return": [],
            "arguments": {
                "reduction": [],
                "backend": []
            }
        },
        "test_l1_loss": {
            "name": "test_l1_loss",
            "location": 415,
            "return": [],
            "arguments": {
                "reduction": [],
                "backend": []
            }
        },
        "test_consistency_loss": {
            "name": "test_consistency_loss",
            "location": 447,
            "return": [],
            "arguments": {
                "backend": []
            }
        },
        "test_sparsity_loss": {
            "name": "test_sparsity_loss",
            "location": 473,
            "return": [],
            "arguments": {
                "dataset": [],
                "backend": []
            }
        },
        "test_l0_loss.generate_random_labels": {
            "name": "generate_random_labels",
            "location": 380,
            "return": [],
            "arguments": {}
        },
        "tf_keras_iris_explainer.DecoderList.__init__": {
            "name": "__init__",
            "location": 264,
            "return": [],
            "arguments": {
                "self": [],
                "decoder": [
                    "tf.keras.Model"
                ]
            }
        },
        "tf_keras_iris_explainer.DecoderList.call": {
            "name": "call",
            "location": 268,
            "return": [],
            "arguments": {
                "self": [],
                "input": [
                    "Union[(tf.Tensor, List[tf.Tensor])]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_counterfactual.py": {
        "logistic_iris": {
            "name": "logistic_iris",
            "location": 13,
            "return": [],
            "arguments": {}
        },
        "cf_iris_explainer": {
            "name": "cf_iris_explainer",
            "location": 20,
            "return": [],
            "arguments": {
                "request": [],
                "logistic_iris": []
            }
        },
        "keras_mnist_cf_explainer": {
            "name": "keras_mnist_cf_explainer",
            "location": 32,
            "return": [],
            "arguments": {
                "request": [],
                "models": []
            }
        },
        "test_define_func": {
            "name": "test_define_func",
            "location": 41,
            "return": [],
            "arguments": {
                "logistic_iris": [],
                "target_class": []
            }
        },
        "test_cf_explainer_iris": {
            "name": "test_cf_explainer_iris",
            "location": 70,
            "return": [],
            "arguments": {
                "disable_tf2": [],
                "cf_iris_explainer": []
            }
        },
        "test_keras_mnist_explainer": {
            "name": "test_keras_mnist_explainer",
            "location": 116,
            "return": [],
            "arguments": {
                "disable_tf2": [],
                "keras_mnist_cf_explainer": [],
                "mnist_data": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_integrated_gradients.py": {
        "ffn_model": {
            "name": "ffn_model",
            "location": 57,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "ffn_model_multi_inputs": {
            "name": "ffn_model_multi_inputs",
            "location": 78,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "ffn_model_subclass": {
            "name": "ffn_model_subclass",
            "location": 103,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "ffn_model_subclass_list_input": {
            "name": "ffn_model_subclass_list_input",
            "location": 137,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "ffn_model_sequential": {
            "name": "ffn_model_sequential",
            "location": 171,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "uncollect_if_both_or_neither_target_fn_target": {
            "name": "uncollect_if_both_or_neither_target_fn_target",
            "location": 192,
            "return": [],
            "arguments": {}
        },
        "test_integrated_gradients_model_sequential": {
            "name": "test_integrated_gradients_model_sequential",
            "location": 212,
            "return": [],
            "arguments": {
                "ffn_model_sequential": [],
                "method": [],
                "baselines": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_model_subclass": {
            "name": "test_integrated_gradients_model_subclass",
            "location": 241,
            "return": [],
            "arguments": {
                "ffn_model_subclass": [],
                "method": [],
                "baselines": [],
                "kwargs": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_model_subclass_list_input": {
            "name": "test_integrated_gradients_model_subclass_list_input",
            "location": 271,
            "return": [],
            "arguments": {
                "ffn_model_subclass_list_input": [],
                "method": [],
                "baselines": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_binary_classification_multi_inputs": {
            "name": "test_integrated_gradients_binary_classification_multi_inputs",
            "location": 308,
            "return": [],
            "arguments": {
                "ffn_model_multi_inputs": [],
                "method": [],
                "baselines": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_binary_classification_single_output_multi_inputs": {
            "name": "test_integrated_gradients_binary_classification_single_output_multi_inputs",
            "location": 345,
            "return": [],
            "arguments": {
                "ffn_model_multi_inputs": [],
                "method": [],
                "baselines": [],
                "target_fn": [],
                "target": [],
                "recwarn": []
            }
        },
        "test_integrated_gradients_binary_classification": {
            "name": "test_integrated_gradients_binary_classification",
            "location": 390,
            "return": [],
            "arguments": {
                "ffn_model": [],
                "method": [],
                "baselines": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_binary_classification_single_output": {
            "name": "test_integrated_gradients_binary_classification_single_output",
            "location": 418,
            "return": [],
            "arguments": {
                "ffn_model": [],
                "method": [],
                "baselines": [],
                "target_fn": [],
                "target": [],
                "recwarn": []
            }
        },
        "test_integrated_gradients_binary_classification_single_output_squash_output": {
            "name": "test_integrated_gradients_binary_classification_single_output_squash_output",
            "location": 452,
            "return": [],
            "arguments": {
                "ffn_model": [],
                "method": [],
                "baselines": [],
                "target": []
            }
        },
        "test_integrated_gradients_binary_classification_layer": {
            "name": "test_integrated_gradients_binary_classification_layer",
            "location": 482,
            "return": [],
            "arguments": {
                "ffn_model": [],
                "method": [],
                "layer_nb": [],
                "baselines": [],
                "layer_inputs_attributions": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_binary_classification_layer_subclass": {
            "name": "test_integrated_gradients_binary_classification_layer_subclass",
            "location": 540,
            "return": [],
            "arguments": {
                "ffn_model_subclass": [],
                "method": [],
                "layer_nb": [],
                "baselines": [],
                "kwargs": [],
                "layer_inputs_attributions": [],
                "target_fn": [],
                "target": []
            }
        },
        "test_integrated_gradients_regression": {
            "name": "test_integrated_gradients_regression",
            "location": 594,
            "return": [],
            "arguments": {
                "ffn_model": [],
                "method": [],
                "baselines": []
            }
        },
        "test_run_forward_from_layer": {
            "name": "test_run_forward_from_layer",
            "location": 614,
            "return": [],
            "arguments": {
                "layer_nb": [],
                "run_from_layer_inputs": []
            }
        },
        "test_check_target": {
            "name": "test_check_target",
            "location": 691,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "test_select_target": {
            "name": "test_select_target",
            "location": 705,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "test_integrated_gradients_binary_classification_multi_layer": {
            "name": "test_integrated_gradients_binary_classification_multi_layer",
            "location": 725,
            "return": [],
            "arguments": {
                "ffn_model": [],
                "method": [],
                "baselines": []
            }
        },
        "test_integrated_gradients_binary_classification_multi_layer_subclassed": {
            "name": "test_integrated_gradients_binary_classification_multi_layer_subclassed",
            "location": 748,
            "return": [],
            "arguments": {
                "ffn_model_subclass": [],
                "method": [],
                "baselines": []
            }
        },
        "good_model": {
            "name": "good_model",
            "location": 766,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ]
            }
        },
        "bad_model": {
            "name": "bad_model",
            "location": 775,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ]
            }
        },
        "test__get_target_from_target_fn__with_2d_output_argmax": {
            "name": "test__get_target_from_target_fn__with_2d_output_argmax",
            "location": 784,
            "return": [],
            "arguments": {}
        },
        "test__get_target_from_target_fn__with_3d_output_argmax": {
            "name": "test__get_target_from_target_fn__with_3d_output_argmax",
            "location": 791,
            "return": [],
            "arguments": {}
        },
        "ffn_model_subclass.Linear.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [],
            "arguments": {
                "self": [],
                "output_dim": [],
                "activation": []
            }
        },
        "ffn_model_subclass.Linear.call": {
            "name": "call",
            "location": 117,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [],
                "mask": []
            }
        },
        "ffn_model_subclass_list_input.Linear.__init__": {
            "name": "__init__",
            "location": 146,
            "return": [],
            "arguments": {
                "self": [],
                "output_dim": [],
                "activation": []
            }
        },
        "ffn_model_subclass_list_input.Linear.call": {
            "name": "call",
            "location": 153,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_shap_wrappers.py": {
        "gen_group_names": {
            "name": "gen_group_names",
            "location": 37,
            "return": [],
            "arguments": {
                "n_groups": []
            }
        },
        "random_ints_with_sum": {
            "name": "random_ints_with_sum",
            "location": 48,
            "return": [],
            "arguments": {
                "n": []
            }
        },
        "gen_random_groups": {
            "name": "gen_random_groups",
            "location": 63,
            "return": [],
            "arguments": {
                "n_cols": []
            }
        },
        "gen_random_weights": {
            "name": "gen_random_weights",
            "location": 86,
            "return": [],
            "arguments": {
                "n_weights": [],
                "seed": []
            }
        },
        "setup_groups_and_weights": {
            "name": "setup_groups_and_weights",
            "location": 99,
            "return": [],
            "arguments": {
                "dimensions": [],
                "b_group_names": [],
                "b_groups": [],
                "b_weights": [],
                "seed": []
            }
        },
        "get_data": {
            "name": "get_data",
            "location": 125,
            "return": [],
            "arguments": {
                "kind": [],
                "n_rows": [],
                "n_cols": [],
                "fnames": [],
                "seed": []
            }
        },
        "get_labels": {
            "name": "get_labels",
            "location": 162,
            "return": [],
            "arguments": {
                "n_rows": [],
                "seed": []
            }
        },
        "generate_test_data": {
            "name": "generate_test_data",
            "location": 171,
            "return": [],
            "arguments": {
                "dimensions": [],
                "b_group_names": [],
                "b_groups": [],
                "b_weights": [],
                "correct": [],
                "error_type": [],
                "data_type": [],
                "dim_mismatch": [],
                "seed": []
            }
        },
        "assert_groups": {
            "name": "assert_groups",
            "location": 251,
            "return": [],
            "arguments": {
                "background_data": [],
                "group_names": [],
                "groups": []
            }
        },
        "test_rank_by_importance": {
            "name": "test_rank_by_importance",
            "location": 296,
            "return": [],
            "arguments": {
                "n_outputs": [],
                "data_dimension": []
            }
        },
        "test_sum_categories": {
            "name": "test_sum_categories",
            "location": 369,
            "return": [],
            "arguments": {
                "n_feats": [],
                "ndim": [],
                "feat_enc_dim": [],
                "start_idx": []
            }
        },
        "mock_ker_expln_id": {
            "name": "mock_ker_expln_id",
            "location": 441,
            "return": [],
            "arguments": {
                "params": [
                    "List"
                ]
            }
        },
        "test__get_data": {
            "name": "test__get_data",
            "location": 475,
            "return": [],
            "arguments": {
                "mock_kernel_shap_explainer": [],
                "data_dimension": [],
                "data_type": [],
                "group_settings": [],
                "input_settings": []
            }
        },
        "uncollect_if_test_check_inputs_kernel": {
            "name": "uncollect_if_test_check_inputs_kernel",
            "location": 571,
            "return": [],
            "arguments": {}
        },
        "test__check_inputs_kernel": {
            "name": "test__check_inputs_kernel",
            "location": 608,
            "return": [],
            "arguments": {
                "caplog": [],
                "mock_kernel_shap_explainer": [],
                "data_type": [],
                "data_dimension": [],
                "group_settings": [],
                "input_settings": [],
                "summarise_background": []
            }
        },
        "test__summarise_background_kernel": {
            "name": "test__summarise_background_kernel",
            "location": 723,
            "return": [],
            "arguments": {
                "caplog": [],
                "mock_kernel_shap_explainer": [],
                "data_dimension": [],
                "data_type": [],
                "use_groups": [],
                "categorical_names": []
            }
        },
        "uncollect_if_test_fit_kernel": {
            "name": "uncollect_if_test_fit_kernel",
            "location": 788,
            "return": [],
            "arguments": {}
        },
        "test_fit_kernel": {
            "name": "test_fit_kernel",
            "location": 808,
            "return": [],
            "arguments": {
                "caplog": [],
                "monkeypatch": [],
                "mock_kernel_shap_explainer": [],
                "data_type": [],
                "summarise_background": [],
                "data_dimension": [],
                "group_settings": [],
                "input_settings": []
            }
        },
        "test_explain_kernel": {
            "name": "test_explain_kernel",
            "location": 947,
            "return": [],
            "arguments": {
                "monkeypatch": [],
                "mock_kernel_shap_explainer": [],
                "use_groups": [],
                "summarise_result": [],
                "data_type": []
            }
        },
        "test_build_explanation_kernel": {
            "name": "test_build_explanation_kernel",
            "location": 1048,
            "return": [],
            "arguments": {
                "mock_kernel_shap_explainer": [],
                "task": []
            }
        },
        "test_kernel_distributed_execution": {
            "name": "test_kernel_distributed_execution",
            "location": 1086,
            "return": [],
            "arguments": {
                "mock_kernel_shap_explainer": [],
                "mock_ker_exp_params": [],
                "n_instances": [],
                "n_features": []
            }
        },
        "mock_tree_expln_id": {
            "name": "mock_tree_expln_id",
            "location": 1110,
            "return": [],
            "arguments": {
                "params": [
                    "List"
                ]
            }
        },
        "test__check_inputs_tree": {
            "name": "test__check_inputs_tree",
            "location": 1131,
            "return": [],
            "arguments": {
                "caplog": [],
                "mock_tree_shap_explainer": [],
                "data_dimension": [],
                "data_type": []
            }
        },
        "test__summarise_background_tree": {
            "name": "test__summarise_background_tree",
            "location": 1162,
            "return": [],
            "arguments": {
                "mock_tree_shap_explainer": [],
                "data_dimension": [],
                "data_type": [],
                "categorical_names": []
            }
        },
        "test_fit_tree": {
            "name": "test_fit_tree",
            "location": 1204,
            "return": [],
            "arguments": {
                "caplog": [],
                "monkeypatch": [],
                "mock_tree_shap_explainer": [],
                "data_type": [],
                "summarise_background": [],
                "data_dimension": []
            }
        },
        "test_explain_tree": {
            "name": "test_explain_tree",
            "location": 1281,
            "return": [],
            "arguments": {
                "caplog": [],
                "monkeypatch": [],
                "mock_tree_shap_explainer": [],
                "data_type": [],
                "summarise_result": [],
                "interactions": []
            }
        },
        "test__check_interactions": {
            "name": "test__check_interactions",
            "location": 1351,
            "return": [],
            "arguments": {
                "caplog": [],
                "mock_tree_shap_explainer": [],
                "data_type": [],
                "approximate": [],
                "labels": []
            }
        },
        "test__check_explainer_setup": {
            "name": "test__check_explainer_setup",
            "location": 1392,
            "return": [],
            "arguments": {
                "mock_tree_shap_explainer": [],
                "data_type": [],
                "labels": []
            }
        },
        "uncollect_if_test_tree_api": {
            "name": "uncollect_if_test_tree_api",
            "location": 1444,
            "return": [],
            "arguments": {}
        },
        "test_tree_api": {
            "name": "test_tree_api",
            "location": 1469,
            "return": [],
            "arguments": {
                "mock_tree_shap_explainer": [],
                "data_type": [],
                "summarise_result": [],
                "labels": [],
                "interactions": [],
                "task": [],
                "approximate": []
            }
        },
        "test__check_result_summarisation": {
            "name": "test__check_result_summarisation",
            "location": 1609,
            "return": [],
            "arguments": {
                "caplog": [],
                "mock_tree_shap_explainer": [],
                "cat_vars_start_enc_dim": []
            }
        },
        "KMeansMock.__init__": {
            "name": "__init__",
            "location": 271,
            "return": [],
            "arguments": {
                "self": [],
                "seed": []
            }
        },
        "KMeansMock._mock_kmeans": {
            "name": "_mock_kmeans",
            "location": 275,
            "return": [],
            "arguments": {
                "self": [],
                "data": [],
                "n_clusters": []
            }
        },
        "KMeansMock.__call__": {
            "name": "__call__",
            "location": 278,
            "return": [],
            "arguments": {
                "self": [],
                "background_data": [],
                "n_background_samples": []
            }
        },
        "test_rank_by_importance.get_column_ranks": {
            "name": "get_column_ranks",
            "location": 301,
            "return": [],
            "arguments": {
                "X": [],
                "ascending": []
            }
        },
        "test_tree_api.setter": {
            "name": "setter",
            "location": 1474,
            "return": [],
            "arguments": {
                "obj": [
                    "object"
                ],
                "attr": [
                    "str"
                ],
                "val": [
                    "Any"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/utils.py": {
        "predict_fcn": {
            "name": "predict_fcn",
            "location": 5,
            "return": [],
            "arguments": {
                "predict_type": [],
                "clf": [],
                "preproc": []
            }
        },
        "get_random_matrix": {
            "name": "get_random_matrix",
            "location": 32,
            "return": [],
            "arguments": {}
        },
        "MockTreeExplainer.__init__": {
            "name": "__init__",
            "location": 55,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": [],
                "seed": []
            }
        },
        "MockTreeExplainer.shap_values": {
            "name": "shap_values",
            "location": 62,
            "return": [],
            "arguments": {
                "self": [],
                "X": []
            }
        },
        "MockTreeExplainer.shap_interaction_values": {
            "name": "shap_interaction_values",
            "location": 73,
            "return": [],
            "arguments": {
                "self": [],
                "X": []
            }
        },
        "MockTreeExplainer._set_expected_value": {
            "name": "_set_expected_value",
            "location": 87,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MockTreeExplainer.__call__": {
            "name": "__call__",
            "location": 97,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MockTreeExplainer._check_input": {
            "name": "_check_input",
            "location": 101,
            "return": [],
            "arguments": {
                "self": [],
                "X": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/__init__.py": {},
    "alibi-master/alibi/explainers/tests/test_simiarlity/conftest.py": {
        "set_seed": {
            "name": "set_seed",
            "location": 17,
            "return": [],
            "arguments": {
                "seed": []
            }
        },
        "seed": {
            "name": "seed",
            "location": 33,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "get_flattened_model_parameters": {
            "name": "get_flattened_model_parameters",
            "location": 39,
            "return": [],
            "arguments": {
                "model": []
            }
        },
        "random_reg_dataset": {
            "name": "random_reg_dataset",
            "location": 50,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "random_cls_dataset": {
            "name": "random_cls_dataset",
            "location": 64,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "linear_cls_model": {
            "name": "linear_cls_model",
            "location": 78,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "linear_reg_model": {
            "name": "linear_reg_model",
            "location": 105,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "linear_models": {
            "name": "linear_models",
            "location": 132,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "tf_linear_model": {
            "name": "tf_linear_model",
            "location": 146,
            "return": [],
            "arguments": {
                "input_shape": [],
                "output_shape": []
            }
        },
        "torch_linear_model": {
            "name": "torch_linear_model",
            "location": 157,
            "return": [],
            "arguments": {
                "input_shape_arg": [],
                "output_shape_arg": []
            }
        },
        "torch_linear_model.Model.__init__": {
            "name": "__init__",
            "location": 164,
            "return": [],
            "arguments": {
                "self": [],
                "input_shape": [],
                "output_shape": []
            }
        },
        "torch_linear_model.Model.forward": {
            "name": "forward",
            "location": 172,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/test_backends.py": {
        "test_backends": {
            "name": "test_backends",
            "location": 14,
            "return": [],
            "arguments": {
                "random_cls_dataset": [],
                "linear_models": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/test_grad_methods_integration.py": {
        "loss_torch": {
            "name": "loss_torch",
            "location": 23,
            "return": [],
            "arguments": {
                "X": [],
                "Y": []
            }
        },
        "compute_angle": {
            "name": "compute_angle",
            "location": 27,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "ds": {
            "name": "ds",
            "location": 36,
            "return": [],
            "arguments": {}
        },
        "normed_ds": {
            "name": "normed_ds",
            "location": 42,
            "return": [],
            "arguments": {}
        },
        "test_correct_grad_dot_sim_result_torch": {
            "name": "test_correct_grad_dot_sim_result_torch",
            "location": 48,
            "return": [],
            "arguments": {
                "seed": [],
                "normed_ds": []
            }
        },
        "test_correct_grad_cos_sim_result_torch": {
            "name": "test_correct_grad_cos_sim_result_torch",
            "location": 70,
            "return": [],
            "arguments": {
                "seed": [],
                "ds": []
            }
        },
        "test_grad_cos_result_order_torch": {
            "name": "test_grad_cos_result_order_torch",
            "location": 92,
            "return": [],
            "arguments": {
                "seed": []
            }
        },
        "test_grad_dot_result_order_torch": {
            "name": "test_grad_dot_result_order_torch",
            "location": 112,
            "return": [],
            "arguments": {
                "seed": []
            }
        },
        "loss_tf": {
            "name": "loss_tf",
            "location": 131,
            "return": [],
            "arguments": {
                "y": [],
                "x": []
            }
        },
        "test_correct_grad_dot_sim_result_tf": {
            "name": "test_correct_grad_dot_sim_result_tf",
            "location": 135,
            "return": [],
            "arguments": {
                "seed": [],
                "normed_ds": []
            }
        },
        "test_correct_grad_cos_sim_result_tf": {
            "name": "test_correct_grad_cos_sim_result_tf",
            "location": 157,
            "return": [],
            "arguments": {
                "seed": [],
                "ds": []
            }
        },
        "test_grad_dot_result_order_tf": {
            "name": "test_grad_dot_result_order_tf",
            "location": 179,
            "return": [],
            "arguments": {
                "seed": []
            }
        },
        "test_grad_cos_result_order_tf": {
            "name": "test_grad_cos_result_order_tf",
            "location": 198,
            "return": [],
            "arguments": {
                "seed": []
            }
        },
        "test_multiple_test_instances_grad_cos": {
            "name": "test_multiple_test_instances_grad_cos",
            "location": 219,
            "return": [],
            "arguments": {
                "precompute_grads": []
            }
        },
        "test_multiple_test_instances_grad_dot": {
            "name": "test_multiple_test_instances_grad_dot",
            "location": 245,
            "return": [],
            "arguments": {
                "precompute_grads": []
            }
        },
        "test_multiple_test_instances_stored_grads_asym_dot": {
            "name": "test_multiple_test_instances_stored_grads_asym_dot",
            "location": 268,
            "return": [],
            "arguments": {
                "precompute_grads": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/test_grad_methods_unit.py": {
        "test_method_explanations": {
            "name": "test_method_explanations",
            "location": 14,
            "return": [],
            "arguments": {
                "linear_cls_model": [],
                "random_cls_dataset": []
            }
        },
        "test_explainer_method_preprocessing": {
            "name": "test_explainer_method_preprocessing",
            "location": 50,
            "return": [],
            "arguments": {
                "linear_cls_model": [],
                "random_cls_dataset": []
            }
        },
        "test_method_sim_fn_error_messaging": {
            "name": "test_method_sim_fn_error_messaging",
            "location": 85,
            "return": [],
            "arguments": {
                "linear_cls_model": []
            }
        },
        "test_method_task_error_messaging": {
            "name": "test_method_task_error_messaging",
            "location": 119,
            "return": [],
            "arguments": {
                "linear_cls_model": []
            }
        },
        "test_task_classification_input": {
            "name": "test_task_classification_input",
            "location": 154,
            "return": [],
            "arguments": {
                "random_cls_dataset": [],
                "linear_cls_model": []
            }
        },
        "test_regression_task_input": {
            "name": "test_regression_task_input",
            "location": 185,
            "return": [],
            "arguments": {
                "linear_reg_model": [],
                "random_reg_dataset": []
            }
        },
        "test_device_error_msgs": {
            "name": "test_device_error_msgs",
            "location": 219,
            "return": [],
            "arguments": {
                "linear_reg_model": []
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/__init__.py": {},
    "alibi-master/alibi/models/__init__.py": {},
    "alibi-master/alibi/models/pytorch/actor_critic.py": {
        "Actor.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ],
                "output_dim": [
                    "int"
                ]
            }
        },
        "Actor.forward": {
            "name": "forward",
            "location": 37,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "Critic.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ]
            }
        },
        "Critic.forward": {
            "name": "forward",
            "location": 79,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/autoencoder.py": {
        "AE.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [],
            "arguments": {
                "self": [],
                "encoder": [
                    "nn.Module"
                ],
                "decoder": [
                    "nn.Module"
                ]
            }
        },
        "AE.forward": {
            "name": "forward",
            "location": 44,
            "return": [
                "Union[(torch.Tensor, List[torch.Tensor])]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "HeAE.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [],
            "arguments": {
                "self": [],
                "encoder": [
                    "nn.Module"
                ],
                "decoder": [
                    "nn.Module"
                ]
            }
        },
        "HeAE.forward": {
            "name": "forward",
            "location": 89,
            "return": [
                "List[torch.Tensor]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/cfrl_models.py": {
        "MNISTClassifier.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dim": [
                    "int"
                ]
            }
        },
        "MNISTClassifier.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "MNISTEncoder.__init__": {
            "name": "__init__",
            "location": 77,
            "return": [],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "int"
                ]
            }
        },
        "MNISTEncoder.forward": {
            "name": "forward",
            "location": 97,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "MNISTDecoder.__init__": {
            "name": "__init__",
            "location": 127,
            "return": [],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "int"
                ]
            }
        },
        "MNISTDecoder.forward": {
            "name": "forward",
            "location": 147,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "ADULTEncoder.__init__": {
            "name": "__init__",
            "location": 177,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ],
                "latent_dim": [
                    "int"
                ]
            }
        },
        "ADULTEncoder.forward": {
            "name": "forward",
            "location": 192,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "ADULTDecoder.__init__": {
            "name": "__init__",
            "location": 217,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ],
                "output_dims": [
                    "List[int]"
                ]
            }
        },
        "ADULTDecoder.forward": {
            "name": "forward",
            "location": 232,
            "return": [
                "List[torch.Tensor]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/metrics.py": {
        "LossContainer.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "loss": [
                    "Callable[([torch.Tensor, torch.Tensor], torch.Tensor)]"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "LossContainer.__call__": {
            "name": "__call__",
            "location": 40,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "torch.Tensor"
                ],
                "y_true": [
                    "torch.Tensor"
                ]
            }
        },
        "LossContainer.result": {
            "name": "result",
            "location": 64,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LossContainer.reset": {
            "name": "reset",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [],
            "arguments": {
                "self": [],
                "reduction": [
                    "Reduction"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "Metric.compute_metric": {
            "name": "compute_metric",
            "location": 101,
            "return": [],
            "arguments": {
                "self": [],
                "y_pred": [
                    "Union[(torch.Tensor, np.ndarray)]"
                ],
                "y_true": [
                    "Union[(torch.Tensor, np.ndarray)]"
                ]
            }
        },
        "Metric.update_state": {
            "name": "update_state",
            "location": 106,
            "return": [],
            "arguments": {
                "self": [],
                "values": [
                    "np.ndarray"
                ]
            }
        },
        "Metric.result": {
            "name": "result",
            "location": 114,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Metric.reset": {
            "name": "reset",
            "location": 130,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AccuracyMetric.__init__": {
            "name": "__init__",
            "location": 139,
            "return": [],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "AccuracyMetric.compute_metric": {
            "name": "compute_metric",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "Union[(torch.Tensor, np.ndarray)]"
                ],
                "y_true": [
                    "Union[(torch.Tensor, np.ndarray)]"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/model.py": {
        "Model.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Model.compile": {
            "name": "compile",
            "location": 24,
            "return": [],
            "arguments": {
                "self": [],
                "optimizer": [
                    "optim.Optimizer"
                ],
                "loss": [
                    "Union[(Callable, List[Callable])]"
                ],
                "loss_weights": [
                    "Optional[List[float]]"
                ],
                "metrics": [
                    "Optional[List[Metric]]"
                ]
            }
        },
        "Model.validate_prediction_labels": {
            "name": "validate_prediction_labels",
            "location": 61,
            "return": [],
            "arguments": {
                "self": [],
                "y_pred": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ],
                "y_true": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ]
            }
        },
        "Model.compute_loss": {
            "name": "compute_loss",
            "location": 106,
            "return": [
                "Tuple[(torch.Tensor, Dict[(str, float)])]"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ],
                "y_true": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ]
            }
        },
        "Model.compute_metrics": {
            "name": "compute_metrics",
            "location": 148,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ],
                "y_true": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ]
            }
        },
        "Model.train_step": {
            "name": "train_step",
            "location": 182,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ],
                "y": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ]
            }
        },
        "Model.test_step": {
            "name": "test_step",
            "location": 221,
            "return": [],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ],
                "y": [
                    "Union[(torch.Tensor, List[torch.Tensor])]"
                ]
            }
        },
        "Model.fit": {
            "name": "fit",
            "location": 256,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "trainloader": [
                    "DataLoader"
                ],
                "epochs": [
                    "int"
                ]
            }
        },
        "Model.evaluate": {
            "name": "evaluate",
            "location": 291,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "testloader": [
                    "DataLoader"
                ]
            }
        },
        "Model._metrics_to_str": {
            "name": "_metrics_to_str",
            "location": 321,
            "return": [
                "str"
            ],
            "arguments": {
                "metrics": [
                    "Dict[(str, float)]"
                ]
            }
        },
        "Model._reset_loss": {
            "name": "_reset_loss",
            "location": 339,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Model._reset_metrics": {
            "name": "_reset_metrics",
            "location": 349,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Model.save_weights": {
            "name": "save_weights",
            "location": 357,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        },
        "Model.load_weights": {
            "name": "load_weights",
            "location": 363,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/__init__.py": {},
    "alibi-master/alibi/models/tensorflow/actor_critic.py": {
        "Actor.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ],
                "output_dim": [
                    "int"
                ]
            }
        },
        "Actor.call": {
            "name": "call",
            "location": 36,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "Critic.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ]
            }
        },
        "Critic.call": {
            "name": "call",
            "location": 80,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/models/tensorflow/autoencoder.py": {
        "AE.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "keras.Model"
                ],
                "decoder": [
                    "keras.Model"
                ]
            }
        },
        "AE.call": {
            "name": "call",
            "location": 37,
            "return": [
                "Union[(tf.Tensor, List[tf.Tensor])]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "HeAE.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "keras.Model"
                ],
                "decoder": [
                    "keras.Model"
                ]
            }
        },
        "HeAE.build": {
            "name": "build",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "HeAE.call": {
            "name": "call",
            "location": 100,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/models/tensorflow/cfrl_models.py": {
        "MNISTClassifier.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dim": [
                    "int"
                ]
            }
        },
        "MNISTClassifier.call": {
            "name": "call",
            "location": 40,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ],
                "training": [
                    "bool"
                ]
            }
        },
        "MNISTEncoder.__init__": {
            "name": "__init__",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "int"
                ]
            }
        },
        "MNISTEncoder.call": {
            "name": "call",
            "location": 93,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "MNISTDecoder.__init__": {
            "name": "__init__",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MNISTDecoder.call": {
            "name": "call",
            "location": 138,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "ADULTEncoder.__init__": {
            "name": "__init__",
            "location": 169,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ],
                "latent_dim": [
                    "int"
                ]
            }
        },
        "ADULTEncoder.call": {
            "name": "call",
            "location": 184,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "ADULTDecoder.__init__": {
            "name": "__init__",
            "location": 211,
            "return": [],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int"
                ],
                "output_dims": [
                    "List[int]"
                ]
            }
        },
        "ADULTDecoder.call": {
            "name": "call",
            "location": 227,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "alibi-master/alibi/models/tensorflow/__init__.py": {},
    "alibi-master/alibi/prototypes/protoselect.py": {
        "_helper_protoselect_euclidean_1knn": {
            "name": "_helper_protoselect_euclidean_1knn",
            "location": 234,
            "return": [
                "Optional[KNeighborsClassifier]"
            ],
            "arguments": {
                "summariser": [
                    "ProtoSelect"
                ],
                "num_prototypes": [
                    "int"
                ],
                "eps": [
                    "float"
                ],
                "knn_kw": [
                    "dict"
                ]
            }
        },
        "_get_splits": {
            "name": "_get_splits",
            "location": 272,
            "return": [
                "Tuple[(Tuple[(np.ndarray, np.ndarray)], Tuple[(np.ndarray, np.ndarray)], List[Tuple[(np.ndarray, np.ndarray)]])]"
            ],
            "arguments": {
                "trainset": [
                    "Tuple[(np.ndarray, np.ndarray)]"
                ],
                "valset": [
                    "Tuple[(Optional[np.ndarray], Optional[np.ndarray])]"
                ],
                "kfold_kw": [
                    "dict"
                ]
            }
        },
        "cv_protoselect_euclidean": {
            "name": "cv_protoselect_euclidean",
            "location": 313,
            "return": [
                "dict"
            ],
            "arguments": {
                "trainset": [
                    "Tuple[(np.ndarray, np.ndarray)]"
                ],
                "protoset": [
                    "Optional[Tuple[(np.ndarray,)]]"
                ],
                "valset": [
                    "Optional[Tuple[(np.ndarray, np.ndarray)]]"
                ],
                "num_prototypes": [
                    "int"
                ],
                "eps_grid": [
                    "Optional[np.ndarray]"
                ],
                "quantiles": [
                    "Optional[Tuple[(float, float)]]"
                ],
                "grid_size": [
                    "int"
                ],
                "n_splits": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ],
                "preprocess_fn": [
                    "Optional[Callable[([np.ndarray], np.ndarray)]]"
                ],
                "protoselect_kw": [
                    "Optional[dict]"
                ],
                "knn_kw": [
                    "Optional[dict]"
                ],
                "kfold_kw": [
                    "Optional[dict]"
                ]
            }
        },
        "_batch_preprocessing": {
            "name": "_batch_preprocessing",
            "location": 448,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "preprocess_fn": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "_imscatterplot": {
            "name": "_imscatterplot",
            "location": 477,
            "return": [
                "plt.Axes"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ],
                "images": [
                    "np.ndarray"
                ],
                "ax": [
                    "Optional[plt.Axes]"
                ],
                "fig_kw": [
                    "Optional[dict]"
                ],
                "image_size": [
                    "Tuple[(int, int)]"
                ],
                "zoom": [
                    "Optional[np.ndarray]"
                ],
                "zoom_lb": [
                    "float"
                ],
                "zoom_ub": [],
                "sort_by_zoom": [
                    "bool"
                ]
            }
        },
        "visualize_image_prototypes": {
            "name": "visualize_image_prototypes",
            "location": 547,
            "return": [
                "plt.Axes"
            ],
            "arguments": {
                "summary": [
                    "'Explanation'"
                ],
                "trainset": [
                    "Tuple[(np.ndarray, np.ndarray)]"
                ],
                "reducer": [
                    "Callable[([np.ndarray], np.ndarray)]"
                ],
                "preprocess_fn": [
                    "Optional[Callable[([np.ndarray], np.ndarray)]]"
                ],
                "knn_kw": [
                    "Optional[dict]"
                ],
                "ax": [
                    "Optional[plt.Axes]"
                ],
                "fig_kw": [
                    "Optional[dict]"
                ],
                "image_size": [
                    "Tuple[(int, int)]"
                ],
                "zoom_lb": [
                    "float"
                ],
                "zoom_ub": [
                    "float"
                ]
            }
        },
        "ProtoSelect.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [],
            "arguments": {
                "self": [],
                "kernel_distance": [
                    "Callable[([np.ndarray, np.ndarray], np.ndarray)]"
                ],
                "eps": [
                    "float"
                ],
                "lambda_penalty": [
                    "Optional[float]"
                ],
                "batch_size": [
                    "int"
                ],
                "preprocess_fn": [
                    "Optional[Callable[([Union[(list, np.ndarray)]], np.ndarray)]]"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "ProtoSelect.fit": {
            "name": "fit",
            "location": 80,
            "return": [
                "'ProtoSelect'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(list, np.ndarray)]"
                ],
                "y": [
                    "Optional[np.ndarray]"
                ],
                "Z": [
                    "Optional[Union[(list, np.ndarray)]]"
                ]
            }
        },
        "ProtoSelect.summarise": {
            "name": "summarise",
            "location": 142,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "num_prototypes": [
                    "int"
                ]
            }
        },
        "ProtoSelect._build_summary": {
            "name": "_build_summary",
            "location": 222,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "protos": [
                    "Dict[(int, List[int])]"
                ]
            }
        }
    },
    "alibi-master/alibi/prototypes/__init__.py": {},
    "alibi-master/alibi/prototypes/tests/test_protoselect.py": {
        "test_protoselect": {
            "name": "test_protoselect",
            "location": 16,
            "return": [],
            "arguments": {
                "n_classes": [],
                "ft_factor": [],
                "kernel_distance": [],
                "num_prototypes": [],
                "eps": []
            }
        },
        "test_cv_protoselect_euclidean": {
            "name": "test_cv_protoselect_euclidean",
            "location": 52,
            "return": [],
            "arguments": {
                "n_classes": [],
                "use_protos": [],
                "use_valset": [],
                "num_prototypes": [],
                "eps_grid": [],
                "quantiles": [],
                "grid_size": [],
                "n_splits": [],
                "batch_size": []
            }
        },
        "test_relabeling": {
            "name": "test_relabeling",
            "location": 106,
            "return": [],
            "arguments": {
                "n_samples": [],
                "n_classes": []
            }
        },
        "test_size_match": {
            "name": "test_size_match",
            "location": 136,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/prototypes/tests/test_utils.py": {
        "test_squared_pairwise_distance": {
            "name": "test_squared_pairwise_distance",
            "location": 9,
            "return": [],
            "arguments": {
                "size": [],
                "ft_size": []
            }
        },
        "test_GaussianRBF": {
            "name": "test_GaussianRBF",
            "location": 30,
            "return": [],
            "arguments": {
                "size": [],
                "ft_size": [],
                "sigma": []
            }
        },
        "test_GaussianRBFDistance": {
            "name": "test_GaussianRBFDistance",
            "location": 50,
            "return": [],
            "arguments": {
                "size": [],
                "ft_size": [],
                "sigma": []
            }
        },
        "test_EuclideanDistance": {
            "name": "test_EuclideanDistance",
            "location": 69,
            "return": [],
            "arguments": {
                "size": [],
                "ft_size": []
            }
        },
        "test_batch_compute_kernel_matrix": {
            "name": "test_batch_compute_kernel_matrix",
            "location": 90,
            "return": [],
            "arguments": {
                "size": [],
                "ft_size": [],
                "batch_size": [],
                "kernel": []
            }
        }
    },
    "alibi-master/alibi/prototypes/tests/__init__.py": {},
    "alibi-master/alibi/tests/conftest.py": {
        "pytest_addoption": {
            "name": "pytest_addoption",
            "location": 4,
            "return": [],
            "arguments": {
                "parser": []
            }
        },
        "opt_dep": {
            "name": "opt_dep",
            "location": 9,
            "return": [],
            "arguments": {
                "request": []
            }
        }
    },
    "alibi-master/alibi/tests/test_dep_management.py": {
        "check_correct_dependencies": {
            "name": "check_correct_dependencies",
            "location": 26,
            "return": [],
            "arguments": {
                "module": [
                    "ModuleType"
                ],
                "dependencies": [
                    "defaultdict"
                ],
                "opt_dep": [
                    "str"
                ]
            }
        },
        "test_explainer_dependencies": {
            "name": "test_explainer_dependencies",
            "location": 56,
            "return": [],
            "arguments": {
                "opt_dep": []
            }
        },
        "test_util_dependencies": {
            "name": "test_util_dependencies",
            "location": 86,
            "return": [],
            "arguments": {
                "opt_dep": []
            }
        },
        "test_dataset_dependencies": {
            "name": "test_dataset_dependencies",
            "location": 100,
            "return": [],
            "arguments": {
                "opt_dep": []
            }
        },
        "test_confidence_dependencies": {
            "name": "test_confidence_dependencies",
            "location": 110,
            "return": [],
            "arguments": {
                "opt_dep": []
            }
        },
        "test_tensorflow_model_dependencies": {
            "name": "test_tensorflow_model_dependencies",
            "location": 116,
            "return": [],
            "arguments": {
                "opt_dep": []
            }
        },
        "test_pytorch_model_dependencies": {
            "name": "test_pytorch_model_dependencies",
            "location": 134,
            "return": [],
            "arguments": {
                "opt_dep": []
            }
        }
    },
    "alibi-master/alibi/tests/test_saving.py": {
        "english_spacy_model": {
            "name": "english_spacy_model",
            "location": 32,
            "return": [],
            "arguments": {}
        },
        "language_model": {
            "name": "language_model",
            "location": 41,
            "return": [],
            "arguments": {}
        },
        "adult_data": {
            "name": "adult_data",
            "location": 47,
            "return": [],
            "arguments": {}
        },
        "iris_data": {
            "name": "iris_data",
            "location": 52,
            "return": [],
            "arguments": {}
        },
        "movie_sentiment_data": {
            "name": "movie_sentiment_data",
            "location": 57,
            "return": [],
            "arguments": {}
        },
        "lr_classifier": {
            "name": "lr_classifier",
            "location": 62,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "rf_classifier": {
            "name": "rf_classifier",
            "location": 78,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "ffn_classifier": {
            "name": "ffn_classifier",
            "location": 95,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "mnist_predictor": {
            "name": "mnist_predictor",
            "location": 108,
            "return": [],
            "arguments": {}
        },
        "iris_ae": {
            "name": "iris_ae",
            "location": 115,
            "return": [],
            "arguments": {
                "iris_data": []
            }
        },
        "ale_explainer": {
            "name": "ale_explainer",
            "location": 137,
            "return": [],
            "arguments": {
                "iris_data": [],
                "lr_classifier": []
            }
        },
        "ig_explainer": {
            "name": "ig_explainer",
            "location": 144,
            "return": [],
            "arguments": {
                "iris_data": [],
                "ffn_classifier": []
            }
        },
        "mnist_segmentation_fn": {
            "name": "mnist_segmentation_fn",
            "location": 149,
            "return": [],
            "arguments": {
                "image": [],
                "size": []
            }
        },
        "ai_explainer": {
            "name": "ai_explainer",
            "location": 158,
            "return": [],
            "arguments": {
                "mnist_predictor": [],
                "request": []
            }
        },
        "atext_explainer_nlp": {
            "name": "atext_explainer_nlp",
            "location": 167,
            "return": [],
            "arguments": {
                "lr_classifier": [],
                "english_spacy_model": [],
                "movie_sentiment_data": []
            }
        },
        "atext_explainer_lm": {
            "name": "atext_explainer_lm",
            "location": 178,
            "return": [],
            "arguments": {
                "lr_classifier": [],
                "language_model": [],
                "movie_sentiment_data": []
            }
        },
        "atab_explainer": {
            "name": "atab_explainer",
            "location": 190,
            "return": [],
            "arguments": {
                "lr_classifier": [],
                "adult_data": []
            }
        },
        "kshap_explainer": {
            "name": "kshap_explainer",
            "location": 202,
            "return": [],
            "arguments": {
                "lr_classifier": [],
                "adult_data": []
            }
        },
        "tree_explainer": {
            "name": "tree_explainer",
            "location": 214,
            "return": [],
            "arguments": {
                "rf_classifier": [],
                "iris_data": []
            }
        },
        "cfrl_explainer": {
            "name": "cfrl_explainer",
            "location": 223,
            "return": [],
            "arguments": {
                "rf_classifier": [],
                "iris_ae": [],
                "iris_data": []
            }
        },
        "similarity_explainer": {
            "name": "similarity_explainer",
            "location": 269,
            "return": [],
            "arguments": {
                "ffn_classifier": [],
                "iris_data": []
            }
        },
        "test_save_ALE": {
            "name": "test_save_ALE",
            "location": 282,
            "return": [],
            "arguments": {
                "ale_explainer": [],
                "lr_classifier": [],
                "iris_data": []
            }
        },
        "test_save_IG": {
            "name": "test_save_IG",
            "location": 306,
            "return": [],
            "arguments": {
                "ig_explainer": [],
                "ffn_classifier": [],
                "iris_data": []
            }
        },
        "test_save_AnchorImage": {
            "name": "test_save_AnchorImage",
            "location": 327,
            "return": [],
            "arguments": {
                "ai_explainer": [],
                "mnist_predictor": []
            }
        },
        "test_save_AnchorText": {
            "name": "test_save_AnchorText",
            "location": 345,
            "return": [],
            "arguments": {
                "atext_explainer": [],
                "lr_classifier": [],
                "movie_sentiment_data": []
            }
        },
        "test_save_AnchorTabular": {
            "name": "test_save_AnchorTabular",
            "location": 364,
            "return": [],
            "arguments": {
                "atab_explainer": [],
                "lr_classifier": [],
                "adult_data": []
            }
        },
        "test_save_KernelShap": {
            "name": "test_save_KernelShap",
            "location": 384,
            "return": [],
            "arguments": {
                "kshap_explainer": [],
                "lr_classifier": [],
                "adult_data": []
            }
        },
        "test_save_TreeShap": {
            "name": "test_save_TreeShap",
            "location": 404,
            "return": [],
            "arguments": {
                "tree_explainer": [],
                "rf_classifier": [],
                "iris_data": []
            }
        },
        "test_save_cfrl": {
            "name": "test_save_cfrl",
            "location": 424,
            "return": [],
            "arguments": {
                "cfrl_explainer": [],
                "rf_classifier": [],
                "iris_data": []
            }
        },
        "test_save_SimilartyExplainer": {
            "name": "test_save_SimilartyExplainer",
            "location": 456,
            "return": [],
            "arguments": {
                "similarity_explainer": [],
                "ffn_classifier": [],
                "iris_data": []
            }
        },
        "cfrl_explainer.DecoderList.__init__": {
            "name": "__init__",
            "location": 233,
            "return": [],
            "arguments": {
                "self": [],
                "decoder": [
                    "tf.keras.Model"
                ]
            }
        },
        "cfrl_explainer.DecoderList.call": {
            "name": "call",
            "location": 237,
            "return": [],
            "arguments": {
                "self": [],
                "input": [
                    "Union[(tf.Tensor, List[tf.Tensor])]"
                ]
            }
        }
    },
    "alibi-master/alibi/tests/test_utils.py": {
        "test_argmax_transformer": {
            "name": "test_argmax_transformer",
            "location": 14,
            "return": [],
            "arguments": {
                "monkeypatch": [],
                "out_dim": [],
                "out_type": []
            }
        }
    },
    "alibi-master/alibi/tests/utils.py": {
        "issorted": {
            "name": "issorted",
            "location": 112,
            "return": [],
            "arguments": {
                "arr": [],
                "reverse": []
            }
        },
        "not_raises": {
            "name": "not_raises",
            "location": 124,
            "return": [],
            "arguments": {
                "ExpectedException": []
            }
        },
        "assert_message_in_logs": {
            "name": "assert_message_in_logs",
            "location": 140,
            "return": [],
            "arguments": {
                "msg": [],
                "records": []
            }
        },
        "MockPredictor.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "out_dim": [
                    "int"
                ],
                "out_type": [
                    "str"
                ],
                "model_type": [
                    "Optional[str]"
                ],
                "seed": [
                    "Optional[int]"
                ]
            }
        },
        "MockPredictor.__call__": {
            "name": "__call__",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MockPredictor._generate_probas": {
            "name": "_generate_probas",
            "location": 59,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "sz": [
                    "Optional[tuple]"
                ]
            }
        },
        "MockPredictor._generate_labels": {
            "name": "_generate_labels",
            "location": 92,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "sz": [
                    "Optional[tuple]"
                ]
            }
        },
        "MockPredictor._generate_logits": {
            "name": "_generate_logits",
            "location": 100,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "sz": [
                    "Optional[tuple]"
                ]
            }
        },
        "MockPredictor.predict": {
            "name": "predict",
            "location": 108,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/tests/__init__.py": {},
    "alibi-master/alibi/utils/approximation_methods.py": {
        "approximation_parameters": {
            "name": "approximation_parameters",
            "location": 29,
            "return": [
                "Tuple[(Callable[([int], List[float])], Callable[([int], List[float])])]"
            ],
            "arguments": {
                "method": [
                    "str"
                ]
            }
        },
        "riemann_builders": {
            "name": "riemann_builders",
            "location": 49,
            "return": [
                "Tuple[(Callable[([int], List[float])], Callable[([int], List[float])])]"
            ],
            "arguments": {
                "method": [
                    "Riemann"
                ]
            }
        },
        "gauss_legendre_builders": {
            "name": "gauss_legendre_builders",
            "location": 104,
            "return": [
                "Tuple[(Callable[([int], List[float])], Callable[([int], List[float])])]"
            ],
            "arguments": {}
        },
        "riemann_builders.step_sizes": {
            "name": "step_sizes",
            "location": 74,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "riemann_builders.alphas": {
            "name": "alphas",
            "location": 82,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "gauss_legendre_builders.step_sizes": {
            "name": "step_sizes",
            "location": 133,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "gauss_legendre_builders.alphas": {
            "name": "alphas",
            "location": 138,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/data.py": {
        "gen_category_map": {
            "name": "gen_category_map",
            "location": 32,
            "return": [
                "Dict[(int, list)]"
            ],
            "arguments": {
                "data": [
                    "Union[(pd.DataFrame, np.ndarray)]"
                ],
                "categorical_columns": [
                    "Union[(List[int], List[str], None)]"
                ]
            }
        },
        "Bunch.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Bunch.__setattr__": {
            "name": "__setattr__",
            "location": 19,
            "return": [],
            "arguments": {
                "self": [],
                "key": [],
                "value": []
            }
        },
        "Bunch.__dir__": {
            "name": "__dir__",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Bunch.__getattr__": {
            "name": "__getattr__",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "key": []
            }
        }
    },
    "alibi-master/alibi/utils/discretizer.py": {
        "Discretizer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "np.ndarray"
                ],
                "numerical_features": [
                    "List[int]"
                ],
                "feature_names": [
                    "List[str]"
                ],
                "percentiles": [
                    "Sequence[Union[(int, float)]]"
                ]
            }
        },
        "Discretizer.get_percentiles": {
            "name": "get_percentiles",
            "location": 49,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ],
                "qts": [
                    "np.ndarray"
                ]
            }
        },
        "Discretizer.bins": {
            "name": "bins",
            "location": 74,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "np.ndarray"
                ]
            }
        },
        "Discretizer.discretize": {
            "name": "discretize",
            "location": 93,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/distance.py": {
        "cityblock_batch": {
            "name": "cityblock_batch",
            "location": 6,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ]
            }
        },
        "mvdm": {
            "name": "mvdm",
            "location": 34,
            "return": [
                "Dict[(int, np.ndarray)]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ],
                "cat_vars": [
                    "dict"
                ],
                "alpha": [
                    "int"
                ]
            }
        },
        "abdm": {
            "name": "abdm",
            "location": 88,
            "return": [],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "cat_vars": [
                    "dict"
                ],
                "cat_vars_bin": [
                    "dict"
                ]
            }
        },
        "multidim_scaling": {
            "name": "multidim_scaling",
            "location": 163,
            "return": [
                "Tuple[(dict, tuple)]"
            ],
            "arguments": {
                "d_pair": [
                    "dict"
                ],
                "feature_range": [
                    "Tuple[(np.ndarray, np.ndarray)]"
                ],
                "n_components": [
                    "int"
                ],
                "use_metric": [
                    "bool"
                ],
                "standardize_cat_vars": [
                    "bool"
                ],
                "smooth": [
                    "float"
                ],
                "center": [
                    "bool"
                ],
                "update_feature_range": [
                    "bool"
                ]
            }
        },
        "squared_pairwise_distance": {
            "name": "squared_pairwise_distance",
            "location": 247,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ],
                "a_min": [
                    "float"
                ],
                "a_max": [
                    "float"
                ]
            }
        },
        "batch_compute_kernel_matrix": {
            "name": "batch_compute_kernel_matrix",
            "location": 275,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "Union[(list, np.ndarray)]"
                ],
                "y": [
                    "Union[(list, np.ndarray)]"
                ],
                "kernel": [
                    "Callable[([np.ndarray, np.ndarray], np.ndarray)]"
                ],
                "batch_size": [
                    "int"
                ],
                "preprocess_fn": [
                    "Optional[Callable[([Union[(list, np.ndarray)]], np.ndarray)]]"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/distributed.py": {
        "batch": {
            "name": "batch",
            "location": 254,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "batch_size": [
                    "Optional[int]"
                ],
                "n_batches": [
                    "int"
                ]
            }
        },
        "default_target_fcn": {
            "name": "default_target_fcn",
            "location": 296,
            "return": [],
            "arguments": {
                "actor": [
                    "Any"
                ],
                "instances": [
                    "tuple"
                ],
                "kwargs": [
                    "Optional[Dict]"
                ]
            }
        },
        "concatenate_minibatches": {
            "name": "concatenate_minibatches",
            "location": 330,
            "return": [
                "Union[(np.ndarray, List[np.ndarray])]"
            ],
            "arguments": {
                "minibatch_results": [
                    "Union[(List[np.ndarray], List[List[np.ndarray]])]"
                ]
            }
        },
        "_array_list_concatenator": {
            "name": "_array_list_concatenator",
            "location": 360,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "minibatch_results": [
                    "List[List[np.ndarray]]"
                ]
            }
        },
        "invert_permutation": {
            "name": "invert_permutation",
            "location": 371,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "p": [
                    "list"
                ]
            }
        },
        "order_result": {
            "name": "order_result",
            "location": 391,
            "return": [
                "List"
            ],
            "arguments": {
                "unordered_result": [
                    "Generator[(Tuple[(int, Any)], None, None)]"
                ]
            }
        },
        "ActorPool.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [],
            "arguments": {
                "self": [],
                "actors": []
            }
        },
        "ActorPool.map": {
            "name": "map",
            "location": 44,
            "return": [],
            "arguments": {
                "self": [],
                "fn": [],
                "values": [],
                "chunksize": []
            }
        },
        "ActorPool.map_unordered": {
            "name": "map_unordered",
            "location": 77,
            "return": [],
            "arguments": {
                "self": [],
                "fn": [],
                "values": [],
                "chunksize": []
            }
        },
        "ActorPool.submit": {
            "name": "submit",
            "location": 112,
            "return": [],
            "arguments": {
                "self": [],
                "fn": [
                    "Callable"
                ],
                "value": [
                    "object"
                ]
            }
        },
        "ActorPool.has_next": {
            "name": "has_next",
            "location": 144,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ActorPool.get_next": {
            "name": "get_next",
            "location": 165,
            "return": [],
            "arguments": {
                "self": [],
                "timeout": []
            }
        },
        "ActorPool.get_next_unordered": {
            "name": "get_next_unordered",
            "location": 203,
            "return": [],
            "arguments": {
                "self": [],
                "timeout": []
            }
        },
        "ActorPool._return_actor": {
            "name": "_return_actor",
            "location": 242,
            "return": [],
            "arguments": {
                "self": [],
                "actor": []
            }
        },
        "ActorPool._chunk": {
            "name": "_chunk",
            "location": 248,
            "return": [
                "Generator[(List, None, None)]"
            ],
            "arguments": {
                "values": [
                    "list"
                ],
                "chunksize": [
                    "int"
                ]
            }
        },
        "DistributedExplainer.__init__": {
            "name": "__init__",
            "location": 428,
            "return": [],
            "arguments": {
                "self": [],
                "distributed_opts": [
                    "Dict[(str, Any)]"
                ],
                "explainer_type": [
                    "Any"
                ],
                "explainer_init_args": [
                    "Tuple"
                ],
                "explainer_init_kwargs": [
                    "dict"
                ],
                "concatenate_results": [
                    "bool"
                ],
                "return_generator": [
                    "bool"
                ]
            }
        },
        "DistributedExplainer.__getattr__": {
            "name": "__getattr__",
            "location": 514,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str"
                ]
            }
        },
        "DistributedExplainer.actor_index": {
            "name": "actor_index",
            "location": 559,
            "return": [],
            "arguments": {
                "self": [],
                "value": [
                    "int"
                ]
            }
        },
        "DistributedExplainer.set_actor_index": {
            "name": "set_actor_index",
            "location": 565,
            "return": [],
            "arguments": {
                "self": [],
                "value": [
                    "int"
                ]
            }
        },
        "DistributedExplainer.return_attribute": {
            "name": "return_attribute",
            "location": 572,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "DistributedExplainer.create_parallel_pool": {
            "name": "create_parallel_pool",
            "location": 585,
            "return": [],
            "arguments": {
                "self": [],
                "explainer_type": [
                    "Any"
                ],
                "explainer_init_args": [
                    "Tuple"
                ],
                "explainer_init_kwargs": [
                    "dict"
                ]
            }
        },
        "DistributedExplainer.get_explanation": {
            "name": "get_explanation",
            "location": 598,
            "return": [
                "Union[(Generator[(Tuple[(int, Any)], None, None)], List[Any], Any)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "PoolCollection.__init__": {
            "name": "__init__",
            "location": 650,
            "return": [],
            "arguments": {
                "self": [],
                "distributed_opts": [
                    "Dict[(str, Any)]"
                ],
                "explainer_type": [
                    "Any"
                ],
                "explainer_init_args": [
                    "List[Tuple]"
                ],
                "explainer_init_kwargs": [
                    "List[Dict]"
                ]
            }
        },
        "PoolCollection.remote_explainer_index": {
            "name": "remote_explainer_index",
            "location": 720,
            "return": [],
            "arguments": {
                "self": [],
                "value": [
                    "int"
                ]
            }
        },
        "PoolCollection.__getattr__": {
            "name": "__getattr__",
            "location": 726,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str"
                ]
            }
        },
        "PoolCollection.__getitem__": {
            "name": "__getitem__",
            "location": 740,
            "return": [],
            "arguments": {
                "self": [],
                "item": [
                    "int"
                ]
            }
        },
        "PoolCollection.create_explainer_handles": {
            "name": "create_explainer_handles",
            "location": 750,
            "return": [],
            "arguments": {
                "distributed_opts": [
                    "Dict[(str, Any)]"
                ],
                "explainer_type": [
                    "Any"
                ],
                "explainer_init_args": [
                    "List[Tuple]"
                ],
                "explainer_init_kwargs": [
                    "List[Dict]"
                ]
            }
        },
        "PoolCollection.get_explanation": {
            "name": "get_explanation",
            "location": 778,
            "return": [
                "List"
            ],
            "arguments": {
                "self": [],
                "X": []
            }
        }
    },
    "alibi-master/alibi/utils/distributions.py": {
        "kl_bernoulli": {
            "name": "kl_bernoulli",
            "location": 4,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "p": [
                    "np.ndarray"
                ],
                "q": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/download.py": {
        "spacy_model": {
            "name": "spacy_model",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/frameworks.py": {},
    "alibi-master/alibi/utils/gradients.py": {
        "perturb": {
            "name": "perturb",
            "location": 5,
            "return": [
                "Tuple[(np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "eps": [
                    "Union[(float, np.ndarray)]"
                ],
                "proba": [
                    "bool"
                ]
            }
        },
        "num_grad_batch": {
            "name": "num_grad_batch",
            "location": 40,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "func": [
                    "Callable"
                ],
                "X": [
                    "np.ndarray"
                ],
                "args": [
                    "Tuple"
                ],
                "eps": [
                    "Union[(float, np.ndarray)]"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/kernel.py": {
        "GaussianRBF.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sigma": [
                    "Optional[Union[(float, np.ndarray)]]"
                ]
            }
        },
        "GaussianRBF.sigma": {
            "name": "sigma",
            "location": 34,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianRBF.__call__": {
            "name": "__call__",
            "location": 37,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ],
                "infer_sigma": [
                    "bool"
                ]
            }
        },
        "GaussianRBFDistance.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [],
            "arguments": {
                "self": [],
                "sigma": [
                    "Optional[Union[(float, np.ndarray)]]"
                ]
            }
        },
        "GaussianRBFDistance.__call__": {
            "name": "__call__",
            "location": 89,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ],
                "infer_sigma": [
                    "bool"
                ]
            }
        },
        "EuclideanDistance.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EuclideanDistance.__call__": {
            "name": "__call__",
            "location": 102,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "np.ndarray"
                ],
                "y": [
                    "np.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/lang_model.py": {
        "LanguageModel.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [],
            "arguments": {
                "self": [],
                "model_path": [
                    "str"
                ],
                "preloading": [
                    "bool"
                ]
            }
        },
        "LanguageModel.from_disk": {
            "name": "from_disk",
            "location": 68,
            "return": [],
            "arguments": {
                "self": [],
                "path": [
                    "Union[(str, Path)]"
                ]
            }
        },
        "LanguageModel.to_disk": {
            "name": "to_disk",
            "location": 86,
            "return": [],
            "arguments": {
                "self": [],
                "path": [
                    "Union[(str, Path)]"
                ]
            }
        },
        "LanguageModel.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 104,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ]
            }
        },
        "LanguageModel.select_word": {
            "name": "select_word",
            "location": 126,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "tokenized_text": [
                    "List[str]"
                ],
                "start_idx": [
                    "int"
                ],
                "punctuation": [
                    "str"
                ]
            }
        },
        "LanguageModel.is_stop_word": {
            "name": "is_stop_word",
            "location": 167,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokenized_text": [
                    "List[str]"
                ],
                "start_idx": [
                    "int"
                ],
                "punctuation": [
                    "str"
                ],
                "stopwords": [
                    "Optional[List[str]]"
                ]
            }
        },
        "LanguageModel.is_punctuation": {
            "name": "is_punctuation",
            "location": 199,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ],
                "punctuation": [
                    "str"
                ]
            }
        },
        "LanguageModel.mask": {
            "name": "mask",
            "location": 228,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LanguageModel.mask_id": {
            "name": "mask_id",
            "location": 235,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LanguageModel.max_num_tokens": {
            "name": "max_num_tokens",
            "location": 242,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LanguageModel.head_tail_split": {
            "name": "head_tail_split",
            "location": 248,
            "return": [
                "Tuple[(str, str, List[str], List[str])]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "LanguageModel.predict_batch_lm": {
            "name": "predict_batch_lm",
            "location": 297,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "transformers.tokenization_utils_base.BatchEncoding"
                ],
                "vocab_size": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "DistilbertBaseUncased.__init__": {
            "name": "__init__",
            "location": 342,
            "return": [],
            "arguments": {
                "self": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "DistilbertBaseUncased.mask": {
            "name": "mask",
            "location": 354,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DistilbertBaseUncased.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 357,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ]
            }
        },
        "BertBaseUncased.__init__": {
            "name": "__init__",
            "location": 364,
            "return": [],
            "arguments": {
                "self": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "BertBaseUncased.mask": {
            "name": "mask",
            "location": 376,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BertBaseUncased.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 379,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ]
            }
        },
        "RobertaBase.__init__": {
            "name": "__init__",
            "location": 386,
            "return": [],
            "arguments": {
                "self": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "RobertaBase.mask": {
            "name": "mask",
            "location": 398,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RobertaBase.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 401,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/mapping.py": {
        "ohe_to_ord_shape": {
            "name": "ohe_to_ord_shape",
            "location": 6,
            "return": [
                "tuple"
            ],
            "arguments": {
                "shape": [
                    "tuple"
                ],
                "cat_vars": [
                    "Dict[(int, int)]"
                ],
                "is_ohe": [
                    "bool"
                ]
            }
        },
        "ord_to_num": {
            "name": "ord_to_num",
            "location": 34,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "data": [
                    "np.ndarray"
                ],
                "dist": [
                    "dict"
                ]
            }
        },
        "num_to_ord": {
            "name": "num_to_ord",
            "location": 62,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "data": [
                    "np.ndarray"
                ],
                "dist": [
                    "dict"
                ]
            }
        },
        "ord_to_ohe": {
            "name": "ord_to_ohe",
            "location": 86,
            "return": [
                "Tuple[(np.ndarray, dict)]"
            ],
            "arguments": {
                "X_ord": [
                    "np.ndarray"
                ],
                "cat_vars_ord": [
                    "dict"
                ]
            }
        },
        "ohe_to_ord": {
            "name": "ohe_to_ord",
            "location": 124,
            "return": [
                "Tuple[(np.ndarray, dict)]"
            ],
            "arguments": {
                "X_ohe": [
                    "np.ndarray"
                ],
                "cat_vars_ohe": [
                    "dict"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/missing_optional_dependency.py": {
        "import_optional": {
            "name": "import_optional",
            "location": 73,
            "return": [
                "Any"
            ],
            "arguments": {
                "module_name": [
                    "str"
                ],
                "names": [
                    "Optional[List[str]]"
                ]
            }
        },
        "MissingDependency.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [],
            "arguments": {
                "self": [],
                "object_name": [
                    "str"
                ],
                "err": [
                    "Union[(ModuleNotFoundError, ImportError)]"
                ],
                "missing_dependency": [
                    "str"
                ]
            }
        },
        "MissingDependency.err_msg": {
            "name": "err_msg",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MissingDependency.__getattr__": {
            "name": "__getattr__",
            "location": 64,
            "return": [],
            "arguments": {
                "self": [],
                "key": []
            }
        },
        "MissingDependency.__call__": {
            "name": "__call__",
            "location": 68,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/utils/tf.py": {
        "argmin_grad": {
            "name": "argmin_grad",
            "location": 5,
            "return": [],
            "arguments": {
                "x": [],
                "y": []
            }
        },
        "one_hot_grad": {
            "name": "one_hot_grad",
            "location": 17,
            "return": [],
            "arguments": {
                "x": [],
                "y": []
            }
        },
        "argmax_grad": {
            "name": "argmax_grad",
            "location": 28,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "round_grad": {
            "name": "round_grad",
            "location": 39,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "argmin_grad.grad": {
            "name": "grad",
            "location": 9,
            "return": [],
            "arguments": {
                "dy": []
            }
        },
        "one_hot_grad.grad": {
            "name": "grad",
            "location": 20,
            "return": [],
            "arguments": {
                "dy": []
            }
        },
        "argmax_grad.grad": {
            "name": "grad",
            "location": 31,
            "return": [],
            "arguments": {
                "dy": []
            }
        },
        "round_grad.grad": {
            "name": "grad",
            "location": 42,
            "return": [],
            "arguments": {
                "dy": []
            }
        }
    },
    "alibi-master/alibi/utils/visualization.py": {
        "_prepare_image": {
            "name": "_prepare_image",
            "location": 30,
            "return": [],
            "arguments": {
                "attr_visual": [
                    "ndarray"
                ]
            }
        },
        "_normalize_scale": {
            "name": "_normalize_scale",
            "location": 34,
            "return": [],
            "arguments": {
                "attr": [
                    "ndarray"
                ],
                "scale_factor": [
                    "float"
                ]
            }
        },
        "_cumulative_sum_threshold": {
            "name": "_cumulative_sum_threshold",
            "location": 45,
            "return": [],
            "arguments": {
                "values": [
                    "ndarray"
                ],
                "percentile": [
                    "Union[(int, float)]"
                ]
            }
        },
        "_normalize_image_attr": {
            "name": "_normalize_image_attr",
            "location": 56,
            "return": [],
            "arguments": {
                "attr": [
                    "ndarray"
                ],
                "sign": [
                    "str"
                ],
                "outlier_perc": [
                    "Union[(int, float)]"
                ]
            }
        },
        "visualize_image_attr": {
            "name": "visualize_image_attr",
            "location": 79,
            "return": [],
            "arguments": {
                "attr": [
                    "ndarray"
                ],
                "original_image": [
                    "Union[(None, ndarray)]"
                ],
                "method": [
                    "str"
                ],
                "sign": [
                    "str"
                ],
                "plt_fig_axis": [
                    "Union[(None, Tuple[(figure, axis)])]"
                ],
                "outlier_perc": [
                    "Union[(int, float)]"
                ],
                "cmap": [
                    "Union[(None, str)]"
                ],
                "alpha_overlay": [
                    "float"
                ],
                "show_colorbar": [
                    "bool"
                ],
                "title": [
                    "Union[(None, str)]"
                ],
                "fig_size": [
                    "Tuple[(int, int)]"
                ],
                "use_pyplot": [
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/wrappers.py": {
        "methdispatch": {
            "name": "methdispatch",
            "location": 39,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "Predictor.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": [],
                "clf": [],
                "preprocessor": []
            }
        },
        "Predictor.__call__": {
            "name": "__call__",
            "location": 17,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "ArgmaxTransformer.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [],
            "arguments": {
                "self": [],
                "predictor": []
            }
        },
        "ArgmaxTransformer.__call__": {
            "name": "__call__",
            "location": 34,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "methdispatch.wrapper": {
            "name": "wrapper",
            "location": 54,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/utils/__init__.py": {},
    "alibi-master/alibi/utils/tests/mocked_opt_dep.py": {
        "mocked_function_without_required_deps": {
            "name": "mocked_function_without_required_deps",
            "location": 9,
            "return": [],
            "arguments": {}
        },
        "MockedClassWithoutRequiredDeps.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_data.py": {
        "test_get_category_map": {
            "name": "test_get_category_map",
            "location": 21,
            "return": [],
            "arguments": {
                "categorical_columns": [],
                "df": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_distance.py": {
        "random_matrix": {
            "name": "random_matrix",
            "location": 13,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_cityblock_batch": {
            "name": "test_cityblock_batch",
            "location": 20,
            "return": [],
            "arguments": {
                "random_matrix": []
            }
        },
        "cats_and_labels": {
            "name": "cats_and_labels",
            "location": 39,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_abdm_mvdm": {
            "name": "test_abdm_mvdm",
            "location": 47,
            "return": [],
            "arguments": {
                "cats_and_labels": []
            }
        },
        "test_multidim_scaling": {
            "name": "test_multidim_scaling",
            "location": 73,
            "return": [],
            "arguments": {
                "cats_and_labels": [],
                "rng": [],
                "update_rng": [],
                "center": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_distributed.py": {
        "data_generator": {
            "name": "data_generator",
            "location": 47,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "kwargs_factory": {
            "name": "kwargs_factory",
            "location": 56,
            "return": [
                "List[Dict[(str, Any)]]"
            ],
            "arguments": {
                "keys": [
                    "List[str]"
                ],
                "values": [
                    "List[List[Any]]"
                ]
            }
        },
        "distributed_opts_id": {
            "name": "distributed_opts_id",
            "location": 92,
            "return": [],
            "arguments": {
                "params": [
                    "dict"
                ]
            }
        },
        "data_generator_id": {
            "name": "data_generator_id",
            "location": 104,
            "return": [],
            "arguments": {
                "params": [
                    "List"
                ]
            }
        },
        "test_distributed_explainer_init": {
            "name": "test_distributed_explainer_init",
            "location": 133,
            "return": [],
            "arguments": {
                "expln_args": [],
                "expln_kwargs": [],
                "distributed_opts": []
            }
        },
        "test_distributed_explainer_get_explanation": {
            "name": "test_distributed_explainer_get_explanation",
            "location": 174,
            "return": [],
            "arguments": {
                "data_generator": [],
                "expln_args": [],
                "expln_kwargs": [],
                "distributed_opts": [],
                "return_generator": [],
                "concatenate_results": []
            }
        },
        "permutation_generator": {
            "name": "permutation_generator",
            "location": 231,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_invert_permutation": {
            "name": "test_invert_permutation",
            "location": 245,
            "return": [],
            "arguments": {
                "permutation_generator": []
            }
        },
        "test_pool_collection_init": {
            "name": "test_pool_collection_init",
            "location": 272,
            "return": [],
            "arguments": {
                "expln_args": [],
                "expln_kwargs": [],
                "distributed_opts": [],
                "concatenate_results": []
            }
        },
        "test_pool_collection_get_explanation": {
            "name": "test_pool_collection_get_explanation",
            "location": 335,
            "return": [],
            "arguments": {
                "data_generator": [],
                "expln_args": [],
                "expln_kwargs": [],
                "distributed_opts": []
            }
        },
        "test_concatenate_minibatches": {
            "name": "test_concatenate_minibatches",
            "location": 375,
            "return": [],
            "arguments": {
                "data_generator": [],
                "n_minibatches": [],
                "repetitions": [],
                "n_features": []
            }
        },
        "MockExplainer.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [],
            "arguments": {
                "self": [],
                "sleep_time": [
                    "int"
                ],
                "multiplier": [
                    "int"
                ]
            }
        },
        "MockExplainer.get_explanation": {
            "name": "get_explanation",
            "location": 26,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "Union[(Tuple[(int, np.ndarray)], np.ndarray)]"
                ]
            }
        },
        "MockExplainer.return_attribute": {
            "name": "return_attribute",
            "location": 38,
            "return": [],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_gradients.py": {
        "logistic_iris": {
            "name": "logistic_iris",
            "location": 10,
            "return": [],
            "arguments": {}
        },
        "test_get_batch_num_gradients_cityblock": {
            "name": "test_get_batch_num_gradients_cityblock",
            "location": 18,
            "return": [],
            "arguments": {
                "shape": [],
                "batch_size": []
            }
        },
        "test_get_batch_num_gradients_logistic_iris": {
            "name": "test_get_batch_num_gradients_logistic_iris",
            "location": 30,
            "return": [],
            "arguments": {
                "logistic_iris": [],
                "batch_size": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_import_optional.py": {
        "TestImportOptional.setup_method": {
            "name": "setup_method",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.teardown_method": {
            "name": "teardown_method",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_module": {
            "name": "test_import_optional_module",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_names": {
            "name": "test_import_optional_names",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_module_missing": {
            "name": "test_import_optional_module_missing",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_names_missing": {
            "name": "test_import_optional_names_missing",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_mapping.py": {
        "test_mapping_fn": {
            "name": "test_mapping_fn",
            "location": 18,
            "return": [],
            "arguments": {}
        }
    },
    "alibi-master/alibi/utils/tests/__init__.py": {},
    "alibi-master/doc/source/conf.py": {},
    "alibi-master/testing/test_notebooks.py": {
        "test_notebook_execution": {
            "name": "test_notebook_execution",
            "location": 46,
            "return": [],
            "arguments": {
                "notebook": []
            }
        }
    }
}
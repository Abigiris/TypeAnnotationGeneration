{
    "allennlp-dureader-master/setup.py": {},
    "allennlp-dureader-master/allennlp/run.py": {},
    "allennlp-dureader-master/allennlp/version.py": {},
    "allennlp-dureader-master/allennlp/__init__.py": {},
    "allennlp-dureader-master/allennlp/commands/dry_run.py": {
        "dry_run_from_args": {
            "name": "dry_run_from_args",
            "location": 74,
            "return": [],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "dry_run_from_params": {
            "name": "dry_run_from_params",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "params": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ]
            }
        },
        "verbosely_create_vocabulary": {
            "name": "verbosely_create_vocabulary",
            "location": 125,
            "return": [
                "Vocabulary"
            ],
            "arguments": {
                "vocab_params": [
                    "Params"
                ],
                "instances": [
                    "List[Instance]"
                ]
            }
        },
        "DryRun.add_subparser": {
            "name": "add_subparser",
            "location": 49,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/elmo.py": {
        "empty_embedding": {
            "name": "empty_embedding",
            "location": 103,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {}
        },
        "elmo_command": {
            "name": "elmo_command",
            "location": 303,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "Elmo.add_subparser": {
            "name": "add_subparser",
            "location": 70,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        },
        "ElmoEmbedder.__init__": {
            "name": "__init__",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str"
                ],
                "weight_file": [
                    "str"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "ElmoEmbedder.batch_to_ids": {
            "name": "batch_to_ids",
            "location": 130,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "List[List[str]]"
                ]
            }
        },
        "ElmoEmbedder.batch_to_embeddings": {
            "name": "batch_to_embeddings",
            "location": 157,
            "return": [
                "Tuple[(torch.Tensor, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "List[List[str]]"
                ]
            }
        },
        "ElmoEmbedder.embed_sentence": {
            "name": "embed_sentence",
            "location": 187,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "List[str]"
                ]
            }
        },
        "ElmoEmbedder.embed_batch": {
            "name": "embed_batch",
            "location": 203,
            "return": [
                "List[numpy.ndarray]"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "List[List[str]]"
                ]
            }
        },
        "ElmoEmbedder.embed_sentences": {
            "name": "embed_sentences",
            "location": 234,
            "return": [
                "Iterable[numpy.ndarray]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "Iterable[List[str]]"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "ElmoEmbedder.embed_file": {
            "name": "embed_file",
            "location": 254,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_file": [
                    "IO"
                ],
                "output_file_path": [
                    "str"
                ],
                "output_format": [
                    "str"
                ],
                "batch_size": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/evaluate.py": {
        "evaluate": {
            "name": "evaluate",
            "location": 82,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "model": [
                    "Model"
                ],
                "instances": [
                    "Iterable[Instance]"
                ],
                "data_iterator": [
                    "DataIterator"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "evaluate_from_args": {
            "name": "evaluate_from_args",
            "location": 100,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "Evaluate.add_subparser": {
            "name": "add_subparser",
            "location": 50,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/fine_tune.py": {
        "fine_tune_model_from_args": {
            "name": "fine_tune_model_from_args",
            "location": 67,
            "return": [],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "fine_tune_model_from_file_paths": {
            "name": "fine_tune_model_from_file_paths",
            "location": 78,
            "return": [
                "Model"
            ],
            "arguments": {
                "model_archive_path": [
                    "str"
                ],
                "config_file": [
                    "str"
                ],
                "serialization_dir": [
                    "str"
                ],
                "overrides": [
                    "str"
                ],
                "file_friendly_logging": [
                    "bool"
                ]
            }
        },
        "fine_tune_model": {
            "name": "fine_tune_model",
            "location": 113,
            "return": [
                "Model"
            ],
            "arguments": {
                "model": [
                    "Model"
                ],
                "params": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ],
                "file_friendly_logging": [
                    "bool"
                ]
            }
        },
        "FineTune.add_subparser": {
            "name": "add_subparser",
            "location": 28,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/make_vocab.py": {
        "make_vocab_from_args": {
            "name": "make_vocab_from_args",
            "location": 58,
            "return": [],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "make_vocab_from_params": {
            "name": "make_vocab_from_params",
            "location": 69,
            "return": [],
            "arguments": {
                "params": [
                    "Params"
                ]
            }
        },
        "MakeVocab.add_subparser": {
            "name": "add_subparser",
            "location": 39,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/predict.py": {
        "_get_predictor": {
            "name": "_get_predictor",
            "location": 101,
            "return": [
                "Predictor"
            ],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "_run": {
            "name": "_run",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "predictor": [
                    "Predictor"
                ],
                "input_file": [
                    "IO"
                ],
                "output_file": [
                    "Optional[IO]"
                ],
                "batch_size": [
                    "int"
                ],
                "print_to_console": [
                    "bool"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "_predict": {
            "name": "_predict",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "Predict.add_subparser": {
            "name": "add_subparser",
            "location": 66,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        },
        "_run._run_predictor": {
            "name": "_run_predictor",
            "location": 125,
            "return": [],
            "arguments": {
                "batch_data": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/serve.py": {
        "_serve": {
            "name": "_serve",
            "location": 72,
            "return": [],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "Serve.add_subparser": {
            "name": "add_subparser",
            "location": 60,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/subcommand.py": {
        "Subcommand.add_subparser": {
            "name": "add_subparser",
            "location": 16,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/train.py": {
        "train_model_from_args": {
            "name": "train_model_from_args",
            "location": 91,
            "return": [],
            "arguments": {
                "args": [
                    "argparse.Namespace"
                ]
            }
        },
        "train_model_from_file": {
            "name": "train_model_from_file",
            "location": 102,
            "return": [
                "Model"
            ],
            "arguments": {
                "parameter_filename": [
                    "str"
                ],
                "serialization_dir": [
                    "str"
                ],
                "overrides": [
                    "str"
                ],
                "file_friendly_logging": [
                    "bool"
                ],
                "recover": [
                    "bool"
                ]
            }
        },
        "datasets_from_params": {
            "name": "datasets_from_params",
            "location": 132,
            "return": [
                "Dict[(str, Iterable[Instance])]"
            ],
            "arguments": {
                "params": [
                    "Params"
                ]
            }
        },
        "create_serialization_dir": {
            "name": "create_serialization_dir",
            "location": 164,
            "return": [
                "None"
            ],
            "arguments": {
                "params": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ],
                "recover": [
                    "bool"
                ]
            }
        },
        "train_model": {
            "name": "train_model",
            "location": 226,
            "return": [
                "Model"
            ],
            "arguments": {
                "params": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ],
                "file_friendly_logging": [
                    "bool"
                ],
                "recover": [
                    "bool"
                ]
            }
        },
        "Train.add_subparser": {
            "name": "add_subparser",
            "location": 58,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/__init__.py": {
        "main": {
            "name": "main",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "prog": [
                    "str"
                ],
                "subcommand_overrides": [
                    "Dict[(str, Subcommand)]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/checks.py": {
        "log_pytorch_version_info": {
            "name": "log_pytorch_version_info",
            "location": 24,
            "return": [],
            "arguments": {}
        },
        "check_dimensions_match": {
            "name": "check_dimensions_match",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "dimension_1": [
                    "int"
                ],
                "dimension_2": [
                    "int"
                ],
                "dim_1_name": [
                    "str"
                ],
                "dim_2_name": [
                    "str"
                ]
            }
        },
        "ConfigurationError.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [],
            "arguments": {
                "self": [],
                "message": []
            }
        },
        "ConfigurationError.__str__": {
            "name": "__str__",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/file_utils.py": {
        "url_to_filename": {
            "name": "url_to_filename",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "url": [
                    "str"
                ],
                "etag": [
                    "str"
                ]
            }
        },
        "filename_to_url": {
            "name": "filename_to_url",
            "location": 40,
            "return": [
                "Tuple[(str, str)]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "cached_path": {
            "name": "cached_path",
            "location": 56,
            "return": [
                "str"
            ],
            "arguments": {
                "url_or_filename": [
                    "str"
                ],
                "cache_dir": [
                    "str"
                ]
            }
        },
        "get_from_cache": {
            "name": "get_from_cache",
            "location": 83,
            "return": [
                "str"
            ],
            "arguments": {
                "url": [
                    "str"
                ],
                "cache_dir": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/params.py": {
        "pop_choice": {
            "name": "pop_choice",
            "location": 295,
            "return": [
                "Any"
            ],
            "arguments": {
                "params": [
                    "Dict[(str, Any)]"
                ],
                "key": [
                    "str"
                ],
                "choices": [
                    "List[Any]"
                ],
                "default_to_first_choice": [
                    "bool"
                ],
                "history": [
                    "str"
                ]
            }
        },
        "_replace_none": {
            "name": "_replace_none",
            "location": 314,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "dictionary": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "Params.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "Dict[(str, Any)]"
                ],
                "history": [
                    "str"
                ],
                "loading_from_archive": [
                    "bool"
                ],
                "files_to_archive": [
                    "Dict[(str, str)]"
                ]
            }
        },
        "Params.add_file_to_archive": {
            "name": "add_file_to_archive",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Params.pop": {
            "name": "pop",
            "location": 85,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": [
                    "Any"
                ]
            }
        },
        "Params.pop_int": {
            "name": "pop_int",
            "location": 104,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": [
                    "Any"
                ]
            }
        },
        "Params.pop_float": {
            "name": "pop_float",
            "location": 114,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": [
                    "Any"
                ]
            }
        },
        "Params.pop_bool": {
            "name": "pop_bool",
            "location": 124,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": [
                    "Any"
                ]
            }
        },
        "Params.get": {
            "name": "get",
            "location": 141,
            "return": [],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": [
                    "Any"
                ]
            }
        },
        "Params.pop_choice": {
            "name": "pop_choice",
            "location": 155,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "choices": [
                    "List[Any]"
                ],
                "default_to_first_choice": [
                    "bool"
                ]
            }
        },
        "Params.as_dict": {
            "name": "as_dict",
            "location": 187,
            "return": [],
            "arguments": {
                "self": [],
                "quiet": []
            }
        },
        "Params.as_flat_dict": {
            "name": "as_flat_dict",
            "location": 215,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Params.duplicate": {
            "name": "duplicate",
            "location": 232,
            "return": [
                "'Params'"
            ],
            "arguments": {
                "self": []
            }
        },
        "Params.assert_empty": {
            "name": "assert_empty",
            "location": 239,
            "return": [],
            "arguments": {
                "self": [],
                "class_name": [
                    "str"
                ]
            }
        },
        "Params.__getitem__": {
            "name": "__getitem__",
            "location": 249,
            "return": [],
            "arguments": {
                "self": [],
                "key": []
            }
        },
        "Params.__setitem__": {
            "name": "__setitem__",
            "location": 255,
            "return": [],
            "arguments": {
                "self": [],
                "key": [],
                "value": []
            }
        },
        "Params.__delitem__": {
            "name": "__delitem__",
            "location": 258,
            "return": [],
            "arguments": {
                "self": [],
                "key": []
            }
        },
        "Params.__iter__": {
            "name": "__iter__",
            "location": 261,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Params.__len__": {
            "name": "__len__",
            "location": 264,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Params._check_is_dict": {
            "name": "_check_is_dict",
            "location": 267,
            "return": [],
            "arguments": {
                "self": [],
                "new_history": [],
                "value": []
            }
        },
        "Params.from_file": {
            "name": "from_file",
            "location": 279,
            "return": [
                "'Params'"
            ],
            "arguments": {
                "params_file": [
                    "str"
                ],
                "params_overrides": [
                    "str"
                ]
            }
        },
        "Params.as_dict.log_recursively": {
            "name": "log_recursively",
            "location": 200,
            "return": [],
            "arguments": {
                "parameters": [],
                "history": []
            }
        },
        "Params.as_flat_dict.recurse": {
            "name": "recurse",
            "location": 221,
            "return": [],
            "arguments": {
                "parameters": [],
                "path": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/registrable.py": {
        "Registrable.register": {
            "name": "register",
            "location": 41,
            "return": [],
            "arguments": {
                "cls": [
                    "Type[T]"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "Registrable.by_name": {
            "name": "by_name",
            "location": 54,
            "return": [
                "Type[T]"
            ],
            "arguments": {
                "cls": [
                    "Type[T]"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "Registrable.list_available": {
            "name": "list_available",
            "location": 60,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "cls": []
            }
        },
        "Registrable.register.add_subclass_to_registry": {
            "name": "add_subclass_to_registry",
            "location": 43,
            "return": [],
            "arguments": {
                "subclass": [
                    "Type[T]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/squad_eval.py": {
        "normalize_answer": {
            "name": "normalize_answer",
            "location": 12,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "f1_score": {
            "name": "f1_score",
            "location": 30,
            "return": [],
            "arguments": {
                "prediction": [],
                "ground_truth": []
            }
        },
        "exact_match_score": {
            "name": "exact_match_score",
            "location": 43,
            "return": [],
            "arguments": {
                "prediction": [],
                "ground_truth": []
            }
        },
        "metric_max_over_ground_truths": {
            "name": "metric_max_over_ground_truths",
            "location": 47,
            "return": [],
            "arguments": {
                "metric_fn": [],
                "prediction": [],
                "ground_truths": []
            }
        },
        "evaluate": {
            "name": "evaluate",
            "location": 55,
            "return": [],
            "arguments": {
                "dataset": [],
                "predictions": []
            }
        },
        "normalize_answer.remove_articles": {
            "name": "remove_articles",
            "location": 14,
            "return": [],
            "arguments": {
                "text": []
            }
        },
        "normalize_answer.white_space_fix": {
            "name": "white_space_fix",
            "location": 17,
            "return": [],
            "arguments": {
                "text": []
            }
        },
        "normalize_answer.remove_punc": {
            "name": "remove_punc",
            "location": 20,
            "return": [],
            "arguments": {
                "text": []
            }
        },
        "normalize_answer.lower": {
            "name": "lower",
            "location": 24,
            "return": [],
            "arguments": {
                "text": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/tee_logger.py": {
        "replace_cr_with_newline": {
            "name": "replace_cr_with_newline",
            "location": 8,
            "return": [],
            "arguments": {
                "message": [
                    "str"
                ]
            }
        },
        "TeeLogger.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str"
                ],
                "terminal": [
                    "TextIO"
                ],
                "file_friendly_terminal_output": [
                    "bool"
                ]
            }
        },
        "TeeLogger.write": {
            "name": "write",
            "location": 37,
            "return": [],
            "arguments": {
                "self": [],
                "message": []
            }
        },
        "TeeLogger.flush": {
            "name": "flush",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/tqdm.py": {
        "Tqdm.set_default_mininterval": {
            "name": "set_default_mininterval",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "float"
                ]
            }
        },
        "Tqdm.set_slower_interval": {
            "name": "set_slower_interval",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "use_slower_interval": [
                    "bool"
                ]
            }
        },
        "Tqdm.tqdm": {
            "name": "tqdm",
            "location": 30,
            "return": [],
            "arguments": {}
        }
    },
    "allennlp-dureader-master/allennlp/common/util.py": {
        "sanitize": {
            "name": "sanitize",
            "location": 31,
            "return": [
                "Any"
            ],
            "arguments": {
                "x": [
                    "Any"
                ]
            }
        },
        "group_by_count": {
            "name": "group_by_count",
            "location": 61,
            "return": [
                "List[List[Any]]"
            ],
            "arguments": {
                "iterable": [
                    "List[Any]"
                ],
                "count": [
                    "int"
                ],
                "default_value": [
                    "Any"
                ]
            }
        },
        "lazy_groups_of": {
            "name": "lazy_groups_of",
            "location": 77,
            "return": [
                "Iterator[List[A]]"
            ],
            "arguments": {
                "iterator": [
                    "Iterator[A]"
                ],
                "group_size": [
                    "int"
                ]
            }
        },
        "pad_sequence_to_length": {
            "name": "pad_sequence_to_length",
            "location": 84,
            "return": [
                "List"
            ],
            "arguments": {
                "sequence": [
                    "List"
                ],
                "desired_length": [
                    "int"
                ],
                "default_value": [
                    "Callable[([], Any)]"
                ],
                "padding_on_right": [
                    "bool"
                ]
            }
        },
        "add_noise_to_dict_values": {
            "name": "add_noise_to_dict_values",
            "location": 128,
            "return": [
                "Dict[(A, float)]"
            ],
            "arguments": {
                "dictionary": [
                    "Dict[(A, float)]"
                ],
                "noise_param": [
                    "float"
                ]
            }
        },
        "namespace_match": {
            "name": "namespace_match",
            "location": 142,
            "return": [],
            "arguments": {
                "pattern": [
                    "str"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "prepare_environment": {
            "name": "prepare_environment",
            "location": 155,
            "return": [],
            "arguments": {
                "params": [
                    "Params"
                ]
            }
        },
        "prepare_global_logging": {
            "name": "prepare_global_logging",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "serialization_dir": [
                    "str"
                ],
                "file_friendly_logging": [
                    "bool"
                ]
            }
        },
        "get_spacy_model": {
            "name": "get_spacy_model",
            "location": 218,
            "return": [
                "SpacyModelType"
            ],
            "arguments": {
                "spacy_model_name": [
                    "str"
                ],
                "pos_tags": [
                    "bool"
                ],
                "parse": [
                    "bool"
                ],
                "ner": [
                    "bool"
                ]
            }
        },
        "import_submodules": {
            "name": "import_submodules",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {
                "package_name": [
                    "str"
                ]
            }
        },
        "peak_memory_mb": {
            "name": "peak_memory_mb",
            "location": 260,
            "return": [
                "float"
            ],
            "arguments": {}
        },
        "gpu_memory_mb": {
            "name": "gpu_memory_mb",
            "location": 285,
            "return": [
                "Dict[(int, int)]"
            ],
            "arguments": {}
        },
        "ensure_list": {
            "name": "ensure_list",
            "location": 314,
            "return": [
                "List[A]"
            ],
            "arguments": {
                "iterable": [
                    "Iterable[A]"
                ]
            }
        },
        "is_lazy": {
            "name": "is_lazy",
            "location": 324,
            "return": [
                "bool"
            ],
            "arguments": {
                "iterable": [
                    "Iterable[A]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/__init__.py": {},
    "allennlp-dureader-master/allennlp/common/testing/model_test_case.py": {
        "ModelTestCase.set_up_model": {
            "name": "set_up_model",
            "location": 20,
            "return": [],
            "arguments": {
                "self": [],
                "param_file": [],
                "dataset_file": []
            }
        },
        "ModelTestCase.ensure_model_can_train_save_and_load": {
            "name": "ensure_model_can_train_save_and_load",
            "location": 37,
            "return": [],
            "arguments": {
                "self": [],
                "param_file": [
                    "str"
                ],
                "tolerance": [
                    "float"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "ModelTestCase.assert_fields_equal": {
            "name": "assert_fields_equal",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field1": [],
                "field2": [],
                "name": [
                    "str"
                ],
                "tolerance": [
                    "float"
                ]
            }
        },
        "ModelTestCase.check_model_computes_gradients_correctly": {
            "name": "check_model_computes_gradients_correctly",
            "location": 132,
            "return": [],
            "arguments": {
                "model": [],
                "model_batch": []
            }
        },
        "ModelTestCase.ensure_batch_predictions_are_consistent": {
            "name": "ensure_batch_predictions_are_consistent",
            "location": 155,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/testing/test_case.py": {
        "AllenNlpTestCase.setUp": {
            "name": "setUp",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AllenNlpTestCase.tearDown": {
            "name": "tearDown",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/testing/__init__.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/build.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/__init__.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/_ext/__init__.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/_ext/highway_lstm_layer/__init__.py": {
        "_import_symbols": {
            "name": "_import_symbols",
            "location": 6,
            "return": [],
            "arguments": {
                "locals": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset.py": {
        "Batch.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ]
            }
        },
        "Batch._check_types": {
            "name": "_check_types",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 45,
            "return": [
                "Dict[(str, Dict[(str, int)])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.as_tensor_dict": {
            "name": "as_tensor_dict",
            "location": 70,
            "return": [
                "Dict[(str, Union[(torch.Tensor, Dict[(str, torch.Tensor)])])]"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, Dict[(str, int)])]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "Batch.__iter__": {
            "name": "__iter__",
            "location": 158,
            "return": [
                "Iterator[Instance]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.index_instances": {
            "name": "index_instances",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/instance.py": {
        "Instance.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fields": [
                    "Mapping[(str, Field)]"
                ]
            }
        },
        "Instance.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 29,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "Instance.index_fields": {
            "name": "index_fields",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "Instance.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 52,
            "return": [
                "Dict[(str, Dict[(str, int)])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Instance.as_tensor_dict": {
            "name": "as_tensor_dict",
            "location": 62,
            "return": [
                "Dict[(str, DataArray)]"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, Dict[(str, int)])]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "Instance.__str__": {
            "name": "__str__",
            "location": 83,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/vocabulary.py": {
        "_read_pretrained_words": {
            "name": "_read_pretrained_words",
            "location": 94,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str"
                ]
            }
        },
        "_NamespaceDependentDefaultDict.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "non_padded_namespaces": [
                    "Sequence[str]"
                ],
                "padded_function": [
                    "Callable[([], Any)]"
                ],
                "non_padded_function": [
                    "Callable[([], Any)]"
                ]
            }
        },
        "_NamespaceDependentDefaultDict.__missing__": {
            "name": "__missing__",
            "location": 72,
            "return": [],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ]
            }
        },
        "_TokenToIndexDefaultDict.__init__": {
            "name": "__init__",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "non_padded_namespaces": [
                    "Sequence[str]"
                ],
                "padding_token": [
                    "str"
                ],
                "oov_token": [
                    "str"
                ]
            }
        },
        "_IndexToTokenDefaultDict.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "non_padded_namespaces": [
                    "Sequence[str]"
                ],
                "padding_token": [
                    "str"
                ],
                "oov_token": [
                    "str"
                ]
            }
        },
        "Vocabulary.__init__": {
            "name": "__init__",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ],
                "min_count": [
                    "Dict[(str, int)]"
                ],
                "max_vocab_size": [
                    "Union[(int, Dict[(str, int)])]"
                ],
                "non_padded_namespaces": [
                    "Sequence[str]"
                ],
                "pretrained_files": [
                    "Optional[Dict[(str, str)]]"
                ],
                "only_include_pretrained_words": [
                    "bool"
                ]
            }
        },
        "Vocabulary.save_to_files": {
            "name": "save_to_files",
            "location": 207,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "directory": [
                    "str"
                ]
            }
        },
        "Vocabulary.from_files": {
            "name": "from_files",
            "location": 234,
            "return": [
                "'Vocabulary'"
            ],
            "arguments": {
                "cls": [],
                "directory": [
                    "str"
                ]
            }
        },
        "Vocabulary.set_from_file": {
            "name": "set_from_file",
            "location": 263,
            "return": [],
            "arguments": {
                "self": [],
                "filename": [
                    "str"
                ],
                "is_padded": [
                    "bool"
                ],
                "oov_token": [
                    "str"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "Vocabulary.from_instances": {
            "name": "from_instances",
            "location": 316,
            "return": [
                "'Vocabulary'"
            ],
            "arguments": {
                "cls": [],
                "instances": [
                    "Iterable['adi.Instance']"
                ],
                "min_count": [
                    "Dict[(str, int)]"
                ],
                "max_vocab_size": [
                    "Union[(int, Dict[(str, int)])]"
                ],
                "non_padded_namespaces": [
                    "Sequence[str]"
                ],
                "pretrained_files": [
                    "Optional[Dict[(str, str)]]"
                ],
                "only_include_pretrained_words": [
                    "bool"
                ]
            }
        },
        "Vocabulary.from_params": {
            "name": "from_params",
            "location": 342,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ],
                "instances": [
                    "Iterable['adi.Instance']"
                ]
            }
        },
        "Vocabulary.add_token_to_namespace": {
            "name": "add_token_to_namespace",
            "location": 385,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "Vocabulary.get_index_to_token_vocabulary": {
            "name": "get_index_to_token_vocabulary",
            "location": 401,
            "return": [
                "Dict[(int, str)]"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ]
            }
        },
        "Vocabulary.get_token_index": {
            "name": "get_token_index",
            "location": 404,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "Vocabulary.get_token_from_index": {
            "name": "get_token_from_index",
            "location": 415,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "Vocabulary.get_vocab_size": {
            "name": "get_vocab_size",
            "location": 418,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ]
            }
        },
        "Vocabulary.__eq__": {
            "name": "__eq__",
            "location": 421,
            "return": [],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vocabulary.__str__": {
            "name": "__str__",
            "location": 426,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/conll2003.py": {
        "_is_divider": {
            "name": "_is_divider",
            "location": 19,
            "return": [
                "bool"
            ],
            "arguments": {
                "line": [
                    "str"
                ]
            }
        },
        "Conll2003DatasetReader.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "tag_label": [
                    "str"
                ],
                "feature_labels": [
                    "Sequence[str]"
                ],
                "lazy": [
                    "bool"
                ],
                "coding_scheme": [
                    "str"
                ]
            }
        },
        "Conll2003DatasetReader._read": {
            "name": "_read",
            "location": 96,
            "return": [
                "Iterable[Instance]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Conll2003DatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 144,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[Token]"
                ]
            }
        },
        "Conll2003DatasetReader.from_params": {
            "name": "from_params",
            "location": 152,
            "return": [
                "'Conll2003DatasetReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_reader.py": {
        "_LazyInstances.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "instance_generator": [
                    "Callable[([], Iterator[Instance])]"
                ]
            }
        },
        "_LazyInstances.__iter__": {
            "name": "__iter__",
            "location": 20,
            "return": [
                "Iterator[Instance]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetReader.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool"
                ]
            }
        },
        "DatasetReader.read": {
            "name": "read",
            "location": 45,
            "return": [
                "Iterable[Instance]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "DatasetReader._read": {
            "name": "_read",
            "location": 79,
            "return": [
                "Iterable[Instance]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "DatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 88,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetReader.from_params": {
            "name": "from_params",
            "location": 108,
            "return": [
                "'DatasetReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/language_modeling.py": {
        "LanguageModelingReader.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokens_per_instance": [
                    "int"
                ],
                "tokenizer": [
                    "Tokenizer"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "LanguageModelingReader._read": {
            "name": "_read",
            "location": 68,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "LanguageModelingReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 93,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "LanguageModelingReader.from_params": {
            "name": "from_params",
            "location": 101,
            "return": [
                "'LanguageModelingReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/penn_tree_bank.py": {
        "PennTreeBankConstituencySpanDatasetReader.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "use_pos_tags": [
                    "bool"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader._read": {
            "name": "_read",
            "location": 53,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "PennTreeBankConstituencySpanDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 69,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[str]"
                ],
                "pos_tags": [
                    "List[str]"
                ],
                "gold_tree": [
                    "Tree"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader._strip_functional_tags": {
            "name": "_strip_functional_tags",
            "location": 146,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "Tree"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader._get_gold_spans": {
            "name": "_get_gold_spans",
            "location": 160,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "Tree"
                ],
                "index": [
                    "int"
                ],
                "typed_spans": [
                    "Dict[(Tuple[(int, int)], str)]"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader.from_params": {
            "name": "from_params",
            "location": 223,
            "return": [
                "'PennTreeBankConstituencySpanDatasetReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/semantic_role_labeling.py": {
        "SrlReader.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "domain_identifier": [
                    "str"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "SrlReader._read": {
            "name": "_read",
            "location": 56,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SrlReader._ontonotes_subset": {
            "name": "_ontonotes_subset",
            "location": 77,
            "return": [
                "Iterable[OntonotesSentence]"
            ],
            "arguments": {
                "ontonotes_reader": [
                    "Ontonotes"
                ],
                "file_path": [
                    "str"
                ],
                "domain_identifier": [
                    "str"
                ]
            }
        },
        "SrlReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 89,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[Token]"
                ],
                "verb_label": [
                    "List[int]"
                ],
                "tags": [
                    "List[str]"
                ]
            }
        },
        "SrlReader.from_params": {
            "name": "from_params",
            "location": 108,
            "return": [
                "'SrlReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/seq2seq.py": {
        "Seq2SeqDatasetReader.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "source_tokenizer": [
                    "Tokenizer"
                ],
                "target_tokenizer": [
                    "Tokenizer"
                ],
                "source_token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "target_token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "source_add_start_token": [
                    "bool"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "Seq2SeqDatasetReader._read": {
            "name": "_read",
            "location": 66,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "Seq2SeqDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 82,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "source_string": [
                    "str"
                ],
                "target_string": [
                    "str"
                ]
            }
        },
        "Seq2SeqDatasetReader.from_params": {
            "name": "from_params",
            "location": 99,
            "return": [
                "'Seq2SeqDatasetReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/sequence_tagging.py": {
        "SequenceTaggingDatasetReader.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "word_tag_delimiter": [
                    "str"
                ],
                "token_delimiter": [
                    "str"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "SequenceTaggingDatasetReader._read": {
            "name": "_read",
            "location": 51,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "SequenceTaggingDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 75,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[Token]"
                ]
            }
        },
        "SequenceTaggingDatasetReader.from_params": {
            "name": "from_params",
            "location": 83,
            "return": [
                "'SequenceTaggingDatasetReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/snli.py": {
        "SnliReader.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokenizer": [
                    "Tokenizer"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "SnliReader._read": {
            "name": "_read",
            "location": 43,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SnliReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 64,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "premise": [
                    "str"
                ],
                "hypothesis": [
                    "str"
                ],
                "label": [
                    "str"
                ]
            }
        },
        "SnliReader.from_params": {
            "name": "from_params",
            "location": 79,
            "return": [
                "'SnliReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/stanford_sentiment_tree_bank.py": {
        "StanfordSentimentTreeBankDatasetReader.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "use_subtrees": [
                    "bool"
                ],
                "granularity": [
                    "str"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "StanfordSentimentTreeBankDatasetReader._read": {
            "name": "_read",
            "location": 68,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "StanfordSentimentTreeBankDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 87,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[str]"
                ],
                "sentiment": [
                    "str"
                ]
            }
        },
        "StanfordSentimentTreeBankDatasetReader.from_params": {
            "name": "from_params",
            "location": 134,
            "return": [
                "'StanfordSentimentTreeBankDatasetReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/coreference_resolution/conll.py": {
        "canonicalize_clusters": {
            "name": "canonicalize_clusters",
            "location": 19,
            "return": [
                "List[List[Tuple[(int, int)]]]"
            ],
            "arguments": {
                "clusters": [
                    "DefaultDict[(int, List[Tuple[(int, int)]])]"
                ]
            }
        },
        "ConllCorefReader.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_span_width": [
                    "int"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "ConllCorefReader._read": {
            "name": "_read",
            "location": 84,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "ConllCorefReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 107,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[List[str]]"
                ],
                "gold_clusters": [
                    "Optional[List[List[Tuple[(int, int)]]]]"
                ]
            }
        },
        "ConllCorefReader.from_params": {
            "name": "from_params",
            "location": 180,
            "return": [
                "'ConllCorefReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "ConllCorefReader._normalize_word": {
            "name": "_normalize_word",
            "location": 188,
            "return": [],
            "arguments": {
                "word": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/coreference_resolution/winobias.py": {
        "WinobiasReader.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_span_width": [
                    "int"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "WinobiasReader._read": {
            "name": "_read",
            "location": 61,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "WinobiasReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 98,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "List[Token]"
                ],
                "gold_clusters": [
                    "Optional[List[List[Tuple[(int, int)]]]]"
                ]
            }
        },
        "WinobiasReader.from_params": {
            "name": "from_params",
            "location": 162,
            "return": [
                "'WinobiasReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/coreference_resolution/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_utils/ontonotes.py": {
        "OntonotesSentence.__init__": {
            "name": "__init__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "document_id": [
                    "str"
                ],
                "sentence_id": [
                    "int"
                ],
                "words": [
                    "List[str]"
                ],
                "pos_tags": [
                    "List[str]"
                ],
                "parse_tree": [
                    "Optional[Tree]"
                ],
                "predicate_lemmas": [
                    "List[Optional[str]]"
                ],
                "predicate_framenet_ids": [
                    "List[Optional[str]]"
                ],
                "word_senses": [
                    "List[Optional[float]]"
                ],
                "speakers": [
                    "List[Optional[str]]"
                ],
                "named_entities": [
                    "List[str]"
                ],
                "srl_frames": [
                    "List[Tuple[(str, List[str])]]"
                ],
                "coref_spans": [
                    "Set[TypedSpan]"
                ]
            }
        },
        "Ontonotes.dataset_iterator": {
            "name": "dataset_iterator",
            "location": 176,
            "return": [
                "Iterator[OntonotesSentence]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes.dataset_path_iterator": {
            "name": "dataset_path_iterator",
            "location": 184,
            "return": [
                "Iterator[str]"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes.dataset_document_iterator": {
            "name": "dataset_document_iterator",
            "location": 200,
            "return": [
                "Iterator[List[OntonotesSentence]]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes.sentence_iterator": {
            "name": "sentence_iterator",
            "location": 227,
            "return": [
                "Iterator[OntonotesSentence]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes._conll_rows_to_sentence": {
            "name": "_conll_rows_to_sentence",
            "location": 235,
            "return": [
                "OntonotesSentence"
            ],
            "arguments": {
                "self": [],
                "conll_rows": [
                    "List[str]"
                ]
            }
        },
        "Ontonotes._process_coref_span_annotations_for_word": {
            "name": "_process_coref_span_annotations_for_word",
            "location": 362,
            "return": [
                "None"
            ],
            "arguments": {
                "label": [
                    "str"
                ],
                "word_index": [
                    "int"
                ],
                "clusters": [
                    "DefaultDict[(int, List[Tuple[(int, int)]])]"
                ],
                "coref_stacks": [
                    "DefaultDict[(int, List[int])]"
                ]
            }
        },
        "Ontonotes._process_span_annotations_for_word": {
            "name": "_process_span_annotations_for_word",
            "location": 411,
            "return": [
                "None"
            ],
            "arguments": {
                "annotations": [
                    "List[str]"
                ],
                "span_labels": [
                    "List[List[str]]"
                ],
                "current_span_labels": [
                    "List[Optional[str]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_utils/span_utils.py": {
        "enumerate_spans": {
            "name": "enumerate_spans",
            "location": 11,
            "return": [
                "List[Tuple[(int, int)]]"
            ],
            "arguments": {
                "sentence": [
                    "List[T]"
                ],
                "offset": [
                    "int"
                ],
                "max_span_width": [
                    "int"
                ],
                "min_span_width": [
                    "int"
                ],
                "filter_function": [
                    "Callable[([List[T]], bool)]"
                ]
            }
        },
        "bio_tags_to_spans": {
            "name": "bio_tags_to_spans",
            "location": 60,
            "return": [
                "List[TypedStringSpan]"
            ],
            "arguments": {
                "tag_sequence": [
                    "List[str]"
                ],
                "classes_to_ignore": [
                    "List[str]"
                ]
            }
        },
        "bioul_tags_to_spans": {
            "name": "bioul_tags_to_spans",
            "location": 132,
            "return": [
                "List[TypedStringSpan]"
            ],
            "arguments": {
                "tag_sequence": [
                    "List[str]"
                ],
                "classes_to_ignore": [
                    "List[str]"
                ]
            }
        },
        "iob1_to_bioul": {
            "name": "iob1_to_bioul",
            "location": 176,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "tag_sequence": [
                    "List[str]"
                ]
            }
        },
        "iob1_to_bioul.replace_label": {
            "name": "replace_label",
            "location": 196,
            "return": [],
            "arguments": {
                "full_label": [],
                "new_label": []
            }
        },
        "iob1_to_bioul.pop_replace_append": {
            "name": "pop_replace_append",
            "location": 202,
            "return": [],
            "arguments": {
                "in_stack": [],
                "out_stack": [],
                "new_label": []
            }
        },
        "iob1_to_bioul.process_stack": {
            "name": "process_stack",
            "location": 209,
            "return": [],
            "arguments": {
                "stack": [],
                "out_stack": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_utils/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/squad.py": {
        "SquadReader.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokenizer": [
                    "Tokenizer"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "SquadReader._read": {
            "name": "_read",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SquadReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 75,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "question_text": [
                    "str"
                ],
                "passage_text": [
                    "str"
                ],
                "char_spans": [
                    "List[Tuple[(int, int)]]"
                ],
                "answer_texts": [
                    "List[str]"
                ],
                "passage_tokens": [
                    "List[Token]"
                ]
            }
        },
        "SquadReader.from_params": {
            "name": "from_params",
            "location": 111,
            "return": [
                "'SquadReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/triviaqa.py": {
        "TriviaQaReader.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "base_tarball_path": [
                    "str"
                ],
                "unfiltered_tarball_path": [
                    "str"
                ],
                "tokenizer": [
                    "Tokenizer"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "TriviaQaReader._read": {
            "name": "_read",
            "location": 66,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "TriviaQaReader.pick_paragraphs": {
            "name": "pick_paragraphs",
            "location": 114,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "evidence_files": [
                    "List[List[str]]"
                ],
                "question": [
                    "str"
                ],
                "answer_texts": [
                    "List[str]"
                ]
            }
        },
        "TriviaQaReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 137,
            "return": [
                "Instance"
            ],
            "arguments": {
                "self": [],
                "question_text": [
                    "str"
                ],
                "passage_text": [
                    "str"
                ],
                "token_spans": [
                    "List[Tuple[(int, int)]]"
                ],
                "answer_texts": [
                    "List[str]"
                ],
                "question_tokens": [
                    "List[Token]"
                ],
                "passage_tokens": [
                    "List[Token]"
                ]
            }
        },
        "TriviaQaReader.from_params": {
            "name": "from_params",
            "location": 157,
            "return": [
                "'TriviaQaReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/util.py": {
        "normalize_text": {
            "name": "normalize_text",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        },
        "char_span_to_token_span": {
            "name": "char_span_to_token_span",
            "location": 34,
            "return": [
                "Tuple[(Tuple[(int, int)], bool)]"
            ],
            "arguments": {
                "token_offsets": [
                    "List[Tuple[(int, int)]]"
                ],
                "character_span": [
                    "Tuple[(int, int)]"
                ]
            }
        },
        "find_valid_answer_spans": {
            "name": "find_valid_answer_spans",
            "location": 95,
            "return": [
                "List[Tuple[(int, int)]]"
            ],
            "arguments": {
                "passage_tokens": [
                    "List[Token]"
                ],
                "answer_texts": [
                    "List[str]"
                ]
            }
        },
        "make_reading_comprehension_instance": {
            "name": "make_reading_comprehension_instance",
            "location": 136,
            "return": [
                "Instance"
            ],
            "arguments": {
                "question_tokens": [
                    "List[Token]"
                ],
                "passage_tokens": [
                    "List[Token]"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ],
                "passage_text": [
                    "str"
                ],
                "token_spans": [
                    "List[Tuple[(int, int)]]"
                ],
                "answer_texts": [
                    "List[str]"
                ],
                "additional_metadata": [
                    "Dict[(str, Any)]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/fields/array_field.py": {
        "ArrayField.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "array": [
                    "numpy.ndarray"
                ],
                "padding_value": [
                    "int"
                ]
            }
        },
        "ArrayField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 22,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayField.as_tensor": {
            "name": "as_tensor",
            "location": 27,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "ArrayField.empty_field": {
            "name": "empty_field",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ArrayField.__str__": {
            "name": "__str__",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/field.py": {
        "Field.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "Field.index": {
            "name": "index",
            "location": 50,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "Field.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 60,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.as_tensor": {
            "name": "as_tensor",
            "location": 71,
            "return": [
                "DataArray"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "Field.empty_field": {
            "name": "empty_field",
            "location": 96,
            "return": [
                "'Field'"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.batch_tensors": {
            "name": "batch_tensors",
            "location": 109,
            "return": [
                "DataArray"
            ],
            "arguments": {
                "self": [],
                "tensor_list": [
                    "List[DataArray]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/index_field.py": {
        "IndexField.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ],
                "sequence_field": [
                    "SequenceField"
                ]
            }
        },
        "IndexField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 40,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IndexField.as_tensor": {
            "name": "as_tensor",
            "location": 44,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "IndexField.empty_field": {
            "name": "empty_field",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IndexField.__str__": {
            "name": "__str__",
            "location": 56,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/label_field.py": {
        "LabelField.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "Union[(str, int)]"
                ],
                "label_namespace": [
                    "str"
                ],
                "skip_indexing": [
                    "bool"
                ]
            }
        },
        "LabelField._maybe_warn_for_namespace": {
            "name": "_maybe_warn_for_namespace",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label_namespace": [
                    "str"
                ]
            }
        },
        "LabelField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 76,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "LabelField.index": {
            "name": "index",
            "location": 81,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "LabelField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 86,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelField.as_tensor": {
            "name": "as_tensor",
            "location": 90,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "LabelField.empty_field": {
            "name": "empty_field",
            "location": 99,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelField.__str__": {
            "name": "__str__",
            "location": 102,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/list_field.py": {
        "ListField.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_list": [
                    "List[Field]"
                ]
            }
        },
        "ListField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 35,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "ListField.index": {
            "name": "index",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "ListField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 45,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListField.sequence_length": {
            "name": "sequence_length",
            "location": 64,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListField.as_tensor": {
            "name": "as_tensor",
            "location": 68,
            "return": [
                "DataArray"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "ListField.empty_field": {
            "name": "empty_field",
            "location": 85,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ListField.batch_tensors": {
            "name": "batch_tensors",
            "location": 96,
            "return": [
                "DataArray"
            ],
            "arguments": {
                "self": [],
                "tensor_list": [
                    "List[DataArray]"
                ]
            }
        },
        "ListField.__str__": {
            "name": "__str__",
            "location": 100,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/metadata_field.py": {
        "MetadataField.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metadata": [
                    "Any"
                ]
            }
        },
        "MetadataField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 31,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetadataField.as_tensor": {
            "name": "as_tensor",
            "location": 35,
            "return": [
                "DataArray"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "MetadataField.empty_field": {
            "name": "empty_field",
            "location": 43,
            "return": [
                "'MetadataField'"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetadataField.batch_tensors": {
            "name": "batch_tensors",
            "location": 48,
            "return": [
                "DataArray"
            ],
            "arguments": {
                "cls": [],
                "tensor_list": [
                    "List[DataArray]"
                ]
            }
        },
        "MetadataField.__str__": {
            "name": "__str__",
            "location": 52,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/multilabel_field.py": {
        "MultiLabelField.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "Sequence[Union[(str, int)]]"
                ],
                "label_namespace": [
                    "str"
                ],
                "skip_indexing": [
                    "bool"
                ],
                "num_labels": [
                    "Optional[int]"
                ]
            }
        },
        "MultiLabelField._maybe_warn_for_namespace": {
            "name": "_maybe_warn_for_namespace",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label_namespace": [
                    "str"
                ]
            }
        },
        "MultiLabelField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 92,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "MultiLabelField.index": {
            "name": "index",
            "location": 98,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "MultiLabelField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 106,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiLabelField.as_tensor": {
            "name": "as_tensor",
            "location": 110,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "MultiLabelField.empty_field": {
            "name": "empty_field",
            "location": 124,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiLabelField.__str__": {
            "name": "__str__",
            "location": 127,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/sequence_field.py": {
        "SequenceField.sequence_length": {
            "name": "sequence_length",
            "location": 11,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/sequence_label_field.py": {
        "SequenceLabelField.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "Union[(List[str], List[int])]"
                ],
                "sequence_field": [
                    "SequenceField"
                ],
                "label_namespace": [
                    "str"
                ]
            }
        },
        "SequenceLabelField._maybe_warn_for_namespace": {
            "name": "_maybe_warn_for_namespace",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label_namespace": [
                    "str"
                ]
            }
        },
        "SequenceLabelField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 80,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "SequenceLabelField.index": {
            "name": "index",
            "location": 86,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "SequenceLabelField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 92,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabelField.as_tensor": {
            "name": "as_tensor",
            "location": 96,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "SequenceLabelField.empty_field": {
            "name": "empty_field",
            "location": 106,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabelField.__str__": {
            "name": "__str__",
            "location": 112,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/span_field.py": {
        "SpanField.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "span_start": [
                    "int"
                ],
                "span_end": [
                    "int"
                ],
                "sequence_field": [
                    "SequenceField"
                ]
            }
        },
        "SpanField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 46,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanField.as_tensor": {
            "name": "as_tensor",
            "location": 51,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "SpanField.empty_field": {
            "name": "empty_field",
            "location": 60,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanField.__str__": {
            "name": "__str__",
            "location": 63,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/text_field.py": {
        "TextField.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[Token]"
                ],
                "token_indexers": [
                    "Dict[(str, TokenIndexer)]"
                ]
            }
        },
        "TextField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "TextField.index": {
            "name": "index",
            "location": 54,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "TextField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 62,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextField.sequence_length": {
            "name": "sequence_length",
            "location": 100,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextField.as_tensor": {
            "name": "as_tensor",
            "location": 104,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "TextField.empty_field": {
            "name": "empty_field",
            "location": 125,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TextField.batch_tensors": {
            "name": "batch_tensors",
            "location": 134,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "tensor_list": [
                    "List[Dict[(str, torch.Tensor)]]"
                ]
            }
        },
        "TextField.__str__": {
            "name": "__str__",
            "location": 140,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/iterators/adaptive_iterator.py": {
        "AdaptiveIterator.__init__": {
            "name": "__init__",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "adaptive_memory_usage_constant": [
                    "float"
                ],
                "padding_memory_scaling": [
                    "Callable[([Dict[(str, Dict[(str, int)])]], float)]"
                ],
                "maximum_batch_size": [
                    "int"
                ],
                "biggest_batch_first": [
                    "bool"
                ],
                "batch_size": [
                    "int"
                ],
                "sorting_keys": [
                    "List[Tuple[(str, str)]]"
                ],
                "padding_noise": [
                    "float"
                ],
                "instances_per_epoch": [
                    "int"
                ],
                "max_instances_in_memory": [
                    "int"
                ]
            }
        },
        "AdaptiveIterator.get_num_batches": {
            "name": "get_num_batches",
            "location": 105,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ]
            }
        },
        "AdaptiveIterator._create_batches": {
            "name": "_create_batches",
            "location": 114,
            "return": [
                "Iterable[Batch]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "AdaptiveIterator._adaptive_grouping": {
            "name": "_adaptive_grouping",
            "location": 132,
            "return": [
                "List[List[Instance]]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "List[Instance]"
                ]
            }
        },
        "AdaptiveIterator.from_params": {
            "name": "from_params",
            "location": 155,
            "return": [
                "'AdaptiveIterator'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/basic_iterator.py": {
        "BasicIterator.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int"
                ],
                "instances_per_epoch": [
                    "int"
                ],
                "max_instances_in_memory": [
                    "int"
                ]
            }
        },
        "BasicIterator.get_num_batches": {
            "name": "get_num_batches",
            "location": 46,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ]
            }
        },
        "BasicIterator._take_instances": {
            "name": "_take_instances",
            "location": 56,
            "return": [
                "Iterator[Instance]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "max_instances": [
                    "Optional[int]"
                ]
            }
        },
        "BasicIterator._memory_sized_lists": {
            "name": "_memory_sized_lists",
            "location": 87,
            "return": [
                "Iterable[List[Instance]]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ]
            }
        },
        "BasicIterator._create_batches": {
            "name": "_create_batches",
            "location": 124,
            "return": [
                "Iterable[Batch]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "BasicIterator.from_params": {
            "name": "from_params",
            "location": 135,
            "return": [
                "'BasicIterator'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/bucket_iterator.py": {
        "BucketIterator.__init__": {
            "name": "__init__",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sorting_keys": [
                    "List[Tuple[(str, str)]]"
                ],
                "padding_noise": [
                    "float"
                ],
                "biggest_batch_first": [
                    "bool"
                ],
                "batch_size": [
                    "int"
                ],
                "instances_per_epoch": [
                    "int"
                ],
                "max_instances_in_memory": [
                    "int"
                ]
            }
        },
        "BucketIterator._create_batches": {
            "name": "_create_batches",
            "location": 77,
            "return": [
                "Iterable[Batch]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "BucketIterator._sort_by_padding": {
            "name": "_sort_by_padding",
            "location": 100,
            "return": [
                "List[Instance]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "List[Instance]"
                ],
                "sorting_keys": [
                    "List[Tuple[(str, str)]]"
                ],
                "padding_noise": [
                    "float"
                ]
            }
        },
        "BucketIterator.from_params": {
            "name": "from_params",
            "location": 127,
            "return": [
                "'BucketIterator'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/data_iterator.py": {
        "DataIterator.__call__": {
            "name": "__call__",
            "location": 22,
            "return": [
                "Generator[(Dict[(str, Union[(numpy.ndarray, Dict[(str, numpy.ndarray)])])], None, None)]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "num_epochs": [
                    "int"
                ],
                "shuffle": [
                    "bool"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "DataIterator.get_num_batches": {
            "name": "get_num_batches",
            "location": 61,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ]
            }
        },
        "DataIterator._yield_one_epoch": {
            "name": "_yield_one_epoch",
            "location": 69,
            "return": [],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "shuffle": [
                    "bool"
                ],
                "cuda_device": [
                    "int"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "DataIterator._create_batches": {
            "name": "_create_batches",
            "location": 81,
            "return": [
                "Iterable[Batch]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Iterable[Instance]"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "DataIterator.from_params": {
            "name": "from_params",
            "location": 88,
            "return": [
                "'DataIterator'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "DataIterator.index_with": {
            "name": "index_with",
            "location": 95,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/tokenizers/character_tokenizer.py": {
        "CharacterTokenizer.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "byte_encoding": [
                    "str"
                ],
                "lowercase_characters": [
                    "bool"
                ],
                "start_tokens": [
                    "List[str]"
                ],
                "end_tokens": [
                    "List[str]"
                ]
            }
        },
        "CharacterTokenizer.batch_tokenize": {
            "name": "batch_tokenize",
            "location": 50,
            "return": [
                "List[List[Token]]"
            ],
            "arguments": {
                "self": [],
                "texts": [
                    "List[str]"
                ]
            }
        },
        "CharacterTokenizer.tokenize": {
            "name": "tokenize",
            "location": 54,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "CharacterTokenizer.from_params": {
            "name": "from_params",
            "location": 78,
            "return": [
                "'CharacterTokenizer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/token.py": {
        "Token.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "idx": [
                    "int"
                ],
                "pos": [
                    "str"
                ],
                "tag": [
                    "str"
                ],
                "dep": [
                    "str"
                ],
                "ent_type": [
                    "str"
                ],
                "text_id": [
                    "int"
                ]
            }
        },
        "Token.__str__": {
            "name": "__str__",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Token.__repr__": {
            "name": "__repr__",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/tokenizer.py": {
        "Tokenizer.batch_tokenize": {
            "name": "batch_tokenize",
            "location": 26,
            "return": [
                "List[List[Token]]"
            ],
            "arguments": {
                "self": [],
                "texts": [
                    "List[str]"
                ]
            }
        },
        "Tokenizer.tokenize": {
            "name": "tokenize",
            "location": 33,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "Tokenizer.from_params": {
            "name": "from_params",
            "location": 44,
            "return": [
                "'Tokenizer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_filter.py": {
        "WordFilter.filter_words": {
            "name": "filter_words",
            "location": 19,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[Token]"
                ]
            }
        },
        "WordFilter.from_params": {
            "name": "from_params",
            "location": 26,
            "return": [
                "'WordFilter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "PassThroughWordFilter.filter_words": {
            "name": "filter_words",
            "location": 38,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[Token]"
                ]
            }
        },
        "StopwordFilter.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "StopwordFilter.filter_words": {
            "name": "filter_words",
            "location": 75,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[Token]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_splitter.py": {
        "WordSplitter.batch_split_words": {
            "name": "batch_split_words",
            "location": 20,
            "return": [
                "List[List[Token]]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[str]"
                ]
            }
        },
        "WordSplitter.split_words": {
            "name": "split_words",
            "location": 29,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "WordSplitter.from_params": {
            "name": "from_params",
            "location": 36,
            "return": [
                "'WordSplitter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "SimpleWordSplitter.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleWordSplitter.split_words": {
            "name": "split_words",
            "location": 58,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "SimpleWordSplitter._can_split": {
            "name": "_can_split",
            "location": 99,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ]
            }
        },
        "SimpleWordSplitter.from_params": {
            "name": "from_params",
            "location": 103,
            "return": [
                "'WordSplitter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "LettersDigitsWordSplitter.split_words": {
            "name": "split_words",
            "location": 115,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "LettersDigitsWordSplitter.from_params": {
            "name": "from_params",
            "location": 122,
            "return": [
                "'WordSplitter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "JustSpacesWordSplitter.split_words": {
            "name": "split_words",
            "location": 139,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "JustSpacesWordSplitter.from_params": {
            "name": "from_params",
            "location": 143,
            "return": [
                "'WordSplitter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "NltkWordSplitter.split_words": {
            "name": "split_words",
            "location": 158,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "NltkWordSplitter.from_params": {
            "name": "from_params",
            "location": 164,
            "return": [
                "'WordSplitter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "SpacyWordSplitter.__init__": {
            "name": "__init__",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "language": [
                    "str"
                ],
                "pos_tags": [
                    "bool"
                ],
                "parse": [
                    "bool"
                ],
                "ner": [
                    "bool"
                ]
            }
        },
        "SpacyWordSplitter.batch_split_words": {
            "name": "batch_split_words",
            "location": 183,
            "return": [
                "List[List[Token]]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[str]"
                ]
            }
        },
        "SpacyWordSplitter.split_words": {
            "name": "split_words",
            "location": 187,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "SpacyWordSplitter.from_params": {
            "name": "from_params",
            "location": 192,
            "return": [
                "'WordSplitter'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_stemmer.py": {
        "WordStemmer.stem_word": {
            "name": "stem_word",
            "location": 20,
            "return": [
                "Token"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "Token"
                ]
            }
        },
        "WordStemmer.from_params": {
            "name": "from_params",
            "location": 27,
            "return": [
                "'WordStemmer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "PassThroughWordStemmer.stem_word": {
            "name": "stem_word",
            "location": 39,
            "return": [
                "Token"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "Token"
                ]
            }
        },
        "PorterStemmer.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PorterStemmer.stem_word": {
            "name": "stem_word",
            "location": 52,
            "return": [
                "Token"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "Token"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_tokenizer.py": {
        "WordTokenizer.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "word_splitter": [
                    "WordSplitter"
                ],
                "word_filter": [
                    "WordFilter"
                ],
                "word_stemmer": [
                    "WordStemmer"
                ],
                "start_tokens": [
                    "List[str]"
                ],
                "end_tokens": [
                    "List[str]"
                ]
            }
        },
        "WordTokenizer.tokenize": {
            "name": "tokenize",
            "location": 68,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "WordTokenizer.batch_tokenize": {
            "name": "batch_tokenize",
            "location": 79,
            "return": [
                "List[List[Token]]"
            ],
            "arguments": {
                "self": [],
                "texts": [
                    "List[str]"
                ]
            }
        },
        "WordTokenizer._filter_and_stem": {
            "name": "_filter_and_stem",
            "location": 83,
            "return": [
                "List[Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[Token]"
                ]
            }
        },
        "WordTokenizer.from_params": {
            "name": "from_params",
            "location": 93,
            "return": [
                "'WordTokenizer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/token_indexers/dep_label_indexer.py": {
        "DepLabelIndexer.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ]
            }
        },
        "DepLabelIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 32,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "DepLabelIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 42,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "DepLabelIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 47,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "DepLabelIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 51,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int"
                ]
            }
        },
        "DepLabelIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 55,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "DepLabelIndexer.from_params": {
            "name": "from_params",
            "location": 62,
            "return": [
                "'DepLabelIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/elmo_indexer.py": {
        "_make_bos_eos": {
            "name": "_make_bos_eos",
            "location": 13,
            "return": [],
            "arguments": {
                "character": [
                    "int"
                ],
                "padding_character": [
                    "int"
                ],
                "beginning_of_word_character": [
                    "int"
                ],
                "end_of_word_character": [
                    "int"
                ],
                "max_word_length": [
                    "int"
                ]
            }
        },
        "ELMoCharacterMapper.convert_word_to_char_ids": {
            "name": "convert_word_to_char_ids",
            "location": 61,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "word": [
                    "str"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.__init__": {
            "name": "__init__",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 93,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 97,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 105,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "List[int]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 110,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ELMoTokenCharactersIndexer._default_value_for_padding": {
            "name": "_default_value_for_padding",
            "location": 114,
            "return": [],
            "arguments": {}
        },
        "ELMoTokenCharactersIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 118,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[List[int]]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.from_params": {
            "name": "from_params",
            "location": 127,
            "return": [
                "'ELMoTokenCharactersIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/ner_tag_indexer.py": {
        "NerTagIndexer.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ]
            }
        },
        "NerTagIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 31,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "NerTagIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 38,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "NerTagIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 45,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "NerTagIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 49,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int"
                ]
            }
        },
        "NerTagIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 53,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "NerTagIndexer.from_params": {
            "name": "from_params",
            "location": 60,
            "return": [
                "'NerTagIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/pos_tag_indexer.py": {
        "PosTagIndexer.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ],
                "coarse_tags": [
                    "bool"
                ]
            }
        },
        "PosTagIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 36,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "PosTagIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 49,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "PosTagIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 59,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PosTagIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 63,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int"
                ]
            }
        },
        "PosTagIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 67,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "PosTagIndexer.from_params": {
            "name": "from_params",
            "location": 74,
            "return": [
                "'PosTagIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/single_id_token_indexer.py": {
        "SingleIdTokenIndexer.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ],
                "lowercase_tokens": [
                    "bool"
                ]
            }
        },
        "SingleIdTokenIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 31,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "SingleIdTokenIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 41,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "SingleIdTokenIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 54,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SingleIdTokenIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 58,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int"
                ]
            }
        },
        "SingleIdTokenIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 62,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "SingleIdTokenIndexer.from_params": {
            "name": "from_params",
            "location": 69,
            "return": [
                "'SingleIdTokenIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/token_characters_indexer.py": {
        "TokenCharactersIndexer.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "str"
                ],
                "character_tokenizer": [
                    "CharacterTokenizer"
                ]
            }
        },
        "TokenCharactersIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 39,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "TokenCharactersIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 49,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "TokenCharactersIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 64,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "List[int]"
                ]
            }
        },
        "TokenCharactersIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 68,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenCharactersIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 72,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[List[int]]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "TokenCharactersIndexer.from_params": {
            "name": "from_params",
            "location": 96,
            "return": [
                "'TokenCharactersIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/token_indexer.py": {
        "TokenIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 22,
            "return": [],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "counter": [
                    "Dict[(str, Dict[(str, int)])]"
                ]
            }
        },
        "TokenIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 33,
            "return": [
                "TokenType"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Token"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "TokenIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 41,
            "return": [
                "TokenType"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 48,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "TokenType"
                ]
            }
        },
        "TokenIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 57,
            "return": [
                "List[TokenType]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[TokenType]"
                ],
                "desired_num_tokens": [
                    "int"
                ],
                "padding_lengths": [
                    "Dict[(str, int)]"
                ]
            }
        },
        "TokenIndexer.from_params": {
            "name": "from_params",
            "location": 73,
            "return": [
                "'TokenIndexer'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "TokenIndexer.dict_from_params": {
            "name": "dict_from_params",
            "location": 78,
            "return": [
                "'Dict[str, TokenIndexer]'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/__init__.py": {},
    "allennlp-dureader-master/allennlp/dureader/dataloader.py": {
        "BRCDataLoader.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [],
            "arguments": {
                "self": [],
                "dataset": [],
                "batch_size": [],
                "shuffle": [],
                "sampler": [],
                "batch_sampler": [],
                "num_workers": [],
                "pin_memory": [],
                "drop_last": []
            }
        },
        "BRCDataLoader._collate_fn": {
            "name": "_collate_fn",
            "location": 21,
            "return": [],
            "arguments": {
                "self": [],
                "batch": []
            }
        },
        "BRCDataLoader._pad_sequence": {
            "name": "_pad_sequence",
            "location": 71,
            "return": [],
            "arguments": {
                "self": [],
                "sequences": [],
                "pad_length": [],
                "pad_value": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/dureader/dataset.py": {
        "display": {
            "name": "display",
            "location": 34,
            "return": [],
            "arguments": {
                "message": []
            }
        },
        "BRCDataset.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [],
            "arguments": {
                "self": [],
                "max_p_num": [],
                "max_p_len": [],
                "max_q_len": [],
                "is_train": [],
                "files": [],
                "rank": [],
                "world_size": [],
                "keep_raw": []
            }
        },
        "BRCDataset._load_dataset": {
            "name": "_load_dataset",
            "location": 59,
            "return": [],
            "arguments": {
                "self": [],
                "data_path": [],
                "train": []
            }
        },
        "BRCDataset.__len__": {
            "name": "__len__",
            "location": 142,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BRCDataset.__getitem__": {
            "name": "__getitem__",
            "location": 145,
            "return": [],
            "arguments": {
                "self": [],
                "idx": []
            }
        },
        "BRCDataset._one_mini_batch": {
            "name": "_one_mini_batch",
            "location": 185,
            "return": [],
            "arguments": {
                "self": [],
                "data": [],
                "indices": [],
                "pad_id": []
            }
        },
        "BRCDataset._dynamic_padding": {
            "name": "_dynamic_padding",
            "location": 230,
            "return": [],
            "arguments": {
                "self": [],
                "batch_data": [],
                "pad_id": []
            }
        },
        "BRCDataset.word_iter": {
            "name": "word_iter",
            "location": 242,
            "return": [],
            "arguments": {
                "self": [],
                "set_name": []
            }
        },
        "BRCDataset.convert_to_ids": {
            "name": "convert_to_ids",
            "location": 269,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/dureader/vocab.py": {
        "Vocab.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [],
            "arguments": {
                "self": [],
                "filename": [],
                "initial_tokens": [],
                "lower": []
            }
        },
        "Vocab.size": {
            "name": "size",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Vocab.load_from_file": {
            "name": "load_from_file",
            "location": 59,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "Vocab.get_id": {
            "name": "get_id",
            "location": 69,
            "return": [],
            "arguments": {
                "self": [],
                "token": []
            }
        },
        "Vocab.get_token": {
            "name": "get_token",
            "location": 83,
            "return": [],
            "arguments": {
                "self": [],
                "idx": []
            }
        },
        "Vocab.add": {
            "name": "add",
            "location": 96,
            "return": [],
            "arguments": {
                "self": [],
                "token": [],
                "cnt": []
            }
        },
        "Vocab.filter_tokens_by_cnt": {
            "name": "filter_tokens_by_cnt",
            "location": 117,
            "return": [],
            "arguments": {
                "self": [],
                "min_cnt": []
            }
        },
        "Vocab.randomly_init_embeddings": {
            "name": "randomly_init_embeddings",
            "location": 132,
            "return": [],
            "arguments": {
                "self": [],
                "embed_dim": []
            }
        },
        "Vocab.load_pretrained_embeddings": {
            "name": "load_pretrained_embeddings",
            "location": 143,
            "return": [],
            "arguments": {
                "self": [],
                "embedding_path": []
            }
        },
        "Vocab.convert_to_ids": {
            "name": "convert_to_ids",
            "location": 174,
            "return": [],
            "arguments": {
                "self": [],
                "tokens": []
            }
        },
        "Vocab.recover_from_ids": {
            "name": "recover_from_ids",
            "location": 185,
            "return": [],
            "arguments": {
                "self": [],
                "ids": [],
                "stop_id": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/archival.py": {
        "archive_model": {
            "name": "archive_model",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "serialization_dir": [
                    "str"
                ],
                "weights": [
                    "str"
                ],
                "files_to_archive": [
                    "Dict[(str, str)]"
                ]
            }
        },
        "load_archive": {
            "name": "load_archive",
            "location": 86,
            "return": [
                "Archive"
            ],
            "arguments": {
                "archive_file": [
                    "str"
                ],
                "cuda_device": [
                    "int"
                ],
                "overrides": [
                    "str"
                ],
                "weights_file": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/biattentive_classification_network.py": {
        "BiattentiveClassificationNetwork.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "embedding_dropout": [
                    "float"
                ],
                "pre_encode_feedforward": [
                    "FeedForward"
                ],
                "encoder": [
                    "Seq2SeqEncoder"
                ],
                "integrator": [
                    "Seq2SeqEncoder"
                ],
                "integrator_dropout": [
                    "float"
                ],
                "output_layer": [
                    "Union[(FeedForward, Maxout)]"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "BiattentiveClassificationNetwork.forward": {
            "name": "forward",
            "location": 119,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "label": [
                    "torch.LongTensor"
                ]
            }
        },
        "BiattentiveClassificationNetwork.decode": {
            "name": "decode",
            "location": 190,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "BiattentiveClassificationNetwork.get_metrics": {
            "name": "get_metrics",
            "location": 203,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "BiattentiveClassificationNetwork.from_params": {
            "name": "from_params",
            "location": 207,
            "return": [
                "'BiattentiveClassificationNetwork'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/constituency_parser.py": {
        "SpanConstituencyParser.__init__": {
            "name": "__init__",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "span_extractor": [
                    "SpanExtractor"
                ],
                "encoder": [
                    "Seq2SeqEncoder"
                ],
                "feedforward_layer": [
                    "FeedForward"
                ],
                "pos_tag_embedding": [
                    "Embedding"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ],
                "evalb_directory_path": [
                    "str"
                ]
            }
        },
        "SpanConstituencyParser.forward": {
            "name": "forward",
            "location": 125,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "spans": [
                    "torch.LongTensor"
                ],
                "metadata": [
                    "List[Dict[(str, Any)]]"
                ],
                "pos_tags": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "span_labels": [
                    "torch.LongTensor"
                ]
            }
        },
        "SpanConstituencyParser.decode": {
            "name": "decode",
            "location": 236,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "SpanConstituencyParser.construct_trees": {
            "name": "construct_trees",
            "location": 261,
            "return": [
                "List[Tree]"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.FloatTensor"
                ],
                "all_spans": [
                    "torch.LongTensor"
                ],
                "num_spans": [
                    "torch.LongTensor"
                ],
                "sentences": [
                    "List[List[str]]"
                ],
                "pos_tags": [
                    "List[List[str]]"
                ]
            }
        },
        "SpanConstituencyParser.resolve_overlap_conflicts_greedily": {
            "name": "resolve_overlap_conflicts_greedily",
            "location": 333,
            "return": [
                "List[SpanInformation]"
            ],
            "arguments": {
                "spans": [
                    "List[SpanInformation]"
                ]
            }
        },
        "SpanConstituencyParser.construct_tree_from_spans": {
            "name": "construct_tree_from_spans",
            "location": 387,
            "return": [
                "Tree"
            ],
            "arguments": {
                "spans_to_labels": [
                    "Dict[(Tuple[(int, int)], str)]"
                ],
                "sentence": [
                    "List[str]"
                ],
                "pos_tags": [
                    "List[str]"
                ]
            }
        },
        "SpanConstituencyParser.get_metrics": {
            "name": "get_metrics",
            "location": 452,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "SpanConstituencyParser.from_params": {
            "name": "from_params",
            "location": 461,
            "return": [
                "'SpanConstituencyParser'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        },
        "SpanConstituencyParser.construct_tree_from_spans.assemble_subtree": {
            "name": "assemble_subtree",
            "location": 405,
            "return": [],
            "arguments": {
                "start": [
                    "int"
                ],
                "end": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/crf_tagger.py": {
        "CrfTagger.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "encoder": [
                    "Seq2SeqEncoder"
                ],
                "label_namespace": [
                    "str"
                ],
                "constraint_type": [
                    "str"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "CrfTagger.forward": {
            "name": "forward",
            "location": 76,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "tags": [
                    "torch.LongTensor"
                ]
            }
        },
        "CrfTagger.decode": {
            "name": "decode",
            "location": 135,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "CrfTagger.get_metrics": {
            "name": "get_metrics",
            "location": 150,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "CrfTagger.from_params": {
            "name": "from_params",
            "location": 155,
            "return": [
                "'CrfTagger'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/decomposable_attention.py": {
        "DecomposableAttention.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "attend_feedforward": [
                    "FeedForward"
                ],
                "similarity_function": [
                    "SimilarityFunction"
                ],
                "compare_feedforward": [
                    "FeedForward"
                ],
                "aggregate_feedforward": [
                    "FeedForward"
                ],
                "premise_encoder": [
                    "Optional[Seq2SeqEncoder]"
                ],
                "hypothesis_encoder": [
                    "Optional[Seq2SeqEncoder]"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "DecomposableAttention.forward": {
            "name": "forward",
            "location": 95,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "premise": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "hypothesis": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "label": [
                    "torch.IntTensor"
                ]
            }
        },
        "DecomposableAttention.get_metrics": {
            "name": "get_metrics",
            "location": 174,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "DecomposableAttention.from_params": {
            "name": "from_params",
            "location": 180,
            "return": [
                "'DecomposableAttention'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/ensemble.py": {
        "Ensemble.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "submodels": [
                    "List[Model]"
                ]
            }
        },
        "Ensemble._load": {
            "name": "_load",
            "location": 34,
            "return": [
                "'Model'"
            ],
            "arguments": {
                "cls": [],
                "config": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ],
                "weights_file": [
                    "str"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/model.py": {
        "remove_pretrained_embedding_params": {
            "name": "remove_pretrained_embedding_params",
            "location": 277,
            "return": [],
            "arguments": {
                "params": [
                    "Params"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "regularizer": [
                    "RegularizerApplicator"
                ]
            }
        },
        "Model.get_regularization_penalty": {
            "name": "get_regularization_penalty",
            "location": 54,
            "return": [
                "Union[(float, torch.autograd.Variable)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.get_parameters_for_histogram_tensorboard_logging": {
            "name": "get_parameters_for_histogram_tensorboard_logging",
            "location": 64,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.forward": {
            "name": "forward",
            "location": 71,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.forward_on_instance": {
            "name": "forward_on_instance",
            "location": 112,
            "return": [
                "Dict[(str, numpy.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "instance": [
                    "Instance"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "Model.forward_on_instances": {
            "name": "forward_on_instances",
            "location": 122,
            "return": [
                "List[Dict[(str, numpy.ndarray)]]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "List[Instance]"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "Model.decode": {
            "name": "decode",
            "location": 160,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "Model.get_metrics": {
            "name": "get_metrics",
            "location": 177,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "Model.from_params": {
            "name": "from_params",
            "location": 193,
            "return": [
                "'Model'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        },
        "Model._load": {
            "name": "_load",
            "location": 199,
            "return": [
                "'Model'"
            ],
            "arguments": {
                "cls": [],
                "config": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ],
                "weights_file": [
                    "str"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "Model.load": {
            "name": "load",
            "location": 235,
            "return": [
                "'Model'"
            ],
            "arguments": {
                "cls": [],
                "config": [
                    "Params"
                ],
                "serialization_dir": [
                    "str"
                ],
                "weights_file": [
                    "str"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/semantic_role_labeler.py": {
        "write_to_conll_eval_file": {
            "name": "write_to_conll_eval_file",
            "location": 224,
            "return": [],
            "arguments": {
                "prediction_file": [
                    "TextIO"
                ],
                "gold_file": [
                    "TextIO"
                ],
                "verb_index": [
                    "Optional[int]"
                ],
                "sentence": [
                    "List[str]"
                ],
                "prediction": [
                    "List[str]"
                ],
                "gold_labels": [
                    "List[str]"
                ]
            }
        },
        "convert_bio_tags_to_conll_format": {
            "name": "convert_bio_tags_to_conll_format",
            "location": 269,
            "return": [],
            "arguments": {
                "labels": [
                    "List[str]"
                ]
            }
        },
        "SemanticRoleLabeler.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "encoder": [
                    "Seq2SeqEncoder"
                ],
                "binary_feature_dim": [
                    "int"
                ],
                "embedding_dropout": [
                    "float"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ],
                "label_smoothing": [
                    "float"
                ]
            }
        },
        "SemanticRoleLabeler.forward": {
            "name": "forward",
            "location": 82,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "verb_indicator": [
                    "torch.LongTensor"
                ],
                "tags": [
                    "torch.LongTensor"
                ]
            }
        },
        "SemanticRoleLabeler.decode": {
            "name": "decode",
            "location": 151,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "SemanticRoleLabeler.get_metrics": {
            "name": "get_metrics",
            "location": 174,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "SemanticRoleLabeler.get_viterbi_pairwise_potentials": {
            "name": "get_viterbi_pairwise_potentials",
            "location": 180,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabeler.from_params": {
            "name": "from_params",
            "location": 206,
            "return": [
                "'SemanticRoleLabeler'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/simple_tagger.py": {
        "SimpleTagger.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "encoder": [
                    "Seq2SeqEncoder"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "SimpleTagger.forward": {
            "name": "forward",
            "location": 63,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "tags": [
                    "torch.LongTensor"
                ]
            }
        },
        "SimpleTagger.decode": {
            "name": "decode",
            "location": 118,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "SimpleTagger.get_metrics": {
            "name": "get_metrics",
            "location": 139,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "SimpleTagger.from_params": {
            "name": "from_params",
            "location": 143,
            "return": [
                "'SimpleTagger'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/__init__.py": {},
    "allennlp-dureader-master/allennlp/models/coreference_resolution/coref.py": {
        "CoreferenceResolver.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "context_layer": [
                    "Seq2SeqEncoder"
                ],
                "mention_feedforward": [
                    "FeedForward"
                ],
                "antecedent_feedforward": [
                    "FeedForward"
                ],
                "feature_size": [
                    "int"
                ],
                "max_span_width": [
                    "int"
                ],
                "spans_per_word": [
                    "float"
                ],
                "max_antecedents": [
                    "int"
                ],
                "lexical_dropout": [
                    "float"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "CoreferenceResolver.forward": {
            "name": "forward",
            "location": 113,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "spans": [
                    "torch.IntTensor"
                ],
                "span_labels": [
                    "torch.IntTensor"
                ],
                "metadata": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "CoreferenceResolver.decode": {
            "name": "decode",
            "location": 292,
            "return": [],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "CoreferenceResolver.get_metrics": {
            "name": "get_metrics",
            "location": 370,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "CoreferenceResolver._generate_valid_antecedents": {
            "name": "_generate_valid_antecedents",
            "location": 380,
            "return": [
                "Tuple[(torch.IntTensor, torch.IntTensor, torch.FloatTensor)]"
            ],
            "arguments": {
                "num_spans_to_keep": [
                    "int"
                ],
                "max_antecedents": [
                    "int"
                ],
                "device": [
                    "int"
                ]
            }
        },
        "CoreferenceResolver._compute_span_pair_embeddings": {
            "name": "_compute_span_pair_embeddings",
            "location": 442,
            "return": [],
            "arguments": {
                "self": [],
                "top_span_embeddings": [
                    "torch.FloatTensor"
                ],
                "antecedent_embeddings": [
                    "torch.FloatTensor"
                ],
                "antecedent_offsets": [
                    "torch.FloatTensor"
                ]
            }
        },
        "CoreferenceResolver._compute_antecedent_gold_labels": {
            "name": "_compute_antecedent_gold_labels",
            "location": 497,
            "return": [],
            "arguments": {
                "top_span_labels": [
                    "torch.IntTensor"
                ],
                "antecedent_labels": [
                    "torch.IntTensor"
                ]
            }
        },
        "CoreferenceResolver._compute_coreference_scores": {
            "name": "_compute_coreference_scores",
            "location": 536,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "pairwise_embeddings": [
                    "torch.FloatTensor"
                ],
                "top_span_mention_scores": [
                    "torch.FloatTensor"
                ],
                "antecedent_mention_scores": [
                    "torch.FloatTensor"
                ],
                "antecedent_log_mask": [
                    "torch.FloatTensor"
                ]
            }
        },
        "CoreferenceResolver.from_params": {
            "name": "from_params",
            "location": 586,
            "return": [
                "'CoreferenceResolver'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/coreference_resolution/__init__.py": {},
    "allennlp-dureader-master/allennlp/models/encoder_decoders/simple_seq2seq.py": {
        "SimpleSeq2Seq.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "source_embedder": [
                    "TextFieldEmbedder"
                ],
                "encoder": [
                    "Seq2SeqEncoder"
                ],
                "max_decoding_steps": [
                    "int"
                ],
                "target_namespace": [
                    "str"
                ],
                "target_embedding_dim": [
                    "int"
                ],
                "attention_function": [
                    "SimilarityFunction"
                ],
                "scheduled_sampling_ratio": [
                    "float"
                ]
            }
        },
        "SimpleSeq2Seq.forward": {
            "name": "forward",
            "location": 108,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "target_tokens": [
                    "Dict[(str, torch.LongTensor)]"
                ]
            }
        },
        "SimpleSeq2Seq._prepare_decode_step_input": {
            "name": "_prepare_decode_step_input",
            "location": 185,
            "return": [
                "torch.LongTensor"
            ],
            "arguments": {
                "self": [],
                "input_indices": [
                    "torch.LongTensor"
                ],
                "decoder_hidden_state": [
                    "torch.LongTensor"
                ],
                "encoder_outputs": [
                    "torch.LongTensor"
                ],
                "encoder_outputs_mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "SimpleSeq2Seq._get_loss": {
            "name": "_get_loss",
            "location": 230,
            "return": [
                "torch.LongTensor"
            ],
            "arguments": {
                "logits": [
                    "torch.LongTensor"
                ],
                "targets": [
                    "torch.LongTensor"
                ],
                "target_mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "SimpleSeq2Seq.decode": {
            "name": "decode",
            "location": 262,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "SimpleSeq2Seq.from_params": {
            "name": "from_params",
            "location": 287,
            "return": [
                "'SimpleSeq2Seq'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/encoder_decoders/__init__.py": {},
    "allennlp-dureader-master/allennlp/models/reading_comprehension/bidaf.py": {
        "BidirectionalAttentionFlow.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "num_highway_layers": [
                    "int"
                ],
                "phrase_layer": [
                    "Seq2SeqEncoder"
                ],
                "attention_similarity_function": [
                    "SimilarityFunction"
                ],
                "modeling_layer": [
                    "Seq2SeqEncoder"
                ],
                "span_end_encoder": [
                    "Seq2SeqEncoder"
                ],
                "dropout": [
                    "float"
                ],
                "mask_lstms": [
                    "bool"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "BidirectionalAttentionFlow.forward": {
            "name": "forward",
            "location": 118,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "passage": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "span_start": [
                    "torch.IntTensor"
                ],
                "span_end": [
                    "torch.IntTensor"
                ],
                "metadata": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_metrics": {
            "name": "get_metrics",
            "location": 291,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_best_span": {
            "name": "get_best_span",
            "location": 302,
            "return": [
                "Variable"
            ],
            "arguments": {
                "span_start_logits": [
                    "Variable"
                ],
                "span_end_logits": [
                    "Variable"
                ]
            }
        },
        "BidirectionalAttentionFlow.from_params": {
            "name": "from_params",
            "location": 330,
            "return": [
                "'BidirectionalAttentionFlow'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/reading_comprehension/bidaf_ensemble.py": {
        "ensemble": {
            "name": "ensemble",
            "location": 121,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "subresults": [
                    "List[Dict[(str, torch.Tensor)]]"
                ]
            }
        },
        "BidafEnsemble.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "submodels": [
                    "List[BidirectionalAttentionFlow]"
                ]
            }
        },
        "BidafEnsemble.forward": {
            "name": "forward",
            "location": 29,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "passage": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "span_start": [
                    "torch.IntTensor"
                ],
                "span_end": [
                    "torch.IntTensor"
                ],
                "metadata": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "BidafEnsemble.get_metrics": {
            "name": "get_metrics",
            "location": 102,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "BidafEnsemble.from_params": {
            "name": "from_params",
            "location": 110,
            "return": [],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/reading_comprehension/dureader_bidaf.py": {
        "BidirectionalAttentionFlow.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Vocabulary"
                ],
                "text_field_embedder": [
                    "TextFieldEmbedder"
                ],
                "num_highway_layers": [
                    "int"
                ],
                "phrase_layer": [
                    "Seq2SeqEncoder"
                ],
                "attention_similarity_function": [
                    "SimilarityFunction"
                ],
                "modeling_layer": [
                    "Seq2SeqEncoder"
                ],
                "span_end_encoder": [
                    "Seq2SeqEncoder"
                ],
                "dropout": [
                    "float"
                ],
                "mask_lstms": [
                    "bool"
                ],
                "initializer": [
                    "InitializerApplicator"
                ],
                "regularizer": [
                    "Optional[RegularizerApplicator]"
                ]
            }
        },
        "BidirectionalAttentionFlow.apply_concat_mask_fn": {
            "name": "apply_concat_mask_fn",
            "location": 123,
            "return": [],
            "arguments": {
                "self": [],
                "vector": [],
                "mask": [],
                "batch_size": [],
                "fn": []
            }
        },
        "BidirectionalAttentionFlow.forward": {
            "name": "forward",
            "location": 152,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "passage": [
                    "Dict[(str, torch.LongTensor)]"
                ],
                "span_start": [
                    "torch.IntTensor"
                ],
                "span_end": [
                    "torch.IntTensor"
                ],
                "metadata": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_metrics": {
            "name": "get_metrics",
            "location": 349,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_best_span": {
            "name": "get_best_span",
            "location": 360,
            "return": [],
            "arguments": {
                "span_start_logits": [
                    "Variable"
                ],
                "span_end_logits": [
                    "Variable"
                ]
            }
        },
        "BidirectionalAttentionFlow.from_params": {
            "name": "from_params",
            "location": 388,
            "return": [
                "'BidirectionalAttentionFlow'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/alternating_highway_lstm.py": {
        "_AlternatingHighwayLSTMFunction.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "_AlternatingHighwayLSTMFunction.forward": {
            "name": "forward",
            "location": 22,
            "return": [
                "Tuple[(torch.Tensor, None)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "weight": [
                    "torch.Tensor"
                ],
                "bias": [
                    "torch.Tensor"
                ],
                "state_accumulator": [
                    "torch.Tensor"
                ],
                "memory_accumulator": [
                    "torch.Tensor"
                ],
                "dropout_mask": [
                    "torch.Tensor"
                ],
                "lengths": [
                    "torch.Tensor"
                ],
                "gates": [
                    "torch.Tensor"
                ]
            }
        },
        "_AlternatingHighwayLSTMFunction.backward": {
            "name": "backward",
            "location": 62,
            "return": [],
            "arguments": {
                "self": [],
                "grad_output": [],
                "grad_hy": []
            }
        },
        "AlternatingHighwayLSTM.__init__": {
            "name": "__init__",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ]
            }
        },
        "AlternatingHighwayLSTM.reset_parameters": {
            "name": "reset_parameters",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AlternatingHighwayLSTM.forward": {
            "name": "forward",
            "location": 209,
            "return": [
                "Tuple[(PackedSequence, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ],
                "initial_state": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/attention.py": {
        "Attention.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "similarity_function": [
                    "SimilarityFunction"
                ],
                "normalize": [
                    "bool"
                ]
            }
        },
        "Attention.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "vector": [
                    "torch.Tensor"
                ],
                "matrix": [
                    "torch.Tensor"
                ],
                "matrix_mask": [
                    "torch.Tensor"
                ]
            }
        },
        "Attention.from_params": {
            "name": "from_params",
            "location": 64,
            "return": [
                "'Attention'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/augmented_lstm.py": {
        "AugmentedLstm.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "go_forward": [
                    "bool"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "use_highway": [
                    "bool"
                ],
                "use_input_projection_bias": [
                    "bool"
                ]
            }
        },
        "AugmentedLstm.reset_parameters": {
            "name": "reset_parameters",
            "location": 85,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AugmentedLstm.forward": {
            "name": "forward",
            "location": 95,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ],
                "initial_state": [
                    "Optional[Tuple[(torch.Tensor, torch.Tensor)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/conditional_random_field.py": {
        "allowed_transitions": {
            "name": "allowed_transitions",
            "location": 13,
            "return": [
                "List[Tuple[(int, int)]]"
            ],
            "arguments": {
                "constraint_type": [
                    "str"
                ],
                "tokens": [
                    "Dict[(int, str)]"
                ]
            }
        },
        "ConditionalRandomField.__init__": {
            "name": "__init__",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_tags": [
                    "int"
                ],
                "constraints": [
                    "List[Tuple[(int, int)]]"
                ]
            }
        },
        "ConditionalRandomField.reset_parameters": {
            "name": "reset_parameters",
            "location": 108,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConditionalRandomField._input_likelihood": {
            "name": "_input_likelihood",
            "location": 113,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "ConditionalRandomField._joint_likelihood": {
            "name": "_joint_likelihood",
            "location": 153,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "torch.Tensor"
                ],
                "tags": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "ConditionalRandomField.forward": {
            "name": "forward",
            "location": 218,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "tags": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.ByteTensor"
                ]
            }
        },
        "ConditionalRandomField.viterbi_tags": {
            "name": "viterbi_tags",
            "location": 234,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "Variable"
                ],
                "mask": [
                    "Variable"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/elmo.py": {
        "Elmo.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str"
                ],
                "weight_file": [
                    "str"
                ],
                "num_output_representations": [
                    "int"
                ],
                "requires_grad": [
                    "bool"
                ],
                "do_layer_norm": [
                    "bool"
                ],
                "dropout": [
                    "float"
                ],
                "module": [
                    "torch.nn.Module"
                ]
            }
        },
        "Elmo.forward": {
            "name": "forward",
            "location": 90,
            "return": [
                "Dict[(str, Union[(torch.Tensor, List[torch.Tensor])])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        },
        "Elmo.from_params": {
            "name": "from_params",
            "location": 144,
            "return": [
                "'Elmo'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "_ElmoCharacterEncoder.__init__": {
            "name": "__init__",
            "location": 198,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str"
                ],
                "weight_file": [
                    "str"
                ],
                "requires_grad": [
                    "bool"
                ]
            }
        },
        "_ElmoCharacterEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 221,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder.forward": {
            "name": "forward",
            "location": 225,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        },
        "_ElmoCharacterEncoder._load_weights": {
            "name": "_load_weights",
            "location": 298,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_char_embedding": {
            "name": "_load_char_embedding",
            "location": 304,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_cnn_weights": {
            "name": "_load_cnn_weights",
            "location": 318,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_highway": {
            "name": "_load_highway",
            "location": 350,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_projection": {
            "name": "_load_projection",
            "location": 379,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_ElmoBiLm.__init__": {
            "name": "__init__",
            "location": 412,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str"
                ],
                "weight_file": [
                    "str"
                ],
                "requires_grad": [
                    "bool"
                ]
            }
        },
        "_ElmoBiLm.forward": {
            "name": "forward",
            "location": 435,
            "return": [
                "Dict[(str, Union[(torch.Tensor, List[torch.Tensor])])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/elmo_lstm.py": {
        "ElmoLstm.__init__": {
            "name": "__init__",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "cell_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "requires_grad": [
                    "bool"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "memory_cell_clip_value": [
                    "Optional[float]"
                ],
                "state_projection_clip_value": [
                    "Optional[float]"
                ]
            }
        },
        "ElmoLstm.forward": {
            "name": "forward",
            "location": 103,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "ElmoLstm._lstm_forward": {
            "name": "_lstm_forward",
            "location": 162,
            "return": [
                "Tuple[(torch.Tensor, Tuple[(torch.Tensor, torch.Tensor)])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ],
                "initial_state": [
                    "Optional[Tuple[(torch.Tensor, torch.Tensor)]]"
                ]
            }
        },
        "ElmoLstm.load_weights": {
            "name": "load_weights",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weight_file": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/encoder_base.py": {
        "_EncoderBase.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "stateful": [
                    "bool"
                ]
            }
        },
        "_EncoderBase.sort_and_run_forward": {
            "name": "sort_and_run_forward",
            "location": 33,
            "return": [],
            "arguments": {
                "self": [],
                "module": [
                    "Callable[([PackedSequence, Optional[RnnState]], Tuple[(Union[(PackedSequence, torch.Tensor)], RnnState)])]"
                ],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ],
                "hidden_state": [
                    "Optional[RnnState]"
                ]
            }
        },
        "_EncoderBase._get_initial_states": {
            "name": "_get_initial_states",
            "location": 121,
            "return": [
                "Optional[RnnState]"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int"
                ],
                "num_valid": [
                    "int"
                ],
                "sorting_indices": [
                    "torch.LongTensor"
                ]
            }
        },
        "_EncoderBase._update_states": {
            "name": "_update_states",
            "location": 209,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "final_states": [
                    "RnnStateStorage"
                ],
                "restoration_indices": [
                    "torch.LongTensor"
                ]
            }
        },
        "_EncoderBase.reset_states": {
            "name": "reset_states",
            "location": 289,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/feedforward.py": {
        "FeedForward.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "hidden_dims": [
                    "Union[(int, Sequence[int])]"
                ],
                "activations": [
                    "Union[(Activation, Sequence[Activation])]"
                ],
                "dropout": [
                    "Union[(float, Sequence[float])]"
                ]
            }
        },
        "FeedForward.get_output_dim": {
            "name": "get_output_dim",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FeedForward.get_input_dim": {
            "name": "get_input_dim",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FeedForward.forward": {
            "name": "forward",
            "location": 75,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        },
        "FeedForward.from_params": {
            "name": "from_params",
            "location": 83,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/highway.py": {
        "Highway.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "activation": [
                    "Callable[([torch.Tensor], torch.Tensor)]"
                ]
            }
        },
        "Highway.forward": {
            "name": "forward",
            "location": 49,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/layer_norm.py": {
        "LayerNorm.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dimension": [
                    "int"
                ],
                "eps": [
                    "float"
                ]
            }
        },
        "LayerNorm.forward": {
            "name": "forward",
            "location": 35,
            "return": [],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/lstm_cell_with_projection.py": {
        "LstmCellWithProjection.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "cell_size": [
                    "int"
                ],
                "go_forward": [
                    "bool"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "memory_cell_clip_value": [
                    "Optional[float]"
                ],
                "state_projection_clip_value": [
                    "Optional[float]"
                ]
            }
        },
        "LstmCellWithProjection.reset_parameters": {
            "name": "reset_parameters",
            "location": 84,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LstmCellWithProjection.forward": {
            "name": "forward",
            "location": 94,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.FloatTensor"
                ],
                "batch_lengths": [
                    "List[int]"
                ],
                "initial_state": [
                    "Optional[Tuple[(torch.Tensor, torch.Tensor)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/matrix_attention.py": {
        "MatrixAttention.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "similarity_function": [
                    "SimilarityFunction"
                ]
            }
        },
        "MatrixAttention.forward": {
            "name": "forward",
            "location": 45,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "matrix_1": [
                    "torch.Tensor"
                ],
                "matrix_2": [
                    "torch.Tensor"
                ]
            }
        },
        "MatrixAttention.from_params": {
            "name": "from_params",
            "location": 60,
            "return": [
                "'MatrixAttention'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/maxout.py": {
        "Maxout.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "output_dims": [
                    "Union[(int, Sequence[int])]"
                ],
                "pool_sizes": [
                    "Union[(int, Sequence[int])]"
                ],
                "dropout": [
                    "Union[(float, Sequence[float])]"
                ]
            }
        },
        "Maxout.get_output_dim": {
            "name": "get_output_dim",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Maxout.get_input_dim": {
            "name": "get_input_dim",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Maxout.forward": {
            "name": "forward",
            "location": 75,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        },
        "Maxout.from_params": {
            "name": "from_params",
            "location": 92,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/scalar_mix.py": {
        "ScalarMix.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mixture_size": [
                    "int"
                ],
                "do_layer_norm": [
                    "bool"
                ]
            }
        },
        "ScalarMix.forward": {
            "name": "forward",
            "location": 26,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "List[torch.Tensor]"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "ScalarMix.forward._do_layer_norm": {
            "name": "_do_layer_norm",
            "location": 43,
            "return": [],
            "arguments": {
                "tensor": [],
                "broadcast_mask": [],
                "num_elements_not_masked": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_pruner.py": {
        "SpanPruner.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scorer": [
                    "torch.nn.Module"
                ]
            }
        },
        "SpanPruner.forward": {
            "name": "forward",
            "location": 25,
            "return": [
                "Tuple[(torch.FloatTensor, torch.LongTensor, torch.LongTensor, torch.FloatTensor)]"
            ],
            "arguments": {
                "self": [],
                "span_embeddings": [
                    "torch.FloatTensor"
                ],
                "span_mask": [
                    "torch.LongTensor"
                ],
                "num_spans_to_keep": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/stacked_alternating_lstm.py": {
        "StackedAlternatingLstm.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "use_highway": [
                    "bool"
                ],
                "use_input_projection_bias": [
                    "bool"
                ]
            }
        },
        "StackedAlternatingLstm.forward": {
            "name": "forward",
            "location": 72,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ],
                "initial_state": [
                    "Optional[Tuple[(torch.Tensor, torch.Tensor)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/time_distributed.py": {
        "TimeDistributed.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [],
            "arguments": {
                "self": [],
                "module": []
            }
        },
        "TimeDistributed.forward": {
            "name": "forward",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/intra_sentence_attention.py": {
        "IntraSentenceAttentionEncoder.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "projection_dim": [
                    "int"
                ],
                "similarity_function": [
                    "SimilarityFunction"
                ],
                "num_attention_heads": [
                    "int"
                ],
                "combination": [
                    "str"
                ],
                "output_dim": [
                    "int"
                ]
            }
        },
        "IntraSentenceAttentionEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 86,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntraSentenceAttentionEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 90,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntraSentenceAttentionEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 94,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IntraSentenceAttentionEncoder.forward": {
            "name": "forward",
            "location": 98,
            "return": [],
            "arguments": {
                "self": [],
                "tokens": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "IntraSentenceAttentionEncoder.from_params": {
            "name": "from_params",
            "location": 142,
            "return": [
                "'IntraSentenceAttentionEncoder'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/multi_head_self_attention.py": {
        "MultiHeadSelfAttention.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_heads": [
                    "int"
                ],
                "input_dim": [
                    "int"
                ],
                "attention_dim": [
                    "int"
                ],
                "values_dim": [
                    "int"
                ],
                "output_projection_dim": [
                    "int"
                ],
                "attention_dropout_prob": [
                    "float"
                ]
            }
        },
        "MultiHeadSelfAttention.get_input_dim": {
            "name": "get_input_dim",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttention.get_output_dim": {
            "name": "get_output_dim",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttention.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttention.forward": {
            "name": "forward",
            "location": 83,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "MultiHeadSelfAttention.from_params": {
            "name": "from_params",
            "location": 156,
            "return": [
                "'MultiHeadSelfAttention'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/pass_through_encoder.py": {
        "PassThroughEncoder.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ]
            }
        },
        "PassThroughEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 19,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PassThroughEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 23,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PassThroughEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PassThroughEncoder.forward": {
            "name": "forward",
            "location": 31,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "PassThroughEncoder.from_params": {
            "name": "from_params",
            "location": 39,
            "return": [
                "'PassThroughEncoder'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/pytorch_seq2seq_wrapper.py": {
        "PytorchSeq2SeqWrapper.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "torch.nn.Module"
                ],
                "stateful": [
                    "bool"
                ]
            }
        },
        "PytorchSeq2SeqWrapper.get_input_dim": {
            "name": "get_input_dim",
            "location": 56,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2SeqWrapper.get_output_dim": {
            "name": "get_output_dim",
            "location": 60,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2SeqWrapper.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 64,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2SeqWrapper.forward": {
            "name": "forward",
            "location": 68,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ],
                "hidden_state": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/seq2seq_encoder.py": {
        "Seq2SeqEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2SeqEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 23,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2SeqEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 30,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2SeqEncoder.from_params": {
            "name": "from_params",
            "location": 39,
            "return": [
                "'Seq2SeqEncoder'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/stacked_self_attention.py": {
        "StackedSelfAttentionEncoder.__init__": {
            "name": "__init__",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "hidden_dim": [
                    "int"
                ],
                "projection_dim": [
                    "int"
                ],
                "feedforward_hidden_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "num_attention_heads": [
                    "int"
                ],
                "use_positional_encoding": [
                    "bool"
                ],
                "dropout_prob": [
                    "float"
                ],
                "residual_dropout_prob": [
                    "float"
                ],
                "attention_dropout_prob": [
                    "float"
                ]
            }
        },
        "StackedSelfAttentionEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 116,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "StackedSelfAttentionEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 120,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "StackedSelfAttentionEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 124,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "StackedSelfAttentionEncoder.forward": {
            "name": "forward",
            "location": 128,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "StackedSelfAttentionEncoder.from_params": {
            "name": "from_params",
            "location": 157,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/__init__.py": {
        "_Seq2SeqWrapper.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module_class": [
                    "Type[torch.nn.modules.RNNBase]"
                ]
            }
        },
        "_Seq2SeqWrapper.__call__": {
            "name": "__call__",
            "location": 69,
            "return": [
                "PytorchSeq2SeqWrapper"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Seq2SeqWrapper.from_params": {
            "name": "from_params",
            "location": 72,
            "return": [
                "PytorchSeq2SeqWrapper"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/boe_encoder.py": {
        "BagOfEmbeddingsEncoder.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding_dim": [
                    "int"
                ],
                "averaged": [
                    "bool"
                ]
            }
        },
        "BagOfEmbeddingsEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 33,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BagOfEmbeddingsEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 37,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BagOfEmbeddingsEncoder.forward": {
            "name": "forward",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "tokens": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "BagOfEmbeddingsEncoder.from_params": {
            "name": "from_params",
            "location": 67,
            "return": [
                "'BagOfEmbeddingsEncoder'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/cnn_encoder.py": {
        "CnnEncoder.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding_dim": [
                    "int"
                ],
                "num_filters": [
                    "int"
                ],
                "ngram_filter_sizes": [
                    "Tuple[(int, ...)]"
                ],
                "conv_layer_activation": [
                    "Activation"
                ],
                "output_dim": [
                    "Optional[int]"
                ]
            }
        },
        "CnnEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 79,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "CnnEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 83,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "CnnEncoder.forward": {
            "name": "forward",
            "location": 86,
            "return": [],
            "arguments": {
                "self": [],
                "tokens": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "CnnEncoder.from_params": {
            "name": "from_params",
            "location": 120,
            "return": [
                "'CnnEncoder'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/pytorch_seq2vec_wrapper.py": {
        "PytorchSeq2VecWrapper.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "torch.nn.modules.RNNBase"
                ]
            }
        },
        "PytorchSeq2VecWrapper.get_input_dim": {
            "name": "get_input_dim",
            "location": 49,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2VecWrapper.get_output_dim": {
            "name": "get_output_dim",
            "location": 52,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2VecWrapper.forward": {
            "name": "forward",
            "location": 59,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ],
                "hidden_state": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/seq2vec_encoder.py": {
        "Seq2VecEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2VecEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 23,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2VecEncoder.from_params": {
            "name": "from_params",
            "location": 31,
            "return": [
                "'Seq2VecEncoder'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/__init__.py": {
        "_Seq2VecWrapper.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module_class": [
                    "Type[torch.nn.modules.RNNBase]"
                ]
            }
        },
        "_Seq2VecWrapper.__call__": {
            "name": "__call__",
            "location": 61,
            "return": [
                "PytorchSeq2VecWrapper"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Seq2VecWrapper.from_params": {
            "name": "from_params",
            "location": 64,
            "return": [
                "PytorchSeq2VecWrapper"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/bilinear.py": {
        "BilinearSimilarity.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1_dim": [
                    "int"
                ],
                "tensor_2_dim": [
                    "int"
                ],
                "activation": [
                    "Activation"
                ]
            }
        },
        "BilinearSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BilinearSimilarity.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "BilinearSimilarity.from_params": {
            "name": "from_params",
            "location": 52,
            "return": [
                "'BilinearSimilarity'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/cosine.py": {
        "CosineSimilarity.forward": {
            "name": "forward",
            "location": 15,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "CosineSimilarity.from_params": {
            "name": "from_params",
            "location": 21,
            "return": [
                "'CosineSimilarity'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/dot_product.py": {
        "DotProductSimilarity.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scale_output": [
                    "bool"
                ]
            }
        },
        "DotProductSimilarity.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "DotProductSimilarity.from_params": {
            "name": "from_params",
            "location": 34,
            "return": [
                "'DotProductSimilarity'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/linear.py": {
        "LinearSimilarity.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1_dim": [
                    "int"
                ],
                "tensor_2_dim": [
                    "int"
                ],
                "combination": [
                    "str"
                ],
                "activation": [
                    "Activation"
                ]
            }
        },
        "LinearSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 59,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LinearSimilarity.forward": {
            "name": "forward",
            "location": 65,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "LinearSimilarity.from_params": {
            "name": "from_params",
            "location": 71,
            "return": [
                "'LinearSimilarity'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/multiheaded.py": {
        "MultiHeadedSimilarity.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_heads": [
                    "int"
                ],
                "tensor_1_dim": [
                    "int"
                ],
                "tensor_1_projected_dim": [
                    "int"
                ],
                "tensor_2_dim": [
                    "int"
                ],
                "tensor_2_projected_dim": [
                    "int"
                ],
                "internal_similarity": [
                    "SimilarityFunction"
                ]
            }
        },
        "MultiHeadedSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadedSimilarity.forward": {
            "name": "forward",
            "location": 77,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "MultiHeadedSimilarity.from_params": {
            "name": "from_params",
            "location": 97,
            "return": [
                "'MultiHeadedSimilarity'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/mylinear.py": {
        "MyLinearSimilarity.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1_dim": [
                    "int"
                ],
                "tensor_2_dim": [
                    "int"
                ],
                "combination": [
                    "str"
                ],
                "activation": [
                    "Activation"
                ]
            }
        },
        "MyLinearSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MyLinearSimilarity.forward": {
            "name": "forward",
            "location": 68,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "MyLinearSimilarity.from_params": {
            "name": "from_params",
            "location": 90,
            "return": [
                "'MyLinearSimilarity'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/similarity_function.py": {
        "SimilarityFunction.forward": {
            "name": "forward",
            "location": 23,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "torch.Tensor"
                ],
                "tensor_2": [
                    "torch.Tensor"
                ]
            }
        },
        "SimilarityFunction.from_params": {
            "name": "from_params",
            "location": 33,
            "return": [
                "'SimilarityFunction'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/span_extractors/bidirectional_endpoint_span_extractor.py": {
        "BidirectionalEndpointSpanExtractor.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "forward_combination": [
                    "str"
                ],
                "backward_combination": [
                    "str"
                ],
                "num_width_embeddings": [
                    "int"
                ],
                "span_width_embedding_dim": [
                    "int"
                ],
                "bucket_widths": [
                    "bool"
                ],
                "use_sentinels": [
                    "bool"
                ]
            }
        },
        "BidirectionalEndpointSpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 101,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalEndpointSpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 104,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalEndpointSpanExtractor.forward": {
            "name": "forward",
            "location": 116,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "torch.FloatTensor"
                ],
                "span_indices": [
                    "torch.LongTensor"
                ],
                "sequence_mask": [
                    "torch.LongTensor"
                ],
                "span_indices_mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "BidirectionalEndpointSpanExtractor.from_params": {
            "name": "from_params",
            "location": 223,
            "return": [
                "'BidirectionalEndpointSpanExtractor'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/endpoint_span_extractor.py": {
        "EndpointSpanExtractor.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "combination": [
                    "str"
                ],
                "num_width_embeddings": [
                    "int"
                ],
                "span_width_embedding_dim": [
                    "int"
                ],
                "bucket_widths": [
                    "bool"
                ],
                "use_exclusive_start_indices": [
                    "bool"
                ]
            }
        },
        "EndpointSpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 78,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "EndpointSpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 81,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "EndpointSpanExtractor.forward": {
            "name": "forward",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "torch.FloatTensor"
                ],
                "span_indices": [
                    "torch.LongTensor"
                ],
                "sequence_mask": [
                    "torch.LongTensor"
                ],
                "span_indices_mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "EndpointSpanExtractor.from_params": {
            "name": "from_params",
            "location": 149,
            "return": [
                "'EndpointSpanExtractor'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/self_attentive_span_extractor.py": {
        "SelfAttentiveSpanExtractor.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ]
            }
        },
        "SelfAttentiveSpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 39,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SelfAttentiveSpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 42,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SelfAttentiveSpanExtractor.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "torch.FloatTensor"
                ],
                "span_indices": [
                    "torch.LongTensor"
                ],
                "sequence_mask": [
                    "torch.LongTensor"
                ],
                "span_indices_mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "SelfAttentiveSpanExtractor.from_params": {
            "name": "from_params",
            "location": 114,
            "return": [
                "'SelfAttentiveSpanExtractor'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/span_extractor.py": {
        "SpanExtractor.forward": {
            "name": "forward",
            "location": 20,
            "return": [],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "torch.FloatTensor"
                ],
                "span_indices": [
                    "torch.LongTensor"
                ],
                "sequence_mask": [
                    "torch.LongTensor"
                ],
                "span_indices_mask": [
                    "torch.LongTensor"
                ]
            }
        },
        "SpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 56,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 62,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanExtractor.from_params": {
            "name": "from_params",
            "location": 70,
            "return": [
                "'SpanExtractor'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/text_field_embedders/basic_text_field_embedder.py": {
        "BasicTextFieldEmbedder.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_embedders": [
                    "Dict[(str, TokenEmbedder)]"
                ]
            }
        },
        "BasicTextFieldEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 32,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicTextFieldEmbedder.forward": {
            "name": "forward",
            "location": 38,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "text_field_input": [
                    "Dict[(str, torch.Tensor)]"
                ],
                "num_wrapping_dims": [
                    "int"
                ]
            }
        },
        "BasicTextFieldEmbedder.from_params": {
            "name": "from_params",
            "location": 57,
            "return": [
                "'BasicTextFieldEmbedder'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/text_field_embedders/text_field_embedder.py": {
        "TextFieldEmbedder.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "text_field_input": [
                    "Dict[(str, torch.Tensor)]"
                ],
                "num_wrapping_dims": [
                    "int"
                ]
            }
        },
        "TextFieldEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 45,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextFieldEmbedder.from_params": {
            "name": "from_params",
            "location": 54,
            "return": [
                "'TextFieldEmbedder'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/text_field_embedders/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/token_embedders/elmo_token_embedder.py": {
        "ElmoTokenEmbedder.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str"
                ],
                "weight_file": [
                    "str"
                ],
                "do_layer_norm": [
                    "bool"
                ],
                "dropout": [
                    "float"
                ],
                "requires_grad": [
                    "bool"
                ]
            }
        },
        "ElmoTokenEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ElmoTokenEmbedder.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        },
        "ElmoTokenEmbedder.from_params": {
            "name": "from_params",
            "location": 66,
            "return": [
                "'ElmoTokenEmbedder'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/embedding.py": {
        "_read_pretrained_embedding_file": {
            "name": "_read_pretrained_embedding_file",
            "location": 176,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str"
                ],
                "embedding_dim": [
                    "int"
                ],
                "vocab": [
                    "Vocabulary"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "_read_pretrained_word2vec_format_embedding_file": {
            "name": "_read_pretrained_word2vec_format_embedding_file",
            "location": 216,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str"
                ],
                "embedding_dim": [
                    "int"
                ],
                "vocab": [
                    "Vocabulary"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "_read_pretrained_hdf5_format_embedding_file": {
            "name": "_read_pretrained_hdf5_format_embedding_file",
            "location": 279,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str"
                ],
                "embedding_dim": [
                    "int"
                ],
                "vocab": [
                    "Vocabulary"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "Embedding.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_embeddings": [
                    "int"
                ],
                "embedding_dim": [
                    "int"
                ],
                "projection_dim": [
                    "int"
                ],
                "weight": [
                    "torch.FloatTensor"
                ],
                "padding_index": [
                    "int"
                ],
                "trainable": [
                    "bool"
                ],
                "max_norm": [
                    "float"
                ],
                "norm_type": [
                    "float"
                ],
                "scale_grad_by_freq": [
                    "bool"
                ],
                "sparse": [
                    "bool"
                ]
            }
        },
        "Embedding.get_output_dim": {
            "name": "get_output_dim",
            "location": 106,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Embedding.forward": {
            "name": "forward",
            "location": 110,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": []
            }
        },
        "Embedding.from_params": {
            "name": "from_params",
            "location": 130,
            "return": [
                "'Embedding'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/token_characters_encoder.py": {
        "TokenCharactersEncoder.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding": [
                    "Embedding"
                ],
                "encoder": [
                    "Seq2VecEncoder"
                ],
                "dropout": [
                    "float"
                ]
            }
        },
        "TokenCharactersEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 31,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenCharactersEncoder.forward": {
            "name": "forward",
            "location": 34,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "token_characters": [
                    "torch.Tensor"
                ]
            }
        },
        "TokenCharactersEncoder.from_params": {
            "name": "from_params",
            "location": 39,
            "return": [
                "'TokenCharactersEncoder'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/token_embedder.py": {
        "TokenEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 22,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenEmbedder.from_params": {
            "name": "from_params",
            "location": 30,
            "return": [
                "'TokenEmbedder'"
            ],
            "arguments": {
                "cls": [],
                "vocab": [
                    "Vocabulary"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/__init__.py": {},
    "allennlp-dureader-master/allennlp/nn/activations.py": {
        "Activation.__call__": {
            "name": "__call__",
            "location": 42,
            "return": [
                "torch.autograd.Variable"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.autograd.Variable"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/initializers.py": {
        "uniform_unit_scaling": {
            "name": "uniform_unit_scaling",
            "location": 66,
            "return": [],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "nonlinearity": [
                    "str"
                ]
            }
        },
        "block_orthogonal": {
            "name": "block_orthogonal",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "split_sizes": [
                    "List[int]"
                ],
                "gain": [
                    "float"
                ]
            }
        },
        "_initializer_wrapper": {
            "name": "_initializer_wrapper",
            "location": 156,
            "return": [
                "Type[Initializer]"
            ],
            "arguments": {
                "init_function": [
                    "Callable[(..., None)]"
                ]
            }
        },
        "Initializer.__call__": {
            "name": "__call__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.autograd.Variable"
                ]
            }
        },
        "Initializer.from_params": {
            "name": "from_params",
            "location": 57,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "InitializerApplicator.__init__": {
            "name": "__init__",
            "location": 195,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initializers": [
                    "List[Tuple[(str, Initializer)]]"
                ]
            }
        },
        "InitializerApplicator.__call__": {
            "name": "__call__",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "torch.nn.Module"
                ]
            }
        },
        "InitializerApplicator.from_params": {
            "name": "from_params",
            "location": 239,
            "return": [
                "'InitializerApplicator'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "List[Tuple[(str, Params)]]"
                ]
            }
        },
        "_initializer_wrapper.Init.__init__": {
            "name": "__init__",
            "location": 158,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_initializer_wrapper.Init.__call__": {
            "name": "__call__",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.autograd.Variable"
                ]
            }
        },
        "_initializer_wrapper.Init.__repr__": {
            "name": "__repr__",
            "location": 163,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_initializer_wrapper.Init.from_params": {
            "name": "from_params",
            "location": 166,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/util.py": {
        "batch_tensor_dicts": {
            "name": "batch_tensor_dicts",
            "location": 17,
            "return": [
                "Dict[(str, torch.Tensor)]"
            ],
            "arguments": {
                "tensor_dicts": [
                    "List[Dict[(str, torch.Tensor)]]"
                ],
                "remove_trailing_dimension": [
                    "bool"
                ]
            }
        },
        "get_lengths_from_binary_sequence_mask": {
            "name": "get_lengths_from_binary_sequence_mask",
            "location": 44,
            "return": [],
            "arguments": {
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "sort_batch_by_length": {
            "name": "sort_batch_by_length",
            "location": 63,
            "return": [],
            "arguments": {
                "tensor": [
                    "torch.autograd.Variable"
                ],
                "sequence_lengths": [
                    "torch.autograd.Variable"
                ]
            }
        },
        "get_final_encoder_states": {
            "name": "get_final_encoder_states",
            "location": 108,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "encoder_outputs": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ],
                "bidirectional": [
                    "bool"
                ]
            }
        },
        "get_dropout_mask": {
            "name": "get_dropout_mask",
            "location": 141,
            "return": [],
            "arguments": {
                "dropout_probability": [
                    "float"
                ],
                "tensor_for_masking": [
                    "torch.autograd.Variable"
                ]
            }
        },
        "masked_softmax": {
            "name": "masked_softmax",
            "location": 168,
            "return": [],
            "arguments": {
                "vector": [],
                "mask": []
            }
        },
        "masked_log_softmax": {
            "name": "masked_log_softmax",
            "location": 190,
            "return": [],
            "arguments": {
                "vector": [],
                "mask": []
            }
        },
        "viterbi_decode": {
            "name": "viterbi_decode",
            "location": 218,
            "return": [],
            "arguments": {
                "tag_sequence": [
                    "torch.Tensor"
                ],
                "transition_matrix": [
                    "torch.Tensor"
                ],
                "tag_observations": [
                    "Optional[List[int]]"
                ]
            }
        },
        "get_text_field_mask": {
            "name": "get_text_field_mask",
            "location": 304,
            "return": [
                "torch.LongTensor"
            ],
            "arguments": {
                "text_field_tensors": [
                    "Dict[(str, torch.Tensor)]"
                ],
                "num_wrapping_dims": [
                    "int"
                ]
            }
        },
        "_last_dimension_applicator": {
            "name": "_last_dimension_applicator",
            "location": 346,
            "return": [],
            "arguments": {
                "function_to_apply": [
                    "Callable[([torch.Tensor, Optional[torch.Tensor]], torch.Tensor)]"
                ],
                "tensor": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "last_dim_softmax": {
            "name": "last_dim_softmax",
            "location": 367,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "last_dim_log_softmax": {
            "name": "last_dim_log_softmax",
            "location": 376,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "weighted_sum": {
            "name": "weighted_sum",
            "location": 385,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "matrix": [
                    "torch.Tensor"
                ],
                "attention": [
                    "torch.Tensor"
                ]
            }
        },
        "sequence_cross_entropy_with_logits": {
            "name": "sequence_cross_entropy_with_logits",
            "location": 424,
            "return": [
                "torch.FloatTensor"
            ],
            "arguments": {
                "logits": [
                    "torch.FloatTensor"
                ],
                "targets": [
                    "torch.LongTensor"
                ],
                "weights": [
                    "torch.FloatTensor"
                ],
                "batch_average": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ]
            }
        },
        "replace_masked_values": {
            "name": "replace_masked_values",
            "location": 496,
            "return": [
                "Variable"
            ],
            "arguments": {
                "tensor": [
                    "Variable"
                ],
                "mask": [
                    "Variable"
                ],
                "replace_with": [
                    "float"
                ]
            }
        },
        "device_mapping": {
            "name": "device_mapping",
            "location": 511,
            "return": [],
            "arguments": {
                "cuda_device": [
                    "int"
                ]
            }
        },
        "ones_like": {
            "name": "ones_like",
            "location": 525,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ]
            }
        },
        "zeros_like": {
            "name": "zeros_like",
            "location": 533,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ]
            }
        },
        "combine_tensors": {
            "name": "combine_tensors",
            "location": 541,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensors": [
                    "List[torch.Tensor]"
                ]
            }
        },
        "_get_combination": {
            "name": "_get_combination",
            "location": 572,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensors": [
                    "List[torch.Tensor]"
                ]
            }
        },
        "get_combined_dim": {
            "name": "get_combined_dim",
            "location": 594,
            "return": [
                "int"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensor_dims": [
                    "List[int]"
                ]
            }
        },
        "_get_combination_dim": {
            "name": "_get_combination_dim",
            "location": 616,
            "return": [
                "int"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensor_dims": [
                    "List[int]"
                ]
            }
        },
        "logsumexp": {
            "name": "logsumexp",
            "location": 631,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "dim": [
                    "int"
                ],
                "keepdim": [
                    "bool"
                ]
            }
        },
        "get_device_of": {
            "name": "get_device_of",
            "location": 655,
            "return": [
                "int"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ]
            }
        },
        "flatten_and_batch_shift_indices": {
            "name": "flatten_and_batch_shift_indices",
            "location": 664,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "indices": [
                    "torch.Tensor"
                ],
                "sequence_length": [
                    "int"
                ]
            }
        },
        "batched_index_select": {
            "name": "batched_index_select",
            "location": 708,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "target": [
                    "torch.Tensor"
                ],
                "indices": [
                    "torch.LongTensor"
                ],
                "flattened_indices": [
                    "Optional[torch.LongTensor]"
                ]
            }
        },
        "flattened_index_select": {
            "name": "flattened_index_select",
            "location": 761,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "target": [
                    "torch.Tensor"
                ],
                "indices": [
                    "torch.LongTensor"
                ]
            }
        },
        "get_range_vector": {
            "name": "get_range_vector",
            "location": 793,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "size": [
                    "int"
                ],
                "device": [
                    "int"
                ]
            }
        },
        "bucket_values": {
            "name": "bucket_values",
            "location": 805,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "distances": [
                    "torch.Tensor"
                ],
                "num_identity_buckets": [
                    "int"
                ],
                "num_total_buckets": [
                    "int"
                ]
            }
        },
        "add_sentence_boundary_token_ids": {
            "name": "add_sentence_boundary_token_ids",
            "location": 844,
            "return": [
                "Tuple[(torch.Tensor, torch.Tensor)]"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ],
                "sentence_begin_token": [
                    "Any"
                ],
                "sentence_end_token": [
                    "Any"
                ]
            }
        },
        "remove_sentence_boundaries": {
            "name": "remove_sentence_boundaries",
            "location": 900,
            "return": [
                "Tuple[(torch.Tensor, torch.Tensor)]"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "mask": [
                    "torch.Tensor"
                ]
            }
        },
        "add_positional_features": {
            "name": "add_positional_features",
            "location": 943,
            "return": [],
            "arguments": {
                "tensor": [
                    "torch.Tensor"
                ],
                "min_timescale": [
                    "float"
                ],
                "max_timescale": [
                    "float"
                ]
            }
        },
        "device_mapping.inner_device_mapping": {
            "name": "inner_device_mapping",
            "location": 517,
            "return": [
                "torch.Storage"
            ],
            "arguments": {
                "storage": [
                    "torch.Storage"
                ],
                "location": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/__init__.py": {},
    "allennlp-dureader-master/allennlp/nn/regularizers/regularizer.py": {
        "Regularizer.__call__": {
            "name": "__call__",
            "location": 12,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "parameter": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/regularizers/regularizers.py": {
        "L1Regularizer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "float"
                ]
            }
        },
        "L1Regularizer.__call__": {
            "name": "__call__",
            "location": 13,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "parameter": [
                    "torch.Tensor"
                ]
            }
        },
        "L2Regularizer.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "float"
                ]
            }
        },
        "L2Regularizer.__call__": {
            "name": "__call__",
            "location": 24,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "parameter": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/regularizers/regularizer_applicator.py": {
        "RegularizerApplicator.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "regularizers": [
                    "Sequence[Tuple[(str, Regularizer)]]"
                ]
            }
        },
        "RegularizerApplicator.__call__": {
            "name": "__call__",
            "location": 25,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "torch.nn.Module"
                ]
            }
        },
        "RegularizerApplicator.from_params": {
            "name": "from_params",
            "location": 44,
            "return": [
                "Optional['RegularizerApplicator']"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "List[Tuple[(str, Params)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/regularizers/__init__.py": {},
    "allennlp-dureader-master/allennlp/service/db.py": {
        "DemoDatabase.add_result": {
            "name": "add_result",
            "location": 24,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "headers": [
                    "JsonDict"
                ],
                "model_name": [
                    "str"
                ],
                "inputs": [
                    "JsonDict"
                ],
                "outputs": [
                    "JsonDict"
                ]
            }
        },
        "DemoDatabase.get_result": {
            "name": "get_result",
            "location": 35,
            "return": [
                "Permadata"
            ],
            "arguments": {
                "self": [],
                "perma_id": [
                    "int"
                ]
            }
        },
        "DemoDatabase.from_environment": {
            "name": "from_environment",
            "location": 43,
            "return": [
                "Optional['DemoDatabase']"
            ],
            "arguments": {
                "cls": []
            }
        },
        "PostgresDemoDatabase.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dbname": [
                    "str"
                ],
                "host": [
                    "str"
                ],
                "port": [
                    "str"
                ],
                "user": [
                    "str"
                ],
                "password": [
                    "str"
                ]
            }
        },
        "PostgresDemoDatabase._connect": {
            "name": "_connect",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PostgresDemoDatabase._health_check": {
            "name": "_health_check",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PostgresDemoDatabase.from_environment": {
            "name": "from_environment",
            "location": 116,
            "return": [
                "Optional['PostgresDemoDatabase']"
            ],
            "arguments": {
                "cls": []
            }
        },
        "PostgresDemoDatabase.add_result": {
            "name": "add_result",
            "location": 135,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "headers": [
                    "JsonDict"
                ],
                "model_name": [
                    "str"
                ],
                "inputs": [
                    "JsonDict"
                ],
                "outputs": [
                    "JsonDict"
                ]
            }
        },
        "PostgresDemoDatabase.get_result": {
            "name": "get_result",
            "location": 160,
            "return": [
                "Optional[Permadata]"
            ],
            "arguments": {
                "self": [],
                "perma_id": [
                    "int"
                ]
            }
        },
        "InMemoryDemoDatabase.__init__": {
            "name": "__init__",
            "location": 183,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "InMemoryDemoDatabase.add_result": {
            "name": "add_result",
            "location": 186,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "headers": [
                    "JsonDict"
                ],
                "model_name": [
                    "str"
                ],
                "inputs": [
                    "JsonDict"
                ],
                "outputs": [
                    "JsonDict"
                ]
            }
        },
        "InMemoryDemoDatabase.get_result": {
            "name": "get_result",
            "location": 194,
            "return": [
                "Permadata"
            ],
            "arguments": {
                "self": [],
                "perma_id": [
                    "int"
                ]
            }
        },
        "InMemoryDemoDatabase.from_environment": {
            "name": "from_environment",
            "location": 201,
            "return": [
                "Optional['InMemoryDemoDatabase']"
            ],
            "arguments": {
                "cls": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/permalinks.py": {
        "int_to_slug": {
            "name": "int_to_slug",
            "location": 17,
            "return": [
                "str"
            ],
            "arguments": {
                "i": [
                    "int"
                ]
            }
        },
        "slug_to_int": {
            "name": "slug_to_int",
            "location": 26,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "slug": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/server_flask.py": {
        "run": {
            "name": "run",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "port": [
                    "int"
                ],
                "trained_models": [
                    "Dict[(str, DemoModel)]"
                ],
                "static_dir": [
                    "str"
                ]
            }
        },
        "make_app": {
            "name": "make_app",
            "location": 74,
            "return": [
                "Flask"
            ],
            "arguments": {
                "build_dir": [
                    "str"
                ],
                "demo_db": [
                    "Optional[DemoDatabase]"
                ]
            }
        },
        "ServerError.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [],
            "arguments": {
                "self": [],
                "message": [],
                "status_code": [],
                "payload": []
            }
        },
        "ServerError.to_dict": {
            "name": "to_dict",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "make_app.handle_invalid_usage": {
            "name": "handle_invalid_usage",
            "location": 97,
            "return": [
                "Response"
            ],
            "arguments": {
                "error": [
                    "ServerError"
                ]
            }
        },
        "make_app._caching_prediction": {
            "name": "_caching_prediction",
            "location": 103,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "model": [
                    "Predictor"
                ],
                "data": [
                    "str"
                ]
            }
        },
        "make_app.index": {
            "name": "index",
            "location": 110,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "make_app.permadata": {
            "name": "permadata",
            "location": 114,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "make_app.predict": {
            "name": "predict",
            "location": 153,
            "return": [
                "Response"
            ],
            "arguments": {
                "model_name": [
                    "str"
                ]
            }
        },
        "make_app.list_models": {
            "name": "list_models",
            "location": 240,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "make_app.info": {
            "name": "info",
            "location": 245,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "make_app.return_page": {
            "name": "return_page",
            "location": 269,
            "return": [
                "Response"
            ],
            "arguments": {
                "permalink": [
                    "str"
                ]
            }
        },
        "make_app.static_proxy": {
            "name": "static_proxy",
            "location": 274,
            "return": [
                "Response"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "make_app.static_js_proxy": {
            "name": "static_js_proxy",
            "location": 278,
            "return": [
                "Response"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/server_simple.py": {
        "make_app": {
            "name": "make_app",
            "location": 39,
            "return": [
                "Flask"
            ],
            "arguments": {
                "predictor": [
                    "Predictor"
                ],
                "field_names": [
                    "List[str]"
                ],
                "static_dir": [
                    "str"
                ],
                "sanitizer": [
                    "Callable[([JsonDict], JsonDict)]"
                ],
                "title": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 114,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "_html": {
            "name": "_html",
            "location": 699,
            "return": [
                "str"
            ],
            "arguments": {
                "title": [
                    "str"
                ],
                "field_names": [
                    "List[str]"
                ]
            }
        },
        "make_app.handle_invalid_usage": {
            "name": "handle_invalid_usage",
            "location": 74,
            "return": [
                "Response"
            ],
            "arguments": {
                "error": [
                    "ServerError"
                ]
            }
        },
        "make_app.index": {
            "name": "index",
            "location": 80,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "make_app.predict": {
            "name": "predict",
            "location": 88,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "make_app.static_proxy": {
            "name": "static_proxy",
            "location": 105,
            "return": [
                "Response"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/__init__.py": {},
    "allennlp-dureader-master/allennlp/service/predictors/bidaf.py": {
        "BidafPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 15,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/constituency_parser.py": {
        "ConstituencyParserPredictor.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Model"
                ],
                "dataset_reader": [
                    "DatasetReader"
                ]
            }
        },
        "ConstituencyParserPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 70,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        },
        "ConstituencyParserPredictor.predict_json": {
            "name": "predict_json",
            "location": 80,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "JsonDict"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "ConstituencyParserPredictor.predict_batch_json": {
            "name": "predict_batch_json",
            "location": 92,
            "return": [
                "List[JsonDict]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[JsonDict]"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "ConstituencyParserPredictor._build_hierplane_tree": {
            "name": "_build_hierplane_tree",
            "location": 104,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "Tree"
                ],
                "index": [
                    "int"
                ],
                "is_root": [
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/coref.py": {
        "CorefPredictor.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Model"
                ],
                "dataset_reader": [
                    "DatasetReader"
                ]
            }
        },
        "CorefPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 25,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/decomposable_attention.py": {
        "DecomposableAttentionPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 15,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/predictor.py": {
        "Predictor.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Model"
                ],
                "dataset_reader": [
                    "DatasetReader"
                ]
            }
        },
        "Predictor.load_line": {
            "name": "load_line",
            "location": 20,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "line": [
                    "str"
                ]
            }
        },
        "Predictor.dump_line": {
            "name": "dump_line",
            "location": 27,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "outputs": [
                    "JsonDict"
                ]
            }
        },
        "Predictor.predict_json": {
            "name": "predict_json",
            "location": 34,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "JsonDict"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "Predictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 40,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        },
        "Predictor.predict_batch_json": {
            "name": "predict_batch_json",
            "location": 48,
            "return": [
                "List[JsonDict]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[JsonDict]"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "Predictor._batch_json_to_instances": {
            "name": "_batch_json_to_instances",
            "location": 55,
            "return": [
                "List[Tuple[(Instance, JsonDict)]]"
            ],
            "arguments": {
                "self": [],
                "json_dicts": [
                    "List[JsonDict]"
                ]
            }
        },
        "Predictor.from_archive": {
            "name": "from_archive",
            "location": 70,
            "return": [
                "'Predictor'"
            ],
            "arguments": {
                "cls": [],
                "archive": [
                    "Archive"
                ],
                "predictor_name": [
                    "str"
                ]
            }
        },
        "DemoModel.__init__": {
            "name": "__init__",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "archive_file": [
                    "str"
                ],
                "predictor_name": [
                    "str"
                ]
            }
        },
        "DemoModel.predictor": {
            "name": "predictor",
            "location": 97,
            "return": [
                "Predictor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/semantic_role_labeler.py": {
        "SemanticRoleLabelerPredictor.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Model"
                ],
                "dataset_reader": [
                    "DatasetReader"
                ]
            }
        },
        "SemanticRoleLabelerPredictor.make_srl_string": {
            "name": "make_srl_string",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "words": [
                    "List[str]"
                ],
                "tags": [
                    "List[str]"
                ]
            }
        },
        "SemanticRoleLabelerPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 45,
            "return": [],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        },
        "SemanticRoleLabelerPredictor._sentence_to_srl_instances": {
            "name": "_sentence_to_srl_instances",
            "location": 48,
            "return": [
                "Tuple[(List[Instance], JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        },
        "SemanticRoleLabelerPredictor.predict_batch_json": {
            "name": "predict_batch_json",
            "location": 87,
            "return": [
                "List[JsonDict]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[JsonDict]"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "SemanticRoleLabelerPredictor.predict_json": {
            "name": "predict_json",
            "location": 158,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "JsonDict"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/sentence_tagger.py": {
        "SentenceTaggerPredictor.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Model"
                ],
                "dataset_reader": [
                    "DatasetReader"
                ]
            }
        },
        "SentenceTaggerPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 26,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/simple_seq2seq.py": {
        "SimpleSeq2SeqPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 14,
            "return": [
                "Tuple[(Instance, JsonDict)]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/__init__.py": {},
    "allennlp-dureader-master/allennlp/training/learning_rate_schedulers.py": {
        "LearningRateScheduler.from_params": {
            "name": "from_params",
            "location": 26,
            "return": [],
            "arguments": {
                "cls": [],
                "optimizer": [
                    "torch.optim.Optimizer"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/optimizers.py": {
        "Optimizer.from_params": {
            "name": "from_params",
            "location": 36,
            "return": [],
            "arguments": {
                "cls": [],
                "model_parameters": [
                    "List"
                ],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/trainer.py": {
        "is_sparse": {
            "name": "is_sparse",
            "location": 40,
            "return": [],
            "arguments": {
                "tensor": []
            }
        },
        "sparse_clip_norm": {
            "name": "sparse_clip_norm",
            "location": 44,
            "return": [
                "float"
            ],
            "arguments": {
                "parameters": [],
                "max_norm": [],
                "norm_type": []
            }
        },
        "time_to_str": {
            "name": "time_to_str",
            "location": 114,
            "return": [
                "str"
            ],
            "arguments": {
                "timestamp": [
                    "int"
                ]
            }
        },
        "str_to_time": {
            "name": "str_to_time",
            "location": 124,
            "return": [
                "datetime.datetime"
            ],
            "arguments": {
                "time_str": [
                    "str"
                ]
            }
        },
        "TensorboardWriter.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_log": [
                    "SummaryWriter"
                ],
                "validation_log": [
                    "SummaryWriter"
                ]
            }
        },
        "TensorboardWriter.add_train_scalar": {
            "name": "add_train_scalar",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "value": [
                    "float"
                ],
                "global_step": [
                    "int"
                ]
            }
        },
        "TensorboardWriter.add_train_histogram": {
            "name": "add_train_histogram",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "values": [
                    "torch.Tensor"
                ],
                "global_step": [
                    "int"
                ]
            }
        },
        "TensorboardWriter.add_validation_scalar": {
            "name": "add_validation_scalar",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "value": [
                    "float"
                ],
                "global_step": [
                    "int"
                ]
            }
        },
        "Trainer.__init__": {
            "name": "__init__",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Model"
                ],
                "optimizer": [
                    "torch.optim.Optimizer"
                ],
                "iterator": [
                    "DataIterator"
                ],
                "train_dataset": [
                    "Iterable[Instance]"
                ],
                "validation_dataset": [
                    "Optional[Iterable[Instance]]"
                ],
                "patience": [
                    "int"
                ],
                "validation_metric": [
                    "str"
                ],
                "num_epochs": [
                    "int"
                ],
                "serialization_dir": [
                    "Optional[str]"
                ],
                "num_serialized_models_to_keep": [
                    "int"
                ],
                "keep_serialized_model_every_num_seconds": [
                    "int"
                ],
                "model_save_interval": [
                    "float"
                ],
                "cuda_device": [
                    "Union[(int, List)]"
                ],
                "grad_norm": [
                    "Optional[float]"
                ],
                "grad_clipping": [
                    "Optional[float]"
                ],
                "learning_rate_scheduler": [
                    "Optional[PytorchLRScheduler]"
                ],
                "summary_interval": [
                    "int"
                ],
                "histogram_interval": [
                    "int"
                ]
            }
        },
        "Trainer._enable_gradient_clipping": {
            "name": "_enable_gradient_clipping",
            "location": 287,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._enable_activation_logging": {
            "name": "_enable_activation_logging",
            "location": 296,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._rescale_gradients": {
            "name": "_rescale_gradients",
            "location": 338,
            "return": [
                "Optional[float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._data_parallel": {
            "name": "_data_parallel",
            "location": 347,
            "return": [],
            "arguments": {
                "self": [],
                "batch": []
            }
        },
        "Trainer._batch_loss": {
            "name": "_batch_loss",
            "location": 363,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "torch.Tensor"
                ],
                "for_training": [
                    "bool"
                ]
            }
        },
        "Trainer._get_metrics": {
            "name": "_get_metrics",
            "location": 383,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "total_loss": [
                    "float"
                ],
                "batch_num": [
                    "int"
                ],
                "reset": [
                    "bool"
                ]
            }
        },
        "Trainer._train_epoch": {
            "name": "_train_epoch",
            "location": 393,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ]
            }
        },
        "Trainer._should_stop_early": {
            "name": "_should_stop_early",
            "location": 489,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "metric_history": [
                    "List[float]"
                ]
            }
        },
        "Trainer._parameter_and_gradient_statistics_to_tensorboard": {
            "name": "_parameter_and_gradient_statistics_to_tensorboard",
            "location": 502,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ],
                "batch_grad_norm": [
                    "float"
                ]
            }
        },
        "Trainer._histograms_to_tensorboard": {
            "name": "_histograms_to_tensorboard",
            "location": 533,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ],
                "histogram_parameters": [
                    "Set[str]"
                ]
            }
        },
        "Trainer._metrics_to_tensorboard": {
            "name": "_metrics_to_tensorboard",
            "location": 543,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ],
                "train_metrics": [
                    "dict"
                ],
                "val_metrics": [
                    "dict"
                ]
            }
        },
        "Trainer._metrics_to_console": {
            "name": "_metrics_to_console",
            "location": 563,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_metrics": [
                    "dict"
                ],
                "val_metrics": [
                    "dict"
                ]
            }
        },
        "Trainer._update_learning_rate": {
            "name": "_update_learning_rate",
            "location": 588,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ],
                "val_metric": [
                    "float"
                ],
                "batch_num_total": [
                    "int"
                ]
            }
        },
        "Trainer._validation_loss": {
            "name": "_validation_loss",
            "location": 613,
            "return": [
                "Tuple[(float, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.train": {
            "name": "train",
            "location": 643,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._description_from_metrics": {
            "name": "_description_from_metrics",
            "location": 730,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "metrics": [
                    "Dict[(str, float)]"
                ]
            }
        },
        "Trainer._save_checkpoint": {
            "name": "_save_checkpoint",
            "location": 734,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "Union[(int, str)]"
                ],
                "val_metric_per_epoch": [
                    "List[float]"
                ],
                "is_best": [
                    "Optional[bool]"
                ]
            }
        },
        "Trainer._restore_checkpoint": {
            "name": "_restore_checkpoint",
            "location": 788,
            "return": [
                "Tuple[(int, List[float])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.from_params": {
            "name": "from_params",
            "location": 875,
            "return": [
                "'Trainer'"
            ],
            "arguments": {
                "cls": [],
                "model": [
                    "Model"
                ],
                "serialization_dir": [
                    "str"
                ],
                "iterator": [
                    "DataIterator"
                ],
                "train_data": [
                    "Iterable[Instance]"
                ],
                "validation_data": [
                    "Optional[Iterable[Instance]]"
                ],
                "params": [
                    "Params"
                ]
            }
        },
        "Trainer._enable_activation_logging.hook": {
            "name": "hook",
            "location": 311,
            "return": [],
            "arguments": {
                "module_": [],
                "inputs": [],
                "outputs": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/__init__.py": {},
    "allennlp-dureader-master/allennlp/training/metrics/average.py": {
        "Average.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Average.__call__": {
            "name": "__call__",
            "location": 19,
            "return": [],
            "arguments": {
                "self": [],
                "value": []
            }
        },
        "Average.get_metric": {
            "name": "get_metric",
            "location": 30,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "Average.reset": {
            "name": "reset",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/boolean_accuracy.py": {
        "BooleanAccuracy.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BooleanAccuracy.__call__": {
            "name": "__call__",
            "location": 23,
            "return": [],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor"
                ],
                "gold_labels": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "BooleanAccuracy.get_metric": {
            "name": "get_metric",
            "location": 56,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "BooleanAccuracy.reset": {
            "name": "reset",
            "location": 68,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/categorical_accuracy.py": {
        "CategoricalAccuracy.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "top_k": [
                    "int"
                ]
            }
        },
        "CategoricalAccuracy.__call__": {
            "name": "__call__",
            "location": 21,
            "return": [],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor"
                ],
                "gold_labels": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "CategoricalAccuracy.get_metric": {
            "name": "get_metric",
            "location": 65,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "CategoricalAccuracy.reset": {
            "name": "reset",
            "location": 77,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/conll_coref_scores.py": {
        "ConllCorefScores.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConllCorefScores.__call__": {
            "name": "__call__",
            "location": 16,
            "return": [],
            "arguments": {
                "self": [],
                "top_spans": [],
                "antecedent_indices": [],
                "predicted_antecedents": [],
                "metadata_list": []
            }
        },
        "ConllCorefScores.get_metric": {
            "name": "get_metric",
            "location": 29,
            "return": [
                "Tuple[(float, float, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "ConllCorefScores.reset": {
            "name": "reset",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConllCorefScores.get_gold_clusters": {
            "name": "get_gold_clusters",
            "location": 42,
            "return": [],
            "arguments": {
                "gold_clusters": []
            }
        },
        "ConllCorefScores.get_predicted_clusters": {
            "name": "get_predicted_clusters",
            "location": 51,
            "return": [],
            "arguments": {
                "top_spans": [],
                "antecedent_indices": [],
                "predicted_antecedents": []
            }
        },
        "Scorer.__init__": {
            "name": "__init__",
            "location": 91,
            "return": [],
            "arguments": {
                "self": [],
                "metric": []
            }
        },
        "Scorer.update": {
            "name": "update",
            "location": 98,
            "return": [],
            "arguments": {
                "self": [],
                "predicted": [],
                "gold": [],
                "mention_to_predicted": [],
                "mention_to_gold": []
            }
        },
        "Scorer.get_f1": {
            "name": "get_f1",
            "location": 109,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Scorer.get_recall": {
            "name": "get_recall",
            "location": 116,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Scorer.get_precision": {
            "name": "get_precision",
            "location": 122,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Scorer.get_prf": {
            "name": "get_prf",
            "location": 128,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Scorer.b_cubed": {
            "name": "b_cubed",
            "location": 132,
            "return": [],
            "arguments": {
                "clusters": [],
                "mention_to_gold": []
            }
        },
        "Scorer.muc": {
            "name": "muc",
            "location": 154,
            "return": [],
            "arguments": {
                "clusters": [],
                "mention_to_gold": []
            }
        },
        "Scorer.phi4": {
            "name": "phi4",
            "location": 174,
            "return": [],
            "arguments": {
                "gold_clustering": [],
                "predicted_clustering": []
            }
        },
        "Scorer.ceafe": {
            "name": "ceafe",
            "location": 183,
            "return": [],
            "arguments": {
                "clusters": [],
                "gold_clusters": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/entropy.py": {
        "Entropy.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Entropy.__call__": {
            "name": "__call__",
            "location": 19,
            "return": [],
            "arguments": {
                "self": [],
                "logits": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "Entropy.get_metric": {
            "name": "get_metric",
            "location": 45,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "Entropy.reset": {
            "name": "reset",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/evalb_bracketing_scorer.py": {
        "EvalbBracketingScorer.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "evalb_directory_path": [
                    "str"
                ],
                "evalb_param_filename": [
                    "str"
                ]
            }
        },
        "EvalbBracketingScorer.__call__": {
            "name": "__call__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predicted_trees": [
                    "List[Tree]"
                ],
                "gold_trees": [
                    "List[Tree]"
                ]
            }
        },
        "EvalbBracketingScorer.get_metric": {
            "name": "get_metric",
            "location": 94,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "EvalbBracketingScorer.reset": {
            "name": "reset",
            "location": 109,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/f1_measure.py": {
        "F1Measure.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "positive_label": [
                    "int"
                ]
            }
        },
        "F1Measure.__call__": {
            "name": "__call__",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor"
                ],
                "gold_labels": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "F1Measure.get_metric": {
            "name": "get_metric",
            "location": 76,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "F1Measure.reset": {
            "name": "reset",
            "location": 92,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/mention_recall.py": {
        "MentionRecall.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MentionRecall.__call__": {
            "name": "__call__",
            "location": 16,
            "return": [],
            "arguments": {
                "self": [],
                "batched_top_spans": [
                    "torch.Tensor"
                ],
                "batched_metadata": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "MentionRecall.get_metric": {
            "name": "get_metric",
            "location": 28,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "MentionRecall.reset": {
            "name": "reset",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/metric.py": {
        "Metric.__call__": {
            "name": "__call__",
            "location": 14,
            "return": [],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor"
                ],
                "gold_labels": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "Metric.get_metric": {
            "name": "get_metric",
            "location": 31,
            "return": [
                "Union[(float, Tuple[(float, ...)], Dict[(str, float)])]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "Metric.reset": {
            "name": "reset",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Metric.from_params": {
            "name": "from_params",
            "location": 44,
            "return": [],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ],
                "vocab": [
                    "Optional[Vocabulary]"
                ]
            }
        },
        "Metric.unwrap_to_tensors": {
            "name": "unwrap_to_tensors",
            "location": 51,
            "return": [],
            "arguments": {}
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/span_based_f1_measure.py": {
        "SpanBasedF1Measure.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocabulary": [
                    "Vocabulary"
                ],
                "tag_namespace": [
                    "str"
                ],
                "ignore_classes": [
                    "List[str]"
                ],
                "label_encoding": [
                    "str"
                ]
            }
        },
        "SpanBasedF1Measure.__call__": {
            "name": "__call__",
            "location": 71,
            "return": [],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor"
                ],
                "gold_labels": [
                    "torch.Tensor"
                ],
                "mask": [
                    "Optional[torch.Tensor]"
                ],
                "prediction_map": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "SpanBasedF1Measure._handle_continued_spans": {
            "name": "_handle_continued_spans",
            "location": 154,
            "return": [
                "List[TypedStringSpan]"
            ],
            "arguments": {
                "spans": [
                    "List[TypedStringSpan]"
                ]
            }
        },
        "SpanBasedF1Measure.get_metric": {
            "name": "get_metric",
            "location": 189,
            "return": [],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "SpanBasedF1Measure._compute_metrics": {
            "name": "_compute_metrics",
            "location": 229,
            "return": [],
            "arguments": {
                "true_positives": [
                    "int"
                ],
                "false_positives": [
                    "int"
                ],
                "false_negatives": [
                    "int"
                ]
            }
        },
        "SpanBasedF1Measure.reset": {
            "name": "reset",
            "location": 235,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/squad_em_and_f1.py": {
        "SquadEmAndF1.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SquadEmAndF1.__call__": {
            "name": "__call__",
            "location": 22,
            "return": [],
            "arguments": {
                "self": [],
                "best_span_string": [],
                "answer_strings": []
            }
        },
        "SquadEmAndF1.get_metric": {
            "name": "get_metric",
            "location": 42,
            "return": [
                "Tuple[(float, float)]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool"
                ]
            }
        },
        "SquadEmAndF1.reset": {
            "name": "reset",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SquadEmAndF1.__str__": {
            "name": "__str__",
            "location": 61,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/__init__.py": {},
    "allennlp-dureader-master/doc/conf.py": {
        "linkcode_resolve": {
            "name": "linkcode_resolve",
            "location": 199,
            "return": [],
            "arguments": {
                "domain": [],
                "info": []
            }
        }
    },
    "allennlp-dureader-master/scripts/cache_models.py": {},
    "allennlp-dureader-master/scripts/check_docs.py": {
        "documented_modules": {
            "name": "documented_modules",
            "location": 39,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "docs_dir": [
                    "str"
                ],
                "module_regex": [
                    "str"
                ]
            }
        },
        "existing_modules": {
            "name": "existing_modules",
            "location": 51,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "module_glob": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/create_elmo_embeddings_from_vocab.py": {
        "main": {
            "name": "main",
            "location": 21,
            "return": [],
            "arguments": {
                "vocab_path": [
                    "str"
                ],
                "elmo_config_path": [
                    "str"
                ],
                "elmo_weights_path": [
                    "str"
                ],
                "output_dir": [
                    "str"
                ],
                "batch_size": [
                    "int"
                ],
                "device": [
                    "int"
                ],
                "use_custom_oov_token": [
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/inspect_cache.py": {},
    "allennlp-dureader-master/scripts/regenerate_archived_models.py": {
        "generate_archive": {
            "name": "generate_archive",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "config_file": [
                    "str"
                ],
                "serialization_dir": [
                    "str"
                ],
                "weights_file": [
                    "str"
                ],
                "archive_name": [
                    "str"
                ],
                "exist_ok": [
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/train_fixtures.py": {
        "train_fixture": {
            "name": "train_fixture",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "config_prefix": [
                    "str"
                ]
            }
        },
        "train_fixture_gpu": {
            "name": "train_fixture_gpu",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "config_prefix": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/verify.py": {
        "main": {
            "name": "main",
            "location": 14,
            "return": [],
            "arguments": {
                "checks": []
            }
        }
    },
    "allennlp-dureader-master/scripts/write_srl_predictions_to_conll_format.py": {
        "main": {
            "name": "main",
            "location": 14,
            "return": [],
            "arguments": {
                "serialization_directory": [],
                "device": []
            }
        }
    },
    "allennlp-dureader-master/scripts/ai2-internal/run_with_beaker.py": {
        "main": {
            "name": "main",
            "location": 21,
            "return": [],
            "arguments": {
                "param_file": [
                    "str"
                ],
                "extra_beaker_commands": [
                    "List[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/notebooks_test.py": {
        "TestNotebooks.test_vocabulary_tutorial": {
            "name": "test_vocabulary_tutorial",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNotebooks.test_data_pipeline_tutorial": {
            "name": "test_data_pipeline_tutorial",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNotebooks.test_embedding_tokens_tutorial": {
            "name": "test_embedding_tokens_tutorial",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNotebooks.execute_notebook": {
            "name": "execute_notebook",
            "location": 20,
            "return": [],
            "arguments": {
                "notebook_path": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/__init__.py": {},
    "allennlp-dureader-master/tests/commands/dry_run_test.py": {
        "TestDryRun.setUp": {
            "name": "setUp",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDryRun.test_dry_run_doesnt_overwrite_vocab": {
            "name": "test_dry_run_doesnt_overwrite_vocab",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/elmo_test.py": {
        "TestElmoCommand.test_all_embedding_works": {
            "name": "test_all_embedding_works",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_top_embedding_works": {
            "name": "test_top_embedding_works",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_average_embedding_works": {
            "name": "test_average_embedding_works",
            "location": 81,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_batch_embedding_works": {
            "name": "test_batch_embedding_works",
            "location": 115,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_duplicate_sentences": {
            "name": "test_duplicate_sentences",
            "location": 149,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_empty_sentences_are_filtered": {
            "name": "test_empty_sentences_are_filtered",
            "location": 184,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoEmbedder.test_embeddings_are_as_expected": {
            "name": "test_embeddings_are_as_expected",
            "location": 220,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoEmbedder.test_embed_batch_is_empty_sentence": {
            "name": "test_embed_batch_is_empty_sentence",
            "location": 245,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoEmbedder.test_embed_batch_contains_empty_sentence": {
            "name": "test_embed_batch_contains_empty_sentence",
            "location": 251,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/evaluate_test.py": {
        "TestEvaluate.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEvaluate.test_evaluate_from_args": {
            "name": "test_evaluate_from_args",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/fine_tune_test.py": {
        "TestFineTune.setUp": {
            "name": "setUp",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFineTune.test_fine_tune_model_runs_from_file_paths": {
            "name": "test_fine_tune_model_runs_from_file_paths",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFineTune.test_fine_tune_runs_from_parser_arguments": {
            "name": "test_fine_tune_runs_from_parser_arguments",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFineTune.test_fine_tune_fails_without_required_args": {
            "name": "test_fine_tune_fails_without_required_args",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/main_test.py": {
        "TestMain.test_fails_on_unknown_command": {
            "name": "test_fails_on_unknown_command",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMain.test_subcommand_overrides": {
            "name": "test_subcommand_overrides",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMain.test_other_modules": {
            "name": "test_other_modules",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMain.test_subcommand_overrides.do_nothing": {
            "name": "do_nothing",
            "location": 28,
            "return": [],
            "arguments": {
                "_": []
            }
        },
        "TestMain.test_subcommand_overrides.FakeEvaluate.add_subparser": {
            "name": "add_subparser",
            "location": 34,
            "return": [],
            "arguments": {
                "self": [],
                "name": [],
                "parser": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/make_vocab_test.py": {
        "TestMakeVocab.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMakeVocab.test_make_vocab_fails_without_vocabulary_key": {
            "name": "test_make_vocab_fails_without_vocabulary_key",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMakeVocab.test_make_vocab_makes_vocab": {
            "name": "test_make_vocab_makes_vocab",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/predict_test.py": {
        "TestPredict.test_add_predict_subparser": {
            "name": "test_add_predict_subparser",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_works_with_known_model": {
            "name": "test_works_with_known_model",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_batch_prediction_works_with_known_model": {
            "name": "test_batch_prediction_works_with_known_model",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_fails_without_required_args": {
            "name": "test_fails_without_required_args",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_can_specify_predictor": {
            "name": "test_can_specify_predictor",
            "location": 125,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_other_modules": {
            "name": "test_other_modules",
            "location": 169,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_alternative_file_formats": {
            "name": "test_alternative_file_formats",
            "location": 227,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_can_specify_predictor.Bidaf3Predictor.predict_json": {
            "name": "predict_json",
            "location": 130,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "JsonDict"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "TestPredict.test_alternative_file_formats.BidafCsvPredictor.load_line": {
            "name": "load_line",
            "location": 235,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "line": [
                    "str"
                ]
            }
        },
        "TestPredict.test_alternative_file_formats.BidafCsvPredictor.dump_line": {
            "name": "dump_line",
            "location": 240,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "outputs": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/commands/serve_test.py": {
        "TestServe.test_add_serve": {
            "name": "test_add_serve",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/train_test.py": {
        "TestTrain.test_train_model": {
            "name": "test_train_model",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrain.test_train_with_test_set": {
            "name": "test_train_with_test_set",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrain.test_train_args": {
            "name": "test_train_args",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LazyFakeReader.__init__": {
            "name": "__init__",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LazyFakeReader._read": {
            "name": "_read",
            "location": 104,
            "return": [
                "Iterable[Instance]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "LazyFakeReader.from_params": {
            "name": "from_params",
            "location": 111,
            "return": [
                "'LazyTestReader'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "TestTrainOnLazyDataset.test_train_model": {
            "name": "test_train_model",
            "location": 116,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainOnLazyDataset.test_train_with_test_set": {
            "name": "test_train_with_test_set",
            "location": 145,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/__init__.py": {},
    "allennlp-dureader-master/tests/common/file_utils_test.py": {
        "set_up_glove": {
            "name": "set_up_glove",
            "location": 12,
            "return": [],
            "arguments": {
                "url": [
                    "str"
                ],
                "byt": [
                    "bytes"
                ],
                "change_etag_every": [
                    "int"
                ]
            }
        },
        "set_up_glove.head_callback": {
            "name": "head_callback",
            "location": 26,
            "return": [],
            "arguments": {
                "_": []
            }
        },
        "TestFileUtils.setUp": {
            "name": "setUp",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_url_to_filename": {
            "name": "test_url_to_filename",
            "location": 55,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_url_to_filename_with_etags": {
            "name": "test_url_to_filename_with_etags",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_url_to_filename_with_etags_eliminates_quotes": {
            "name": "test_url_to_filename_with_etags_eliminates_quotes",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_get_from_cache": {
            "name": "test_get_from_cache",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_cached_path": {
            "name": "test_cached_path",
            "location": 130,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/common/params_test.py": {
        "TestParams.test_load_from_file": {
            "name": "test_load_from_file",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_overrides": {
            "name": "test_overrides",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_as_flat_dict": {
            "name": "test_as_flat_dict",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_add_file_to_archive": {
            "name": "test_add_file_to_archive",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_add_file_to_archive.A.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "b": [
                    "'B'"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.A.from_params": {
            "name": "from_params",
            "location": 62,
            "return": [
                "'A'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.B.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str"
                ],
                "c": [
                    "'C'"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.B.from_params": {
            "name": "from_params",
            "location": 72,
            "return": [
                "'B'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.C.__init__": {
            "name": "__init__",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "c_file": [
                    "str"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.C.from_params": {
            "name": "from_params",
            "location": 86,
            "return": [
                "'C'"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/common/registrable_test.py": {
        "TestRegistrable.test_registrable_functionality_works": {
            "name": "test_registrable_functionality_works",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_dataset_readers": {
            "name": "test_registry_has_builtin_dataset_readers",
            "location": 63,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_iterators": {
            "name": "test_registry_has_builtin_iterators",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_tokenizers": {
            "name": "test_registry_has_builtin_tokenizers",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_token_indexers": {
            "name": "test_registry_has_builtin_token_indexers",
            "location": 78,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_regularizers": {
            "name": "test_registry_has_builtin_regularizers",
            "location": 82,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_initializers": {
            "name": "test_registry_has_builtin_initializers",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_learning_rate_schedulers": {
            "name": "test_registry_has_builtin_learning_rate_schedulers",
            "location": 104,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_token_embedders": {
            "name": "test_registry_has_builtin_token_embedders",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_text_field_embedders": {
            "name": "test_registry_has_builtin_text_field_embedders",
            "location": 118,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_seq2seq_encoders": {
            "name": "test_registry_has_builtin_seq2seq_encoders",
            "location": 121,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_seq2vec_encoders": {
            "name": "test_registry_has_builtin_seq2vec_encoders",
            "location": 127,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_similarity_functions": {
            "name": "test_registry_has_builtin_similarity_functions",
            "location": 134,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/common/test_util.py": {
        "TestCommonUtils.test_group_by_count": {
            "name": "test_group_by_count",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_lazy_groups_of": {
            "name": "test_lazy_groups_of",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_pad_sequence_to_length": {
            "name": "test_pad_sequence_to_length",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_namespace_match": {
            "name": "test_namespace_match",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_sanitize": {
            "name": "test_sanitize",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_import_submodules": {
            "name": "test_import_submodules",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/common/__init__.py": {},
    "allennlp-dureader-master/tests/custom_extensions/alternating_highway_lstm_test.py": {
        "TestCustomHighwayLSTM.test_small_model": {
            "name": "test_small_model",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCustomHighwayLSTM.test_large_model": {
            "name": "test_large_model",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCustomHighwayLSTM.test_validation_forward_pass_is_deterministic_in_model_with_dropout": {
            "name": "test_validation_forward_pass_is_deterministic_in_model_with_dropout",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCustomHighwayLSTM.forward_and_backward_outputs_match": {
            "name": "forward_and_backward_outputs_match",
            "location": 38,
            "return": [],
            "arguments": {
                "baseline_model": [],
                "kernel_model": [],
                "baseline_input": [],
                "kernel_input": [],
                "lengths": []
            }
        },
        "TestCustomHighwayLSTM.get_models_and_inputs": {
            "name": "get_models_and_inputs",
            "location": 88,
            "return": [],
            "arguments": {
                "batch_size": [],
                "input_size": [],
                "output_size": [],
                "num_layers": [],
                "timesteps": [],
                "dropout_prob": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_test.py": {
        "TestDataset.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_instances_must_have_homogeneous_fields": {
            "name": "test_instances_must_have_homogeneous_fields",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_padding_lengths_uses_max_instance_lengths": {
            "name": "test_padding_lengths_uses_max_instance_lengths",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_as_tensor_dict": {
            "name": "test_as_tensor_dict",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.get_instances": {
            "name": "get_instances",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/vocabulary_test.py": {
        "TestVocabulary.setUp": {
            "name": "setUp",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_max_vocab_size_single_int": {
            "name": "test_from_dataset_respects_max_vocab_size_single_int",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_min_count": {
            "name": "test_from_dataset_respects_min_count",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_exclusive_embedding_file": {
            "name": "test_from_dataset_respects_exclusive_embedding_file",
            "location": 52,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_inclusive_embedding_file": {
            "name": "test_from_dataset_respects_inclusive_embedding_file",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_add_word_to_index_gives_consistent_results": {
            "name": "test_add_word_to_index_gives_consistent_results",
            "location": 98,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_namespaces": {
            "name": "test_namespaces",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_namespace_dependent_default_dict": {
            "name": "test_namespace_dependent_default_dict",
            "location": 135,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_unknown_token": {
            "name": "test_unknown_token",
            "location": 145,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_set_from_file_reads_padded_files": {
            "name": "test_set_from_file_reads_padded_files",
            "location": 157,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_set_from_file_reads_non_padded_files": {
            "name": "test_set_from_file_reads_non_padded_files",
            "location": 190,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_saving_and_loading": {
            "name": "test_saving_and_loading",
            "location": 213,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_saving_and_loading_works_with_byte_encoding": {
            "name": "test_saving_and_loading_works_with_byte_encoding",
            "location": 253,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_params": {
            "name": "test_from_params",
            "location": 274,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_vocab_can_print": {
            "name": "test_vocab_can_print",
            "location": 304,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/__init__.py": {},
    "allennlp-dureader-master/tests/data/dataset_readers/conll2003_dataset_reader_test.py": {
        "TestConll2003Reader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 10,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": [],
                "coding_scheme": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/language_modeling_dataset_test.py": {
        "TestLanguageModelingDatasetReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 9,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/lazy_dataset_reader_test.py": {
        "LazyDatasetReader.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [],
            "arguments": {
                "self": [],
                "instances": [
                    "List[Instance]"
                ],
                "lazy": [
                    "bool"
                ]
            }
        },
        "LazyDatasetReader._read": {
            "name": "_read",
            "location": 20,
            "return": [
                "Iterable[Instance]"
            ],
            "arguments": {
                "self": [],
                "_": [
                    "str"
                ]
            }
        },
        "TestLazyDatasetReader.setUp": {
            "name": "setUp",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLazyDatasetReader.test_lazy": {
            "name": "test_lazy",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLazyDatasetReader.test_non_lazy": {
            "name": "test_non_lazy",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/penn_tree_bank_reader_test.py": {
        "TestPennTreeBankConstituencySpanReader.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_strip_functional_tags": {
            "name": "test_strip_functional_tags",
            "location": 90,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_get_gold_spans_correctly_extracts_spans": {
            "name": "test_get_gold_spans_correctly_extracts_spans",
            "location": 97,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_get_gold_spans_correctly_extracts_spans_with_nested_labels": {
            "name": "test_get_gold_spans_correctly_extracts_spans_with_nested_labels",
            "location": 106,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/seq2seq_test.py": {
        "TestSeq2SeqDatasetReader.test_default_format": {
            "name": "test_default_format",
            "location": 9,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestSeq2SeqDatasetReader.test_source_add_start_token": {
            "name": "test_source_add_start_token",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/sequence_tagging_test.py": {
        "TestSequenceTaggingDatasetReader.test_default_format": {
            "name": "test_default_format",
            "location": 9,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestSequenceTaggingDatasetReader.test_brown_corpus_format": {
            "name": "test_brown_corpus_format",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/snli_reader_test.py": {
        "TestSnliReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 9,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/srl_dataset_reader_test.py": {
        "TestSrlReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 9,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestSrlReader.test_srl_reader_can_filter_by_domain": {
            "name": "test_srl_reader_can_filter_by_domain",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/stanford_sentiment_tree_bank_test.py": {
        "TestStanfordSentimentTreebankReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 10,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_use_subtrees": {
            "name": "test_use_subtrees",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_3_class": {
            "name": "test_3_class",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_2_class": {
            "name": "test_2_class",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_from_params": {
            "name": "test_from_params",
            "location": 97,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/__init__.py": {},
    "allennlp-dureader-master/tests/data/dataset_readers/coreference/coref_reader_test.py": {
        "TestCorefReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 13,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestCorefReader.check_candidate_mentions_are_well_defined": {
            "name": "check_candidate_mentions_are_well_defined",
            "location": 72,
            "return": [],
            "arguments": {
                "self": [],
                "span_starts": [],
                "span_ends": [],
                "text": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/coreference/winobias_reader_test.py": {
        "TestWinobiasReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 13,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestWinobiasReader.check_candidate_mentions_are_well_defined": {
            "name": "check_candidate_mentions_are_well_defined",
            "location": 52,
            "return": [],
            "arguments": {
                "self": [],
                "span_starts": [],
                "span_ends": [],
                "text": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/dataset_utils/ontonotes_test.py": {
        "TestOntonotes.test_dataset_iterator": {
            "name": "test_dataset_iterator",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestOntonotes.test_dataset_path_iterator": {
            "name": "test_dataset_path_iterator",
            "location": 122,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestOntonotes.test_ontonotes_can_read_conll_file_with_multiple_documents": {
            "name": "test_ontonotes_can_read_conll_file_with_multiple_documents",
            "location": 130,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/dataset_utils/span_utils_test.py": {
        "SpanUtilsTest.test_bio_tags_to_spans_extracts_correct_spans": {
            "name": "test_bio_tags_to_spans_extracts_correct_spans",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_bio_tags_to_spans_ignores_specified_tags": {
            "name": "test_bio_tags_to_spans_ignores_specified_tags",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_enumerate_spans_enumerates_all_spans": {
            "name": "test_enumerate_spans_enumerates_all_spans",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_bioul_tags_to_spans": {
            "name": "test_bioul_tags_to_spans",
            "location": 60,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_iob1_to_bioul": {
            "name": "test_iob1_to_bioul",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_enumerate_spans_enumerates_all_spans.no_prefixed_punctuation": {
            "name": "no_prefixed_punctuation",
            "location": 47,
            "return": [],
            "arguments": {
                "tokens": [
                    "List[Token]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/squad_test.py": {
        "TestSquadReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 10,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        },
        "TestSquadReader.test_can_build_from_params": {
            "name": "test_can_build_from_params",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/triviaqa_test.py": {
        "TestTriviaQaReader.test_read": {
            "name": "test_read",
            "location": 10,
            "return": [],
            "arguments": {
                "self": [],
                "lazy": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/util_test.py": {
        "TestReadingComprehensionUtil.test_char_span_to_token_span_handles_easy_cases": {
            "name": "test_char_span_to_token_span_handles_easy_cases",
            "location": 8,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestReadingComprehensionUtil.test_char_span_to_token_span_handles_hard_cases": {
            "name": "test_char_span_to_token_span_handles_hard_cases",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/tests/data/fields/array_field_test.py": {
        "TestArrayField.test_get_padding_lengths_correctly_returns_ordered_shape": {
            "name": "test_get_padding_lengths_correctly_returns_ordered_shape",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_as_tensor_handles_larger_padding_dimensions": {
            "name": "test_as_tensor_handles_larger_padding_dimensions",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_padding_handles_list_fields": {
            "name": "test_padding_handles_list_fields",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_padding_handles_list_fields_with_padding_values": {
            "name": "test_padding_handles_list_fields_with_padding_values",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/index_field_test.py": {
        "TestIndexField.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_as_tensor_converts_field_correctly": {
            "name": "test_as_tensor_converts_field_correctly",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_index_field_raises_on_incorrect_label_type": {
            "name": "test_index_field_raises_on_incorrect_label_type",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_index_field_empty_field_works": {
            "name": "test_index_field_empty_field_works",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/label_field_test.py": {
        "TestLabelField.test_as_tensor_returns_integer_tensor": {
            "name": "test_as_tensor_returns_integer_tensor",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_can_index_with_vocab": {
            "name": "test_label_field_can_index_with_vocab",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_raises_with_non_integer_labels_and_no_indexing": {
            "name": "test_label_field_raises_with_non_integer_labels_and_no_indexing",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_raises_with_incorrect_label_type": {
            "name": "test_label_field_raises_with_incorrect_label_type",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_empty_field_works": {
            "name": "test_label_field_empty_field_works",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_class_variables_for_namespace_warnings_work_correctly": {
            "name": "test_class_variables_for_namespace_warnings_work_correctly",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/list_field_test.py": {
        "TestListField.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_get_padding_lengths": {
            "name": "test_get_padding_lengths",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_list_field_can_handle_empty_text_fields": {
            "name": "test_list_field_can_handle_empty_text_fields",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_list_field_can_handle_empty_index_fields": {
            "name": "test_list_field_can_handle_empty_index_fields",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_list_field_can_handle_empty_sequence_label_fields": {
            "name": "test_list_field_can_handle_empty_sequence_label_fields",
            "location": 64,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_all_fields_padded_to_max_length": {
            "name": "test_all_fields_padded_to_max_length",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_nested_list_fields_are_padded_correctly": {
            "name": "test_nested_list_fields_are_padded_correctly",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_fields_can_pad_to_greater_than_max_length": {
            "name": "test_fields_can_pad_to_greater_than_max_length",
            "location": 98,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_as_tensor_can_handle_multiple_token_indexers": {
            "name": "test_as_tensor_can_handle_multiple_token_indexers",
            "location": 116,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_as_tensor_can_handle_multiple_token_indexers_and_empty_fields": {
            "name": "test_as_tensor_can_handle_multiple_token_indexers_and_empty_fields",
            "location": 150,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 181,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/multilabel_field_test.py": {
        "TestMultiLabelField.test_as_tensor_returns_integer_tensor": {
            "name": "test_as_tensor_returns_integer_tensor",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_can_index_with_vocab": {
            "name": "test_multilabel_field_can_index_with_vocab",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_non_integer_labels_and_no_indexing": {
            "name": "test_multilabel_field_raises_with_non_integer_labels_and_no_indexing",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_no_indexing_and_missing_num_labels": {
            "name": "test_multilabel_field_raises_with_no_indexing_and_missing_num_labels",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_no_indexing_and_wrong_num_labels": {
            "name": "test_multilabel_field_raises_with_no_indexing_and_wrong_num_labels",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_incorrect_label_type": {
            "name": "test_multilabel_field_raises_with_incorrect_label_type",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_given_num_labels": {
            "name": "test_multilabel_field_raises_with_given_num_labels",
            "location": 44,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_empty_field_works": {
            "name": "test_multilabel_field_empty_field_works",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_class_variables_for_namespace_warnings_work_correctly": {
            "name": "test_class_variables_for_namespace_warnings_work_correctly",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/sequence_label_field_test.py": {
        "TestSequenceLabelField.setUp": {
            "name": "setUp",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_tag_length_mismatch_raises": {
            "name": "test_tag_length_mismatch_raises",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_count_vocab_items_correctly_indexes_tags": {
            "name": "test_count_vocab_items_correctly_indexes_tags",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_index_converts_field_correctly": {
            "name": "test_index_converts_field_correctly",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_as_tensor_produces_integer_targets": {
            "name": "test_as_tensor_produces_integer_targets",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_sequence_label_field_raises_on_incorrect_type": {
            "name": "test_sequence_label_field_raises_on_incorrect_type",
            "location": 64,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_class_variables_for_namespace_warnings_work_correctly": {
            "name": "test_class_variables_for_namespace_warnings_work_correctly",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 87,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/span_field_test.py": {
        "TestSpanField.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_as_tensor_converts_span_field_correctly": {
            "name": "test_as_tensor_converts_span_field_correctly",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_span_field_raises_on_incorrect_label_type": {
            "name": "test_span_field_raises_on_incorrect_label_type",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_span_field_raises_on_ill_defined_span": {
            "name": "test_span_field_raises_on_ill_defined_span",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_span_field_raises_if_span_end_is_greater_than_sentence_length": {
            "name": "test_span_field_raises_if_span_end_is_greater_than_sentence_length",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_empty_span_field_works": {
            "name": "test_empty_span_field_works",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/text_field_test.py": {
        "TestTextField.setUp": {
            "name": "setUp",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_field_counts_vocab_items_correctly": {
            "name": "test_field_counts_vocab_items_correctly",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_index_converts_field_correctly": {
            "name": "test_index_converts_field_correctly",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_get_padding_lengths_raises_if_no_indexed_tokens": {
            "name": "test_get_padding_lengths_raises_if_no_indexed_tokens",
            "location": 113,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_padding_lengths_are_computed_correctly": {
            "name": "test_padding_lengths_are_computed_correctly",
            "location": 120,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_words": {
            "name": "test_as_tensor_handles_words",
            "location": 140,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_longer_lengths": {
            "name": "test_as_tensor_handles_longer_lengths",
            "location": 149,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_characters": {
            "name": "test_as_tensor_handles_characters",
            "location": 159,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_words_and_characters_with_longer_lengths": {
            "name": "test_as_tensor_handles_words_and_characters_with_longer_lengths",
            "location": 173,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 192,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/__init__.py": {},
    "allennlp-dureader-master/tests/data/iterators/adaptive_iterator_test.py": {
        "TestAdaptiveIterator.test_create_batches_groups_correctly": {
            "name": "test_create_batches_groups_correctly",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAdaptiveIterator.test_create_batches_respects_maximum_batch_size": {
            "name": "test_create_batches_respects_maximum_batch_size",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAdaptiveIterator.test_biggest_batch_first_passes_off_to_bucket_iterator": {
            "name": "test_biggest_batch_first_passes_off_to_bucket_iterator",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAdaptiveIterator.test_from_params": {
            "name": "test_from_params",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/iterators/basic_iterator_test.py": {
        "IteratorTest.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IteratorTest.create_instance": {
            "name": "create_instance",
            "location": 41,
            "return": [],
            "arguments": {
                "self": [],
                "str_tokens": [
                    "List[str]"
                ]
            }
        },
        "IteratorTest.assert_instances_are_correct": {
            "name": "assert_instances_are_correct",
            "location": 47,
            "return": [],
            "arguments": {
                "self": [],
                "candidate_instances": []
            }
        },
        "TestBasicIterator.test_get_num_batches": {
            "name": "test_get_num_batches",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_yield_one_epoch_iterates_over_the_data_once": {
            "name": "test_yield_one_epoch_iterates_over_the_data_once",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_call_iterates_over_data_forever": {
            "name": "test_call_iterates_over_data_forever",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_create_batches_groups_correctly": {
            "name": "test_create_batches_groups_correctly",
            "location": 91,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_few_instances_per_epoch": {
            "name": "test_few_instances_per_epoch",
            "location": 101,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_many_instances_per_epoch": {
            "name": "test_many_instances_per_epoch",
            "location": 121,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_shuffle": {
            "name": "test_shuffle",
            "location": 141,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_max_instances_in_memory": {
            "name": "test_max_instances_in_memory",
            "location": 161,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_multiple_cursors": {
            "name": "test_multiple_cursors",
            "location": 172,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_from_params": {
            "name": "test_from_params",
            "location": 205,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IteratorTest.setUp.LazyIterable.__iter__": {
            "name": "__iter__",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/iterators/bucket_iterator_test.py": {
        "TestBucketIterator.test_create_batches_groups_correctly": {
            "name": "test_create_batches_groups_correctly",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBucketIterator.test_create_batches_groups_correctly_with_max_instances": {
            "name": "test_create_batches_groups_correctly_with_max_instances",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBucketIterator.test_biggest_batch_first_works": {
            "name": "test_biggest_batch_first_works",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBucketIterator.test_from_params": {
            "name": "test_from_params",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/iterators/__init__.py": {},
    "allennlp-dureader-master/tests/data/tokenizers/character_tokenizer_test.py": {
        "TestCharacterTokenizer.test_splits_into_characters": {
            "name": "test_splits_into_characters",
            "location": 7,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCharacterTokenizer.test_batch_tokenization": {
            "name": "test_batch_tokenization",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCharacterTokenizer.test_handles_byte_encoding": {
            "name": "test_handles_byte_encoding",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/tokenizers/word_splitter_test.py": {
        "TestSimpleWordSplitter.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_complex_punctuation": {
            "name": "test_tokenize_handles_complex_punctuation",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_contraction": {
            "name": "test_tokenize_handles_contraction",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_batch_tokenization": {
            "name": "test_batch_tokenization",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_multiple_contraction": {
            "name": "test_tokenize_handles_multiple_contraction",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_final_apostrophe": {
            "name": "test_tokenize_handles_final_apostrophe",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_special_cases": {
            "name": "test_tokenize_handles_special_cases",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.setUp": {
            "name": "setUp",
            "location": 63,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.test_tokenize_handles_complex_punctuation": {
            "name": "test_tokenize_handles_complex_punctuation",
            "location": 67,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.test_tokenize_handles_unicode_letters": {
            "name": "test_tokenize_handles_unicode_letters",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.test_tokenize_handles_splits_all_punctuation": {
            "name": "test_tokenize_handles_splits_all_punctuation",
            "location": 81,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.setUp": {
            "name": "setUp",
            "location": 90,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_complex_punctuation": {
            "name": "test_tokenize_handles_complex_punctuation",
            "location": 94,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_contraction": {
            "name": "test_tokenize_handles_contraction",
            "location": 106,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_multiple_contraction": {
            "name": "test_tokenize_handles_multiple_contraction",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_final_apostrophe": {
            "name": "test_tokenize_handles_final_apostrophe",
            "location": 120,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_removes_whitespace_tokens": {
            "name": "test_tokenize_removes_whitespace_tokens",
            "location": 126,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_special_cases": {
            "name": "test_tokenize_handles_special_cases",
            "location": 132,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/tokenizers/word_tokenizer_test.py": {
        "TestWordTokenizer.test_passes_through_correctly": {
            "name": "test_passes_through_correctly",
            "location": 8,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordTokenizer.test_batch_tokenization": {
            "name": "test_batch_tokenization",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordTokenizer.test_stems_and_filters_correctly": {
            "name": "test_stems_and_filters_correctly",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/tokenizers/__init__.py": {},
    "allennlp-dureader-master/tests/data/token_indexers/character_token_indexer_test.py": {
        "CharacterTokenIndexerTest.test_count_vocab_items_respects_casing": {
            "name": "test_count_vocab_items_respects_casing",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CharacterTokenIndexerTest.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CharacterTokenIndexerTest.test_token_to_indices_produces_correct_characters": {
            "name": "test_token_to_indices_produces_correct_characters",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/dep_label_indexer_test.py": {
        "TestDepLabelIndexer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_count_vocab_items_uses_pos_tags": {
            "name": "test_count_vocab_items_uses_pos_tags",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_token_to_indices_uses_pos_tags": {
            "name": "test_token_to_indices_uses_pos_tags",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_padding_functions": {
            "name": "test_padding_functions",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/elmo_indexer_test.py": {
        "TestELMoTokenCharactersIndexer.test_bos_to_char_ids": {
            "name": "test_bos_to_char_ids",
            "location": 8,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestELMoTokenCharactersIndexer.test_eos_to_char_ids": {
            "name": "test_eos_to_char_ids",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestELMoTokenCharactersIndexer.test_unicode_to_char_ids": {
            "name": "test_unicode_to_char_ids",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestELMoTokenCharactersIndexer.test_elmo_as_array_produces_token_sequence": {
            "name": "test_elmo_as_array_produces_token_sequence",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/ner_tag_indexer_test.py": {
        "TestNerTagIndexer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_count_vocab_items_uses_ner_tags": {
            "name": "test_count_vocab_items_uses_ner_tags",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_token_to_indices_uses_ner_tags": {
            "name": "test_token_to_indices_uses_ner_tags",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_padding_functions": {
            "name": "test_padding_functions",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/pos_tag_indexer_test.py": {
        "TestPosTagIndexer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_count_vocab_items_uses_pos_tags": {
            "name": "test_count_vocab_items_uses_pos_tags",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_token_to_indices_uses_pos_tags": {
            "name": "test_token_to_indices_uses_pos_tags",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_padding_functions": {
            "name": "test_padding_functions",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/single_id_token_indexer_test.py": {
        "TestSingleIdTokenIndexer.test_count_vocab_items_respects_casing": {
            "name": "test_count_vocab_items_respects_casing",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSingleIdTokenIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/__init__.py": {},
    "allennlp-dureader-master/tests/models/archival_test.py": {
        "ArchivalTest.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ArchivalTest.test_archiving": {
            "name": "test_archiving",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ArchivalTest.test_extra_files": {
            "name": "test_extra_files",
            "location": 77,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/biattentive_classification_network_test.py": {
        "BiattentiveClassificationNetworkMaxoutTest.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_maxout_bcn_can_train_save_and_load": {
            "name": "test_maxout_bcn_can_train_save_and_load",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_feedforward_bcn_can_train_save_and_load": {
            "name": "test_feedforward_bcn_can_train_save_and_load",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/constituency_parser_test.py": {
        "SpanConstituencyParserTest.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.tearDown": {
            "name": "tearDown",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_span_parser_can_save_and_load": {
            "name": "test_span_parser_can_save_and_load",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_forward_can_handle_a_single_word_as_input": {
            "name": "test_forward_can_handle_a_single_word_as_input",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_decode_runs": {
            "name": "test_decode_runs",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_resolve_overlap_conflicts_greedily": {
            "name": "test_resolve_overlap_conflicts_greedily",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_construct_tree_from_spans": {
            "name": "test_construct_tree_from_spans",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_construct_tree_from_spans_handles_nested_labels": {
            "name": "test_construct_tree_from_spans_handles_nested_labels",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_tree_construction_with_too_few_spans_creates_trees_with_depth_one_word_nodes": {
            "name": "test_tree_construction_with_too_few_spans_creates_trees_with_depth_one_word_nodes",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/crf_tagger_test.py": {
        "CrfTaggerTest.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_simple_tagger_can_train_save_and_load": {
            "name": "test_simple_tagger_can_train_save_and_load",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/decomposable_attention_test.py": {
        "TestDecomposableAttention.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_model_can_train_save_and_load": {
            "name": "test_model_can_train_save_and_load",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_model_load": {
            "name": "test_model_load",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_mismatched_dimensions_raise_configuration_errors": {
            "name": "test_mismatched_dimensions_raise_configuration_errors",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/semantic_role_labeler_test.py": {
        "SemanticRoleLabelerTest.setUp": {
            "name": "setUp",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_srl_model_can_train_save_and_load": {
            "name": "test_srl_model_can_train_save_and_load",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_decode_runs_correctly": {
            "name": "test_decode_runs_correctly",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_bio_tags_correctly_convert_to_conll_format": {
            "name": "test_bio_tags_correctly_convert_to_conll_format",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_perl_eval_script_can_run_on_printed_conll_files": {
            "name": "test_perl_eval_script_can_run_on_printed_conll_files",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 71,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/simple_tagger_test.py": {
        "SimpleTaggerTest.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_simple_tagger_can_train_save_and_load": {
            "name": "test_simple_tagger_can_train_save_and_load",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_regularization": {
            "name": "test_regularization",
            "location": 44,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerRegularizationTest.setUp": {
            "name": "setUp",
            "location": 67,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerRegularizationTest.test_regularization": {
            "name": "test_regularization",
            "location": 85,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/sniff_test.py": {
        "SniffTest.test_config": {
            "name": "test_config",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_machine_comprehension": {
            "name": "test_machine_comprehension",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_semantic_role_labeling": {
            "name": "test_semantic_role_labeling",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_textual_entailment": {
            "name": "test_textual_entailment",
            "location": 67,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_coreference_resolution": {
            "name": "test_coreference_resolution",
            "location": 91,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_ner": {
            "name": "test_ner",
            "location": 107,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_constituency_parsing": {
            "name": "test_constituency_parsing",
            "location": 117,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/__init__.py": {},
    "allennlp-dureader-master/tests/models/coreference_resolution/coref_test.py": {
        "CorefTest.setUp": {
            "name": "setUp",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CorefTest.test_coref_model_can_train_save_and_load": {
            "name": "test_coref_model_can_train_save_and_load",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CorefTest.test_decode": {
            "name": "test_decode",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/encoder_decoders/simple_seq2seq_test.py": {
        "SimpleSeq2SeqWithoutAttentionTest.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithoutAttentionTest.test_encoder_decoder_can_train_save_and_load": {
            "name": "test_encoder_decoder_can_train_save_and_load",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithoutAttentionTest.test_loss_is_computed_correctly": {
            "name": "test_loss_is_computed_correctly",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithoutAttentionTest.test_decode_runs_correctly": {
            "name": "test_decode_runs_correctly",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithAttentionTest.setUp": {
            "name": "setUp",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithAttentionTest.test_encoder_decoder_can_train_save_and_load": {
            "name": "test_encoder_decoder_can_train_save_and_load",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/encoder_decoders/__init__.py": {},
    "allennlp-dureader-master/tests/models/reading_comprehension/bidaf_ensemble_test.py": {
        "BidafEnsembleTest.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidafEnsembleTest.test_ensemble_chooses_highest_average_confidence_2": {
            "name": "test_ensemble_chooses_highest_average_confidence_2",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidafEnsembleTest.test_ensemble_chooses_highest_average_confidence_3": {
            "name": "test_ensemble_chooses_highest_average_confidence_3",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidafEnsembleTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/reading_comprehension/bidaf_test.py": {
        "BidirectionalAttentionFlowTest.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_model_can_train_save_and_load": {
            "name": "test_model_can_train_save_and_load",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_get_best_span": {
            "name": "test_get_best_span",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 113,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/tests/modules/attention_test.py": {
        "TestAttention.test_no_mask": {
            "name": "test_no_mask",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_masked": {
            "name": "test_masked",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_batched_no_mask": {
            "name": "test_batched_no_mask",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_batched_masked": {
            "name": "test_batched_masked",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_non_normalized_attention_works": {
            "name": "test_non_normalized_attention_works",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_can_build_from_params": {
            "name": "test_can_build_from_params",
            "location": 82,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/augmented_lstm_test.py": {
        "TestAugmentedLSTM.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_variable_length_sequences_return_correctly_padded_outputs": {
            "name": "test_variable_length_sequences_return_correctly_padded_outputs",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_variable_length_sequences_run_backward_return_correctly_padded_outputs": {
            "name": "test_variable_length_sequences_run_backward_return_correctly_padded_outputs",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_computes_same_function_as_pytorch_lstm": {
            "name": "test_augmented_lstm_computes_same_function_as_pytorch_lstm",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_works_with_highway_connections": {
            "name": "test_augmented_lstm_works_with_highway_connections",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_throws_error_on_non_packed_sequence_input": {
            "name": "test_augmented_lstm_throws_error_on_non_packed_sequence_input",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_is_initialized_with_correct_biases": {
            "name": "test_augmented_lstm_is_initialized_with_correct_biases",
            "location": 92,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/conditional_random_field_test.py": {
        "TestConditionalRandomField.setUp": {
            "name": "setUp",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.score": {
            "name": "score",
            "location": 44,
            "return": [],
            "arguments": {
                "self": [],
                "logits": [],
                "tags": []
            }
        },
        "TestConditionalRandomField.test_forward_works_without_mask": {
            "name": "test_forward_works_without_mask",
            "location": 59,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_forward_works_with_mask": {
            "name": "test_forward_works_with_mask",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_viterbi_tags": {
            "name": "test_viterbi_tags",
            "location": 113,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_constrained_viterbi_tags": {
            "name": "test_constrained_viterbi_tags",
            "location": 144,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_allowed_transitions": {
            "name": "test_allowed_transitions",
            "location": 169,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/elmo_test.py": {
        "ElmoTestCase.setUp": {
            "name": "setUp",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ElmoTestCase._load_sentences_embeddings": {
            "name": "_load_sentences_embeddings",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoBiLm.test_elmo_bilm": {
            "name": "test_elmo_bilm",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmo.setUp": {
            "name": "setUp",
            "location": 117,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmo._sentences_to_ids": {
            "name": "_sentences_to_ids",
            "location": 122,
            "return": [],
            "arguments": {
                "self": [],
                "sentences": []
            }
        },
        "TestElmo.test_elmo": {
            "name": "test_elmo",
            "location": 138,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmo.test_elmo_4D_input": {
            "name": "test_elmo_4D_input",
            "location": 154,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmo.test_elmo_with_module": {
            "name": "test_elmo_with_module",
            "location": 180,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoRequiresGrad._run_test": {
            "name": "_run_test",
            "location": 197,
            "return": [],
            "arguments": {
                "self": [],
                "requires_grad": []
            }
        },
        "TestElmoRequiresGrad.test_elmo_requires_grad": {
            "name": "test_elmo_requires_grad",
            "location": 214,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoRequiresGrad.test_elmo_does_not_require_grad": {
            "name": "test_elmo_does_not_require_grad",
            "location": 217,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenRepresentation.test_elmo_token_representation": {
            "name": "test_elmo_token_representation",
            "location": 222,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenRepresentation.test_elmo_token_representation_bos_eos": {
            "name": "test_elmo_token_representation_bos_eos",
            "location": 256,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/encoder_base_test.py": {
        "TestEncoderBase.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEncoderBase.test_non_stateful_states_are_sorted_correctly": {
            "name": "test_non_stateful_states_are_sorted_correctly",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEncoderBase.test_get_initial_states": {
            "name": "test_get_initial_states",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEncoderBase.test_update_states": {
            "name": "test_update_states",
            "location": 120,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/feedforward_test.py": {
        "TestFeedForward.test_init_checks_hidden_dim_consistency": {
            "name": "test_init_checks_hidden_dim_consistency",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFeedForward.test_init_checks_activation_consistency": {
            "name": "test_init_checks_activation_consistency",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFeedForward.test_forward_gives_correct_output": {
            "name": "test_forward_gives_correct_output",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/highway_test.py": {
        "TestHighway.test_forward_works_on_simple_input": {
            "name": "test_forward_works_on_simple_input",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/lstm_cell_with_projection_test.py": {
        "TestLstmCellWithProjection.test_elmo_lstm_cell_completes_forward_pass": {
            "name": "test_elmo_lstm_cell_completes_forward_pass",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/matrix_attention_test.py": {
        "TestMatrixAttention.test_forward_works_on_simple_input": {
            "name": "test_forward_works_on_simple_input",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMatrixAttention.test_can_build_from_params": {
            "name": "test_can_build_from_params",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/maxout_test.py": {
        "TestMaxout.test_init_checks_output_dims_consistency": {
            "name": "test_init_checks_output_dims_consistency",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMaxout.test_init_checks_pool_sizes_consistency": {
            "name": "test_init_checks_pool_sizes_consistency",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMaxout.test_init_checks_dropout_consistency": {
            "name": "test_init_checks_dropout_consistency",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMaxout.test_forward_gives_correct_output": {
            "name": "test_forward_gives_correct_output",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/scalar_mix_test.py": {
        "TestScalarMix.test_scalar_mix_can_run_forward": {
            "name": "test_scalar_mix_can_run_forward",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestScalarMix.test_scalar_mix_throws_error_on_incorrect_number_of_inputs": {
            "name": "test_scalar_mix_throws_error_on_incorrect_number_of_inputs",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestScalarMix.test_scalar_mix_layer_norm": {
            "name": "test_scalar_mix_layer_norm",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoder_test.py": {
        "TestSeq2SeqEncoder.test_from_params_builders_encoder_correctly": {
            "name": "test_from_params_builders_encoder_correctly",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSeq2SeqEncoder.test_from_params_requires_batch_first": {
            "name": "test_from_params_requires_batch_first",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoder_test.py": {
        "TestSeq2VecEncoder.test_from_params_builders_encoder_correctly": {
            "name": "test_from_params_builders_encoder_correctly",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSeq2VecEncoder.test_from_params_requires_batch_first": {
            "name": "test_from_params_requires_batch_first",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_pruner_test.py": {
        "TestSpanPruner.test_span_pruner_selects_top_scored_spans_and_respects_masking": {
            "name": "test_span_pruner_selects_top_scored_spans_and_respects_masking",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanPruner.test_span_scorer_raises_with_incorrect_scorer_spec": {
            "name": "test_span_scorer_raises_with_incorrect_scorer_spec",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSpanPruner.test_span_scorer_works_for_completely_masked_rows": {
            "name": "test_span_scorer_works_for_completely_masked_rows",
            "location": 52,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/stacked_alternating_lstm_test.py": {
        "TestStackedAlternatingLstm.test_stacked_alternating_lstm_completes_forward_pass": {
            "name": "test_stacked_alternating_lstm_completes_forward_pass",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStackedAlternatingLstm.test_lstms_are_interleaved": {
            "name": "test_lstms_are_interleaved",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/stacked_elmo_lstm_test.py": {
        "TestElmoLstmCell.test_elmo_lstm": {
            "name": "test_elmo_lstm",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/time_distributed_test.py": {
        "TestTimeDistributed.test_time_distributed_reshapes_correctly": {
            "name": "test_time_distributed_reshapes_correctly",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTimeDistributed.test_time_distributed_works_with_multiple_inputs": {
            "name": "test_time_distributed_works_with_multiple_inputs",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/__init__.py": {},
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/intra_sentence_attention_test.py": {
        "TestIntraSentenceAttentionEncoder.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIntraSentenceAttentionEncoder.test_constructor_asserts_multi_head_consistency": {
            "name": "test_constructor_asserts_multi_head_consistency",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIntraSentenceAttentionEncoder.test_forward_works_with_simple_attention": {
            "name": "test_forward_works_with_simple_attention",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestIntraSentenceAttentionEncoder.test_forward_works_with_multi_headed_attention": {
            "name": "test_forward_works_with_multi_headed_attention",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/multi_head_self_attention_test.py": {
        "MultiHeadSelfAttentionTest.test_multi_head_self_attention_can_build_from_params": {
            "name": "test_multi_head_self_attention_can_build_from_params",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttentionTest.test_multi_head_self_attention_runs_forward": {
            "name": "test_multi_head_self_attention_runs_forward",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttentionTest.test_multi_head_self_attention_respects_masking": {
            "name": "test_multi_head_self_attention_respects_masking",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/pass_through_encoder_test.py": {
        "TestStackedSelfAttention.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStackedSelfAttention.test_pass_through_encoder_passes_through": {
            "name": "test_pass_through_encoder_passes_through",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/pytorch_seq2seq_wrapper_test.py": {
        "TestPytorchSeq2SeqWrapper.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_works_even_with_empty_sequences": {
            "name": "test_forward_works_even_with_empty_sequences",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_pulls_out_correct_tensor_without_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_without_sequence_lengths",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_pulls_out_correct_tensor_with_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_with_sequence_lengths",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_pulls_out_correct_tensor_for_unsorted_batches": {
            "name": "test_forward_pulls_out_correct_tensor_for_unsorted_batches",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_does_not_compress_tensors_padded_to_greater_than_the_max_sequence_length": {
            "name": "test_forward_does_not_compress_tensors_padded_to_greater_than_the_max_sequence_length",
            "location": 107,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_raises_if_batch_first_is_false": {
            "name": "test_wrapper_raises_if_batch_first_is_false",
            "location": 121,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_works_when_passed_state_with_zero_length_sequences": {
            "name": "test_wrapper_works_when_passed_state_with_zero_length_sequences",
            "location": 127,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_can_call_backward_with_zero_length_sequences": {
            "name": "test_wrapper_can_call_backward_with_zero_length_sequences",
            "location": 145,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_stateful": {
            "name": "test_wrapper_stateful",
            "location": 161,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_stateful_single_state_gru": {
            "name": "test_wrapper_stateful_single_state_gru",
            "location": 185,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/stacked_self_attention_test.py": {
        "TestStackedSelfAttention.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStackedSelfAttention.test_stacked_self_attention_can_run_foward": {
            "name": "test_stacked_self_attention_can_run_foward",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/__init__.py": {},
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/boe_encoder_test.py": {
        "TestBagOfEmbeddingsEncoder.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_forward_does_correct_computation": {
            "name": "test_forward_does_correct_computation",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_forward_does_correct_computation_with_average": {
            "name": "test_forward_does_correct_computation_with_average",
            "location": 44,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_forward_does_correct_computation_with_average_no_mask": {
            "name": "test_forward_does_correct_computation_with_average_no_mask",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/cnn_encoder_test.py": {
        "TestCnnEncoder.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCnnEncoder.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCnnEncoder.test_forward_does_correct_computation": {
            "name": "test_forward_does_correct_computation",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCnnEncoder.test_forward_runs_with_larger_input": {
            "name": "test_forward_runs_with_larger_input",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/pytorch_seq2vec_wrapper_test.py": {
        "TestPytorchSeq2VecWrapper.test_get_dimensions_is_correct": {
            "name": "test_get_dimensions_is_correct",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_pulls_out_correct_tensor_without_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_without_sequence_lengths",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_pulls_out_correct_tensor_with_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_with_sequence_lengths",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_works_even_with_empty_sequences": {
            "name": "test_forward_works_even_with_empty_sequences",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_pulls_out_correct_tensor_with_unsorted_batches": {
            "name": "test_forward_pulls_out_correct_tensor_with_unsorted_batches",
            "location": 84,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_wrapper_raises_if_batch_first_is_false": {
            "name": "test_wrapper_raises_if_batch_first_is_false",
            "location": 117,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/__init__.py": {},
    "allennlp-dureader-master/tests/modules/similarity_functions/bilinear_test.py": {
        "TestBilinearSimilarityFunction.test_weights_are_correct_sizes": {
            "name": "test_weights_are_correct_sizes",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBilinearSimilarityFunction.test_forward_does_a_bilinear_product": {
            "name": "test_forward_does_a_bilinear_product",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBilinearSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBilinearSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/cosine_test.py": {
        "TestCosineSimilarityFunction.test_forward_does_a_cosine_similarity": {
            "name": "test_forward_does_a_cosine_similarity",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCosineSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestCosineSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/dot_product_test.py": {
        "TestDotProductSimilarityFunction.test_forward_does_a_dot_product": {
            "name": "test_forward_does_a_dot_product",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDotProductSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDotProductSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/linear_test.py": {
        "TestLinearSimilarityFunction.test_weights_are_correct_sizes": {
            "name": "test_weights_are_correct_sizes",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_does_a_weighted_product": {
            "name": "test_forward_does_a_weighted_product",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_multiply_combinations": {
            "name": "test_forward_works_with_multiply_combinations",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_divide_combinations": {
            "name": "test_forward_works_with_divide_combinations",
            "location": 55,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_add_combinations": {
            "name": "test_forward_works_with_add_combinations",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_subtract_combinations": {
            "name": "test_forward_works_with_subtract_combinations",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 85,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/multiheaded_test.py": {
        "TestMultiHeadedSimilarityFunction.test_weights_are_correct_sizes": {
            "name": "test_weights_are_correct_sizes",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultiHeadedSimilarityFunction.test_forward": {
            "name": "test_forward",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/__init__.py": {},
    "allennlp-dureader-master/tests/modules/span_extractors/bidirectional_endpoint_span_extractor_test.py": {
        "TestBidirectonalEndpointSpanExtractor.test_bidirectional_endpoint_span_extractor_can_build_from_params": {
            "name": "test_bidirectional_endpoint_span_extractor_can_build_from_params",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_raises_on_odd_input_dimension": {
            "name": "test_raises_on_odd_input_dimension",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_correct_sequence_elements_are_embedded": {
            "name": "test_correct_sequence_elements_are_embedded",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_correct_sequence_elements_are_embedded_with_a_masked_sequence": {
            "name": "test_correct_sequence_elements_are_embedded_with_a_masked_sequence",
            "location": 101,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_forward_raises_with_invalid_indices": {
            "name": "test_forward_raises_with_invalid_indices",
            "location": 178,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_extractors/endpoint_span_extractor_test.py": {
        "TestEndpointSpanExtractor.test_endpoint_span_extractor_can_build_from_params": {
            "name": "test_endpoint_span_extractor_can_build_from_params",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEndpointSpanExtractor.test_correct_sequence_elements_are_embedded": {
            "name": "test_correct_sequence_elements_are_embedded",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEndpointSpanExtractor.test_masked_indices_are_handled_correctly": {
            "name": "test_masked_indices_are_handled_correctly",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEndpointSpanExtractor.test_masked_indices_are_handled_correctly_with_exclusive_indices": {
            "name": "test_masked_indices_are_handled_correctly_with_exclusive_indices",
            "location": 78,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_extractors/self_attentive_span_extractor_test.py": {
        "TestSelfAttentiveSpanExtractor.test_locally_normalised_span_extractor_can_build_from_params": {
            "name": "test_locally_normalised_span_extractor_can_build_from_params",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSelfAttentiveSpanExtractor.test_attention_is_normalised_correctly": {
            "name": "test_attention_is_normalised_correctly",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_extractors/__init__.py": {},
    "allennlp-dureader-master/tests/modules/text_field_embedders/basic_text_field_embedder_test.py": {
        "TestBasicTextFieldEmbedder.setUp": {
            "name": "setUp",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_get_output_dim_aggregates_dimension_from_each_embedding": {
            "name": "test_get_output_dim_aggregates_dimension_from_each_embedding",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_forward_asserts_input_field_match": {
            "name": "test_forward_asserts_input_field_match",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_forward_concats_resultant_embeddings": {
            "name": "test_forward_concats_resultant_embeddings",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_forward_works_on_higher_order_input": {
            "name": "test_forward_works_on_higher_order_input",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/text_field_embedders/__init__.py": {},
    "allennlp-dureader-master/tests/modules/token_embedders/elmo_token_embedder_test.py": {
        "TestElmoTokenEmbedder.setUp": {
            "name": "setUp",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenEmbedder.test_tagger_with_elmo_token_embedder_can_train_save_and_load": {
            "name": "test_tagger_with_elmo_token_embedder_can_train_save_and_load",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenEmbedder.test_tagger_with_elmo_token_embedder_forward_pass_runs_correctly": {
            "name": "test_tagger_with_elmo_token_embedder_forward_pass_runs_correctly",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenEmbedder.test_file_archiving": {
            "name": "test_file_archiving",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/token_embedders/embedding_test.py": {
        "TestEmbedding.test_get_embedding_layer_uses_correct_embedding_dim": {
            "name": "test_get_embedding_layer_uses_correct_embedding_dim",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_forward_works_with_projection_layer": {
            "name": "test_forward_works_with_projection_layer",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_embedding_layer_actually_initializes_word_vectors_correctly": {
            "name": "test_embedding_layer_actually_initializes_word_vectors_correctly",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_get_embedding_layer_initializes_unseen_words_randomly_not_zero": {
            "name": "test_get_embedding_layer_initializes_unseen_words_randomly_not_zero",
            "location": 67,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_read_hdf5_format_file": {
            "name": "test_read_hdf5_format_file",
            "location": 82,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_read_hdf5_raises_on_invalid_shape": {
            "name": "test_read_hdf5_raises_on_invalid_shape",
            "location": 100,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/token_embedders/token_characters_encoder_test.py": {
        "TestTokenCharactersEncoder.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTokenCharactersEncoder.test_get_output_dim_uses_encoder_output_dim": {
            "name": "test_get_output_dim_uses_encoder_output_dim",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTokenCharactersEncoder.test_forward_applies_embedding_then_encoder": {
            "name": "test_forward_applies_embedding_then_encoder",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/token_embedders/__init__.py": {},
    "allennlp-dureader-master/tests/nn/initializers_test.py": {
        "TestInitializers.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.tearDown": {
            "name": "tearDown",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_regex_matches_are_initialized_correctly": {
            "name": "test_regex_matches_are_initialized_correctly",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_block_orthogonal_can_initialize": {
            "name": "test_block_orthogonal_can_initialize",
            "location": 55,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_block_orthogonal_raises_on_mismatching_dimensions": {
            "name": "test_block_orthogonal_raises_on_mismatching_dimensions",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_uniform_unit_scaling_can_initialize": {
            "name": "test_uniform_unit_scaling_can_initialize",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_block_orthogonal_can_initialize.test_block_is_orthogonal": {
            "name": "test_block_is_orthogonal",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "block": []
            }
        },
        "TestInitializers.test_regex_matches_are_initialized_correctly.Net.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_regex_matches_are_initialized_correctly.Net.forward": {
            "name": "forward",
            "location": 34,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": []
            }
        }
    },
    "allennlp-dureader-master/tests/nn/regularizers_test.py": {
        "TestRegularizers.test_l1_regularization": {
            "name": "test_l1_regularization",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegularizers.test_l2_regularization": {
            "name": "test_l2_regularization",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegularizers.test_regularizer_applicator_respects_regex_matching": {
            "name": "test_regularizer_applicator_respects_regex_matching",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestRegularizers.test_from_params": {
            "name": "test_from_params",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/nn/util_test.py": {
        "TestNnUtil.test_get_sequence_lengths_from_binary_mask": {
            "name": "test_get_sequence_lengths_from_binary_mask",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_sequence_lengths_converts_to_long_tensor_and_avoids_variable_overflow": {
            "name": "test_get_sequence_lengths_converts_to_long_tensor_and_avoids_variable_overflow",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sort_tensor_by_length": {
            "name": "test_sort_tensor_by_length",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sort_tensor_by_length_raises_on_non_variable_inputs": {
            "name": "test_sort_tensor_by_length_raises_on_non_variable_inputs",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_final_encoder_states": {
            "name": "test_get_final_encoder_states",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_masked_softmax_no_mask": {
            "name": "test_masked_softmax_no_mask",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_masked_softmax_masked": {
            "name": "test_masked_softmax_masked",
            "location": 108,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_masked_log_softmax_masked": {
            "name": "test_masked_log_softmax_masked",
            "location": 187,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_text_field_mask_returns_a_correct_mask": {
            "name": "test_get_text_field_mask_returns_a_correct_mask",
            "location": 220,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_text_field_mask_returns_a_correct_mask_character_only_input": {
            "name": "test_get_text_field_mask_returns_a_correct_mask_character_only_input",
            "location": 229,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_text_field_mask_returns_a_correct_mask_list_field": {
            "name": "test_get_text_field_mask_returns_a_correct_mask_list_field",
            "location": 237,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_last_dim_softmax_does_softmax_on_last_dim": {
            "name": "test_last_dim_softmax_does_softmax_on_last_dim",
            "location": 246,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_last_dim_softmax_handles_mask_correctly": {
            "name": "test_last_dim_softmax_handles_mask_correctly",
            "location": 264,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_works_on_simple_input": {
            "name": "test_weighted_sum_works_on_simple_input",
            "location": 283,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_handles_higher_order_input": {
            "name": "test_weighted_sum_handles_higher_order_input",
            "location": 299,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_handles_uneven_higher_order_input": {
            "name": "test_weighted_sum_handles_uneven_higher_order_input",
            "location": 315,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_handles_3d_attention_with_3d_matrix": {
            "name": "test_weighted_sum_handles_3d_attention_with_3d_matrix",
            "location": 334,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_viterbi_decode": {
            "name": "test_viterbi_decode",
            "location": 351,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sequence_cross_entropy_with_logits_masks_loss_correctly": {
            "name": "test_sequence_cross_entropy_with_logits_masks_loss_correctly",
            "location": 426,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sequence_cross_entropy_with_logits_smooths_labels_correctly": {
            "name": "test_sequence_cross_entropy_with_logits_smooths_labels_correctly",
            "location": 453,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sequence_cross_entropy_with_logits_averages_batch_correctly": {
            "name": "test_sequence_cross_entropy_with_logits_averages_batch_correctly",
            "location": 472,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_replace_masked_values_replaces_masked_values_with_finite_value": {
            "name": "test_replace_masked_values_replaces_masked_values_with_finite_value",
            "location": 493,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_logsumexp": {
            "name": "test_logsumexp",
            "location": 499,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_flatten_and_batch_shift_indices": {
            "name": "test_flatten_and_batch_shift_indices",
            "location": 517,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_batched_index_select": {
            "name": "test_batched_index_select",
            "location": 531,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_flattened_index_select": {
            "name": "test_flattened_index_select",
            "location": 556,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_bucket_values": {
            "name": "test_bucket_values",
            "location": 584,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_add_sentence_boundary_token_ids_handles_2D_input": {
            "name": "test_add_sentence_boundary_token_ids_handles_2D_input",
            "location": 590,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_add_sentence_boundary_token_ids_handles_3D_input": {
            "name": "test_add_sentence_boundary_token_ids_handles_3D_input",
            "location": 601,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_remove_sentence_boundaries": {
            "name": "test_remove_sentence_boundaries",
            "location": 626,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_add_positional_features": {
            "name": "test_add_positional_features",
            "location": 648,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/nn/__init__.py": {},
    "allennlp-dureader-master/tests/service/server_flask_test.py": {
        "CountingPredictor.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CountingPredictor.predict_json": {
            "name": "predict_json",
            "location": 39,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "JsonDict"
                ],
                "cuda_device": [
                    "int"
                ]
            }
        },
        "TestFlask.setUp": {
            "name": "setUp",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.post_json": {
            "name": "post_json",
            "location": 60,
            "return": [
                "Response"
            ],
            "arguments": {
                "self": [],
                "endpoint": [
                    "str"
                ],
                "data": [
                    "JsonDict"
                ]
            }
        },
        "TestFlask.tearDown": {
            "name": "tearDown",
            "location": 66,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_list_models": {
            "name": "test_list_models",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_unknown_model": {
            "name": "test_unknown_model",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_machine_comprehension": {
            "name": "test_machine_comprehension",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_textual_entailment": {
            "name": "test_textual_entailment",
            "location": 95,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_semantic_role_labeling": {
            "name": "test_semantic_role_labeling",
            "location": 103,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_caching": {
            "name": "test_caching",
            "location": 110,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_disable_caching": {
            "name": "test_disable_caching",
            "location": 150,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_missing_static_dir": {
            "name": "test_missing_static_dir",
            "location": 176,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_permalinks_fail_gracefully_with_no_database": {
            "name": "test_permalinks_fail_gracefully_with_no_database",
            "location": 183,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_permalinks_work": {
            "name": "test_permalinks_work",
            "location": 204,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_permalinks_work.post": {
            "name": "post",
            "location": 212,
            "return": [
                "Response"
            ],
            "arguments": {
                "endpoint": [
                    "str"
                ],
                "data": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/service/server_simple_test.py": {
        "post_json": {
            "name": "post_json",
            "location": 15,
            "return": [
                "flask.Response"
            ],
            "arguments": {
                "client": [
                    "flask.testing.FlaskClient"
                ],
                "endpoint": [
                    "str"
                ],
                "data": [
                    "JsonDict"
                ]
            }
        },
        "TestSimpleServer.setUp": {
            "name": "setUp",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.tearDown": {
            "name": "tearDown",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_standard_model": {
            "name": "test_standard_model",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_sanitizer": {
            "name": "test_sanitizer",
            "location": 61,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_static_dir": {
            "name": "test_static_dir",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_sanitizer.sanitize": {
            "name": "sanitize",
            "location": 62,
            "return": [
                "JsonDict"
            ],
            "arguments": {
                "result": [
                    "JsonDict"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/service/__init__.py": {},
    "allennlp-dureader-master/tests/service/predictors/bidaf_test.py": {
        "TestBidafPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBidafPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/constituency_parser_test.py": {
        "TestConstituencyParserPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConstituencyParserPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestConstituencyParserPredictor.test_build_hierplane_tree": {
            "name": "test_build_hierplane_tree",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/coref_test.py": {
        "TestCorefPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/decomposable_attention_test.py": {
        "TestDecomposableAttentionPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttentionPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/simple_seq2seq_test.py": {
        "TestSimpleSeq2SeqPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/srl_test.py": {
        "TestSrlPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSrlPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSrlPredictor.test_prediction_with_no_verbs": {
            "name": "test_prediction_with_no_verbs",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/__init__.py": {},
    "allennlp-dureader-master/tests/training/optimizer_test.py": {
        "TestOptimizer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestOptimizer.test_optimizer_basic": {
            "name": "test_optimizer_basic",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestOptimizer.test_optimizer_parameter_groups": {
            "name": "test_optimizer_parameter_groups",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/trainer_test.py": {
        "TestTrainer.setUp": {
            "name": "setUp",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_run": {
            "name": "test_trainer_can_run",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_run_cuda": {
            "name": "test_trainer_can_run_cuda",
            "location": 73,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_run_multiple_gpu": {
            "name": "test_trainer_can_run_multiple_gpu",
            "location": 81,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_resume_training": {
            "name": "test_trainer_can_resume_training",
            "location": 89,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_should_stop_early_with_increasing_metric": {
            "name": "test_should_stop_early_with_increasing_metric",
            "location": 107,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_should_stop_early_with_decreasing_metric": {
            "name": "test_should_stop_early_with_decreasing_metric",
            "location": 116,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_train_driver_raises_on_model_with_no_loss_key": {
            "name": "test_train_driver_raises_on_model_with_no_loss_key",
            "location": 125,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_log_histograms": {
            "name": "test_trainer_can_log_histograms",
            "location": 136,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_respects_num_serialized_models_to_keep": {
            "name": "test_trainer_respects_num_serialized_models_to_keep",
            "location": 147,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_respects_keep_serialized_model_every_num_seconds": {
            "name": "test_trainer_respects_keep_serialized_model_every_num_seconds",
            "location": 161,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_saves_models_at_specified_interval": {
            "name": "test_trainer_saves_models_at_specified_interval",
            "location": 192,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSparseClipGrad.test_sparse_clip_grad": {
            "name": "test_sparse_clip_grad",
            "location": 233,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_train_driver_raises_on_model_with_no_loss_key.FakeModel.forward": {
            "name": "forward",
            "location": 128,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_respects_keep_serialized_model_every_num_seconds.WaitingIterator._create_batches": {
            "name": "_create_batches",
            "location": 170,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/__init__.py": {},
    "allennlp-dureader-master/tests/training/metrics/boolean_accuracy_test.py": {
        "BooleanAccuracyTest.test_accuracy_computation": {
            "name": "test_accuracy_computation",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/categorical_accuracy_test.py": {
        "CategoricalAccuracyTest.test_categorical_accuracy": {
            "name": "test_categorical_accuracy",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy": {
            "name": "test_top_k_categorical_accuracy",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_accumulates_and_resets_correctly": {
            "name": "test_top_k_categorical_accuracy_accumulates_and_resets_correctly",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_respects_mask": {
            "name": "test_top_k_categorical_accuracy_respects_mask",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_works_for_sequences": {
            "name": "test_top_k_categorical_accuracy_works_for_sequences",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_catches_exceptions": {
            "name": "test_top_k_categorical_accuracy_catches_exceptions",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/entropy_test.py": {
        "EntropyTest.test_low_entropy_distribution": {
            "name": "test_low_entropy_distribution",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EntropyTest.test_entropy_for_uniform_distribution": {
            "name": "test_entropy_for_uniform_distribution",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EntropyTest.test_masked_case": {
            "name": "test_masked_case",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/evalb_bracketing_scorer_test.py": {
        "EvalbBracketingScorerTest.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.tearDown": {
            "name": "tearDown",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_correctly_scores_identical_trees": {
            "name": "test_evalb_correctly_scores_identical_trees",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_correctly_scores_imperfect_trees": {
            "name": "test_evalb_correctly_scores_imperfect_trees",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_correctly_calculates_bracketing_metrics_over_multiple_trees": {
            "name": "test_evalb_correctly_calculates_bracketing_metrics_over_multiple_trees",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_with_terrible_trees_handles_nan_f1": {
            "name": "test_evalb_with_terrible_trees_handles_nan_f1",
            "location": 52,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/f1_measure_test.py": {
        "F1MeasureTest.test_f1_measure_catches_exceptions": {
            "name": "test_f1_measure_catches_exceptions",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "F1MeasureTest.test_f1_measure": {
            "name": "test_f1_measure",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "F1MeasureTest.test_f1_measure_accumulates_and_resets_correctly": {
            "name": "test_f1_measure_accumulates_and_resets_correctly",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "F1MeasureTest.test_f1_measure_works_for_sequences": {
            "name": "test_f1_measure_works_for_sequences",
            "location": 81,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/span_based_f1_measure_test.py": {
        "SpanBasedF1Test.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_metrics_are_computed_correcly_with_prediction_map": {
            "name": "test_span_metrics_are_computed_correcly_with_prediction_map",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_metrics_are_computed_correctly": {
            "name": "test_span_metrics_are_computed_correctly",
            "location": 110,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_f1_can_build_from_params": {
            "name": "test_span_f1_can_build_from_params",
            "location": 170,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_f1_matches_perl_script_for_continued_arguments": {
            "name": "test_span_f1_matches_perl_script_for_continued_arguments",
            "location": 176,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/__init__.py": {},
    "allennlp-dureader-master/tools/distributed_utils.py": {
        "average_gradients": {
            "name": "average_gradients",
            "location": 9,
            "return": [],
            "arguments": {
                "model": []
            }
        },
        "broadcast_params": {
            "name": "broadcast_params",
            "location": 15,
            "return": [],
            "arguments": {
                "model": []
            }
        },
        "dist_init": {
            "name": "dist_init",
            "location": 20,
            "return": [],
            "arguments": {
                "port": [],
                "backend": []
            }
        }
    },
    "allennlp-dureader-master/tools/dureader_eval.py": {
        "normalize": {
            "name": "normalize",
            "location": 37,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "data_check": {
            "name": "data_check",
            "location": 56,
            "return": [],
            "arguments": {
                "obj": [],
                "task": []
            }
        },
        "read_file": {
            "name": "read_file",
            "location": 82,
            "return": [],
            "arguments": {
                "file_name": [],
                "task": [],
                "is_ref": []
            }
        },
        "compute_bleu_rouge": {
            "name": "compute_bleu_rouge",
            "location": 127,
            "return": [],
            "arguments": {
                "pred_dict": [],
                "ref_dict": [],
                "bleu_order": []
            }
        },
        "local_prf": {
            "name": "local_prf",
            "location": 142,
            "return": [],
            "arguments": {
                "pred_list": [],
                "ref_list": []
            }
        },
        "compute_prf": {
            "name": "compute_prf",
            "location": 157,
            "return": [],
            "arguments": {
                "pred_dict": [],
                "ref_dict": []
            }
        },
        "prepare_prf": {
            "name": "prepare_prf",
            "location": 194,
            "return": [],
            "arguments": {
                "pred_dict": [],
                "ref_dict": []
            }
        },
        "filter_dict": {
            "name": "filter_dict",
            "location": 203,
            "return": [],
            "arguments": {
                "result_dict": [],
                "key_tag": []
            }
        },
        "get_metrics": {
            "name": "get_metrics",
            "location": 214,
            "return": [],
            "arguments": {
                "pred_result": [],
                "ref_result": [],
                "task": [],
                "source": []
            }
        },
        "prepare_bleu": {
            "name": "prepare_bleu",
            "location": 267,
            "return": [],
            "arguments": {
                "pred_result": [],
                "ref_result": [],
                "task": []
            }
        },
        "get_main_result": {
            "name": "get_main_result",
            "location": 304,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_entity_result": {
            "name": "get_entity_result",
            "location": 329,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_desc_result": {
            "name": "get_desc_result",
            "location": 349,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_yesno_result": {
            "name": "get_yesno_result",
            "location": 369,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_all_result": {
            "name": "get_all_result",
            "location": 426,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "format_metrics": {
            "name": "format_metrics",
            "location": 446,
            "return": [],
            "arguments": {
                "metrics": [],
                "task": [],
                "err_msg": []
            }
        },
        "main": {
            "name": "main",
            "location": 514,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "read_file._open": {
            "name": "_open",
            "location": 99,
            "return": [],
            "arguments": {
                "file_name": [],
                "mode": [],
                "zip_obj": []
            }
        },
        "get_yesno_result._uniq": {
            "name": "_uniq",
            "location": 384,
            "return": [],
            "arguments": {
                "li": [],
                "is_ref": []
            }
        },
        "get_yesno_result._expand_result": {
            "name": "_expand_result",
            "location": 402,
            "return": [],
            "arguments": {
                "uniq_li": []
            }
        },
        "get_yesno_result._get_yesno_ans": {
            "name": "_get_yesno_ans",
            "location": 409,
            "return": [],
            "arguments": {
                "qid": [],
                "result_dict": [],
                "is_ref": []
            }
        }
    },
    "allennlp-dureader-master/tools/load_helper.py": {
        "check_keys": {
            "name": "check_keys",
            "location": 5,
            "return": [],
            "arguments": {
                "model": [],
                "pretrained_state_dict": []
            }
        },
        "load_pretrain": {
            "name": "load_pretrain",
            "location": 18,
            "return": [],
            "arguments": {
                "model": [],
                "pretrained_path": []
            }
        },
        "restore_from": {
            "name": "restore_from",
            "location": 27,
            "return": [],
            "arguments": {
                "model": [],
                "optimizer": [],
                "ckpt_path": []
            }
        }
    },
    "allennlp-dureader-master/tools/log_helper.py": {
        "init_log": {
            "name": "init_log",
            "location": 10,
            "return": [],
            "arguments": {
                "name": [],
                "filter_by_rank": [],
                "level": []
            }
        },
        "print_speed": {
            "name": "print_speed",
            "location": 29,
            "return": [],
            "arguments": {
                "i": [],
                "i_time": [],
                "n": []
            }
        },
        "main": {
            "name": "main",
            "location": 40,
            "return": [],
            "arguments": {}
        }
    },
    "allennlp-dureader-master/tools/lr_helper.py": {
        "_IterLRScheduler.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [],
            "arguments": {
                "self": [],
                "optimizer": [],
                "last_iter": []
            }
        },
        "_IterLRScheduler.get_lr": {
            "name": "get_lr",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_IterLRScheduler.step": {
            "name": "step",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "iter": []
            }
        },
        "IterLinearLR.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [],
            "arguments": {
                "self": [],
                "optimizer": [],
                "gamma": [],
                "last_iter": []
            }
        },
        "IterLinearLR.get_lr": {
            "name": "get_lr",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IterExponentialLR.__init__": {
            "name": "__init__",
            "location": 60,
            "return": [],
            "arguments": {
                "self": [],
                "optimizer": [],
                "gamma": [],
                "last_iter": []
            }
        },
        "IterExponentialLR.get_lr": {
            "name": "get_lr",
            "location": 64,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tools/parse_anno_json.py": {
        "reader": {
            "name": "reader",
            "location": 5,
            "return": [],
            "arguments": {
                "input": []
            }
        },
        "writer": {
            "name": "writer",
            "location": 9,
            "return": [],
            "arguments": {
                "output": []
            }
        },
        "add_yesno_answer": {
            "name": "add_yesno_answer",
            "location": 12,
            "return": [],
            "arguments": {
                "input": [],
                "output": []
            }
        },
        "get_segmented_sentences": {
            "name": "get_segmented_sentences",
            "location": 22,
            "return": [],
            "arguments": {
                "input": [],
                "output": []
            }
        }
    },
    "allennlp-dureader-master/tools/train_val.py": {
        "get_rank_world_size": {
            "name": "get_rank_world_size",
            "location": 127,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "construct_allen_vocab_from_du_vocab": {
            "name": "construct_allen_vocab_from_du_vocab",
            "location": 141,
            "return": [],
            "arguments": {
                "du_vocab": []
            }
        },
        "prepare_du_vocab": {
            "name": "prepare_du_vocab",
            "location": 157,
            "return": [],
            "arguments": {
                "vocab_dir": [],
                "trainset": [],
                "embed_size": [],
                "args": []
            }
        },
        "build_dataloader": {
            "name": "build_dataloader",
            "location": 189,
            "return": [],
            "arguments": {
                "files": [],
                "args": [],
                "is_train": []
            }
        },
        "warmup": {
            "name": "warmup",
            "location": 200,
            "return": [],
            "arguments": {
                "model": [],
                "train_loader": [],
                "optimizer": [],
                "args": []
            }
        },
        "makedirs": {
            "name": "makedirs",
            "location": 215,
            "return": [],
            "arguments": {
                "dirs": []
            }
        },
        "main": {
            "name": "main",
            "location": 219,
            "return": [],
            "arguments": {}
        },
        "train": {
            "name": "train",
            "location": 292,
            "return": [],
            "arguments": {
                "train_loader": [],
                "model": [],
                "lr_scheduler": [],
                "epoch": [],
                "args": [],
                "warmup": []
            }
        },
        "validate": {
            "name": "validate",
            "location": 339,
            "return": [],
            "arguments": {
                "val_loader": [],
                "model": [],
                "args": []
            }
        },
        "dump_pred_results": {
            "name": "dump_pred_results",
            "location": 384,
            "return": [],
            "arguments": {
                "pred_answers": [],
                "output_file": [],
                "readable": []
            }
        },
        "evaluate": {
            "name": "evaluate",
            "location": 394,
            "return": [],
            "arguments": {
                "pred_answers": [],
                "ref_answers": []
            }
        },
        "get_ref_answers": {
            "name": "get_ref_answers",
            "location": 407,
            "return": [],
            "arguments": {
                "samples": []
            }
        },
        "get_pred_answers": {
            "name": "get_pred_answers",
            "location": 418,
            "return": [],
            "arguments": {
                "best_spans": [],
                "best_scores": [],
                "samples": []
            }
        },
        "find_best_answer": {
            "name": "find_best_answer",
            "location": 455,
            "return": [],
            "arguments": {
                "best_spans": [],
                "best_scores": [],
                "batch_size": []
            }
        },
        "get_answer_str": {
            "name": "get_answer_str",
            "location": 482,
            "return": [],
            "arguments": {
                "answer_doc": [],
                "answer_span": [],
                "sample": []
            }
        },
        "AverageMeter.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AverageMeter.reset": {
            "name": "reset",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "AverageMeter.update": {
            "name": "update",
            "location": 120,
            "return": [],
            "arguments": {
                "self": [],
                "val": [],
                "n": []
            }
        }
    },
    "allennlp-dureader-master/tools/train_word2vec.py": {},
    "allennlp-dureader-master/tools/ZQ.py": {},
    "allennlp-dureader-master/utils/dureader_eval.py": {
        "normalize": {
            "name": "normalize",
            "location": 37,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "data_check": {
            "name": "data_check",
            "location": 56,
            "return": [],
            "arguments": {
                "obj": [],
                "task": []
            }
        },
        "read_file": {
            "name": "read_file",
            "location": 82,
            "return": [],
            "arguments": {
                "file_name": [],
                "task": [],
                "is_ref": []
            }
        },
        "compute_bleu_rouge": {
            "name": "compute_bleu_rouge",
            "location": 127,
            "return": [],
            "arguments": {
                "pred_dict": [],
                "ref_dict": [],
                "bleu_order": []
            }
        },
        "local_prf": {
            "name": "local_prf",
            "location": 142,
            "return": [],
            "arguments": {
                "pred_list": [],
                "ref_list": []
            }
        },
        "compute_prf": {
            "name": "compute_prf",
            "location": 157,
            "return": [],
            "arguments": {
                "pred_dict": [],
                "ref_dict": []
            }
        },
        "prepare_prf": {
            "name": "prepare_prf",
            "location": 194,
            "return": [],
            "arguments": {
                "pred_dict": [],
                "ref_dict": []
            }
        },
        "filter_dict": {
            "name": "filter_dict",
            "location": 203,
            "return": [],
            "arguments": {
                "result_dict": [],
                "key_tag": []
            }
        },
        "get_metrics": {
            "name": "get_metrics",
            "location": 214,
            "return": [],
            "arguments": {
                "pred_result": [],
                "ref_result": [],
                "task": [],
                "source": []
            }
        },
        "prepare_bleu": {
            "name": "prepare_bleu",
            "location": 267,
            "return": [],
            "arguments": {
                "pred_result": [],
                "ref_result": [],
                "task": []
            }
        },
        "get_main_result": {
            "name": "get_main_result",
            "location": 304,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_entity_result": {
            "name": "get_entity_result",
            "location": 329,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_desc_result": {
            "name": "get_desc_result",
            "location": 349,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_yesno_result": {
            "name": "get_yesno_result",
            "location": 369,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "get_all_result": {
            "name": "get_all_result",
            "location": 426,
            "return": [],
            "arguments": {
                "qid": [],
                "pred_result": [],
                "ref_result": []
            }
        },
        "format_metrics": {
            "name": "format_metrics",
            "location": 446,
            "return": [],
            "arguments": {
                "metrics": [],
                "task": [],
                "err_msg": []
            }
        },
        "main": {
            "name": "main",
            "location": 514,
            "return": [],
            "arguments": {
                "args": []
            }
        },
        "read_file._open": {
            "name": "_open",
            "location": 99,
            "return": [],
            "arguments": {
                "file_name": [],
                "mode": [],
                "zip_obj": []
            }
        },
        "get_yesno_result._uniq": {
            "name": "_uniq",
            "location": 384,
            "return": [],
            "arguments": {
                "li": [],
                "is_ref": []
            }
        },
        "get_yesno_result._expand_result": {
            "name": "_expand_result",
            "location": 402,
            "return": [],
            "arguments": {
                "uniq_li": []
            }
        },
        "get_yesno_result._get_yesno_ans": {
            "name": "_get_yesno_ans",
            "location": 409,
            "return": [],
            "arguments": {
                "qid": [],
                "result_dict": [],
                "is_ref": []
            }
        }
    },
    "allennlp-dureader-master/utils/filter_passage_by_title_question_f1.py": {
        "to_list": {
            "name": "to_list",
            "location": 5,
            "return": [],
            "arguments": {
                "text": []
            }
        }
    },
    "allennlp-dureader-master/utils/get_vocab.py": {
        "get_vocab": {
            "name": "get_vocab",
            "location": 29,
            "return": [],
            "arguments": {
                "files": [],
                "vocab_file": []
            }
        }
    },
    "allennlp-dureader-master/utils/preprocess.py": {
        "precision_recall_f1": {
            "name": "precision_recall_f1",
            "location": 29,
            "return": [],
            "arguments": {
                "prediction": [],
                "ground_truth": []
            }
        },
        "recall": {
            "name": "recall",
            "location": 58,
            "return": [],
            "arguments": {
                "prediction": [],
                "ground_truth": []
            }
        },
        "f1_score": {
            "name": "f1_score",
            "location": 72,
            "return": [],
            "arguments": {
                "prediction": [],
                "ground_truth": []
            }
        },
        "metric_max_over_ground_truths": {
            "name": "metric_max_over_ground_truths",
            "location": 86,
            "return": [],
            "arguments": {
                "metric_fn": [],
                "prediction": [],
                "ground_truths": []
            }
        },
        "find_best_question_match": {
            "name": "find_best_question_match",
            "location": 105,
            "return": [],
            "arguments": {
                "doc": [],
                "question": [],
                "with_score": []
            }
        },
        "find_fake_answer": {
            "name": "find_fake_answer",
            "location": 142,
            "return": [],
            "arguments": {
                "sample": []
            }
        }
    },
    "allennlp-dureader-master/utils/__init__.py": {},
    "allennlp-dureader-master/utils/bleu_metric/bleu.py": {
        "Bleu.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [],
            "arguments": {
                "self": [],
                "n": []
            }
        },
        "Bleu.compute_score": {
            "name": "compute_score",
            "location": 21,
            "return": [],
            "arguments": {
                "self": [],
                "gts": [],
                "res": []
            }
        },
        "Bleu.method": {
            "name": "method",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/utils/bleu_metric/bleu_scorer.py": {
        "precook": {
            "name": "precook",
            "location": 23,
            "return": [],
            "arguments": {
                "s": [],
                "n": [],
                "out": []
            }
        },
        "cook_refs": {
            "name": "cook_refs",
            "location": 35,
            "return": [],
            "arguments": {
                "refs": [],
                "eff": [],
                "n": []
            }
        },
        "cook_test": {
            "name": "cook_test",
            "location": 60,
            "return": [],
            "arguments": {
                "test": [],
                "xxx_todo_changeme": [],
                "eff": [],
                "n": []
            }
        },
        "BleuScorer.copy": {
            "name": "copy",
            "location": 92,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BleuScorer.__init__": {
            "name": "__init__",
            "location": 100,
            "return": [],
            "arguments": {
                "self": [],
                "test": [],
                "refs": [],
                "n": [],
                "special_reflen": []
            }
        },
        "BleuScorer.cook_append": {
            "name": "cook_append",
            "location": 109,
            "return": [],
            "arguments": {
                "self": [],
                "test": [],
                "refs": []
            }
        },
        "BleuScorer.ratio": {
            "name": "ratio",
            "location": 122,
            "return": [],
            "arguments": {
                "self": [],
                "option": []
            }
        },
        "BleuScorer.score_ratio": {
            "name": "score_ratio",
            "location": 126,
            "return": [],
            "arguments": {
                "self": [],
                "option": []
            }
        },
        "BleuScorer.score_ratio_str": {
            "name": "score_ratio_str",
            "location": 130,
            "return": [],
            "arguments": {
                "self": [],
                "option": []
            }
        },
        "BleuScorer.reflen": {
            "name": "reflen",
            "location": 133,
            "return": [],
            "arguments": {
                "self": [],
                "option": []
            }
        },
        "BleuScorer.testlen": {
            "name": "testlen",
            "location": 137,
            "return": [],
            "arguments": {
                "self": [],
                "option": []
            }
        },
        "BleuScorer.retest": {
            "name": "retest",
            "location": 141,
            "return": [],
            "arguments": {
                "self": [],
                "new_test": []
            }
        },
        "BleuScorer.rescore": {
            "name": "rescore",
            "location": 152,
            "return": [],
            "arguments": {
                "self": [],
                "new_test": []
            }
        },
        "BleuScorer.size": {
            "name": "size",
            "location": 157,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BleuScorer.__iadd__": {
            "name": "__iadd__",
            "location": 161,
            "return": [],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "BleuScorer.compatible": {
            "name": "compatible",
            "location": 175,
            "return": [],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "BleuScorer.single_reflen": {
            "name": "single_reflen",
            "location": 178,
            "return": [],
            "arguments": {
                "self": [],
                "option": []
            }
        },
        "BleuScorer._single_reflen": {
            "name": "_single_reflen",
            "location": 181,
            "return": [],
            "arguments": {
                "self": [],
                "reflens": [],
                "option": [],
                "testlen": []
            }
        },
        "BleuScorer.recompute_score": {
            "name": "recompute_score",
            "location": 194,
            "return": [],
            "arguments": {
                "self": [],
                "option": [],
                "verbose": []
            }
        },
        "BleuScorer.compute_score": {
            "name": "compute_score",
            "location": 198,
            "return": [],
            "arguments": {
                "self": [],
                "option": [],
                "verbose": []
            }
        }
    },
    "allennlp-dureader-master/utils/bleu_metric/__init__.py": {},
    "allennlp-dureader-master/utils/rouge_metric/rouge.py": {
        "my_lcs": {
            "name": "my_lcs",
            "location": 13,
            "return": [],
            "arguments": {
                "string": [],
                "sub": []
            }
        },
        "Rouge.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Rouge.calc_score": {
            "name": "calc_score",
            "location": 45,
            "return": [],
            "arguments": {
                "self": [],
                "candidate": [],
                "refs": []
            }
        },
        "Rouge.compute_score": {
            "name": "compute_score",
            "location": 77,
            "return": [],
            "arguments": {
                "self": [],
                "gts": [],
                "res": []
            }
        },
        "Rouge.method": {
            "name": "method",
            "location": 104,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/utils/rouge_metric/__init__.py": {}
}
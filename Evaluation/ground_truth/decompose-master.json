{
    "decompose-master/setup.py": {},
    "decompose-master/decompose/sklearn.py": {
        "DECOMPOSE.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "modelDirectory": [
                    "str"
                ],
                "priors": [
                    "Tuple[(Distribution, ...)]"
                ],
                "n_components": [
                    "int"
                ],
                "isFullyObserved": [
                    "bool"
                ],
                "dtype": [
                    "type"
                ],
                "maxIterations": [
                    "int"
                ],
                "cv": [
                    "CV"
                ],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "stopCriterionInit": [
                    "StopCriterion"
                ],
                "stopCriterionEM": [
                    "StopCriterion"
                ],
                "stopCriterionBCD": [
                    "StopCriterion"
                ],
                "device": [
                    "str"
                ]
            }
        },
        "DECOMPOSE.noiseUniformity": {
            "name": "noiseUniformity",
            "location": 63,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.cv": {
            "name": "cv",
            "location": 67,
            "return": [
                "CV"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.n_components": {
            "name": "n_components",
            "location": 71,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.components_": {
            "name": "components_",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.variance_ratio_": {
            "name": "variance_ratio_",
            "location": 83,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.trainMask": {
            "name": "trainMask",
            "location": 87,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.testMask": {
            "name": "testMask",
            "location": 91,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.observedMask": {
            "name": "observedMask",
            "location": 95,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "DECOMPOSE.__calc_variance_ratio": {
            "name": "__calc_variance_ratio",
            "location": 98,
            "return": [],
            "arguments": {
                "self": [],
                "data": [],
                "U": []
            }
        },
        "DECOMPOSE.fit": {
            "name": "fit",
            "location": 112,
            "return": [
                "'DECOMPOSE'"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "DECOMPOSE.fit_transform": {
            "name": "fit_transform",
            "location": 163,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ]
            }
        },
        "DECOMPOSE.transform": {
            "name": "transform",
            "location": 170,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "np.ndarray"
                ],
                "transformModelDirectory": [
                    "str"
                ]
            }
        }
    },
    "decompose-master/decompose/version.py": {},
    "decompose-master/decompose/__init__.py": {},
    "decompose-master/decompose/cv/cv.py": {
        "CV.isLowrank": {
            "name": "isLowrank",
            "location": 11,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CV.lowrankMask": {
            "name": "lowrankMask",
            "location": 15,
            "return": [
                "Tuple[(Tensor, ...)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CV.mask": {
            "name": "mask",
            "location": 19,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Block.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nFolds": [
                    "Tuple[(int, ...)]"
                ],
                "foldNumber": [
                    "int"
                ]
            }
        },
        "Block.nFolds": {
            "name": "nFolds",
            "location": 30,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.foldNumber": {
            "name": "foldNumber",
            "location": 34,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.isLowrank": {
            "name": "isLowrank",
            "location": 37,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.lowrankMask": {
            "name": "lowrankMask",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Block.mask": {
            "name": "mask",
            "location": 59,
            "return": [],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Block.testMask": {
            "name": "testMask",
            "location": 67,
            "return": [],
            "arguments": {
                "self": [],
                "Mf": [],
                "foldNumber": [],
                "nFolds": [],
                "nValues": []
            }
        }
    },
    "decompose-master/decompose/cv/__init__.py": {},
    "decompose-master/decompose/data/lowRank.py": {
        "LowRank.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rank": [
                    "int"
                ],
                "M_train": [
                    "Tuple[(int, ...)]"
                ],
                "M_test": [
                    "Tuple[(int, ...)]"
                ],
                "dtype": [
                    "type"
                ]
            }
        },
        "LowRank.tensorReconstruction": {
            "name": "tensorReconstruction",
            "location": 50,
            "return": [
                "ndarray"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(ndarray, ndarray)]"
                ]
            }
        },
        "LowRank.training": {
            "name": "training",
            "location": 59,
            "return": [
                "ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank.test": {
            "name": "test",
            "location": 67,
            "return": [
                "ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank.training_input_fn": {
            "name": "training_input_fn",
            "location": 75,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank.test_input_fn": {
            "name": "test_input_fn",
            "location": 94,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank.__var_training": {
            "name": "__var_training",
            "location": 113,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank.__var_test": {
            "name": "__var_test",
            "location": 121,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank.residuals_training": {
            "name": "residuals_training",
            "location": 128,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(ndarray, ndarray)]"
                ]
            }
        },
        "LowRank.var_expl_training": {
            "name": "var_expl_training",
            "location": 144,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(ndarray, ndarray)]"
                ]
            }
        },
        "LowRank.residuals_test": {
            "name": "residuals_test",
            "location": 158,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(ndarray, ndarray)]"
                ]
            }
        },
        "LowRank.var_expl_test": {
            "name": "var_expl_test",
            "location": 174,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(ndarray, ndarray)]"
                ]
            }
        }
    },
    "decompose-master/decompose/data/random.py": {
        "Random.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, int)]"
                ],
                "dtype": [
                    "type"
                ]
            }
        },
        "Random.input_fn": {
            "name": "input_fn",
            "location": 22,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Random.M": {
            "name": "M",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Random.input_fn.f": {
            "name": "f",
            "location": 33,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/data/__init__.py": {},
    "decompose-master/decompose/distributions/algorithms.py": {
        "Algorithms.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Algorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "Algorithms.mode": {
            "name": "mode",
            "location": 17,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "Algorithms.pdf": {
            "name": "pdf",
            "location": 21,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Algorithms.fit": {
            "name": "fit",
            "location": 25,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Algorithms.llh": {
            "name": "llh",
            "location": 30,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "Algorithms.fitLatents": {
            "name": "fitLatents",
            "location": 34,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenDoubleLomax.py": {
        "CenDoubleLomax.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "alpha": [
                    "Tensor"
                ],
                "beta": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenDoubleLomax.parameterInfo": {
            "name": "parameterInfo",
            "location": 28,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenDoubleLomax.mu": {
            "name": "mu",
            "location": 39,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenDoubleLomax.alpha": {
            "name": "alpha",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "tf.Tensor"
                ]
            }
        },
        "CenDoubleLomax.beta": {
            "name": "beta",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "beta": [
                    "tf.Tensor"
                ]
            }
        },
        "CenDoubleLomax.tau": {
            "name": "tau",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "CenDoubleLomax.nonNegative": {
            "name": "nonNegative",
            "location": 68,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenDoubleLomax.homogenous": {
            "name": "homogenous",
            "location": 72,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenDoubleLomax.cond": {
            "name": "cond",
            "location": 75,
            "return": [
                "CenLaplace"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenDoubleLomax.shape": {
            "name": "shape",
            "location": 87,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenDoubleLomax.latentShape": {
            "name": "latentShape",
            "location": 91,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenDoubleLomaxAlgorithms.py": {
        "CenDoubleLomaxAlgorithms.sample": {
            "name": "sample",
            "location": 13,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenDoubleLomaxAlgorithms.mode": {
            "name": "mode",
            "location": 23,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenDoubleLomaxAlgorithms.pdf": {
            "name": "pdf",
            "location": 28,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenDoubleLomaxAlgorithms.llh": {
            "name": "llh",
            "location": 33,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenDoubleLomaxAlgorithms.fit": {
            "name": "fit",
            "location": 39,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenDoubleLomaxAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 46,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenLaplace.py": {
        "CenLaplace.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "beta": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenLaplace.parameterInfo": {
            "name": "parameterInfo",
            "location": 25,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenLaplace.mu": {
            "name": "mu",
            "location": 34,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenLaplaceAlgorithms.py": {
        "CenLaplaceAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenLaplaceAlgorithms.mode": {
            "name": "mode",
            "location": 20,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenLaplaceAlgorithms.pdf": {
            "name": "pdf",
            "location": 26,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenLaplaceAlgorithms.fit": {
            "name": "fit",
            "location": 34,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenLaplaceAlgorithms.llh": {
            "name": "llh",
            "location": 41,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenLaplaceAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 49,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnElasticNetAlgorithms.py": {
        "CenNnElasticNetAlgorithms.mode": {
            "name": "mode",
            "location": 11,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNnElasticNetAlgorithms.fit": {
            "name": "fit",
            "location": 16,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnFullyElasticNet.py": {
        "CenNnFullyElasticNet.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "b": [
                    "Tensor"
                ],
                "mu": [
                    "Tensor"
                ],
                "betaExponential": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "alpha": [
                    "Tensor"
                ],
                "beta": [
                    "Tensor"
                ],
                "tauLomax": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenNnFullyElasticNet.parameterInfo": {
            "name": "parameterInfo",
            "location": 34,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenNnFullyElasticNet.b": {
            "name": "b",
            "location": 54,
            "return": [],
            "arguments": {
                "self": [],
                "b": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNet.mu": {
            "name": "mu",
            "location": 62,
            "return": [],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNet.tau": {
            "name": "tau",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNet.betaExponential": {
            "name": "betaExponential",
            "location": 78,
            "return": [],
            "arguments": {
                "self": [],
                "betaExponential": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNet.muLomax": {
            "name": "muLomax",
            "location": 82,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNet.alpha": {
            "name": "alpha",
            "location": 91,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnFullyElasticNet.beta": {
            "name": "beta",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "beta": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnFullyElasticNet.nonNegative": {
            "name": "nonNegative",
            "location": 111,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNet.homogenous": {
            "name": "homogenous",
            "location": 115,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNet.cond": {
            "name": "cond",
            "location": 118,
            "return": [
                "CenNnFullyElasticNetCond"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNet.shape": {
            "name": "shape",
            "location": 140,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNet.latentShape": {
            "name": "latentShape",
            "location": 144,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnFullyElasticNetAlgorithms.py": {
        "CenNnFullyElasticNetAlgorithms.getParameters": {
            "name": "getParameters",
            "location": 15,
            "return": [
                "Tuple[(Tensor, Dict[(str, Tensor)], Dict[(str, Tensor)], Dict[(str, Tensor)])]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNnFullyElasticNetAlgorithms.sample": {
            "name": "sample",
            "location": 31,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetAlgorithms.mode": {
            "name": "mode",
            "location": 45,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNnFullyElasticNetAlgorithms.pdf": {
            "name": "pdf",
            "location": 50,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetAlgorithms.fit": {
            "name": "fit",
            "location": 64,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetAlgorithms.llh": {
            "name": "llh",
            "location": 102,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 116,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnFullyElasticNetCond.py": {
        "CenNnFullyElasticNetCond.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "b": [
                    "Tensor"
                ],
                "mu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "betaExponential": [
                    "Tensor"
                ],
                "beta": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenNnFullyElasticNetCond.parameterInfo": {
            "name": "parameterInfo",
            "location": 31,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenNnFullyElasticNetCond.b": {
            "name": "b",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "b": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetCond.mu": {
            "name": "mu",
            "location": 56,
            "return": [],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetCond.tau": {
            "name": "tau",
            "location": 64,
            "return": [],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetCond.betaExponential": {
            "name": "betaExponential",
            "location": 72,
            "return": [],
            "arguments": {
                "self": [],
                "betaExponential": [
                    "Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetCond.beta": {
            "name": "beta",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "beta": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnFullyElasticNetCond.nonNegative": {
            "name": "nonNegative",
            "location": 84,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNetCond.homogenous": {
            "name": "homogenous",
            "location": 88,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNetCond.cond": {
            "name": "cond",
            "location": 91,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNetCond.shape": {
            "name": "shape",
            "location": 95,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnFullyElasticNetCond.latentShape": {
            "name": "latentShape",
            "location": 99,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnNormal.py": {
        "CenNnNormal.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenNnNormal.parameterInfo": {
            "name": "parameterInfo",
            "location": 24,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenNnNormal.mu": {
            "name": "mu",
            "location": 33,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnNormalAlgorithms.py": {
        "CenNnNormalAlgorithms.sample": {
            "name": "sample",
            "location": 11,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenNnNormalAlgorithms.mode": {
            "name": "mode",
            "location": 19,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNnNormalAlgorithms.pdf": {
            "name": "pdf",
            "location": 25,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenNnNormalAlgorithms.fit": {
            "name": "fit",
            "location": 33,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnNormalAlgorithms.llh": {
            "name": "llh",
            "location": 41,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnNormalAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 49,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnT.py": {
        "CenNnT.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "Psi": [
                    "Tensor"
                ],
                "nu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenNnT.parameterInfo": {
            "name": "parameterInfo",
            "location": 28,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenNnT.mu": {
            "name": "mu",
            "location": 39,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnT.Psi": {
            "name": "Psi",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "Psi": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnT.nu": {
            "name": "nu",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nu": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnT.tau": {
            "name": "tau",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "CenNnT.nonNegative": {
            "name": "nonNegative",
            "location": 68,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnT.homogenous": {
            "name": "homogenous",
            "location": 72,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnT.cond": {
            "name": "cond",
            "location": 75,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnT.shape": {
            "name": "shape",
            "location": 92,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNnT.latentShape": {
            "name": "latentShape",
            "location": 96,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenNnTAlgorithms.py": {
        "CenNnTAlgorithms.sample": {
            "name": "sample",
            "location": 13,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenNnTAlgorithms.mode": {
            "name": "mode",
            "location": 21,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNnTAlgorithms.pdf": {
            "name": "pdf",
            "location": 26,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenNnTAlgorithms.llh": {
            "name": "llh",
            "location": 35,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnTAlgorithms.fit": {
            "name": "fit",
            "location": 44,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNnTAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 49,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNormal.py": {
        "CenNormal.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenNormal.parameterInfo": {
            "name": "parameterInfo",
            "location": 24,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenNormal.mu": {
            "name": "mu",
            "location": 33,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenNormalAlgorithms.py": {
        "CenNormalAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenNormalAlgorithms.mode": {
            "name": "mode",
            "location": 20,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNormalAlgorithms.pdf": {
            "name": "pdf",
            "location": 26,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenNormalAlgorithms.fit": {
            "name": "fit",
            "location": 34,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNormalAlgorithms.llh": {
            "name": "llh",
            "location": 42,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNormalAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 50,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNormalRankOne.py": {
        "CenNormalRankOne.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "tau0": [
                    "Tensor"
                ],
                "tau1": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenNormalRankOne.parameterInfo": {
            "name": "parameterInfo",
            "location": 26,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, int)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenNormalRankOne.mu": {
            "name": "mu",
            "location": 36,
            "return": [
                "Tuple[(Tensor, Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNormalRankOne.tau0": {
            "name": "tau0",
            "location": 46,
            "return": [],
            "arguments": {
                "self": [],
                "tau0": [
                    "Tensor"
                ]
            }
        },
        "CenNormalRankOne.tau1": {
            "name": "tau1",
            "location": 54,
            "return": [],
            "arguments": {
                "self": [],
                "tau1": [
                    "Tensor"
                ]
            }
        },
        "CenNormalRankOne.nonNegative": {
            "name": "nonNegative",
            "location": 58,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNormalRankOne.homogenous": {
            "name": "homogenous",
            "location": 62,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNormalRankOne.cond": {
            "name": "cond",
            "location": 65,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNormalRankOne.shape": {
            "name": "shape",
            "location": 69,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CenNormalRankOne.latentShape": {
            "name": "latentShape",
            "location": 74,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenNormalRankOneAlgorithms.py": {
        "CenNormalRankOneAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenNormalRankOneAlgorithms.mode": {
            "name": "mode",
            "location": 21,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenNormalRankOneAlgorithms.pdf": {
            "name": "pdf",
            "location": 29,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenNormalRankOneAlgorithms.fitGamma": {
            "name": "fitGamma",
            "location": 38,
            "return": [],
            "arguments": {
                "cls": [],
                "tau": []
            }
        },
        "CenNormalRankOneAlgorithms.fit": {
            "name": "fit",
            "location": 56,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNormalRankOneAlgorithms.llh": {
            "name": "llh",
            "location": 92,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenNormalRankOneAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 101,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenNormalRankOneHeuristicAlgorithms.py": {
        "CenNormalRankOneHeuristicAlgorithms.fit": {
            "name": "fit",
            "location": 12,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/cenT.py": {
        "CenT.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "Psi": [
                    "Tensor"
                ],
                "nu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "CenT.parameterInfo": {
            "name": "parameterInfo",
            "location": 28,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "CenT.mu": {
            "name": "mu",
            "location": 39,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/cenTAlgorithms.py": {
        "CenTAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "CenTAlgorithms.mode": {
            "name": "mode",
            "location": 21,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "CenTAlgorithms.pdf": {
            "name": "pdf",
            "location": 27,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CenTAlgorithms.llh": {
            "name": "llh",
            "location": 35,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenTAlgorithms.fit": {
            "name": "fit",
            "location": 43,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "CenTAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 71,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/chopin2011.py": {
        "updateTensor": {
            "name": "updateTensor",
            "location": 11,
            "return": [],
            "arguments": {
                "x": [],
                "mask": [],
                "newValues": []
            }
        },
        "randint": {
            "name": "randint",
            "location": 23,
            "return": [],
            "arguments": {
                "low": [],
                "high": []
            }
        },
        "gather": {
            "name": "gather",
            "location": 30,
            "return": [],
            "arguments": {
                "data": [],
                "indexes": []
            }
        },
        "gather_nd": {
            "name": "gather_nd",
            "location": 38,
            "return": [],
            "arguments": {
                "data": [],
                "indexes": []
            }
        },
        "count_nonzero": {
            "name": "count_nonzero",
            "location": 46,
            "return": [],
            "arguments": {
                "data": [],
                "axis": [],
                "keep_dims": [],
                "dtype": []
            }
        },
        "rejectionSamplingExp": {
            "name": "rejectionSamplingExp",
            "location": 53,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "rejectionSamplingNorm": {
            "name": "rejectionSamplingNorm",
            "location": 88,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "ppf": {
            "name": "ppf",
            "location": 111,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "rightTail": {
            "name": "rightTail",
            "location": 121,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "getConsts": {
            "name": "getConsts",
            "location": 132,
            "return": [],
            "arguments": {
                "dtype": []
            }
        },
        "twoRegions": {
            "name": "twoRegions",
            "location": 147,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "k": []
            }
        },
        "allOther": {
            "name": "allOther",
            "location": 203,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "k": []
            }
        },
        "chopin": {
            "name": "chopin",
            "location": 273,
            "return": [],
            "arguments": {
                "aAll": [],
                "bAll": []
            }
        },
        "rtstdnorm": {
            "name": "rtstdnorm",
            "location": 394,
            "return": [],
            "arguments": {
                "aAll": [],
                "bAll": []
            }
        },
        "rtnorm2": {
            "name": "rtnorm2",
            "location": 431,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "mu": [],
                "sigma": [],
                "size": []
            }
        },
        "rtnormFlipped": {
            "name": "rtnormFlipped",
            "location": 488,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "mu": [],
                "sigma": []
            }
        },
        "rtnorm": {
            "name": "rtnorm",
            "location": 507,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "mu": [],
                "sigma": [],
                "nSamples": []
            }
        },
        "rejectionSamplingExp.notStop": {
            "name": "notStop",
            "location": 62,
            "return": [],
            "arguments": {
                "z": [],
                "e": []
            }
        },
        "rejectionSamplingExp.body": {
            "name": "body",
            "location": 67,
            "return": [],
            "arguments": {
                "z": [],
                "e": []
            }
        },
        "rejectionSamplingNorm.notStop": {
            "name": "notStop",
            "location": 93,
            "return": [],
            "arguments": {
                "r": []
            }
        },
        "rejectionSamplingNorm.body": {
            "name": "body",
            "location": 98,
            "return": [],
            "arguments": {
                "r": []
            }
        },
        "chopin.notAccepted": {
            "name": "notAccepted",
            "location": 328,
            "return": [],
            "arguments": {
                "rAll": [],
                "acceptedAll": [],
                "kAll": []
            }
        },
        "chopin.body": {
            "name": "body",
            "location": 331,
            "return": [],
            "arguments": {
                "rAll": [],
                "acceptedAll": [],
                "kAll": []
            }
        }
    },
    "decompose-master/decompose/distributions/distribution.py": {
        "Properties.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "persistent": [
                    "bool"
                ]
            }
        },
        "Properties.name": {
            "name": "name",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Properties.dtype": {
            "name": "dtype",
            "location": 55,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Properties.drawType": {
            "name": "drawType",
            "location": 59,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Properties.updateType": {
            "name": "updateType",
            "location": 63,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Properties.persistent": {
            "name": "persistent",
            "location": 67,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Distribution.__init__": {
            "name": "__init__",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "properties": [
                    "Properties"
                ],
                "hyperParameters": [
                    "Tuple[str]"
                ]
            }
        },
        "Distribution.__init": {
            "name": "__init",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "Distribution.get_parameters": {
            "name": "get_parameters",
            "location": 137,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.set_parameters": {
            "name": "set_parameters",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "Distribution.random": {
            "name": "random",
            "location": 149,
            "return": [
                "'Distribution'"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ],
                "name": [
                    "str"
                ],
                "dtype": [
                    "type"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "persistent": [
                    "bool"
                ]
            }
        },
        "Distribution.__mul__": {
            "name": "__mul__",
            "location": 196,
            "return": [
                "'Distribution'"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "object"
                ]
            }
        },
        "Distribution.__rmul__": {
            "name": "__rmul__",
            "location": 218,
            "return": [],
            "arguments": {
                "self": [],
                "other": [
                    "object"
                ]
            }
        },
        "Distribution.__getitem__": {
            "name": "__getitem__",
            "location": 236,
            "return": [
                "'Distribution'"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "object"
                ]
            }
        },
        "Distribution.parameterInfo": {
            "name": "parameterInfo",
            "location": 270,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "Distribution.vars": {
            "name": "vars",
            "location": 292,
            "return": [
                "Variable"
            ],
            "arguments": {
                "self": [],
                "parameterName": [
                    "str"
                ]
            }
        },
        "Distribution.persistent": {
            "name": "persistent",
            "location": 313,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.algorithms": {
            "name": "algorithms",
            "location": 323,
            "return": [
                "Type[Algorithms]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.parameterNames": {
            "name": "parameterNames",
            "location": 327,
            "return": [
                "Tuple[(str, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.shape": {
            "name": "shape",
            "location": 333,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.latentShape": {
            "name": "latentShape",
            "location": 339,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.dtype": {
            "name": "dtype",
            "location": 344,
            "return": [
                "DType"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.name": {
            "name": "name",
            "location": 349,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.nonNegative": {
            "name": "nonNegative",
            "location": 355,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.drawType": {
            "name": "drawType",
            "location": 380,
            "return": [],
            "arguments": {
                "self": [],
                "drawType": [
                    "DrawType"
                ]
            }
        },
        "Distribution.updateType": {
            "name": "updateType",
            "location": 384,
            "return": [],
            "arguments": {
                "self": [],
                "updateType": [
                    "UpdateType"
                ]
            }
        },
        "Distribution.homogenous": {
            "name": "homogenous",
            "location": 389,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.draw": {
            "name": "draw",
            "location": 400,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.update": {
            "name": "update",
            "location": 416,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Distribution.cond": {
            "name": "cond",
            "location": 433,
            "return": [
                "'Distribution'"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.sample": {
            "name": "sample",
            "location": 447,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "nSamples": [
                    "int"
                ]
            }
        },
        "Distribution.mode": {
            "name": "mode",
            "location": 465,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.fit": {
            "name": "fit",
            "location": 477,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Distribution.fitLatents": {
            "name": "fitLatents",
            "location": 493,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Distribution.pdf": {
            "name": "pdf",
            "location": 509,
            "return": [],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Distribution.llh": {
            "name": "llh",
            "location": 525,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Distribution.getEstimator": {
            "name": "getEstimator",
            "location": 542,
            "return": [
                "tf.estimator.Estimator"
            ],
            "arguments": {
                "cls": [],
                "distType": [
                    "Type['Distribution']"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "parameterProperty.__init__": {
            "name": "__init__",
            "location": 611,
            "return": [],
            "arguments": {
                "self": [],
                "fget": [],
                "fset": [],
                "fdel": [],
                "doc": [],
                "name": []
            }
        },
        "parameterProperty.__set__": {
            "name": "__set__",
            "location": 620,
            "return": [],
            "arguments": {
                "self": [],
                "obj": [],
                "value": []
            }
        },
        "parameterProperty.__get__": {
            "name": "__get__",
            "location": 627,
            "return": [],
            "arguments": {
                "self": [],
                "obj": [],
                "objtype": []
            }
        },
        "parameterProperty.__delete__": {
            "name": "__delete__",
            "location": 634,
            "return": [],
            "arguments": {
                "self": [],
                "obj": []
            }
        },
        "parameterProperty.getter": {
            "name": "getter",
            "location": 639,
            "return": [],
            "arguments": {
                "self": [],
                "fget": []
            }
        },
        "parameterProperty.setter": {
            "name": "setter",
            "location": 642,
            "return": [],
            "arguments": {
                "self": [],
                "name": []
            }
        },
        "parameterProperty.deleter": {
            "name": "deleter",
            "location": 652,
            "return": [],
            "arguments": {
                "self": [],
                "fdel": []
            }
        },
        "Distribution.getEstimator.model_fn": {
            "name": "model_fn",
            "location": 559,
            "return": [],
            "arguments": {
                "features": [],
                "labels": [],
                "mode": []
            }
        },
        "parameterProperty.setter.noop": {
            "name": "noop",
            "location": 648,
            "return": [],
            "arguments": {
                "fset": []
            }
        }
    },
    "decompose-master/decompose/distributions/exponential.py": {
        "Exponential.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "beta": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "Exponential.parameterInfo": {
            "name": "parameterInfo",
            "location": 25,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "Exponential.beta": {
            "name": "beta",
            "location": 38,
            "return": [],
            "arguments": {
                "self": [],
                "beta": [
                    "Tensor"
                ]
            }
        },
        "Exponential.nonNegative": {
            "name": "nonNegative",
            "location": 42,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Exponential.homogenous": {
            "name": "homogenous",
            "location": 46,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Exponential.cond": {
            "name": "cond",
            "location": 49,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "Exponential.shape": {
            "name": "shape",
            "location": 53,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Exponential.latentShape": {
            "name": "latentShape",
            "location": 57,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/exponentialAlgorithms.py": {
        "ExponentialAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "ExponentialAlgorithms.mode": {
            "name": "mode",
            "location": 19,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "ExponentialAlgorithms.pdf": {
            "name": "pdf",
            "location": 24,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "ExponentialAlgorithms.fit": {
            "name": "fit",
            "location": 35,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "ExponentialAlgorithms.llh": {
            "name": "llh",
            "location": 42,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "ExponentialAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 53,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/jumpNormal.py": {
        "JumpNormal.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "mu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "nu": [
                    "Tensor"
                ],
                "beta": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "JumpNormal.parameterInfo": {
            "name": "parameterInfo",
            "location": 28,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "JumpNormal.mu": {
            "name": "mu",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "JumpNormal.tau": {
            "name": "tau",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "JumpNormal.nu": {
            "name": "nu",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nu": [
                    "Tensor"
                ]
            }
        },
        "JumpNormal.beta": {
            "name": "beta",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "beta": [
                    "Tensor"
                ]
            }
        },
        "JumpNormal.nonNegative": {
            "name": "nonNegative",
            "location": 72,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "JumpNormal.homogenous": {
            "name": "homogenous",
            "location": 76,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "JumpNormal.cond": {
            "name": "cond",
            "location": 79,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "JumpNormal.shape": {
            "name": "shape",
            "location": 83,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "JumpNormal.latentShape": {
            "name": "latentShape",
            "location": 87,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/jumpNormalAlgorithms.py": {
        "JumpNormalAlgorithms.alpha": {
            "name": "alpha",
            "location": 13,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "JumpNormalAlgorithms.mode": {
            "name": "mode",
            "location": 37,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "JumpNormalAlgorithms.sample": {
            "name": "sample",
            "location": 64,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "JumpNormalAlgorithms.logConstant": {
            "name": "logConstant",
            "location": 105,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "JumpNormalAlgorithms.pdf": {
            "name": "pdf",
            "location": 121,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "JumpNormalAlgorithms.llh": {
            "name": "llh",
            "location": 127,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "JumpNormalAlgorithms.fit": {
            "name": "fit",
            "location": 142,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "JumpNormalAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 147,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/laplace.py": {
        "Laplace.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "mu": [
                    "Tensor"
                ],
                "beta": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "Laplace.parameterInfo": {
            "name": "parameterInfo",
            "location": 26,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "Laplace.mu": {
            "name": "mu",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "Laplace.beta": {
            "name": "beta",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "beta": [
                    "Tensor"
                ]
            }
        },
        "Laplace.nonNegative": {
            "name": "nonNegative",
            "location": 52,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Laplace.homogenous": {
            "name": "homogenous",
            "location": 56,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Laplace.cond": {
            "name": "cond",
            "location": 59,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "Laplace.shape": {
            "name": "shape",
            "location": 63,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Laplace.latentShape": {
            "name": "latentShape",
            "location": 67,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/laplaceAlgorithms.py": {
        "LaplaceAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "LaplaceAlgorithms.mode": {
            "name": "mode",
            "location": 20,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "LaplaceAlgorithms.pdf": {
            "name": "pdf",
            "location": 25,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "LaplaceAlgorithms.fit": {
            "name": "fit",
            "location": 32,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "LaplaceAlgorithms.llh": {
            "name": "llh",
            "location": 41,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "LaplaceAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 48,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/lomax.py": {
        "Lomax.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "alpha": [
                    "Tensor"
                ],
                "beta": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "Lomax.parameterInfo": {
            "name": "parameterInfo",
            "location": 28,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "Lomax.mu": {
            "name": "mu",
            "location": 39,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Lomax.alpha": {
            "name": "alpha",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "tf.Tensor"
                ]
            }
        },
        "Lomax.beta": {
            "name": "beta",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "beta": [
                    "tf.Tensor"
                ]
            }
        },
        "Lomax.tau": {
            "name": "tau",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "Lomax.nonNegative": {
            "name": "nonNegative",
            "location": 68,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Lomax.homogenous": {
            "name": "homogenous",
            "location": 72,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Lomax.cond": {
            "name": "cond",
            "location": 75,
            "return": [
                "Exponential"
            ],
            "arguments": {
                "self": []
            }
        },
        "Lomax.shape": {
            "name": "shape",
            "location": 87,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Lomax.latentShape": {
            "name": "latentShape",
            "location": 91,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/lomaxAlgorithms.py": {
        "LomaxAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "LomaxAlgorithms.mode": {
            "name": "mode",
            "location": 21,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "LomaxAlgorithms.pdf": {
            "name": "pdf",
            "location": 26,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "LomaxAlgorithms.llh": {
            "name": "llh",
            "location": 30,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "LomaxAlgorithms.f": {
            "name": "f",
            "location": 37,
            "return": [],
            "arguments": {
                "cls": [],
                "y": [],
                "beta": [],
                "tn": []
            }
        },
        "LomaxAlgorithms.fit": {
            "name": "fit",
            "location": 43,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "LomaxAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 96,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/nnNormal.py": {
        "NnNormal.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "mu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "NnNormal.parameterInfo": {
            "name": "parameterInfo",
            "location": 26,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "NnNormal.mu": {
            "name": "mu",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "NnNormal.tau": {
            "name": "tau",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "NnNormal.nonNegative": {
            "name": "nonNegative",
            "location": 52,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnNormal.homogenous": {
            "name": "homogenous",
            "location": 56,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnNormal.cond": {
            "name": "cond",
            "location": 59,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnNormal.shape": {
            "name": "shape",
            "location": 63,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnNormal.latentShape": {
            "name": "latentShape",
            "location": 67,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/nnNormalAlgorithms.py": {
        "NnNormalAlgorithms.sample": {
            "name": "sample",
            "location": 13,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "NnNormalAlgorithms.mode": {
            "name": "mode",
            "location": 22,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "NnNormalAlgorithms.pdf": {
            "name": "pdf",
            "location": 28,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "NnNormalAlgorithms.llh": {
            "name": "llh",
            "location": 42,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "NnNormalAlgorithms.gradStep": {
            "name": "gradStep",
            "location": 57,
            "return": [],
            "arguments": {
                "cls": [],
                "data": [],
                "mu": [],
                "tau": [],
                "v": [],
                "e": []
            }
        },
        "NnNormalAlgorithms.fit": {
            "name": "fit",
            "location": 85,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "NnNormalAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 118,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/nnUniform.py": {
        "NnUniform.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "dummy": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "NnUniform.parameterInfo": {
            "name": "parameterInfo",
            "location": 25,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "NnUniform.shape": {
            "name": "shape",
            "location": 34,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnUniform.latentShape": {
            "name": "latentShape",
            "location": 38,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnUniform.dummy": {
            "name": "dummy",
            "location": 46,
            "return": [],
            "arguments": {
                "self": [],
                "dummy": [
                    "Tensor"
                ]
            }
        },
        "NnUniform.nonNegative": {
            "name": "nonNegative",
            "location": 50,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnUniform.homogenous": {
            "name": "homogenous",
            "location": 54,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NnUniform.cond": {
            "name": "cond",
            "location": 57,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/nnUniformAlgorithms.py": {
        "NnUniformAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "NnUniformAlgorithms.mode": {
            "name": "mode",
            "location": 16,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "NnUniformAlgorithms.pdf": {
            "name": "pdf",
            "location": 20,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "NnUniformAlgorithms.fit": {
            "name": "fit",
            "location": 24,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "NnUniformAlgorithms.llh": {
            "name": "llh",
            "location": 30,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "NnUniformAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 37,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/normal.py": {
        "Normal.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "mu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "Normal.parameterInfo": {
            "name": "parameterInfo",
            "location": 25,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "Normal.mu": {
            "name": "mu",
            "location": 39,
            "return": [],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "Normal.tau": {
            "name": "tau",
            "location": 47,
            "return": [],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "Normal.nonNegative": {
            "name": "nonNegative",
            "location": 51,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Normal.homogenous": {
            "name": "homogenous",
            "location": 55,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Normal.cond": {
            "name": "cond",
            "location": 58,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "Normal.shape": {
            "name": "shape",
            "location": 62,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Normal.latentShape": {
            "name": "latentShape",
            "location": 66,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/normalAlgorithms.py": {
        "NormalAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "NormalAlgorithms.mode": {
            "name": "mode",
            "location": 19,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "NormalAlgorithms.pdf": {
            "name": "pdf",
            "location": 24,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "NormalAlgorithms.fit": {
            "name": "fit",
            "location": 31,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "NormalAlgorithms.llh": {
            "name": "llh",
            "location": 40,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "NormalAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 47,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/normalCenNnFullyElasticNetCond.py": {
        "NormalCenNnFullyElasticNetCond.fromUnordered": {
            "name": "fromUnordered",
            "location": 15,
            "return": [
                "Normal"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalCenNnFullyElasticNetCond.product": {
            "name": "product",
            "location": 23,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "n0": [
                    "Normal"
                ],
                "n1": [
                    "CenNnFullyElasticNetCond"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/normalExponential.py": {
        "NormalExponential.fromUnordered": {
            "name": "fromUnordered",
            "location": 14,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalExponential.product": {
            "name": "product",
            "location": 23,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "e": [
                    "Exponential"
                ]
            }
        },
        "NormalExponential.mu": {
            "name": "mu",
            "location": 29,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "e": [
                    "Exponential"
                ]
            }
        },
        "NormalExponential.tau": {
            "name": "tau",
            "location": 33,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "e": [
                    "Exponential"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/normalLaplace.py": {
        "NormalLaplace.fromUnordered": {
            "name": "fromUnordered",
            "location": 15,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalLaplace.product": {
            "name": "product",
            "location": 24,
            "return": [
                "JumpNormal"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "l": [
                    "Laplace"
                ]
            }
        },
        "NormalLaplace.mu": {
            "name": "mu",
            "location": 34,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "l": [
                    "Laplace"
                ]
            }
        },
        "NormalLaplace.tau": {
            "name": "tau",
            "location": 38,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "l": [
                    "Laplace"
                ]
            }
        },
        "NormalLaplace.nu": {
            "name": "nu",
            "location": 42,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "l": [
                    "Laplace"
                ]
            }
        },
        "NormalLaplace.beta": {
            "name": "beta",
            "location": 46,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "l": [
                    "Laplace"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/normalNnNormal.py": {
        "NormalNnNormal.fromUnordered": {
            "name": "fromUnordered",
            "location": 12,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalNnNormal.product": {
            "name": "product",
            "location": 21,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "nnn": [
                    "NnNormal"
                ]
            }
        },
        "NormalNnNormal.mu": {
            "name": "mu",
            "location": 27,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "nnn": [
                    "NnNormal"
                ]
            }
        },
        "NormalNnNormal.tau": {
            "name": "tau",
            "location": 34,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "nnn": [
                    "NnNormal"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/normalNnUniform.py": {
        "NormalNnUniform.fromUnordered": {
            "name": "fromUnordered",
            "location": 15,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalNnUniform.product": {
            "name": "product",
            "location": 24,
            "return": [
                "NnNormal"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "u": [
                    "NnUniform"
                ]
            }
        },
        "NormalNnUniform.mu": {
            "name": "mu",
            "location": 30,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [],
                "u": []
            }
        },
        "NormalNnUniform.tau": {
            "name": "tau",
            "location": 34,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [],
                "u": []
            }
        }
    },
    "decompose-master/decompose/distributions/normalNormal.py": {
        "NormalNormal.fromUnordered": {
            "name": "fromUnordered",
            "location": 12,
            "return": [
                "Normal"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalNormal.product": {
            "name": "product",
            "location": 20,
            "return": [
                "Normal"
            ],
            "arguments": {
                "self": [],
                "n0": [
                    "Normal"
                ],
                "n1": [
                    "Normal"
                ]
            }
        },
        "NormalNormal.mu": {
            "name": "mu",
            "location": 27,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n0": [],
                "n1": []
            }
        },
        "NormalNormal.tau": {
            "name": "tau",
            "location": 34,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n0": [],
                "n1": []
            }
        }
    },
    "decompose-master/decompose/distributions/normalUniform.py": {
        "NormalUniform.fromUnordered": {
            "name": "fromUnordered",
            "location": 14,
            "return": [
                "Normal"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "NormalUniform.product": {
            "name": "product",
            "location": 23,
            "return": [
                "Normal"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "Normal"
                ],
                "u": [
                    "Uniform"
                ]
            }
        },
        "NormalUniform.mu": {
            "name": "mu",
            "location": 29,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [],
                "u": []
            }
        },
        "NormalUniform.tau": {
            "name": "tau",
            "location": 33,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "n": [],
                "u": []
            }
        }
    },
    "decompose-master/decompose/distributions/product.py": {
        "Product.fromUnordered": {
            "name": "fromUnordered",
            "location": 13,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "Product.productParams": {
            "name": "productParams",
            "location": 17,
            "return": [],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "Product.name": {
            "name": "name",
            "location": 30,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "Product.homogenous": {
            "name": "homogenous",
            "location": 33,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "Product.drawType": {
            "name": "drawType",
            "location": 36,
            "return": [
                "DrawType"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        },
        "Product.updateType": {
            "name": "updateType",
            "location": 42,
            "return": [
                "UpdateType"
            ],
            "arguments": {
                "self": [],
                "d0": [
                    "Distribution"
                ],
                "d1": [
                    "Distribution"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/productDistLookup.py": {
        "ProductDict.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ProductDict.__getattr__": {
            "name": "__getattr__",
            "location": 69,
            "return": [],
            "arguments": {
                "self": [],
                "name": []
            }
        },
        "ProductDict.__ProductDict.__init__": {
            "name": "__init__",
            "location": 3,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ProductDict.__ProductDict.lookup": {
            "name": "lookup",
            "location": 52,
            "return": [],
            "arguments": {
                "self": [],
                "d0": [],
                "d1": []
            }
        }
    },
    "decompose-master/decompose/distributions/properties.py": {},
    "decompose-master/decompose/distributions/t.py": {
        "T.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "mu": [
                    "Tensor"
                ],
                "Psi": [
                    "Tensor"
                ],
                "nu": [
                    "Tensor"
                ],
                "tau": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "T.parameterInfo": {
            "name": "parameterInfo",
            "location": 29,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "T.mu": {
            "name": "mu",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mu": [
                    "Tensor"
                ]
            }
        },
        "T.Psi": {
            "name": "Psi",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "Psi": [
                    "tf.Tensor"
                ]
            }
        },
        "T.nu": {
            "name": "nu",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nu": [
                    "tf.Tensor"
                ]
            }
        },
        "T.tau": {
            "name": "tau",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tau": [
                    "Tensor"
                ]
            }
        },
        "T.nonNegative": {
            "name": "nonNegative",
            "location": 73,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "T.homogenous": {
            "name": "homogenous",
            "location": 77,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "T.cond": {
            "name": "cond",
            "location": 80,
            "return": [
                "Normal"
            ],
            "arguments": {
                "self": []
            }
        },
        "T.shape": {
            "name": "shape",
            "location": 97,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "T.latentShape": {
            "name": "latentShape",
            "location": 101,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/tAlgorithms.py": {
        "TAlgorithms.sample": {
            "name": "sample",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "TAlgorithms.mode": {
            "name": "mode",
            "location": 19,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "TAlgorithms.pdf": {
            "name": "pdf",
            "location": 24,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "TAlgorithms.llh": {
            "name": "llh",
            "location": 31,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "TAlgorithms.nuStep": {
            "name": "nuStep",
            "location": 38,
            "return": [],
            "arguments": {
                "cls": [],
                "nu": [],
                "n": [],
                "delta": [],
                "p": []
            }
        },
        "TAlgorithms.fit": {
            "name": "fit",
            "location": 55,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "TAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 84,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/tfppf.py": {
        "tfppf": {
            "name": "tfppf",
            "location": 76,
            "return": [],
            "arguments": {
                "y0": []
            }
        },
        "polevl": {
            "name": "polevl",
            "location": 123,
            "return": [],
            "arguments": {
                "x": [],
                "coef": []
            }
        }
    },
    "decompose-master/decompose/distributions/trnorm.py": {
        "updateTensor": {
            "name": "updateTensor",
            "location": 11,
            "return": [],
            "arguments": {
                "x": [],
                "mask": [],
                "newValues": []
            }
        },
        "randint": {
            "name": "randint",
            "location": 23,
            "return": [],
            "arguments": {
                "low": [],
                "high": []
            }
        },
        "gather": {
            "name": "gather",
            "location": 30,
            "return": [],
            "arguments": {
                "data": [],
                "indexes": []
            }
        },
        "gather_nd": {
            "name": "gather_nd",
            "location": 38,
            "return": [],
            "arguments": {
                "data": [],
                "indexes": []
            }
        },
        "count_nonzero": {
            "name": "count_nonzero",
            "location": 46,
            "return": [],
            "arguments": {
                "data": [],
                "axis": [],
                "keep_dims": [],
                "dtype": []
            }
        },
        "rejectionSamplingExp": {
            "name": "rejectionSamplingExp",
            "location": 53,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "rejectionSamplingNorm": {
            "name": "rejectionSamplingNorm",
            "location": 88,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "ppf": {
            "name": "ppf",
            "location": 111,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "rightTail": {
            "name": "rightTail",
            "location": 121,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "getConsts": {
            "name": "getConsts",
            "location": 132,
            "return": [],
            "arguments": {
                "dtype": []
            }
        },
        "twoRegions": {
            "name": "twoRegions",
            "location": 147,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "k": []
            }
        },
        "allOther": {
            "name": "allOther",
            "location": 203,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "k": []
            }
        },
        "chopin": {
            "name": "chopin",
            "location": 273,
            "return": [],
            "arguments": {
                "aAll": [],
                "bAll": []
            }
        },
        "rtstdnorm": {
            "name": "rtstdnorm",
            "location": 394,
            "return": [],
            "arguments": {
                "aAll": [],
                "bAll": []
            }
        },
        "rtnorm2": {
            "name": "rtnorm2",
            "location": 431,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "mu": [],
                "sigma": [],
                "size": []
            }
        },
        "rtnormFlipped": {
            "name": "rtnormFlipped",
            "location": 488,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "mu": [],
                "sigma": [],
                "size": []
            }
        },
        "rtnorm": {
            "name": "rtnorm",
            "location": 507,
            "return": [],
            "arguments": {
                "a": [],
                "b": [],
                "mu": [],
                "sigma": [],
                "size": []
            }
        },
        "rejectionSamplingExp.notStop": {
            "name": "notStop",
            "location": 62,
            "return": [],
            "arguments": {
                "z": [],
                "e": []
            }
        },
        "rejectionSamplingExp.body": {
            "name": "body",
            "location": 67,
            "return": [],
            "arguments": {
                "z": [],
                "e": []
            }
        },
        "rejectionSamplingNorm.notStop": {
            "name": "notStop",
            "location": 93,
            "return": [],
            "arguments": {
                "r": []
            }
        },
        "rejectionSamplingNorm.body": {
            "name": "body",
            "location": 98,
            "return": [],
            "arguments": {
                "r": []
            }
        },
        "chopin.notAccepted": {
            "name": "notAccepted",
            "location": 328,
            "return": [],
            "arguments": {
                "rAll": [],
                "acceptedAll": [],
                "kAll": []
            }
        },
        "chopin.body": {
            "name": "body",
            "location": 331,
            "return": [],
            "arguments": {
                "rAll": [],
                "acceptedAll": [],
                "kAll": []
            }
        }
    },
    "decompose-master/decompose/distributions/uniform.py": {
        "Uniform.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithms": [
                    "Type[Algorithms]"
                ],
                "dummy": [
                    "Tensor"
                ],
                "properties": [
                    "Properties"
                ]
            }
        },
        "Uniform.parameterInfo": {
            "name": "parameterInfo",
            "location": 25,
            "return": [
                "ParameterInfo"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple[(int, ...)]"
                ],
                "latentShape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "Uniform.shape": {
            "name": "shape",
            "location": 34,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Uniform.latentShape": {
            "name": "latentShape",
            "location": 38,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Uniform.dummy": {
            "name": "dummy",
            "location": 46,
            "return": [],
            "arguments": {
                "self": [],
                "dummy": [
                    "Tensor"
                ]
            }
        },
        "Uniform.nonNegative": {
            "name": "nonNegative",
            "location": 50,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Uniform.homogenous": {
            "name": "homogenous",
            "location": 54,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Uniform.cond": {
            "name": "cond",
            "location": 57,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/distributions/uniformAlgorithms.py": {
        "UniformAlgorithms.sample": {
            "name": "sample",
            "location": 11,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "nSamples": [
                    "Tensor"
                ]
            }
        },
        "UniformAlgorithms.mode": {
            "name": "mode",
            "location": 15,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ]
            }
        },
        "UniformAlgorithms.pdf": {
            "name": "pdf",
            "location": 19,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        },
        "UniformAlgorithms.fit": {
            "name": "fit",
            "location": 23,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "UniformAlgorithms.llh": {
            "name": "llh",
            "location": 29,
            "return": [
                "float"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "tf.Tensor"
                ]
            }
        },
        "UniformAlgorithms.fitLatents": {
            "name": "fitLatents",
            "location": 33,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "Dict[(str, Tensor)]"
                ],
                "data": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/distributions/__init__.py": {},
    "decompose-master/decompose/distributions/tests/test_cenDoubleLomaxAlgorithms.py": {
        "test_cenDoubleLomax_sample": {
            "name": "test_cenDoubleLomax_sample",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_cenDoubleLomax_mode": {
            "name": "test_cenDoubleLomax_mode",
            "location": 60,
            "return": [],
            "arguments": {}
        },
        "test_cenDoubleLomax_pdf": {
            "name": "test_cenDoubleLomax_pdf",
            "location": 77,
            "return": [],
            "arguments": {}
        },
        "test_cenDoubleLomax_llh": {
            "name": "test_cenDoubleLomax_llh",
            "location": 113,
            "return": [],
            "arguments": {}
        },
        "test_cenDoubleLomax_fit": {
            "name": "test_cenDoubleLomax_fit",
            "location": 151,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_cenLaplaceAlgorithms.py": {
        "test_cenLaplace_fit": {
            "name": "test_cenLaplace_fit",
            "location": 11,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_cenNnFullyElasticNetAlgorithms.py": {
        "test_cenNnFullyElasticNet_sample": {
            "name": "test_cenNnFullyElasticNet_sample",
            "location": 11,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_cenNnNormalAlgorithms.py": {
        "test_cenNnNormal_fit": {
            "name": "test_cenNnNormal_fit",
            "location": 11,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_cenNnTAlgorithms.py": {
        "test_t_sample": {
            "name": "test_t_sample",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_t_mode": {
            "name": "test_t_mode",
            "location": 60,
            "return": [],
            "arguments": {}
        },
        "test_t_pdf": {
            "name": "test_t_pdf",
            "location": 77,
            "return": [],
            "arguments": {}
        },
        "test_t_llh": {
            "name": "test_t_llh",
            "location": 112,
            "return": [],
            "arguments": {}
        },
        "test_t_fit": {
            "name": "test_t_fit",
            "location": 148,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_cenNormalAlgorithms.py": {
        "test_cenNormal_fit": {
            "name": "test_cenNormal_fit",
            "location": 11,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_cenTAlgorithms.py": {
        "test_t_fit": {
            "name": "test_t_fit",
            "location": 11,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_exponentialAlgorithms.py": {
        "test_exponential_sample": {
            "name": "test_exponential_sample",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_exponential_mode": {
            "name": "test_exponential_mode",
            "location": 31,
            "return": [],
            "arguments": {}
        },
        "test_exponential_pdf": {
            "name": "test_exponential_pdf",
            "location": 47,
            "return": [],
            "arguments": {}
        },
        "test_exponential_llh": {
            "name": "test_exponential_llh",
            "location": 68,
            "return": [],
            "arguments": {}
        },
        "test_exponential_fit": {
            "name": "test_exponential_fit",
            "location": 90,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_laplaceAlgorithms.py": {
        "test_laplace_sample": {
            "name": "test_laplace_sample",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_laplace_mode": {
            "name": "test_laplace_mode",
            "location": 34,
            "return": [],
            "arguments": {}
        },
        "test_laplace_pdf": {
            "name": "test_laplace_pdf",
            "location": 51,
            "return": [],
            "arguments": {}
        },
        "test_laplace_llh": {
            "name": "test_laplace_llh",
            "location": 73,
            "return": [],
            "arguments": {}
        },
        "test_laplace_fit": {
            "name": "test_laplace_fit",
            "location": 96,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_lomaxAlgorithms.py": {
        "test_lomax_sample": {
            "name": "test_lomax_sample",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_lomax_mode": {
            "name": "test_lomax_mode",
            "location": 60,
            "return": [],
            "arguments": {}
        },
        "test_lomax_pdf": {
            "name": "test_lomax_pdf",
            "location": 77,
            "return": [],
            "arguments": {}
        },
        "test_lomax_llh": {
            "name": "test_lomax_llh",
            "location": 113,
            "return": [],
            "arguments": {}
        },
        "test_lomax_fit": {
            "name": "test_lomax_fit",
            "location": 150,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/test_nnNormalAlgorithms.py": {
        "test_nnNormal_fit": {
            "name": "test_nnNormal_fit",
            "location": 131,
            "return": [],
            "arguments": {
                "dtype": []
            }
        }
    },
    "decompose-master/decompose/distributions/tests/test_normalAlgorithms.py": {
        "test_normal_sample": {
            "name": "test_normal_sample",
            "location": 12,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_normal_mode": {
            "name": "test_normal_mode",
            "location": 38,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_normal_pdf": {
            "name": "test_normal_pdf",
            "location": 58,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_normal_llh": {
            "name": "test_normal_llh",
            "location": 83,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_normal_fit": {
            "name": "test_normal_fit",
            "location": 109,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        }
    },
    "decompose-master/decompose/distributions/tests/test_tAlgorithms.py": {
        "test_t_sample": {
            "name": "test_t_sample",
            "location": 10,
            "return": [],
            "arguments": {}
        },
        "test_t_mode": {
            "name": "test_t_mode",
            "location": 65,
            "return": [],
            "arguments": {}
        },
        "test_t_pdf": {
            "name": "test_t_pdf",
            "location": 84,
            "return": [],
            "arguments": {}
        },
        "test_t_llh": {
            "name": "test_t_llh",
            "location": 109,
            "return": [],
            "arguments": {}
        },
        "test_t_fit": {
            "name": "test_t_fit",
            "location": 135,
            "return": [],
            "arguments": {}
        }
    },
    "decompose-master/decompose/distributions/tests/__init__.py": {},
    "decompose-master/decompose/likelihoods/allSpecificNormal2dLikelihood.py": {
        "AllSpecificNormal2dLikelihood.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "tau": [
                    "float"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "dtype": []
            }
        },
        "AllSpecificNormal2dLikelihood.init": {
            "name": "init",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "AllSpecificNormal2dLikelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 38,
            "return": [
                "CenNormalRankOne"
            ],
            "arguments": {
                "self": []
            }
        },
        "AllSpecificNormal2dLikelihood.residuals": {
            "name": "residuals",
            "location": 41,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "AllSpecificNormal2dLikelihood.llh": {
            "name": "llh",
            "location": 48,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "AllSpecificNormal2dLikelihood.loss": {
            "name": "loss",
            "location": 53,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "AllSpecificNormal2dLikelihood.update": {
            "name": "update",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "AllSpecificNormal2dLikelihood.prepVars": {
            "name": "prepVars",
            "location": 62,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/likelihoods/cvNormal2dLikelihood.py": {
        "CVNormal2dLikelihood.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "tau": [
                    "float"
                ],
                "cv": [
                    "CV"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "dtype": []
            }
        },
        "CVNormal2dLikelihood.init": {
            "name": "init",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.cv": {
            "name": "cv",
            "location": 49,
            "return": [
                "CV"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormal2dLikelihood.observedMask": {
            "name": "observedMask",
            "location": 53,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormal2dLikelihood.trainMask": {
            "name": "trainMask",
            "location": 57,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormal2dLikelihood.testMask": {
            "name": "testMask",
            "location": 61,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormal2dLikelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 65,
            "return": [
                "CenNormal"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormal2dLikelihood.residuals": {
            "name": "residuals",
            "location": 68,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.testResiduals": {
            "name": "testResiduals",
            "location": 71,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.trainResiduals": {
            "name": "trainResiduals",
            "location": 81,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.llh": {
            "name": "llh",
            "location": 91,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.loss": {
            "name": "loss",
            "location": 96,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.update": {
            "name": "update",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormal2dLikelihood.prepVars": {
            "name": "prepVars",
            "location": 106,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/likelihoods/cvNormalNdLikelihood.py": {
        "CVNormalNdLikelihood.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "tau": [
                    "float"
                ],
                "cv": [
                    "CV"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "dtype": []
            }
        },
        "CVNormalNdLikelihood.init": {
            "name": "init",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.cv": {
            "name": "cv",
            "location": 50,
            "return": [
                "CV"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormalNdLikelihood.observedMask": {
            "name": "observedMask",
            "location": 54,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormalNdLikelihood.trainMask": {
            "name": "trainMask",
            "location": 58,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormalNdLikelihood.testMask": {
            "name": "testMask",
            "location": 62,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormalNdLikelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 66,
            "return": [
                "CenNormal"
            ],
            "arguments": {
                "self": []
            }
        },
        "CVNormalNdLikelihood.residuals": {
            "name": "residuals",
            "location": 69,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.testResiduals": {
            "name": "testResiduals",
            "location": 72,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.trainResiduals": {
            "name": "trainResiduals",
            "location": 83,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.llh": {
            "name": "llh",
            "location": 94,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.loss": {
            "name": "loss",
            "location": 99,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.update": {
            "name": "update",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "CVNormalNdLikelihood.outterTensorProduct": {
            "name": "outterTensorProduct",
            "location": 109,
            "return": [],
            "arguments": {
                "self": [],
                "Us": []
            }
        },
        "CVNormalNdLikelihood.calcB": {
            "name": "calcB",
            "location": 116,
            "return": [],
            "arguments": {
                "self": [],
                "mask": [],
                "UmfOutter": [],
                "f": [],
                "F": []
            }
        },
        "CVNormalNdLikelihood.prepVars": {
            "name": "prepVars",
            "location": 129,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/likelihoods/likelihood.py": {
        "Likelihood.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ]
            }
        },
        "Likelihood.prepVars": {
            "name": "prepVars",
            "location": 18,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Likelihood.lhUfk": {
            "name": "lhUfk",
            "location": 22,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": [],
                "Uf": [
                    "Tensor"
                ],
                "prepVars": [
                    "Tuple[(Tensor, ...)]"
                ],
                "f": [
                    "int"
                ],
                "k": [
                    "Tensor"
                ]
            }
        },
        "Likelihood.update": {
            "name": "update",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Likelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 50,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": []
            }
        },
        "Likelihood.init": {
            "name": "init",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Likelihood.llh": {
            "name": "llh",
            "location": 58,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Likelihood.loss": {
            "name": "loss",
            "location": 62,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Likelihood.M": {
            "name": "M",
            "location": 66,
            "return": [
                "Tuple[(int, ...)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Likelihood.F": {
            "name": "F",
            "location": 70,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Likelihood.K": {
            "name": "K",
            "location": 74,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Likelihood.id": {
            "name": "id",
            "location": 78,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/likelihoods/normal2dLikelihood.py": {
        "Normal2dLikelihood.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "tau": [
                    "float"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "dtype": [
                    "DType"
                ]
            }
        },
        "Normal2dLikelihood.init": {
            "name": "init",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "Normal2dLikelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 35,
            "return": [
                "CenNormal"
            ],
            "arguments": {
                "self": []
            }
        },
        "Normal2dLikelihood.residuals": {
            "name": "residuals",
            "location": 38,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Normal2dLikelihood.llh": {
            "name": "llh",
            "location": 45,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Normal2dLikelihood.loss": {
            "name": "loss",
            "location": 50,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Normal2dLikelihood.update": {
            "name": "update",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "Normal2dLikelihood.prepVars": {
            "name": "prepVars",
            "location": 60,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/likelihoods/normalNdLikelihood.py": {
        "NormalNdLikelihood.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "tau": [
                    "float"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "dtype": []
            }
        },
        "NormalNdLikelihood.init": {
            "name": "init",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "NormalNdLikelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 36,
            "return": [
                "CenNormal"
            ],
            "arguments": {
                "self": []
            }
        },
        "NormalNdLikelihood.residuals": {
            "name": "residuals",
            "location": 39,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "NormalNdLikelihood.llh": {
            "name": "llh",
            "location": 47,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "NormalNdLikelihood.loss": {
            "name": "loss",
            "location": 52,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "NormalNdLikelihood.update": {
            "name": "update",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "NormalNdLikelihood.outterTensorProduct": {
            "name": "outterTensorProduct",
            "location": 62,
            "return": [],
            "arguments": {
                "self": [],
                "Us": []
            }
        },
        "NormalNdLikelihood.prepVars": {
            "name": "prepVars",
            "location": 69,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/likelihoods/specificNormal2dLikelihood.py": {
        "SpecificNormal2dLikelihood.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "tau": [
                    "float"
                ],
                "drawType": [
                    "DrawType"
                ],
                "updateType": [
                    "UpdateType"
                ],
                "dtype": []
            }
        },
        "SpecificNormal2dLikelihood.init": {
            "name": "init",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Tensor"
                ]
            }
        },
        "SpecificNormal2dLikelihood.noiseDistribution": {
            "name": "noiseDistribution",
            "location": 36,
            "return": [
                "CenNormal"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpecificNormal2dLikelihood.residuals": {
            "name": "residuals",
            "location": 39,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "SpecificNormal2dLikelihood.llh": {
            "name": "llh",
            "location": 46,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "SpecificNormal2dLikelihood.loss": {
            "name": "loss",
            "location": 51,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "SpecificNormal2dLikelihood.update": {
            "name": "update",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(Tensor, ...)]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        },
        "SpecificNormal2dLikelihood.prepVars": {
            "name": "prepVars",
            "location": 60,
            "return": [
                "Tuple[(Tensor, Tensor, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int"
                ],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ]
            }
        }
    },
    "decompose-master/decompose/likelihoods/__init__.py": {},
    "decompose-master/decompose/likelihoods/tests/test_normal2dLikelihood.py": {
        "f": {
            "name": "f",
            "location": 15,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "updateType": {
            "name": "updateType",
            "location": 22,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_residuals": {
            "name": "test_residuals",
            "location": 28,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_loss": {
            "name": "test_loss",
            "location": 51,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_llh": {
            "name": "test_llh",
            "location": 74,
            "return": [],
            "arguments": {
                "device": [],
                "dtype": []
            }
        },
        "test_prepVars": {
            "name": "test_prepVars",
            "location": 98,
            "return": [],
            "arguments": {
                "device": [],
                "f": [],
                "dtype": []
            }
        },
        "test_update": {
            "name": "test_update",
            "location": 136,
            "return": [],
            "arguments": {
                "device": [],
                "f": [],
                "updateType": [],
                "dtype": []
            }
        }
    },
    "decompose-master/decompose/likelihoods/tests/__init__.py": {},
    "decompose-master/decompose/models/tensorFactorisation.py": {
        "parameterProperty.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "fget": [],
                "fset": [],
                "fdel": [],
                "doc": [],
                "name": []
            }
        },
        "parameterProperty.__set__": {
            "name": "__set__",
            "location": 57,
            "return": [],
            "arguments": {
                "self": [],
                "obj": [],
                "values": []
            }
        },
        "parameterProperty.__get__": {
            "name": "__get__",
            "location": 73,
            "return": [],
            "arguments": {
                "self": [],
                "obj": [],
                "objtype": []
            }
        },
        "parameterProperty.__delete__": {
            "name": "__delete__",
            "location": 80,
            "return": [],
            "arguments": {
                "self": [],
                "obj": []
            }
        },
        "parameterProperty.getter": {
            "name": "getter",
            "location": 85,
            "return": [],
            "arguments": {
                "self": [],
                "fget": []
            }
        },
        "parameterProperty.setter": {
            "name": "setter",
            "location": 88,
            "return": [],
            "arguments": {
                "self": [],
                "name": []
            }
        },
        "parameterProperty.deleter": {
            "name": "deleter",
            "location": 98,
            "return": [],
            "arguments": {
                "self": [],
                "fdel": []
            }
        },
        "TensorFactorisation.__init__": {
            "name": "__init__",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "List[Tensor]"
                ],
                "priorU": [
                    "List[Distribution]"
                ],
                "likelihood": [
                    "Likelihood"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "stopCriterion": [],
                "phase": [
                    "Phase"
                ],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "transform": [
                    "bool"
                ]
            }
        },
        "TensorFactorisation.random": {
            "name": "random",
            "location": 151,
            "return": [
                "'TensorFactorisation'"
            ],
            "arguments": {
                "cls": [],
                "priorU": [
                    "List[Distribution]"
                ],
                "likelihood": [
                    "Likelihood"
                ],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "phase": [
                    "Phase"
                ],
                "stopCriterion": [],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "transform": [
                    "bool"
                ]
            }
        },
        "TensorFactorisation.transform": {
            "name": "transform",
            "location": 188,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFactorisation.noiseUniformity": {
            "name": "noiseUniformity",
            "location": 192,
            "return": [
                "NoiseUniformity"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFactorisation.U": {
            "name": "U",
            "location": 200,
            "return": [],
            "arguments": {
                "self": [],
                "U": [
                    "Tuple[(tf.Tensor, ...)]"
                ]
            }
        },
        "TensorFactorisation.update": {
            "name": "update",
            "location": 203,
            "return": [
                "Tuple[(Tensor, ...)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "TensorFactorisation.updateTrain": {
            "name": "updateTrain",
            "location": 217,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "TensorFactorisation.updateTransform": {
            "name": "updateTransform",
            "location": 232,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "TensorFactorisation.rescale": {
            "name": "rescale",
            "location": 242,
            "return": [
                "List[Tensor]"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "List[Tensor]"
                ],
                "fNonUnit": [
                    "int"
                ]
            }
        },
        "TensorFactorisation.__setEm": {
            "name": "__setEm",
            "location": 270,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFactorisation.__setBcd": {
            "name": "__setBcd",
            "location": 278,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFactorisation.loss": {
            "name": "loss",
            "location": 286,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "TensorFactorisation.llh": {
            "name": "llh",
            "location": 292,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "TensorFactorisation.llhIndividual": {
            "name": "llhIndividual",
            "location": 308,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "TensorFactorisation.type": {
            "name": "type",
            "location": 330,
            "return": [],
            "arguments": {}
        },
        "TensorFactorisation.id": {
            "name": "id",
            "location": 333,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFactorisation.__model": {
            "name": "__model",
            "location": 342,
            "return": [
                "'TensorFactorisation'"
            ],
            "arguments": {
                "cls": [],
                "data": [
                    "Tensor"
                ],
                "priorTypes": [
                    "List[Distribution]"
                ],
                "M": [
                    "Tuple[(int, ...)]"
                ],
                "K": [
                    "int"
                ],
                "stopCriterion": [],
                "phase": [
                    "Phase"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "reuse": [],
                "isFullyObserved": [
                    "bool"
                ],
                "cv": [
                    "CV"
                ],
                "transform": [
                    "bool"
                ],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "suffix": [
                    "str"
                ]
            }
        },
        "TensorFactorisation.__estimatorSpec": {
            "name": "__estimatorSpec",
            "location": 429,
            "return": [
                "EstimatorSpec"
            ],
            "arguments": {
                "cls": [],
                "mode": [],
                "features": [],
                "device": [
                    "str"
                ],
                "isFullyObserved": [
                    "bool"
                ],
                "priors": [
                    "List[Distribution]"
                ],
                "K": [
                    "int"
                ],
                "stopCriterionInit": [],
                "stopCriterionEM": [],
                "stopCriterionBCD": [],
                "cv": [
                    "CV"
                ],
                "path": [
                    "str"
                ],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "transform": [
                    "bool"
                ],
                "dtype": [
                    "tf.DType"
                ]
            }
        },
        "TensorFactorisation.getEstimator": {
            "name": "getEstimator",
            "location": 564,
            "return": [],
            "arguments": {
                "cls": [],
                "priors": [
                    "Tuple[(Distribution, ...)]"
                ],
                "K": [
                    "int"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "isFullyObserved": [
                    "bool"
                ],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "stopCriterionInit": [],
                "stopCriterionEM": [],
                "stopCriterionBCD": [],
                "path": [
                    "str"
                ],
                "device": [
                    "str"
                ],
                "cv": [
                    "CV"
                ]
            }
        },
        "TensorFactorisation.getTransformEstimator": {
            "name": "getTransformEstimator",
            "location": 591,
            "return": [],
            "arguments": {
                "cls": [],
                "priors": [
                    "Tuple[(Distribution, ...)]"
                ],
                "K": [
                    "int"
                ],
                "chptFile": [
                    "str"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "noiseUniformity": [
                    "NoiseUniformity"
                ],
                "stopCriterionInit": [],
                "stopCriterionEM": [],
                "stopCriterionBCD": [],
                "path": [
                    "str"
                ],
                "device": [
                    "str"
                ]
            }
        },
        "parameterProperty.setter.noop": {
            "name": "noop",
            "location": 94,
            "return": [],
            "arguments": {
                "fset": []
            }
        },
        "TensorFactorisation.getEstimator.model_fn": {
            "name": "model_fn",
            "location": 574,
            "return": [],
            "arguments": {
                "features": [],
                "labels": [],
                "mode": []
            }
        },
        "TensorFactorisation.getTransformEstimator.model_fn": {
            "name": "model_fn",
            "location": 611,
            "return": [],
            "arguments": {
                "features": [],
                "labels": [],
                "mode": []
            }
        }
    },
    "decompose-master/decompose/models/__init__.py": {},
    "decompose-master/decompose/models/tests/__init__.py": {},
    "decompose-master/decompose/postU/postU.py": {
        "PostU.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "likelihood": [
                    "Likelihood"
                ],
                "prior": [
                    "Distribution"
                ],
                "f": [
                    "int"
                ]
            }
        },
        "PostU.f": {
            "name": "f",
            "location": 19,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PostU.prior": {
            "name": "prior",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PostU.updateUf": {
            "name": "updateUf",
            "location": 26,
            "return": [],
            "arguments": {
                "self": [],
                "Uf": [],
                "Ufk": [],
                "k": []
            }
        },
        "PostU.update": {
            "name": "update",
            "location": 30,
            "return": [
                "Tuple[Tensor]"
            ],
            "arguments": {
                "self": [],
                "U": [
                    "List[Tensor]"
                ],
                "X": [
                    "Tensor"
                ],
                "transform": [
                    "bool"
                ]
            }
        },
        "PostU.updateK": {
            "name": "updateK",
            "location": 57,
            "return": [],
            "arguments": {
                "self": [],
                "k": [],
                "prepVars": [],
                "U": []
            }
        },
        "PostU.update.cond": {
            "name": "cond",
            "location": 45,
            "return": [],
            "arguments": {
                "k": [],
                "U": []
            }
        },
        "PostU.update.body": {
            "name": "body",
            "location": 48,
            "return": [],
            "arguments": {
                "k": [],
                "U": []
            }
        }
    },
    "decompose-master/decompose/postU/__init__.py": {},
    "decompose-master/decompose/postU/tests/test_postU.py": {
        "f": {
            "name": "f",
            "location": 17,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "updateType": {
            "name": "updateType",
            "location": 24,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_update": {
            "name": "test_update",
            "location": 29,
            "return": [],
            "arguments": {
                "device": [],
                "f": [],
                "dtype": []
            }
        }
    },
    "decompose-master/decompose/postU/tests/__init__.py": {},
    "decompose-master/decompose/stopCriterions/llhImprovementThreshold.py": {
        "LlhImprovementThreshold.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lhImprovementThreshold": [
                    "float"
                ]
            }
        },
        "LlhImprovementThreshold.init": {
            "name": "init",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ns": [
                    "str"
                ]
            }
        },
        "LlhImprovementThreshold.update": {
            "name": "update",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "LlhImprovementThreshold.stopVar": {
            "name": "stopVar",
            "location": 35,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "LlhImprovementThreshold.llhImprovementThreshold": {
            "name": "llhImprovementThreshold",
            "location": 39,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/stopCriterions/llhStall.py": {
        "LlhStall.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nStalledIterationsThreshold": [
                    "int"
                ]
            }
        },
        "LlhStall.init": {
            "name": "init",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ns": [
                    "str"
                ]
            }
        },
        "LlhStall.update": {
            "name": "update",
            "location": 26,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "LlhStall.stopVar": {
            "name": "stopVar",
            "location": 38,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/stopCriterions/nIterations.py": {
        "NIterations.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": [],
                "nIterations": []
            }
        },
        "NIterations.init": {
            "name": "init",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ns": [
                    "str"
                ]
            }
        },
        "NIterations.update": {
            "name": "update",
            "location": 23,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "NIterations.stopVar": {
            "name": "stopVar",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "decompose-master/decompose/stopCriterions/stopCriterion.py": {
        "StopCriterion.init": {
            "name": "init",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ns": [
                    "str"
                ]
            }
        },
        "NoStop.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "NoStop.init": {
            "name": "init",
            "location": 17,
            "return": [],
            "arguments": {
                "self": [],
                "ns": []
            }
        },
        "NoStop.update": {
            "name": "update",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "X": [
                    "Tensor"
                ]
            }
        },
        "NoStop.stopVar": {
            "name": "stopVar",
            "location": 29,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "StopHook.after_run": {
            "name": "after_run",
            "location": 34,
            "return": [],
            "arguments": {
                "self": [],
                "run_context": [],
                "run_values": []
            }
        }
    },
    "decompose-master/decompose/stopCriterions/__init__.py": {},
    "decompose-master/decompose/tests/fixtures.py": {
        "device": {
            "name": "device",
            "location": 7,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "dtype": {
            "name": "dtype",
            "location": 15,
            "return": [],
            "arguments": {
                "request": []
            }
        }
    },
    "decompose-master/decompose/tests/test_all_priors.py": {
        "PriorDistribution": {
            "name": "PriorDistribution",
            "location": 34,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "test_all_priors": {
            "name": "test_all_priors",
            "location": 42,
            "return": [],
            "arguments": {
                "tmpdir": [],
                "PriorDistribution": []
            }
        }
    },
    "decompose-master/decompose/tests/test_sklearn.py": {
        "test_sklearn": {
            "name": "test_sklearn",
            "location": 14,
            "return": [],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "decompose-master/decompose/tests/test_sklearn_all_het_noise.py": {
        "test_sklearn": {
            "name": "test_sklearn",
            "location": 16,
            "return": [],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "decompose-master/decompose/tests/test_sklearn_cv.py": {
        "test_sklearn_cv": {
            "name": "test_sklearn_cv",
            "location": 15,
            "return": [],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "decompose-master/decompose/tests/test_sklearn_cv_tensor.py": {
        "test_sklearn_cv": {
            "name": "test_sklearn_cv",
            "location": 15,
            "return": [],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "decompose-master/decompose/tests/test_sklearn_het_noise.py": {
        "test_sklearn": {
            "name": "test_sklearn",
            "location": 16,
            "return": [],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "decompose-master/decompose/tests/test_sklearn_tensor.py": {
        "test_sklearn_tensor": {
            "name": "test_sklearn_tensor",
            "location": 14,
            "return": [],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "decompose-master/decompose/tests/__init__.py": {},
    "decompose-master/docs/source/conf.py": {}
}
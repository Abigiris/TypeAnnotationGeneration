{
    "formatml-master/setup.py": {},
    "formatml-master/codrep/visualizer/serve.py": {
        "_list_tasks": {
            "name": "_list_tasks",
            "location": 13,
            "return": [
                "Tuple[(List[str], List[int])]"
            ],
            "arguments": {
                "path": [
                    "Path"
                ]
            }
        },
        "_parse_output": {
            "name": "_parse_output",
            "location": 31,
            "return": [
                "Dict[(str, List[int])]"
            ],
            "arguments": {
                "path": [
                    "Path"
                ],
                "task_names": [
                    "List[str]"
                ]
            }
        },
        "_parse_metadata": {
            "name": "_parse_metadata",
            "location": 54,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "path": [
                    "Optional[Path]"
                ]
            }
        },
        "_create_app": {
            "name": "_create_app",
            "location": 73,
            "return": [
                "Flask"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "_create_app.index": {
            "name": "index",
            "location": 82,
            "return": [
                "Any"
            ],
            "arguments": {}
        },
        "_create_app.tasks": {
            "name": "tasks",
            "location": 86,
            "return": [
                "Response"
            ],
            "arguments": {}
        },
        "_create_app.task": {
            "name": "task",
            "location": 96,
            "return": [
                "Response"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/__init__.py": {},
    "formatml-master/formatml/__main__.py": {
        "main": {
            "name": "main",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/data/instance.py": {
        "Instance.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fields": [
                    "List[Field]"
                ]
            }
        },
        "Instance.index": {
            "name": "index",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Any"
                ]
            }
        },
        "Instance.tensorize": {
            "name": "tensorize",
            "location": 39,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Any"
                ]
            }
        },
        "Instance.collate": {
            "name": "collate",
            "location": 51,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "Instance.to": {
            "name": "to",
            "location": 63,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Dict[(str, Any)]"
                ],
                "device": [
                    "torch_device"
                ]
            }
        },
        "Instance.save": {
            "name": "save",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "Path"
                ]
            }
        },
        "Instance.get_field_by_type": {
            "name": "get_field_by_type",
            "location": 72,
            "return": [
                "Field"
            ],
            "arguments": {
                "self": [],
                "field_type": [
                    "str"
                ]
            }
        },
        "Instance.get_fields_by_type": {
            "name": "get_fields_by_type",
            "location": 75,
            "return": [
                "List[Field]"
            ],
            "arguments": {
                "self": [],
                "field_type": [
                    "str"
                ]
            }
        },
        "Instance._select_input": {
            "name": "_select_input",
            "location": 78,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "field": [
                    "Field"
                ],
                "inputs": [
                    "Any"
                ]
            }
        },
        "Instance.__getitem__": {
            "name": "__getitem__",
            "location": 89,
            "return": [
                "Field"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/data/vocabulary.py": {
        "Vocabulary.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "unknown": [
                    "Optional[_T]"
                ],
                "initial_words": [
                    "Tuple[(_T, ...)]"
                ]
            }
        },
        "Vocabulary.add_item": {
            "name": "add_item",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "_T"
                ]
            }
        },
        "Vocabulary.add_items": {
            "name": "add_items",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "Iterable[_T]"
                ]
            }
        },
        "Vocabulary.get_index": {
            "name": "get_index",
            "location": 50,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "_T"
                ]
            }
        },
        "Vocabulary.get_indexes": {
            "name": "get_indexes",
            "location": 61,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "Iterable[_T]"
                ]
            }
        },
        "Vocabulary.get_item": {
            "name": "get_item",
            "location": 70,
            "return": [
                "_T"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "Vocabulary.get_items": {
            "name": "get_items",
            "location": 79,
            "return": [
                "List[_T]"
            ],
            "arguments": {
                "self": [],
                "indexes": [
                    "Iterable[int]"
                ]
            }
        },
        "Vocabulary.__contains__": {
            "name": "__contains__",
            "location": 88,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "Any"
                ]
            }
        },
        "Vocabulary.__len__": {
            "name": "__len__",
            "location": 97,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/data/__init__.py": {},
    "formatml-master/formatml/data/fields/binary_label_field.py": {
        "BinaryLabelsField.tensorize": {
            "name": "tensorize",
            "location": 10,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "CodRepLabel"
                ]
            }
        },
        "BinaryLabelsField.collate": {
            "name": "collate",
            "location": 15,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[Tensor]"
                ]
            }
        },
        "BinaryLabelsField.to": {
            "name": "to",
            "location": 18,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Tensor"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/field.py": {
        "Field.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "Field.index": {
            "name": "index",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "_TInputs"
                ]
            }
        },
        "Field.tensorize": {
            "name": "tensorize",
            "location": 27,
            "return": [
                "_TOutputs"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "_TInputs"
                ]
            }
        },
        "Field.collate": {
            "name": "collate",
            "location": 36,
            "return": [
                "_TOutputs"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[_TOutputs]"
                ]
            }
        },
        "Field.to": {
            "name": "to",
            "location": 45,
            "return": [
                "_TOutputs"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "_TOutputs"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/indexes_field.py": {
        "IndexesField.tensorize": {
            "name": "tensorize",
            "location": 16,
            "return": [
                "IndexesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Nodes"
                ]
            }
        },
        "IndexesField.collate": {
            "name": "collate",
            "location": 26,
            "return": [
                "IndexesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[IndexesFieldOutput]"
                ]
            }
        },
        "IndexesField.to": {
            "name": "to",
            "location": 39,
            "return": [
                "IndexesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "IndexesFieldOutput"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/internal_type_field.py": {
        "InternalTypeField.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "InternalTypeField.index": {
            "name": "index",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "InternalTypeField.tensorize": {
            "name": "tensorize",
            "location": 25,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "InternalTypeField.collate": {
            "name": "collate",
            "location": 31,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[Tensor]"
                ]
            }
        },
        "InternalTypeField.to": {
            "name": "to",
            "location": 34,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Tensor"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/label_field.py": {
        "LabelField.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "LabelField.index": {
            "name": "index",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "LabelField.tensorize": {
            "name": "tensorize",
            "location": 36,
            "return": [
                "LabelFieldOutput"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "LabelField.collate": {
            "name": "collate",
            "location": 62,
            "return": [
                "LabelFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[LabelFieldOutput]"
                ]
            }
        },
        "LabelField.to": {
            "name": "to",
            "location": 82,
            "return": [
                "LabelFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "LabelFieldOutput"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/length_field.py": {
        "LengthField.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LengthField.tensorize": {
            "name": "tensorize",
            "location": 23,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "LengthField.collate": {
            "name": "collate",
            "location": 26,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[Tensor]"
                ]
            }
        },
        "LengthField.to": {
            "name": "to",
            "location": 29,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Tensor"
                ],
                "device": [
                    "torch_device"
                ]
            }
        },
        "LengthField._length": {
            "name": "_length",
            "location": 32,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Node"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/metadata_field.py": {
        "MetadataField.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetadataField.tensorize": {
            "name": "tensorize",
            "location": 13,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Tuple[(str, Nodes)]"
                ]
            }
        },
        "MetadataField.collate": {
            "name": "collate",
            "location": 17,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[List[str]]"
                ]
            }
        },
        "MetadataField.to": {
            "name": "to",
            "location": 20,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "List[str]"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/roles_field.py": {
        "RolesField.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "RolesField.index": {
            "name": "index",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "RolesField.tensorize": {
            "name": "tensorize",
            "location": 26,
            "return": [
                "RolesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "RolesField.collate": {
            "name": "collate",
            "location": 37,
            "return": [
                "RolesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[RolesFieldOutput]"
                ]
            }
        },
        "RolesField.to": {
            "name": "to",
            "location": 49,
            "return": [
                "RolesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "RolesFieldOutput"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/typed_dgl_graph_field.py": {
        "TypedDGLGraphField.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ],
                "edge_types": [
                    "List[str]"
                ]
            }
        },
        "TypedDGLGraphField.tensorize": {
            "name": "tensorize",
            "location": 25,
            "return": [
                "TypedDGLGraphFieldOutput"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Nodes"
                ]
            }
        },
        "TypedDGLGraphField.collate": {
            "name": "collate",
            "location": 61,
            "return": [
                "TypedDGLGraphFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "Iterable[TypedDGLGraphFieldOutput]"
                ]
            }
        },
        "TypedDGLGraphField.to": {
            "name": "to",
            "location": 70,
            "return": [
                "TypedDGLGraphFieldOutput"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "TypedDGLGraphFieldOutput"
                ],
                "device": [
                    "torch_device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/__init__.py": {},
    "formatml-master/formatml/data/fields/tests/conftest.py": {
        "nodes": {
            "name": "nodes",
            "location": 10,
            "return": [
                "Nodes"
            ],
            "arguments": {}
        },
        "other_nodes": {
            "name": "other_nodes",
            "location": 16,
            "return": [
                "Nodes"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/data/fields/tests/test_dgl_graph_field.py": {
        "_make_field": {
            "name": "_make_field",
            "location": 7,
            "return": [
                "TypedDGLGraphField"
            ],
            "arguments": {
                "edge_types": [
                    "List[str]"
                ]
            }
        },
        "test_graph_field": {
            "name": "test_graph_field",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "Nodes"
                ]
            }
        },
        "test_no_edge_types": {
            "name": "test_no_edge_types",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "Nodes"
                ]
            }
        },
        "test_symmetric_edge_types": {
            "name": "test_symmetric_edge_types",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "Nodes"
                ]
            }
        },
        "test_collate": {
            "name": "test_collate",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "Nodes"
                ],
                "other_nodes": [
                    "Nodes"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/tests/__init__.py": {},
    "formatml-master/formatml/data/types/codrep_label.py": {
        "CodRepLabel.to_tree": {
            "name": "to_tree",
            "location": 8,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CodRepLabel.from_tree": {
            "name": "from_tree",
            "location": 14,
            "return": [
                "'CodRepLabel'"
            ],
            "arguments": {
                "tree": [
                    "Dict[(str, Any)]"
                ]
            }
        }
    },
    "formatml-master/formatml/data/types/__init__.py": {},
    "formatml-master/formatml/datasets/codrep_dataset.py": {
        "CodRepDataset.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CodRepDataset.__getitem__": {
            "name": "__getitem__",
            "location": 14,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "CodRepDataset.__len__": {
            "name": "__len__",
            "location": 18,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/datasets/dataset.py": {
        "Dataset.download": {
            "name": "download",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.pre_tensorize": {
            "name": "pre_tensorize",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.tensorize": {
            "name": "tensorize",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.collate": {
            "name": "collate",
            "location": 16,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        }
    },
    "formatml-master/formatml/datasets/repositories_dataset.py": {
        "RepositoriesDataset.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "download_dir": [
                    "str"
                ],
                "parse_dir": [
                    "str"
                ],
                "tensor_dir": [
                    "str"
                ],
                "repositories": [
                    "List[Tuple[(str, str, str)]]"
                ],
                "instance": [
                    "Instance"
                ],
                "parser": [
                    "Parser"
                ],
                "parallel_downloads": [
                    "int"
                ],
                "bblfsh_endpoint": [
                    "str"
                ],
                "n_workers": [
                    "int"
                ],
                "pickle_protocol": [
                    "int"
                ]
            }
        },
        "RepositoriesDataset.download": {
            "name": "download",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset.pre_tensorize": {
            "name": "pre_tensorize",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset.tensorize": {
            "name": "tensorize",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset.collate": {
            "name": "collate",
            "location": 66,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "RepositoriesDataset.__getitem__": {
            "name": "__getitem__",
            "location": 69,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "int"
                ]
            }
        },
        "RepositoriesDataset.__len__": {
            "name": "__len__",
            "location": 83,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset._compute_cumulative_lengths": {
            "name": "_compute_cumulative_lengths",
            "location": 89,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "sequences": [
                    "Iterable[Sized]"
                ]
            }
        },
        "RepositoriesDataset._download_repository": {
            "name": "_download_repository",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "repository": [
                    "RepositoryDataset"
                ]
            }
        }
    },
    "formatml-master/formatml/datasets/repository_dataset.py": {
        "RepositoryDataset.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.download": {
            "name": "download",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.pre_tensorize": {
            "name": "pre_tensorize",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.tensorize": {
            "name": "tensorize",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.collate": {
            "name": "collate",
            "location": 147,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "RepositoryDataset.__getitem__": {
            "name": "__getitem__",
            "location": 150,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "RepositoryDataset.__len__": {
            "name": "__len__",
            "location": 154,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset._tensorize_worker": {
            "name": "_tensorize_worker",
            "location": 157,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "Path"
                ]
            }
        }
    },
    "formatml-master/formatml/datasets/__init__.py": {},
    "formatml-master/formatml/models/codrep_model.py": {
        "CodRepModel.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "graph_embedder": [
                    "GraphEmbedding"
                ],
                "graph_encoder": [
                    "GraphEncoder"
                ],
                "class_projection": [
                    "Module"
                ],
                "graph_field_name": [
                    "str"
                ],
                "feature_field_names": [
                    "List[str]"
                ],
                "indexes_field_name": [
                    "str"
                ],
                "label_field_name": [
                    "str"
                ]
            }
        },
        "CodRepModel.forward": {
            "name": "forward",
            "location": 45,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "CodRepModel.decode": {
            "name": "decode",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CodRepModel.build_metadata": {
            "name": "build_metadata",
            "location": 101,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/models/gnn_rnn_model.py": {
        "GNNRNNModel.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "graph_embedder": [
                    "GraphEmbedding"
                ],
                "graph_encoder": [
                    "GraphEncoder"
                ],
                "output_embedder": [
                    "PackedEmbedding"
                ],
                "decoder": [
                    "Decoder"
                ],
                "class_projection": [
                    "VocabularyLinear"
                ],
                "graph_field_name": [
                    "str"
                ],
                "feature_field_names": [
                    "List[str]"
                ],
                "label_field_name": [
                    "str"
                ]
            }
        },
        "GNNRNNModel.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        }
    },
    "formatml-master/formatml/models/model.py": {
        "Model.forward": {
            "name": "forward",
            "location": 9,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        }
    },
    "formatml-master/formatml/models/__init__.py": {},
    "formatml-master/formatml/modules/__init__.py": {},
    "formatml-master/formatml/modules/decoders/concat_conditioning_decoder.py": {
        "ConcatConditioningDecoder.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [],
            "arguments": {
                "self": [],
                "recurrent": [
                    "Module"
                ]
            }
        },
        "ConcatConditioningDecoder.forward": {
            "name": "forward",
            "location": 15,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ],
                "conditions": [
                    "Tensor"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/decoders/decoder.py": {},
    "formatml-master/formatml/modules/decoders/__init__.py": {},
    "formatml-master/formatml/modules/graph_encoders/ggnn.py": {
        "GGNN.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "in_feats": [
                    "int"
                ],
                "out_feats": [
                    "int"
                ],
                "n_steps": [
                    "int"
                ],
                "n_etypes": [
                    "int"
                ],
                "bias": [
                    "bool"
                ]
            }
        },
        "GGNN.forward": {
            "name": "forward",
            "location": 36,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "graph": [
                    "DGLGraph"
                ],
                "feat": [
                    "Tensor"
                ],
                "etypes": [
                    "Tensor"
                ]
            }
        },
        "GGNN._message": {
            "name": "_message",
            "location": 65,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "edge_type": [
                    "int"
                ],
                "edge_batch": [
                    "EdgeBatch"
                ]
            }
        },
        "GGNN._update": {
            "name": "_update",
            "location": 68,
            "return": [
                "Dict[(str, Tensor)]"
            ],
            "arguments": {
                "self": [],
                "node_batch": [
                    "NodeBatch"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/graph_encoders/graph_encoder.py": {
        "GraphEncoder.forward": {
            "name": "forward",
            "location": 9,
            "return": [
                "DGLGraph"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/modules/graph_encoders/__init__.py": {},
    "formatml-master/formatml/modules/misc/graph_embedding.py": {
        "GraphEmbedding.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dimensions": [
                    "List[int]"
                ],
                "vocabularies": [
                    "List[Vocabulary]"
                ]
            }
        },
        "GraphEmbedding.forward": {
            "name": "forward",
            "location": 24,
            "return": [
                "DGLGraph"
            ],
            "arguments": {
                "self": [],
                "graph": [
                    "DGLGraph"
                ],
                "features": [
                    "List[Any]"
                ]
            }
        },
        "GraphEmbedding._configure": {
            "name": "_configure",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "example_features": [
                    "List[Any]"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/item_getter.py": {
        "ItemGetter.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "ItemGetter.forward": {
            "name": "forward",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Tensor"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/packed_embedding.py": {
        "PackedEmbedding.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": [],
                "dimension": [
                    "int"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "PackedEmbedding.forward": {
            "name": "forward",
            "location": 14,
            "return": [
                "PackedSequence"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "PackedSequence"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/selector.py": {
        "Selector.forward": {
            "name": "forward",
            "location": 8,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/modules/misc/squeezer.py": {
        "Squeezer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [],
            "arguments": {
                "self": [],
                "dim": [
                    "Optional[int]"
                ]
            }
        },
        "Squeezer.forward": {
            "name": "forward",
            "location": 14,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Tensor"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/unsqueezer.py": {
        "Unsqueezer.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ]
            }
        },
        "Unsqueezer.forward": {
            "name": "forward",
            "location": 12,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Tensor"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/vocabulary_linear.py": {
        "VocabularyLinear.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/modules/misc/__init__.py": {},
    "formatml-master/formatml/parsing/javascript_parser.py": {},
    "formatml-master/formatml/parsing/java_parser.py": {
        "_remove_children": {
            "name": "_remove_children",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "bblfsh_node": [
                    "BblfshNode"
                ]
            }
        },
        "_exclude_if_empty": {
            "name": "_exclude_if_empty",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "bblfsh_node": [
                    "BblfshNode"
                ]
            }
        }
    },
    "formatml-master/formatml/parsing/parser.py": {
        "Node.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Node.__repr__": {
            "name": "__repr__",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Nodes.to_tree": {
            "name": "to_tree",
            "location": 72,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "file_content": [
                    "str"
                ]
            }
        },
        "Nodes.from_token_nodes": {
            "name": "from_token_nodes",
            "location": 108,
            "return": [
                "'Nodes'"
            ],
            "arguments": {
                "token_nodes": [
                    "List[Node]"
                ]
            }
        },
        "Nodes.from_tree": {
            "name": "from_tree",
            "location": 135,
            "return": [
                "'Nodes'"
            ],
            "arguments": {
                "tree": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "BblfshNodeConverter.__init__": {
            "name": "__init__",
            "location": 182,
            "return": [],
            "arguments": {
                "self": [],
                "file_content": [
                    "str"
                ],
                "convert_to_utf8": [
                    "bool"
                ]
            }
        },
        "BblfshNodeConverter.bblfsh_node_to_node": {
            "name": "bblfsh_node_to_node",
            "location": 193,
            "return": [
                "Node"
            ],
            "arguments": {
                "self": [],
                "bblfsh_node": [
                    "BblfshNode"
                ],
                "parent": [
                    "Optional[Node]"
                ]
            }
        },
        "Parser.__init_subclass__": {
            "name": "__init_subclass__",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [],
                "bblfsh_language": [
                    "str"
                ],
                "reserved": [
                    "List[str]"
                ],
                "uast_fixers": [
                    "Optional[Dict[(str, Callable[([BblfshNode], None)])]]"
                ],
                "convert_to_utf8": [
                    "bool"
                ]
            }
        },
        "Parser.__init__": {
            "name": "__init__",
            "location": 243,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "bblfshd_endpoint": [
                    "str"
                ],
                "split_formatting": [
                    "bool"
                ]
            }
        },
        "Parser.split_formatting": {
            "name": "split_formatting",
            "location": 265,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Parser.parse": {
            "name": "parse",
            "location": 268,
            "return": [
                "Nodes"
            ],
            "arguments": {
                "self": [],
                "repository_path": [
                    "Path"
                ],
                "file_path": [
                    "Path"
                ]
            }
        },
        "Parser._augment_tokens": {
            "name": "_augment_tokens",
            "location": 405,
            "return": [
                "List[Node]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[Node]"
                ]
            }
        },
        "Parser._find_parent": {
            "name": "_find_parent",
            "location": 456,
            "return": [
                "Optional[Node]"
            ],
            "arguments": {
                "node_index": [
                    "int"
                ],
                "nodes": [
                    "List[Node]"
                ],
                "closest_left_node": [
                    "Optional[Node]"
                ]
            }
        },
        "Parser._perform_split_formatting": {
            "name": "_perform_split_formatting",
            "location": 487,
            "return": [
                "List[Node]"
            ],
            "arguments": {
                "self": [],
                "nodes": [
                    "List[Node]"
                ]
            }
        },
        "Parser.__del__": {
            "name": "__del__",
            "location": 512,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/parsing/__init__.py": {},
    "formatml-master/formatml/pipelines/pipeline.py": {
        "register_step": {
            "name": "register_step",
            "location": 18,
            "return": [
                "Callable[([Callable[(..., Any)]], Callable[(..., Any)])]"
            ],
            "arguments": {
                "pipeline_name": [
                    "str"
                ],
                "parser_definer": [
                    "Callable[([ArgumentParser], None)]"
                ],
                "graceful_keyboard_interruption": [
                    "bool"
                ]
            }
        },
        "_define_parser": {
            "name": "_define_parser",
            "location": 40,
            "return": [
                "ArgumentParser"
            ],
            "arguments": {}
        },
        "parse_args": {
            "name": "parse_args",
            "location": 64,
            "return": [
                "Tuple[(Callable[(..., Any)], Dict[(str, Any)], bool)]"
            ],
            "arguments": {}
        },
        "register_step.wrapper": {
            "name": "wrapper",
            "location": 23,
            "return": [
                "Callable[(..., Any)]"
            ],
            "arguments": {
                "handler": [
                    "Callable[(..., Any)]"
                ]
            }
        }
    },
    "formatml-master/formatml/pipelines/__init__.py": {},
    "formatml-master/formatml/pipelines/codrep/cli_builder.py": {
        "CLIBuilder.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "parser": [
                    "ArgumentParser"
                ]
            }
        },
        "CLIBuilder.add_configs_dir": {
            "name": "add_configs_dir",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_raw_dir": {
            "name": "add_raw_dir",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_tensors_dir": {
            "name": "add_tensors_dir",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_uasts_dir": {
            "name": "add_uasts_dir",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_instance_file": {
            "name": "add_instance_file",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/pipelines/codrep/index.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "ArgumentParser"
                ]
            }
        },
        "index": {
            "name": "index",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/pipelines/codrep/parse.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "ArgumentParser"
                ]
            }
        },
        "parse": {
            "name": "parse",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/pipelines/codrep/run.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "ArgumentParser"
                ]
            }
        },
        "run": {
            "name": "run",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/pipelines/codrep/tensorize.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "ArgumentParser"
                ]
            }
        },
        "tensorize": {
            "name": "tensorize",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "_tensorize_worker": {
            "name": "_tensorize_worker",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "file_path": [
                    "Path"
                ],
                "instance": [
                    "Instance"
                ],
                "logger": [
                    "Logger"
                ],
                "uasts_dir_path": [
                    "Path"
                ],
                "output_dir_path": [
                    "Path"
                ],
                "pickle_protocol": [
                    "int"
                ]
            }
        }
    },
    "formatml-master/formatml/pipelines/codrep/train.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "ArgumentParser"
                ]
            }
        },
        "train": {
            "name": "train",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "build_model": {
            "name": "build_model",
            "location": 237,
            "return": [
                "CodRepModel"
            ],
            "arguments": {
                "instance": [
                    "Instance"
                ],
                "model_encoder_iterations": [
                    "int"
                ],
                "model_encoder_output_dim": [
                    "int"
                ],
                "model_encoder_message_dim": [
                    "int"
                ],
                "model_decoder_type": [
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/pipelines/codrep/__init__.py": {},
    "formatml-master/formatml/resources/resource.py": {
        "Context.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cache_dir": [
                    "Optional[Path]"
                ]
            }
        },
        "Context.register_resource": {
            "name": "register_resource",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "resource": [
                    "Any"
                ]
            }
        },
        "Context.get_resource": {
            "name": "get_resource",
            "location": 39,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Context.save_resources": {
            "name": "save_resources",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Context.save_resource": {
            "name": "save_resource",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "resource": [
                    "Any"
                ]
            }
        },
        "Context._name_cache_path": {
            "name": "_name_cache_path",
            "location": 63,
            "return": [
                "Path"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Context._resource_cache_path": {
            "name": "_resource_cache_path",
            "location": 66,
            "return": [
                "Path"
            ],
            "arguments": {
                "self": [],
                "resource": [
                    "Any"
                ]
            }
        }
    },
    "formatml-master/formatml/resources/__init__.py": {},
    "formatml-master/formatml/training/trainer.py": {
        "register_metric": {
            "name": "register_metric",
            "location": 35,
            "return": [
                "Callable[([Metric], Metric)]"
            ],
            "arguments": {
                "name": [
                    "str"
                ]
            }
        },
        "_cross_entropy": {
            "name": "_cross_entropy",
            "location": 44,
            "return": [
                "float"
            ],
            "arguments": {
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "_perplexity": {
            "name": "_perplexity",
            "location": 49,
            "return": [
                "float"
            ],
            "arguments": {
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "_mrr": {
            "name": "_mrr",
            "location": 54,
            "return": [
                "float"
            ],
            "arguments": {
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "_accuracy_max_decoding": {
            "name": "_accuracy_max_decoding",
            "location": 79,
            "return": [
                "float"
            ],
            "arguments": {
                "sample": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "register_metric.wrapper": {
            "name": "wrapper",
            "location": 36,
            "return": [
                "Metric"
            ],
            "arguments": {
                "metric": [
                    "Metric"
                ]
            }
        },
        "Trainer.__init__": {
            "name": "__init__",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "instance": [
                    "Instance"
                ],
                "model": [
                    "Model"
                ],
                "optimizer": [
                    "Optimizer"
                ],
                "scheduler": [
                    "Any"
                ],
                "epochs": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ],
                "run_dir_path": [
                    "Path"
                ],
                "eval_every": [
                    "int"
                ],
                "limit_epochs_at": [
                    "Optional[int]"
                ],
                "train_eval_split": [
                    "float"
                ],
                "metric_names": [
                    "List[str]"
                ],
                "selection_metric": [
                    "str"
                ],
                "kept_checkpoints": [
                    "int"
                ],
                "cuda_device": [
                    "Optional[int]"
                ]
            }
        },
        "Trainer.train": {
            "name": "train",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._train_epoch": {
            "name": "_train_epoch",
            "location": 185,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ]
            }
        },
        "Trainer._eval_epoch": {
            "name": "_eval_epoch",
            "location": 213,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ]
            }
        },
        "Trainer._save_checkpoint": {
            "name": "_save_checkpoint",
            "location": 235,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ],
                "score": [
                    "float"
                ],
                "iteration": [
                    "Optional[int]"
                ]
            }
        },
        "Trainer._compute_metrics": {
            "name": "_compute_metrics",
            "location": 274,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Dict[(str, Any)]"
                ],
                "data_type": [
                    "DataType"
                ],
                "accumulate": [
                    "bool"
                ],
                "send_event": [
                    "bool"
                ],
                "epoch": [
                    "int"
                ],
                "iteration": [
                    "int"
                ]
            }
        },
        "Trainer._log_accumulated_metrics": {
            "name": "_log_accumulated_metrics",
            "location": 293,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "data_type": [
                    "DataType"
                ],
                "send_event": [
                    "bool"
                ],
                "epoch": [
                    "int"
                ],
                "iteration": [
                    "int"
                ],
                "dont_reset_accumulated": [
                    "bool"
                ]
            }
        },
        "Trainer._log_values": {
            "name": "_log_values",
            "location": 318,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._average": {
            "name": "_average",
            "location": 354,
            "return": [
                "Optional[float]"
            ],
            "arguments": {
                "values": [
                    "List[float]"
                ]
            }
        },
        "Trainer._reset_accumulated": {
            "name": "_reset_accumulated",
            "location": 357,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_type": [
                    "DataType"
                ]
            }
        },
        "Trainer.__del__": {
            "name": "__del__",
            "location": 360,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._save_checkpoint.save": {
            "name": "save",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/training/__init__.py": {},
    "formatml-master/formatml/utils/config.py": {
        "Config.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Config.save": {
            "name": "save",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "Path"
                ]
            }
        },
        "Config.from_arguments": {
            "name": "from_arguments",
            "location": 20,
            "return": [
                "'Config'"
            ],
            "arguments": {
                "arguments": [
                    "Dict[(str, Any)]"
                ],
                "data_arguments": [
                    "Iterable[str]"
                ],
                "config_argument": [
                    "str"
                ]
            }
        },
        "Config.from_json": {
            "name": "from_json",
            "location": 31,
            "return": [
                "'Config'"
            ],
            "arguments": {
                "json_path": [
                    "Path"
                ]
            }
        }
    },
    "formatml-master/formatml/utils/helpers.py": {
        "setup_logging": {
            "name": "setup_logging",
            "location": 20,
            "return": [
                "Logger"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "log_level": [
                    "str"
                ]
            }
        },
        "get_sha_and_dirtiness": {
            "name": "get_sha_and_dirtiness",
            "location": 30,
            "return": [
                "Optional[Tuple[(str, bool)]]"
            ],
            "arguments": {
                "prompt_on_dirty": [
                    "bool"
                ]
            }
        },
        "date_template_to_path": {
            "name": "date_template_to_path",
            "location": 68,
            "return": [
                "Path"
            ],
            "arguments": {
                "date_template": [
                    "str"
                ]
            }
        },
        "get_generic_arguments": {
            "name": "get_generic_arguments",
            "location": 72,
            "return": [
                "Tuple[(Any, ...)]"
            ],
            "arguments": {
                "cls": [
                    "Type[Any]"
                ],
                "subclass": [
                    "Type[Any]"
                ]
            }
        },
        "istypevar": {
            "name": "istypevar",
            "location": 113,
            "return": [
                "bool"
            ],
            "arguments": {
                "obj": [
                    "Any"
                ]
            }
        },
        "ShortNameFilter.filter": {
            "name": "filter",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "record": [
                    "LogRecord"
                ]
            }
        },
        "get_sha_and_dirtiness.to_str": {
            "name": "to_str",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "string": [
                    "Union[(str, bytes)]"
                ]
            }
        },
        "get_sha_and_dirtiness.print_files": {
            "name": "print_files",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "filenames": [
                    "Iterable[Union[(str, bytes)]]"
                ]
            }
        }
    },
    "formatml-master/formatml/utils/torch_helpers.py": {
        "unpack_packed_sequence": {
            "name": "unpack_packed_sequence",
            "location": 15,
            "return": [
                "List[Tensor]"
            ],
            "arguments": {
                "packed_sequence": [
                    "PackedSequence"
                ]
            }
        },
        "data_if_packed": {
            "name": "data_if_packed",
            "location": 29,
            "return": [
                "Tensor"
            ],
            "arguments": {
                "input": [
                    "Union[(PackedSequence, Tensor)]"
                ]
            }
        },
        "log_grad_flow": {
            "name": "log_grad_flow",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "named_parameters": [
                    "Iterator[Tuple[(str, Parameter)]]"
                ],
                "writer": [
                    "SummaryWriter"
                ],
                "iteration": [
                    "int"
                ]
            }
        }
    },
    "formatml-master/formatml/utils/__init__.py": {}
}
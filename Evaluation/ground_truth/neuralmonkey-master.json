{
    "neuralmonkey-master/docs/source/conf.py": {
        "run_apidoc": {
            "name": "run_apidoc",
            "location": 294,
            "return": [],
            "arguments": {
                "_": []
            }
        },
        "skip": {
            "name": "skip",
            "location": 305,
            "return": [],
            "arguments": {
                "app": [],
                "what": [],
                "name": [],
                "obj": [],
                "skip": [],
                "options": []
            }
        },
        "setup": {
            "name": "setup",
            "location": 311,
            "return": [],
            "arguments": {
                "app": []
            }
        }
    },
    "neuralmonkey-master/lib/__init__.py": {},
    "neuralmonkey-master/lib/subword_nmt/apply_bpe.py": {
        "create_parser": {
            "name": "create_parser",
            "location": 53,
            "return": [],
            "arguments": {}
        },
        "get_pairs": {
            "name": "get_pairs",
            "location": 76,
            "return": [],
            "arguments": {
                "word": []
            }
        },
        "encode": {
            "name": "encode",
            "location": 88,
            "return": [],
            "arguments": {
                "orig": [],
                "bpe_codes": [],
                "cache": []
            }
        },
        "BPE.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [],
            "arguments": {
                "self": [],
                "codes": [],
                "separator": []
            }
        },
        "BPE.segment": {
            "name": "segment",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        }
    },
    "neuralmonkey-master/lib/subword_nmt/bpe_toy.py": {
        "get_stats": {
            "name": "get_stats",
            "location": 21,
            "return": [],
            "arguments": {
                "vocab": []
            }
        },
        "merge_vocab": {
            "name": "merge_vocab",
            "location": 29,
            "return": [],
            "arguments": {
                "pair": [],
                "v_in": []
            }
        }
    },
    "neuralmonkey-master/lib/subword_nmt/chrF.py": {
        "create_parser": {
            "name": "create_parser",
            "location": 30,
            "return": [],
            "arguments": {}
        },
        "extract_ngrams": {
            "name": "extract_ngrams",
            "location": 63,
            "return": [],
            "arguments": {
                "words": [],
                "max_length": [],
                "spaces": []
            }
        },
        "get_correct": {
            "name": "get_correct",
            "location": 79,
            "return": [],
            "arguments": {
                "ngrams_ref": [],
                "ngrams_test": [],
                "correct": [],
                "total": []
            }
        },
        "f1": {
            "name": "f1",
            "location": 90,
            "return": [],
            "arguments": {
                "correct": [],
                "total_hyp": [],
                "total_ref": [],
                "max_length": [],
                "beta": [],
                "smooth": []
            }
        },
        "main": {
            "name": "main",
            "location": 105,
            "return": [],
            "arguments": {
                "args": []
            }
        }
    },
    "neuralmonkey-master/lib/subword_nmt/get_vocab.py": {},
    "neuralmonkey-master/lib/subword_nmt/learn_bpe.py": {
        "create_parser": {
            "name": "create_parser",
            "location": 33,
            "return": [],
            "arguments": {}
        },
        "get_vocabulary": {
            "name": "get_vocabulary",
            "location": 55,
            "return": [],
            "arguments": {
                "fobj": []
            }
        },
        "update_pair_statistics": {
            "name": "update_pair_statistics",
            "location": 64,
            "return": [],
            "arguments": {
                "pair": [],
                "changed": [],
                "stats": [],
                "indices": []
            }
        },
        "get_pair_statistics": {
            "name": "get_pair_statistics",
            "location": 116,
            "return": [],
            "arguments": {
                "vocab": []
            }
        },
        "replace_pair": {
            "name": "replace_pair",
            "location": 135,
            "return": [],
            "arguments": {
                "pair": [],
                "vocab": [],
                "indices": []
            }
        },
        "prune_stats": {
            "name": "prune_stats",
            "location": 159,
            "return": [],
            "arguments": {
                "stats": [],
                "big_stats": [],
                "threshold": []
            }
        }
    },
    "neuralmonkey-master/lib/subword_nmt/segment-char-ngrams.py": {
        "create_parser": {
            "name": "create_parser",
            "location": 21,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/lib/subword_nmt/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/checking.py": {
        "assert_shape": {
            "name": "assert_shape",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor": [
                    "tf.Tensor"
                ],
                "expected_shape": [
                    "List[Optional[int]]"
                ]
            }
        },
        "assert_same_shape": {
            "name": "assert_same_shape",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor_a": [
                    "tf.Tensor"
                ],
                "tensor_b": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/checkpython.py": {},
    "neuralmonkey-master/neuralmonkey/dataset.py": {
        "_normalize_readerdef": {
            "name": "_normalize_readerdef",
            "location": 101,
            "return": [
                "Tuple[(List[str], Reader)]"
            ],
            "arguments": {
                "reader_def": [
                    "ReaderDef"
                ]
            }
        },
        "_normalize_outputspec": {
            "name": "_normalize_outputspec",
            "location": 112,
            "return": [
                "Tuple[(str, str, Writer)]"
            ],
            "arguments": {
                "output_spec": [
                    "OutputSpec"
                ]
            }
        },
        "_normalize_filedef": {
            "name": "_normalize_filedef",
            "location": 118,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "file_def": [
                    "FileDef"
                ]
            }
        },
        "_expand_patterns_flat": {
            "name": "_expand_patterns_flat",
            "location": 124,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "patterns": [
                    "List[str]"
                ]
            }
        },
        "_get_series_paths_and_readers": {
            "name": "_get_series_paths_and_readers",
            "location": 136,
            "return": [
                "Dict[(str, Tuple[(List[str], Reader)])]"
            ],
            "arguments": {
                "series_config": [
                    "SeriesConfig"
                ]
            }
        },
        "_get_series_outputs": {
            "name": "_get_series_outputs",
            "location": 180,
            "return": [
                "List[OutputSpec]"
            ],
            "arguments": {
                "series_config": [
                    "SeriesConfig"
                ]
            }
        },
        "load": {
            "name": "load",
            "location": 207,
            "return": [
                "'Dataset'"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "series": [
                    "List[str]"
                ],
                "data": [
                    "List[SourceSpec]"
                ],
                "batching": [
                    "BatchingScheme"
                ],
                "outputs": [
                    "List[OutputSpec]"
                ],
                "buffer_size": [
                    "int"
                ],
                "shuffled": [
                    "bool"
                ]
            }
        },
        "BatchingScheme.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int"
                ],
                "drop_remainder": [
                    "bool"
                ],
                "bucket_boundaries": [
                    "List[int]"
                ],
                "bucket_batch_sizes": [
                    "List[int]"
                ],
                "ignore_series": [
                    "List[str]"
                ]
            }
        },
        "load._make_iterator": {
            "name": "_make_iterator",
            "location": 274,
            "return": [],
            "arguments": {
                "reader": [],
                "files": []
            }
        },
        "load._make_sl_iterator": {
            "name": "_make_sl_iterator",
            "location": 279,
            "return": [],
            "arguments": {
                "src": [],
                "prep": []
            }
        },
        "load._make_dl_iterator": {
            "name": "_make_dl_iterator",
            "location": 284,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "Dataset.__init__": {
            "name": "__init__",
            "location": 350,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "iterators": [
                    "Dict[(str, Callable[([], Iterator)])]"
                ],
                "batching": [
                    "BatchingScheme"
                ],
                "outputs": [
                    "Dict[(str, Tuple[(str, Writer)])]"
                ],
                "buffer_size": [
                    "Tuple[(int, int)]"
                ],
                "shuffled": [
                    "bool"
                ]
            }
        },
        "Dataset.__len__": {
            "name": "__len__",
            "location": 410,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.__contains__": {
            "name": "__contains__",
            "location": 424,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Dataset.series": {
            "name": "series",
            "location": 436,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.get_series": {
            "name": "get_series",
            "location": 439,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Dataset.maybe_get_series": {
            "name": "maybe_get_series",
            "location": 453,
            "return": [
                "Optional[Iterator]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Dataset.batches": {
            "name": "batches",
            "location": 467,
            "return": [
                "Iterator['Dataset']"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.subset": {
            "name": "subset",
            "location": 581,
            "return": [
                "'Dataset'"
            ],
            "arguments": {
                "self": [],
                "start": [
                    "int"
                ],
                "length": [
                    "int"
                ]
            }
        },
        "load._make_iterator.itergen": {
            "name": "itergen",
            "location": 275,
            "return": [],
            "arguments": {}
        },
        "load._make_sl_iterator.itergen": {
            "name": "itergen",
            "location": 280,
            "return": [],
            "arguments": {}
        },
        "load._make_dl_iterator.itergen": {
            "name": "itergen",
            "location": 285,
            "return": [],
            "arguments": {}
        },
        "Dataset.batches._make_datagen": {
            "name": "_make_datagen",
            "location": 503,
            "return": [],
            "arguments": {
                "rows": [],
                "key": []
            }
        },
        "Dataset.batches._make_datagen.itergen": {
            "name": "itergen",
            "location": 504,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/neuralmonkey/decorators.py": {
        "tensor": {
            "name": "tensor",
            "location": 9,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "tensor.decorate": {
            "name": "decorate",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/experiment.py": {
        "create_config": {
            "name": "create_config",
            "location": 453,
            "return": [
                "Configuration"
            ],
            "arguments": {
                "train_mode": [
                    "bool"
                ]
            }
        },
        "save_git_info": {
            "name": "save_git_info",
            "location": 529,
            "return": [
                "None"
            ],
            "arguments": {
                "git_commit_file": [
                    "str"
                ],
                "git_diff_file": [
                    "str"
                ],
                "branch": [
                    "str"
                ],
                "repo_dir": [
                    "str"
                ]
            }
        },
        "Experiment.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "config_path": [
                    "str"
                ],
                "train_mode": [
                    "bool"
                ],
                "overwrite_output_dir": [
                    "bool"
                ],
                "config_changes": [
                    "List[str]"
                ]
            }
        },
        "Experiment.model": {
            "name": "model",
            "location": 101,
            "return": [
                "Namespace"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment._bless_graph_executors": {
            "name": "_bless_graph_executors",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment.register_inputs": {
            "name": "register_inputs",
            "location": 152,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment.build_model": {
            "name": "build_model",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment.train": {
            "name": "train",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment.load_variables": {
            "name": "load_variables",
            "location": 275,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variable_files": [
                    "List[str]"
                ]
            }
        },
        "Experiment.run_model": {
            "name": "run_model",
            "location": 321,
            "return": [
                "Tuple[(List[ExecutionResult], Dict[(str, List)], Dict[(str, List)])]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "write_out": [
                    "bool"
                ],
                "log_progress": [
                    "int"
                ]
            }
        },
        "Experiment.evaluate": {
            "name": "evaluate",
            "location": 352,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "write_out": [
                    "bool"
                ],
                "log_progress": [
                    "int"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "Experiment.get_path": {
            "name": "get_path",
            "location": 384,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str"
                ],
                "cont_index": [
                    "int"
                ]
            }
        },
        "Experiment.update_initializers": {
            "name": "update_initializers",
            "location": 397,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initializers": [
                    "Iterable[Tuple[(str, Callable)]]"
                ]
            }
        },
        "Experiment.get_initializer": {
            "name": "get_initializer",
            "location": 402,
            "return": [
                "Optional[Callable]"
            ],
            "arguments": {
                "self": [],
                "var_name": [
                    "str"
                ],
                "default": [
                    "Callable"
                ]
            }
        },
        "Experiment._check_unused_initializers": {
            "name": "_check_unused_initializers",
            "location": 414,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment.visualize_embeddings": {
            "name": "visualize_embeddings",
            "location": 422,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Experiment.get_current": {
            "name": "get_current",
            "location": 448,
            "return": [
                "'Experiment'"
            ],
            "arguments": {
                "cls": []
            }
        },
        "_DummyExperiment.__init__": {
            "name": "__init__",
            "location": 502,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_DummyExperiment.update_initializers": {
            "name": "update_initializers",
            "location": 508,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initializers": [
                    "Iterable[Tuple[(str, Callable)]]"
                ]
            }
        },
        "_DummyExperiment.get_initializer": {
            "name": "get_initializer",
            "location": 513,
            "return": [
                "Optional[Callable]"
            ],
            "arguments": {
                "self": [],
                "var_name": [
                    "str"
                ],
                "default": [
                    "Callable"
                ]
            }
        },
        "_DummyExperiment._warn": {
            "name": "_warn",
            "location": 519,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/functions.py": {
        "inverse_sigmoid_decay": {
            "name": "inverse_sigmoid_decay",
            "location": 9,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "param": [],
                "rate": [],
                "min_value": [
                    "float"
                ],
                "max_value": [
                    "float"
                ],
                "name": [
                    "Optional[str]"
                ],
                "dtype": []
            }
        },
        "piecewise_function": {
            "name": "piecewise_function",
            "location": 31,
            "return": [],
            "arguments": {
                "param": [],
                "values": [],
                "changepoints": [],
                "name": [],
                "dtype": []
            }
        },
        "noam_decay": {
            "name": "noam_decay",
            "location": 58,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "learning_rate": [
                    "float"
                ],
                "model_dimension": [
                    "int"
                ],
                "warmup_steps": [
                    "int"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/learning_utils.py": {
        "training_loop": {
            "name": "training_loop",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "cfg": [
                    "Namespace"
                ]
            }
        },
        "_log_model_variables": {
            "name": "_log_model_variables",
            "location": 196,
            "return": [
                "None"
            ],
            "arguments": {
                "trainers": [
                    "List[Trainer]"
                ]
            }
        },
        "_initialize_model": {
            "name": "_initialize_model",
            "location": 239,
            "return": [],
            "arguments": {
                "tf_manager": [
                    "TensorFlowManager"
                ],
                "initial_variables": [
                    "Optional[List[str]]"
                ],
                "executables": [
                    "List[GraphExecutor]"
                ]
            }
        },
        "_check_series_collisions": {
            "name": "_check_series_collisions",
            "location": 254,
            "return": [
                "None"
            ],
            "arguments": {
                "runners": [
                    "List[BaseRunner]"
                ],
                "postprocess": [
                    "Postprocess"
                ]
            }
        },
        "run_on_dataset": {
            "name": "run_on_dataset",
            "location": 272,
            "return": [
                "Tuple[(List[ExecutionResult], Dict[(str, List)], Dict[(str, List)])]"
            ],
            "arguments": {
                "tf_manager": [
                    "TensorFlowManager"
                ],
                "runners": [
                    "List[BaseRunner]"
                ],
                "dataset_runner": [
                    "DatasetRunner"
                ],
                "dataset": [
                    "Dataset"
                ],
                "postprocess": [
                    "Postprocess"
                ],
                "write_out": [
                    "bool"
                ],
                "log_progress": [
                    "int"
                ]
            }
        },
        "join_execution_results": {
            "name": "join_execution_results",
            "location": 396,
            "return": [
                "ExecutionResult"
            ],
            "arguments": {
                "execution_results": [
                    "List[ExecutionResult]"
                ]
            }
        },
        "evaluation": {
            "name": "evaluation",
            "location": 434,
            "return": [],
            "arguments": {
                "evaluators": [],
                "batch": [],
                "execution_results": [],
                "result_data": []
            }
        },
        "_log_continuous_evaluation": {
            "name": "_log_continuous_evaluation",
            "location": 470,
            "return": [
                "None"
            ],
            "arguments": {
                "tb_writer": [
                    "tf.summary.FileWriter"
                ],
                "main_metric": [
                    "str"
                ],
                "eval_result": [
                    "Evaluation"
                ],
                "seen_instances": [
                    "int"
                ],
                "epoch": [
                    "int"
                ],
                "max_epochs": [
                    "int"
                ],
                "execution_results": [
                    "List[ExecutionResult]"
                ],
                "train": [
                    "bool"
                ],
                "dataset_name": [
                    "str"
                ]
            }
        },
        "_format_evaluation_line": {
            "name": "_format_evaluation_line",
            "location": 504,
            "return": [
                "str"
            ],
            "arguments": {
                "evaluation_res": [
                    "Evaluation"
                ],
                "main_metric": [
                    "str"
                ]
            }
        },
        "print_final_evaluation": {
            "name": "print_final_evaluation",
            "location": 519,
            "return": [
                "None"
            ],
            "arguments": {
                "eval_result": [
                    "Evaluation"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "_data_item_to_str": {
            "name": "_data_item_to_str",
            "location": 533,
            "return": [
                "str"
            ],
            "arguments": {
                "item": [
                    "Any"
                ]
            }
        },
        "_print_examples": {
            "name": "_print_examples",
            "location": 548,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Dict[(str, List[Any])]"
                ],
                "outputs": [
                    "Dict[(str, List[Any])]"
                ],
                "val_preview_input_series": [
                    "Optional[List[str]]"
                ],
                "val_preview_output_series": [
                    "Optional[List[str]]"
                ],
                "num_examples": []
            }
        },
        "_skip_lines": {
            "name": "_skip_lines",
            "location": 628,
            "return": [
                "None"
            ],
            "arguments": {
                "start_offset": [
                    "int"
                ],
                "batches": [
                    "Iterator[Dataset]"
                ]
            }
        },
        "join_execution_results.join": {
            "name": "join",
            "location": 402,
            "return": [
                "OutputSeries"
            ],
            "arguments": {
                "output_series": [
                    "List[OutputSeries]"
                ]
            }
        },
        "_print_examples.print_line": {
            "name": "print_line",
            "location": 603,
            "return": [],
            "arguments": {
                "prefix": [],
                "color": [],
                "content": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/logging.py": {
        "Logging._get_time": {
            "name": "_get_time",
            "location": 25,
            "return": [
                "str"
            ],
            "arguments": {}
        },
        "Logging.set_log_file": {
            "name": "set_log_file",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "Logging.log_print": {
            "name": "log_print",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        },
        "Logging.log": {
            "name": "log",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "Logging.notice": {
            "name": "notice",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ]
            }
        },
        "Logging.warn": {
            "name": "warn",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ]
            }
        },
        "Logging.print_header": {
            "name": "print_header",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "title": [
                    "str"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "Logging.debug": {
            "name": "debug",
            "location": 79,
            "return": [],
            "arguments": {
                "message": [
                    "str"
                ],
                "label": [
                    "str"
                ]
            }
        },
        "Logging.debug_enabled": {
            "name": "debug_enabled",
            "location": 91,
            "return": [],
            "arguments": {
                "label": [
                    "str"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/run.py": {
        "load_runtime_config": {
            "name": "load_runtime_config",
            "location": 14,
            "return": [
                "argparse.Namespace"
            ],
            "arguments": {
                "config_path": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/neuralmonkey/tf_manager.py": {
        "_feed_dicts": {
            "name": "_feed_dicts",
            "location": 291,
            "return": [],
            "arguments": {
                "dataset": [
                    "Dataset"
                ],
                "coders": [
                    "Set[Feedable]"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "get_default_tf_manager": {
            "name": "get_default_tf_manager",
            "location": 305,
            "return": [
                "TensorFlowManager"
            ],
            "arguments": {}
        },
        "TensorFlowManager.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_sessions": [
                    "int"
                ],
                "num_threads": [
                    "int"
                ],
                "save_n_best": [
                    "int"
                ],
                "minimize_metric": [
                    "bool"
                ],
                "gpu_allow_growth": [
                    "bool"
                ],
                "per_process_gpu_memory_fraction": [
                    "float"
                ],
                "enable_tf_debug": [
                    "bool"
                ]
            }
        },
        "TensorFlowManager.best_vars_file": {
            "name": "best_vars_file",
            "location": 100,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFlowManager._is_better": {
            "name": "_is_better",
            "location": 106,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        },
        "TensorFlowManager._argworst": {
            "name": "_argworst",
            "location": 112,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "scores": [
                    "List[float]"
                ]
            }
        },
        "TensorFlowManager._update_best_vars": {
            "name": "_update_best_vars",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "var_index": [
                    "int"
                ]
            }
        },
        "TensorFlowManager.init_saving": {
            "name": "init_saving",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vars_prefix": [
                    "str"
                ]
            }
        },
        "TensorFlowManager.validation_hook": {
            "name": "validation_hook",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "score": [
                    "float"
                ],
                "epoch": [
                    "int"
                ],
                "batch": [
                    "int"
                ]
            }
        },
        "TensorFlowManager._run_executables": {
            "name": "_run_executables",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "feed_dict": [
                    "FeedDict"
                ],
                "executables": [
                    "List[GraphExecutor.Executable]"
                ]
            }
        },
        "TensorFlowManager.execute": {
            "name": "execute",
            "location": 188,
            "return": [
                "List[ExecutionResult]"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "Dataset"
                ],
                "feedables": [
                    "Set[Feedable]"
                ],
                "runners": [
                    "Sequence[GraphExecutor]"
                ],
                "train": [
                    "bool"
                ],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ]
            }
        },
        "TensorFlowManager.save": {
            "name": "save",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variable_files": [
                    "Union[(str, List[str])]"
                ]
            }
        },
        "TensorFlowManager.restore": {
            "name": "restore",
            "location": 247,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variable_files": [
                    "Union[(str, List[str])]"
                ]
            }
        },
        "TensorFlowManager.restore_best_vars": {
            "name": "restore_best_vars",
            "location": 263,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFlowManager.initialize_sessions": {
            "name": "initialize_sessions",
            "location": 267,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorFlowManager.initialize_model_parts": {
            "name": "initialize_model_parts",
            "location": 279,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "runners": [
                    "Sequence[GraphExecutor]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tf_utils.py": {
        "_get_current_experiment": {
            "name": "_get_current_experiment",
            "location": 13,
            "return": [],
            "arguments": {}
        },
        "update_initializers": {
            "name": "update_initializers",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "initializers": [
                    "Iterable[Tuple[(str, Callable)]]"
                ]
            }
        },
        "get_initializer": {
            "name": "get_initializer",
            "location": 23,
            "return": [
                "Optional[Callable]"
            ],
            "arguments": {
                "var_name": [
                    "str"
                ],
                "default": [
                    "Callable"
                ]
            }
        },
        "get_variable": {
            "name": "get_variable",
            "location": 35,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "shape": [
                    "ShapeSpec"
                ],
                "dtype": [
                    "tf.DType"
                ],
                "initializer": [
                    "Callable"
                ]
            }
        },
        "get_shape_list": {
            "name": "get_shape_list",
            "location": 54,
            "return": [
                "List[Union[(int, tf.Tensor)]]"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "get_state_shape_invariants": {
            "name": "get_state_shape_invariants",
            "location": 85,
            "return": [
                "tf.TensorShape"
            ],
            "arguments": {
                "state": [
                    "tf.Tensor"
                ]
            }
        },
        "gather_flat": {
            "name": "gather_flat",
            "location": 106,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ],
                "indices": [
                    "tf.Tensor"
                ],
                "batch_size": [
                    "Union[(int, tf.Tensor)]"
                ],
                "beam_size": [
                    "Union[(int, tf.Tensor)]"
                ]
            }
        },
        "partial_transpose": {
            "name": "partial_transpose",
            "location": 134,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ],
                "indices": [
                    "List[int]"
                ]
            }
        },
        "tf_print": {
            "name": "tf_print",
            "location": 152,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "tf.Tensor"
                ],
                "message": [
                    "str"
                ],
                "debug_label": [
                    "str"
                ]
            }
        },
        "layer_norm": {
            "name": "layer_norm",
            "location": 189,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ],
                "epsilon": [
                    "float"
                ]
            }
        },
        "append_tensor": {
            "name": "append_tensor",
            "location": 222,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "tensor": [
                    "tf.Tensor"
                ],
                "appendval": [
                    "tf.Tensor"
                ],
                "axis": [
                    "int"
                ]
            }
        },
        "tf_print.print_tensor": {
            "name": "print_tensor",
            "location": 169,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "np.ndarray"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/train.py": {
        "_main": {
            "name": "_main",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/neuralmonkey/training_profiler.py": {
        "TrainingProfiler.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.start_time": {
            "name": "start_time",
            "location": 36,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.last_log_time": {
            "name": "last_log_time",
            "location": 42,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.last_val_time": {
            "name": "last_val_time",
            "location": 48,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.training_start": {
            "name": "training_start",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.epoch_start": {
            "name": "epoch_start",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.log_done": {
            "name": "log_done",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.validation_start": {
            "name": "validation_start",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.validation_done": {
            "name": "validation_done",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingProfiler.log_after_validation": {
            "name": "log_after_validation",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "val_examples": [
                    "int"
                ],
                "train_examples": [
                    "int"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/vocabulary.py": {
        "from_wordlist": {
            "name": "from_wordlist",
            "location": 32,
            "return": [
                "'Vocabulary'"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "encoding": [
                    "str"
                ],
                "contains_header": [
                    "bool"
                ],
                "contains_frequencies": [
                    "bool"
                ]
            }
        },
        "from_t2t_vocabulary": {
            "name": "from_t2t_vocabulary",
            "location": 102,
            "return": [
                "'Vocabulary'"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "encoding": [
                    "str"
                ]
            }
        },
        "from_nematus_json": {
            "name": "from_nematus_json",
            "location": 137,
            "return": [
                "'Vocabulary'"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "max_size": [
                    "int"
                ],
                "pad_to_max_size": [
                    "bool"
                ]
            }
        },
        "log_sample": {
            "name": "log_sample",
            "location": 317,
            "return": [
                "None"
            ],
            "arguments": {
                "vocabulary": [
                    "List[str]"
                ],
                "size": [
                    "int"
                ]
            }
        },
        "pad_batch": {
            "name": "pad_batch",
            "location": 331,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "sentences": [
                    "List[List[str]]"
                ],
                "max_length": [
                    "int"
                ],
                "add_start_symbol": [
                    "bool"
                ],
                "add_end_symbol": [
                    "bool"
                ]
            }
        },
        "sentence_mask": {
            "name": "sentence_mask",
            "location": 357,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "sentences": [
                    "tf.Tensor"
                ]
            }
        },
        "Vocabulary.__init__": {
            "name": "__init__",
            "location": 177,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[str]"
                ],
                "num_oov_buckets": [
                    "int"
                ]
            }
        },
        "Vocabulary.__len__": {
            "name": "__len__",
            "location": 197,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocabulary.__contains__": {
            "name": "__contains__",
            "location": 205,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "str"
                ]
            }
        },
        "Vocabulary.alphabet": {
            "name": "alphabet",
            "location": 217,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocabulary.index_to_word": {
            "name": "index_to_word",
            "location": 221,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocabulary.strings_to_indices": {
            "name": "strings_to_indices",
            "location": 224,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "tf.Tensor"
                ]
            }
        },
        "Vocabulary.indices_to_strings": {
            "name": "indices_to_strings",
            "location": 246,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "vectors": [
                    "tf.Tensor"
                ]
            }
        },
        "Vocabulary.vectors_to_sentences": {
            "name": "vectors_to_sentences",
            "location": 257,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "self": [],
                "vectors": [
                    "Union[(List[np.ndarray], np.ndarray)]"
                ]
            }
        },
        "Vocabulary.save_wordlist": {
            "name": "save_wordlist",
            "location": 290,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ],
                "overwrite": [
                    "bool"
                ],
                "encoding": [
                    "str"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/attention/base_attention.py": {
        "empty_attention_loop_state": {
            "name": "empty_attention_loop_state",
            "location": 54,
            "return": [
                "AttentionLoopState"
            ],
            "arguments": {
                "batch_size": [
                    "Union[(int, tf.Tensor)]"
                ],
                "length": [
                    "Union[(int, tf.Tensor)]"
                ],
                "dimension": [
                    "Union[(int, tf.Tensor)]"
                ]
            }
        },
        "get_attention_states": {
            "name": "get_attention_states",
            "location": 79,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "encoder": [
                    "Attendable"
                ]
            }
        },
        "get_attention_mask": {
            "name": "get_attention_mask",
            "location": 101,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "encoder": [
                    "Attendable"
                ]
            }
        },
        "BaseAttention.__init__": {
            "name": "__init__",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "BaseAttention.histories": {
            "name": "histories",
            "location": 142,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseAttention.attention": {
            "name": "attention",
            "location": 152,
            "return": [
                "Tuple[(tf.Tensor, Any)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "Any"
                ]
            }
        },
        "BaseAttention.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 160,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseAttention.finalize_loop": {
            "name": "finalize_loop",
            "location": 168,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "last_loop_state": [
                    "Any"
                ]
            }
        },
        "BaseAttention.context_vector_size": {
            "name": "context_vector_size",
            "location": 179,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseAttention.visualize_attention": {
            "name": "visualize_attention",
            "location": 187,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "max_outputs": [
                    "int"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/combination.py": {
        "_sentinel": {
            "name": "_sentinel",
            "location": 330,
            "return": [],
            "arguments": {
                "state": [],
                "prev_state": [],
                "input_": []
            }
        },
        "MultiAttention.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "attention_state_size": [
                    "int"
                ],
                "share_attn_projections": [
                    "bool"
                ],
                "use_sentinels": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "MultiAttention.attention": {
            "name": "attention",
            "location": 56,
            "return": [
                "Tuple[(tf.Tensor, Any)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "Any"
                ]
            }
        },
        "MultiAttention.attn_v": {
            "name": "attn_v",
            "location": 65,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiAttention.attn_size": {
            "name": "attn_size",
            "location": 71,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultiAttention._vector_logit": {
            "name": "_vector_logit",
            "location": 74,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "projected_decoder_state": [
                    "tf.Tensor"
                ],
                "vector_value": [
                    "tf.Tensor"
                ],
                "scope": [
                    "str"
                ]
            }
        },
        "FlatMultiAttention.__init__": {
            "name": "__init__",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoders": [
                    "List[Attendable]"
                ],
                "attention_state_size": [
                    "int"
                ],
                "share_attn_projections": [
                    "bool"
                ],
                "use_sentinels": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "FlatMultiAttention._encoders_tensors": {
            "name": "_encoders_tensors",
            "location": 145,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention._encoders_masks": {
            "name": "_encoders_masks",
            "location": 152,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.encoder_projections_for_logits": {
            "name": "encoder_projections_for_logits",
            "location": 162,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.encoder_attn_biases": {
            "name": "encoder_attn_biases",
            "location": 166,
            "return": [
                "List[tf.Variable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.encoder_projections_for_ctx": {
            "name": "encoder_projections_for_ctx",
            "location": 172,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.masks_concat": {
            "name": "masks_concat",
            "location": 178,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 181,
            "return": [
                "AttentionLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.get_encoder_projections": {
            "name": "get_encoder_projections",
            "location": 201,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": [],
                "scope": [
                    "str"
                ]
            }
        },
        "FlatMultiAttention.context_vector_size": {
            "name": "context_vector_size",
            "location": 235,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "FlatMultiAttention.attention": {
            "name": "attention",
            "location": 240,
            "return": [
                "Tuple[(tf.Tensor, AttentionLoopState)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "AttentionLoopState"
                ]
            }
        },
        "FlatMultiAttention._tile_encoders_for_beamsearch": {
            "name": "_tile_encoders_for_beamsearch",
            "location": 300,
            "return": [],
            "arguments": {
                "self": [],
                "projected_sentinel": []
            }
        },
        "FlatMultiAttention._renorm_softmax": {
            "name": "_renorm_softmax",
            "location": 315,
            "return": [],
            "arguments": {
                "self": [],
                "logits": []
            }
        },
        "FlatMultiAttention.finalize_loop": {
            "name": "finalize_loop",
            "location": 323,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "last_loop_state": [
                    "AttentionLoopState"
                ]
            }
        },
        "HierarchicalMultiAttention.__init__": {
            "name": "__init__",
            "location": 357,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "attentions": [
                    "List[BaseAttention]"
                ],
                "attention_state_size": [
                    "int"
                ],
                "use_sentinels": [
                    "bool"
                ],
                "share_attn_projections": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "HierarchicalMultiAttention.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 382,
            "return": [
                "HierarchicalLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "HierarchicalMultiAttention.attention": {
            "name": "attention",
            "location": 394,
            "return": [
                "Tuple[(tf.Tensor, HierarchicalLoopState)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "HierarchicalLoopState"
                ]
            }
        },
        "HierarchicalMultiAttention.finalize_loop": {
            "name": "finalize_loop",
            "location": 466,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "last_loop_state": [
                    "Any"
                ]
            }
        },
        "HierarchicalMultiAttention.context_vector_size": {
            "name": "context_vector_size",
            "location": 474,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/coverage.py": {
        "CoverageAttention.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoder": [
                    "Attendable"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "state_size": [
                    "int"
                ],
                "max_fertility": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "CoverageAttention.coverage_weights": {
            "name": "coverage_weights",
            "location": 39,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "CoverageAttention.fertility_weights": {
            "name": "fertility_weights",
            "location": 43,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "CoverageAttention.fertility": {
            "name": "fertility",
            "location": 48,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CoverageAttention.get_energies": {
            "name": "get_energies",
            "location": 52,
            "return": [],
            "arguments": {
                "self": [],
                "y": [
                    "tf.Tensor"
                ],
                "weights_in_time": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/feed_forward.py": {
        "Attention.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoder": [
                    "Attendable"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "state_size": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "Attention.attention_states": {
            "name": "attention_states",
            "location": 48,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.attention_mask": {
            "name": "attention_mask",
            "location": 54,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.context_vector_size": {
            "name": "context_vector_size",
            "location": 60,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.state_size": {
            "name": "state_size",
            "location": 65,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.query_projection_matrix": {
            "name": "query_projection_matrix",
            "location": 71,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.key_projection_matrix": {
            "name": "key_projection_matrix",
            "location": 78,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.similarity_bias_vector": {
            "name": "similarity_bias_vector",
            "location": 85,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.projection_bias_vector": {
            "name": "projection_bias_vector",
            "location": 91,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.bias_term": {
            "name": "bias_term",
            "location": 99,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention._att_states_reshaped": {
            "name": "_att_states_reshaped",
            "location": 106,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.hidden_features": {
            "name": "hidden_features",
            "location": 112,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.get_energies": {
            "name": "get_energies",
            "location": 120,
            "return": [],
            "arguments": {
                "self": [],
                "y": [],
                "_": []
            }
        },
        "Attention.attention": {
            "name": "attention",
            "location": 125,
            "return": [
                "Tuple[(tf.Tensor, AttentionLoopState)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "AttentionLoopState"
                ]
            }
        },
        "Attention.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 168,
            "return": [
                "AttentionLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "Attention.finalize_loop": {
            "name": "finalize_loop",
            "location": 187,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "last_loop_state": [
                    "AttentionLoopState"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/namedtuples.py": {},
    "neuralmonkey-master/neuralmonkey/attention/scaled_dot_product.py": {
        "split_for_heads": {
            "name": "split_for_heads",
            "location": 24,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ],
                "n_heads": [
                    "int"
                ],
                "head_dim": [
                    "int"
                ]
            }
        },
        "mask_energies": {
            "name": "mask_energies",
            "location": 45,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "energies_4d": [
                    "tf.Tensor"
                ],
                "mask": [
                    "tf.Tensor"
                ],
                "mask_value": []
            }
        },
        "mask_future": {
            "name": "mask_future",
            "location": 72,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "energies": [
                    "tf.Tensor"
                ],
                "mask_value": []
            }
        },
        "attention": {
            "name": "attention",
            "location": 98,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "queries": [
                    "tf.Tensor"
                ],
                "keys": [
                    "tf.Tensor"
                ],
                "values": [
                    "tf.Tensor"
                ],
                "keys_mask": [
                    "tf.Tensor"
                ],
                "num_heads": [
                    "int"
                ],
                "dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "masked": [
                    "bool"
                ],
                "use_bias": [
                    "bool"
                ]
            }
        },
        "empty_multi_head_loop_state": {
            "name": "empty_multi_head_loop_state",
            "location": 230,
            "return": [
                "MultiHeadLoopState"
            ],
            "arguments": {
                "batch_size": [
                    "Union[(int, tf.Tensor)]"
                ],
                "num_heads": [
                    "Union[(int, tf.Tensor)]"
                ],
                "length": [
                    "Union[(int, tf.Tensor)]"
                ],
                "dimension": [
                    "Union[(int, tf.Tensor)]"
                ]
            }
        },
        "MultiHeadAttention.__init__": {
            "name": "__init__",
            "location": 250,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "n_heads": [
                    "int"
                ],
                "keys_encoder": [
                    "Attendable"
                ],
                "values_encoder": [
                    "Attendable"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "MultiHeadAttention.attention_keys": {
            "name": "attention_keys",
            "location": 285,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadAttention.attention_mask": {
            "name": "attention_mask",
            "location": 289,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadAttention.attention_values": {
            "name": "attention_values",
            "location": 293,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadAttention.attention": {
            "name": "attention",
            "location": 296,
            "return": [
                "Tuple[(tf.Tensor, MultiHeadLoopState)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "MultiHeadLoopState"
                ]
            }
        },
        "MultiHeadAttention.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 351,
            "return": [
                "MultiHeadLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadAttention.finalize_loop": {
            "name": "finalize_loop",
            "location": 356,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "last_loop_state": [
                    "MultiHeadLoopState"
                ]
            }
        },
        "MultiHeadAttention.context_vector_size": {
            "name": "context_vector_size",
            "location": 364,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadAttention.visualize_attention": {
            "name": "visualize_attention",
            "location": 368,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "max_outputs": [
                    "int"
                ]
            }
        },
        "ScaledDotProdAttention.__init__": {
            "name": "__init__",
            "location": 386,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "keys_encoder": [
                    "Attendable"
                ],
                "values_encoder": [
                    "Attendable"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/stateful_context.py": {
        "StatefulContext.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoder": [
                    "Stateful"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "StatefulContext.attention_states": {
            "name": "attention_states",
            "location": 40,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulContext.attention_mask": {
            "name": "attention_mask",
            "location": 45,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulContext.context_vector_size": {
            "name": "context_vector_size",
            "location": 52,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulContext.state_size": {
            "name": "state_size",
            "location": 57,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulContext.attention": {
            "name": "attention",
            "location": 60,
            "return": [
                "Tuple[(tf.Tensor, AttentionLoopState)]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "tf.Tensor"
                ],
                "decoder_prev_state": [
                    "tf.Tensor"
                ],
                "decoder_input": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "AttentionLoopState"
                ]
            }
        },
        "StatefulContext.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 80,
            "return": [
                "AttentionLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulContext.finalize_loop": {
            "name": "finalize_loop",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "last_loop_state": [
                    "AttentionLoopState"
                ]
            }
        },
        "StatefulContext.visualize_attention": {
            "name": "visualize_attention",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "max_outputs": [
                    "int"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/transformer_cross_layer.py": {
        "single": {
            "name": "single",
            "location": 12,
            "return": [],
            "arguments": {
                "queries": [
                    "tf.Tensor"
                ],
                "states": [
                    "tf.Tensor"
                ],
                "mask": [
                    "tf.Tensor"
                ],
                "n_heads": [
                    "int"
                ],
                "attention_dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "normalize": [
                    "bool"
                ],
                "use_dropout": [
                    "bool"
                ],
                "residual": [
                    "bool"
                ],
                "use_att_transform_bias": [
                    "bool"
                ]
            }
        },
        "serial": {
            "name": "serial",
            "location": 68,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "queries": [
                    "tf.Tensor"
                ],
                "encoder_states": [
                    "List[tf.Tensor]"
                ],
                "encoder_masks": [
                    "List[tf.Tensor]"
                ],
                "heads": [
                    "List[int]"
                ],
                "attention_dropout_callbacks": [
                    "List[Callable[([tf.Tensor], tf.Tensor)]]"
                ],
                "dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ]
            }
        },
        "parallel": {
            "name": "parallel",
            "location": 106,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "queries": [
                    "tf.Tensor"
                ],
                "encoder_states": [
                    "List[tf.Tensor]"
                ],
                "encoder_masks": [
                    "List[tf.Tensor]"
                ],
                "heads": [
                    "List[int]"
                ],
                "attention_dropout_callbacks": [
                    "List[Callable[([tf.Tensor], tf.Tensor)]]"
                ],
                "dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ]
            }
        },
        "hierarchical": {
            "name": "hierarchical",
            "location": 152,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "queries": [
                    "tf.Tensor"
                ],
                "encoder_states": [
                    "List[tf.Tensor]"
                ],
                "encoder_masks": [
                    "List[tf.Tensor]"
                ],
                "heads": [
                    "List[int]"
                ],
                "heads_hier": [
                    "int"
                ],
                "attention_dropout_callbacks": [
                    "List[Callable[([tf.Tensor], tf.Tensor)]]"
                ],
                "dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ]
            }
        },
        "flat": {
            "name": "flat",
            "location": 234,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "queries": [
                    "tf.Tensor"
                ],
                "encoder_states": [
                    "List[tf.Tensor]"
                ],
                "encoder_masks": [
                    "List[tf.Tensor]"
                ],
                "heads": [
                    "int"
                ],
                "attention_dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/attention/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/config/builder.py": {
        "build_object": {
            "name": "build_object",
            "location": 81,
            "return": [
                "Any"
            ],
            "arguments": {
                "value": [
                    "str"
                ],
                "all_dicts": [
                    "Dict[(str, Any)]"
                ],
                "existing_objects": [
                    "Dict[(str, Any)]"
                ],
                "depth": [
                    "int"
                ]
            }
        },
        "instantiate_class": {
            "name": "instantiate_class",
            "location": 134,
            "return": [
                "Any"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "all_dicts": [
                    "Dict[(str, Any)]"
                ],
                "existing_objects": [
                    "Dict[(str, Any)]"
                ],
                "depth": [
                    "int"
                ]
            }
        },
        "build_config": {
            "name": "build_config",
            "location": 207,
            "return": [
                "Tuple[(Dict[(str, Any)], Dict[(str, Any)])]"
            ],
            "arguments": {
                "config_dicts": [
                    "Dict[(str, Any)]"
                ],
                "ignore_names": [
                    "Set[str]"
                ],
                "warn_unused": [
                    "bool"
                ]
            }
        },
        "ClassSymbol.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "string": [
                    "str"
                ]
            }
        },
        "ClassSymbol.create": {
            "name": "create",
            "location": 25,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "ObjectRef.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "expression": [
                    "str"
                ]
            }
        },
        "ObjectRef.bind": {
            "name": "bind",
            "location": 69,
            "return": [],
            "arguments": {
                "self": [],
                "value": [
                    "Any"
                ]
            }
        },
        "ObjectRef.target": {
            "name": "target",
            "location": 73,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/config/configuration.py": {
        "Configuration.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Configuration.add_argument": {
            "name": "add_argument",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "required": [
                    "bool"
                ],
                "default": [
                    "Any"
                ],
                "cond": [
                    "Callable[([Any], bool)]"
                ]
            }
        },
        "Configuration.ignore_argument": {
            "name": "ignore_argument",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Configuration.make_namespace": {
            "name": "make_namespace",
            "location": 48,
            "return": [
                "Namespace"
            ],
            "arguments": {
                "self": [],
                "d_obj": []
            }
        },
        "Configuration.load_file": {
            "name": "load_file",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ],
                "changes": [
                    "Optional[List[str]]"
                ]
            }
        },
        "Configuration.build_model": {
            "name": "build_model",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "warn_unused": []
            }
        },
        "Configuration._check_loaded_conf": {
            "name": "_check_loaded_conf",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Configuration.save_file": {
            "name": "save_file",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/config/exceptions.py": {
        "ParseError.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "str"
                ],
                "line": [
                    "int"
                ]
            }
        },
        "ParseError.set_line": {
            "name": "set_line",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "line": [
                    "int"
                ]
            }
        },
        "ParseError.__str__": {
            "name": "__str__",
            "location": 18,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConfigInvalidValueException.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "Any"
                ],
                "message": [
                    "str"
                ]
            }
        },
        "ConfigInvalidValueException.__str__": {
            "name": "__str__",
            "location": 39,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConfigBuildException.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "object_name": [
                    "str"
                ],
                "original_exception": [
                    "Exception"
                ]
            }
        },
        "ConfigBuildException.__str__": {
            "name": "__str__",
            "location": 60,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/config/normalize.py": {
        "normalize_configuration": {
            "name": "normalize_configuration",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "cfg": [
                    "Namespace"
                ],
                "train_mode": [
                    "bool"
                ]
            }
        },
        "_normalize_train_cfg": {
            "name": "_normalize_train_cfg",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "cfg": [
                    "Namespace"
                ]
            }
        },
        "_resolve_period": {
            "name": "_resolve_period",
            "location": 97,
            "return": [
                "Callable[([int, float], bool)]"
            ],
            "arguments": {
                "period": [
                    "Union[(str, int)]"
                ],
                "denominator": [
                    "int"
                ]
            }
        },
        "_resolve_period.get_batch_logger": {
            "name": "get_batch_logger",
            "location": 120,
            "return": [
                "Callable[([int, float], bool)]"
            ],
            "arguments": {
                "period": [
                    "int"
                ]
            }
        },
        "_resolve_period.get_time_logger": {
            "name": "get_time_logger",
            "location": 125,
            "return": [
                "Callable[([int, float], bool)]"
            ],
            "arguments": {
                "period": [
                    "float"
                ]
            }
        },
        "_resolve_period.get_batch_logger.is_time": {
            "name": "is_time",
            "location": 121,
            "return": [
                "bool"
            ],
            "arguments": {
                "step": [
                    "int"
                ],
                "_": [
                    "float"
                ]
            }
        },
        "_resolve_period.get_time_logger.is_time": {
            "name": "is_time",
            "location": 126,
            "return": [
                "bool"
            ],
            "arguments": {
                "step": [
                    "int"
                ],
                "last_time": [
                    "float"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/config/parsing.py": {
        "get_first_match": {
            "name": "get_first_match",
            "location": 35,
            "return": [
                "str"
            ],
            "arguments": {
                "pattern": [
                    "Pattern"
                ],
                "string": [
                    "str"
                ]
            }
        },
        "_keyval_parser_dict": {
            "name": "_keyval_parser_dict",
            "location": 57,
            "return": [
                "Dict[(Any, Callable)]"
            ],
            "arguments": {}
        },
        "_split_on_commas": {
            "name": "_split_on_commas",
            "location": 87,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "string": [
                    "str"
                ]
            }
        },
        "_parse_string": {
            "name": "_parse_string",
            "location": 120,
            "return": [
                "str"
            ],
            "arguments": {
                "string": [
                    "str"
                ],
                "vars_dict": [
                    "VarsDict"
                ]
            }
        },
        "_parse_list": {
            "name": "_parse_list",
            "location": 124,
            "return": [
                "List[Any]"
            ],
            "arguments": {
                "string": [
                    "str"
                ],
                "vars_dict": [
                    "VarsDict"
                ]
            }
        },
        "_parse_tuple": {
            "name": "_parse_tuple",
            "location": 137,
            "return": [
                "Tuple[(Any, ...)]"
            ],
            "arguments": {
                "string": [
                    "str"
                ],
                "vars_dict": [
                    "VarsDict"
                ]
            }
        },
        "_parse_class_name": {
            "name": "_parse_class_name",
            "location": 146,
            "return": [
                "ClassSymbol"
            ],
            "arguments": {
                "string": [
                    "str"
                ],
                "vars_dict": [
                    "VarsDict"
                ]
            }
        },
        "_parse_value": {
            "name": "_parse_value",
            "location": 152,
            "return": [
                "Any"
            ],
            "arguments": {
                "string": [
                    "str"
                ],
                "vars_dict": [
                    "VarsDict"
                ]
            }
        },
        "_parse_ini": {
            "name": "_parse_ini",
            "location": 171,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "config_file": [
                    "Iterable[str]"
                ],
                "filename": [
                    "str"
                ]
            }
        },
        "_apply_change": {
            "name": "_apply_change",
            "location": 195,
            "return": [
                "None"
            ],
            "arguments": {
                "config_dict": [
                    "Dict[(str, Any)]"
                ],
                "setting": [
                    "str"
                ]
            }
        },
        "parse_file": {
            "name": "parse_file",
            "location": 213,
            "return": [
                "Tuple[(Dict[(str, Any)], Dict[(str, Any)])]"
            ],
            "arguments": {
                "config_file": [
                    "Iterable[str]"
                ],
                "changes": [
                    "Iterable[str]"
                ]
            }
        },
        "write_file": {
            "name": "write_file",
            "location": 255,
            "return": [
                "None"
            ],
            "arguments": {
                "config_dict": [
                    "Dict[(str, Any)]"
                ],
                "config_file": [
                    "IO[str]"
                ]
            }
        },
        "VarsDict.__missing__": {
            "name": "__missing__",
            "location": 72,
            "return": [],
            "arguments": {
                "self": [],
                "key": []
            }
        },
        "parse_file.parse_section": {
            "name": "parse_section",
            "location": 229,
            "return": [],
            "arguments": {
                "section": [
                    "str"
                ],
                "output_dict": [
                    "Dict[(str, Any)]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/config/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/decoders/autoregressive.py": {
        "AutoregressiveDecoder.__init__": {
            "name": "__init__",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "max_output_len": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "embedding_size": [
                    "int"
                ],
                "embeddings_source": [
                    "EmbeddedSequence"
                ],
                "tie_embeddings": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ],
                "supress_unk": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "AutoregressiveDecoder.embedding_size": {
            "name": "embedding_size",
            "location": 183,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.go_symbols": {
            "name": "go_symbols",
            "location": 200,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.input_types": {
            "name": "input_types",
            "location": 205,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.input_shapes": {
            "name": "input_shapes",
            "location": 209,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_tokens": {
            "name": "train_tokens",
            "location": 213,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_inputs": {
            "name": "train_inputs",
            "location": 217,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_mask": {
            "name": "train_mask",
            "location": 222,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.decoding_w": {
            "name": "decoding_w",
            "location": 226,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.decoding_b": {
            "name": "decoding_b",
            "location": 243,
            "return": [
                "Optional[tf.Variable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.embedding_matrix": {
            "name": "embedding_matrix",
            "location": 254,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.embed_input_symbols": {
            "name": "embed_input_symbols",
            "location": 269,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "input_symbols": [
                    "tf.Tensor"
                ]
            }
        },
        "AutoregressiveDecoder.train_loop_result": {
            "name": "train_loop_result",
            "location": 275,
            "return": [
                "LoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_logits": {
            "name": "train_logits",
            "location": 279,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_output_states": {
            "name": "train_output_states",
            "location": 284,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_logprobs": {
            "name": "train_logprobs",
            "location": 289,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_xents": {
            "name": "train_xents",
            "location": 293,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.train_loss": {
            "name": "train_loss",
            "location": 313,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.cost": {
            "name": "cost",
            "location": 319,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_loop_result": {
            "name": "runtime_loop_result",
            "location": 323,
            "return": [
                "LoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_logits": {
            "name": "runtime_logits",
            "location": 327,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_output_states": {
            "name": "runtime_output_states",
            "location": 332,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_mask": {
            "name": "runtime_mask",
            "location": 337,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.decoded": {
            "name": "decoded",
            "location": 342,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_xents": {
            "name": "runtime_xents",
            "location": 352,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_loss": {
            "name": "runtime_loss",
            "location": 369,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.runtime_logprobs": {
            "name": "runtime_logprobs",
            "location": 374,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.output_dimension": {
            "name": "output_dimension",
            "location": 378,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.get_initial_feedables": {
            "name": "get_initial_feedables",
            "location": 381,
            "return": [
                "DecoderFeedables"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.get_initial_histories": {
            "name": "get_initial_histories",
            "location": 388,
            "return": [
                "DecoderHistories"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.get_initial_constants": {
            "name": "get_initial_constants",
            "location": 416,
            "return": [
                "DecoderConstants"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.get_initial_loop_state": {
            "name": "get_initial_loop_state",
            "location": 419,
            "return": [
                "LoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.loop_continue_criterion": {
            "name": "loop_continue_criterion",
            "location": 425,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AutoregressiveDecoder.next_state": {
            "name": "next_state",
            "location": 439,
            "return": [
                "Tuple[(tf.Tensor, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "loop_state": [
                    "LoopState"
                ]
            }
        },
        "AutoregressiveDecoder.get_body": {
            "name": "get_body",
            "location": 442,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "train_mode": [
                    "bool"
                ],
                "sample": [
                    "bool"
                ],
                "temperature": [
                    "float"
                ]
            }
        },
        "AutoregressiveDecoder.finalize_loop": {
            "name": "finalize_loop",
            "location": 521,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "final_loop_state": [
                    "LoopState"
                ],
                "train_mode": [
                    "bool"
                ]
            }
        },
        "AutoregressiveDecoder.decoding_loop": {
            "name": "decoding_loop",
            "location": 532,
            "return": [
                "LoopState"
            ],
            "arguments": {
                "self": [],
                "train_mode": [
                    "bool"
                ],
                "sample": [
                    "bool"
                ],
                "temperature": [
                    "float"
                ]
            }
        },
        "AutoregressiveDecoder.feed_dict": {
            "name": "feed_dict",
            "location": 564,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "AutoregressiveDecoder.get_body.is_finished": {
            "name": "is_finished",
            "location": 446,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "finished": [
                    "tf.Tensor"
                ],
                "symbols": [
                    "tf.Tensor"
                ]
            }
        },
        "AutoregressiveDecoder.get_body.state_to_logits": {
            "name": "state_to_logits",
            "location": 450,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "state": [
                    "tf.Tensor"
                ]
            }
        },
        "AutoregressiveDecoder.get_body.logits_to_symbols": {
            "name": "logits_to_symbols",
            "location": 461,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "logits": [
                    "tf.Tensor"
                ],
                "loop_state": [
                    "LoopState"
                ]
            }
        },
        "AutoregressiveDecoder.get_body.body": {
            "name": "body",
            "location": 482,
            "return": [
                "LoopState"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/beam_search_decoder.py": {
        "BeamSearchDecoder.__init__": {
            "name": "__init__",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parent_decoder": [
                    "AutoregressiveDecoder"
                ],
                "beam_size": [
                    "int"
                ],
                "max_steps": [
                    "int"
                ],
                "length_normalization": [
                    "float"
                ]
            }
        },
        "BeamSearchDecoder.outputs": {
            "name": "outputs",
            "location": 168,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.initial_loop_state": {
            "name": "initial_loop_state",
            "location": 194,
            "return": [
                "BeamSearchLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.vocabulary": {
            "name": "vocabulary",
            "location": 200,
            "return": [
                "Vocabulary"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.search_state": {
            "name": "search_state",
            "location": 207,
            "return": [
                "SearchState"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.decoder_state": {
            "name": "decoder_state",
            "location": 211,
            "return": [
                "LoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.search_results": {
            "name": "search_results",
            "location": 215,
            "return": [
                "SearchResults"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.get_initial_loop_state": {
            "name": "get_initial_loop_state",
            "location": 218,
            "return": [
                "BeamSearchLoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.loop_continue_criterion": {
            "name": "loop_continue_criterion",
            "location": 330,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.decoding_loop": {
            "name": "decoding_loop",
            "location": 357,
            "return": [
                "BeamSearchOutput"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder.get_body": {
            "name": "get_body",
            "location": 385,
            "return": [
                "Callable[([Any], BeamSearchLoopState)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchDecoder._length_penalty": {
            "name": "_length_penalty",
            "location": 561,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "lengths": [
                    "tf.Tensor"
                ]
            }
        },
        "BeamSearchDecoder.expand_to_beam": {
            "name": "expand_to_beam",
            "location": 575,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "val": [
                    "tf.Tensor"
                ],
                "dim": [
                    "int"
                ]
            }
        },
        "BeamSearchDecoder.get_body.body": {
            "name": "body",
            "location": 394,
            "return": [
                "BeamSearchLoopState"
            ],
            "arguments": {}
        },
        "BeamSearchDecoder.get_body.body.gather_fn": {
            "name": "gather_fn",
            "location": 515,
            "return": [],
            "arguments": {
                "x": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/classifier.py": {
        "Classifier.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoders": [
                    "List[Stateful]"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "layers": [
                    "List[int]"
                ],
                "activation_fn": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "Classifier.input_types": {
            "name": "input_types",
            "location": 66,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.input_shapes": {
            "name": "input_shapes",
            "location": 70,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.gt_inputs": {
            "name": "gt_inputs",
            "location": 74,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.targets": {
            "name": "targets",
            "location": 78,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier._mlp": {
            "name": "_mlp",
            "location": 82,
            "return": [
                "MultilayerPerceptron"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.loss_with_decoded_ins": {
            "name": "loss_with_decoded_ins",
            "location": 90,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.cost": {
            "name": "cost",
            "location": 94,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.loss_with_gt_ins": {
            "name": "loss_with_gt_ins",
            "location": 104,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.decoded_seq": {
            "name": "decoded_seq",
            "location": 110,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.decoded_logits": {
            "name": "decoded_logits",
            "location": 114,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.runtime_logprobs": {
            "name": "runtime_logprobs",
            "location": 118,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.train_loss": {
            "name": "train_loss",
            "location": 123,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Classifier.runtime_loss": {
            "name": "runtime_loss",
            "location": 127,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Classifier.decoded": {
            "name": "decoded",
            "location": 131,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Classifier.feed_dict": {
            "name": "feed_dict",
            "location": 134,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/ctc_decoder.py": {
        "CTCDecoder.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoder": [
                    "TemporalStateful"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "max_length": [
                    "int"
                ],
                "merge_repeated_targets": [
                    "bool"
                ],
                "merge_repeated_outputs": [
                    "bool"
                ],
                "beam_width": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "CTCDecoder.input_types": {
            "name": "input_types",
            "location": 52,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.input_shapes": {
            "name": "input_shapes",
            "location": 56,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.target_tokens": {
            "name": "target_tokens",
            "location": 60,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.train_targets": {
            "name": "train_targets",
            "location": 64,
            "return": [
                "tf.SparseTensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.decoded": {
            "name": "decoded",
            "location": 76,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.train_loss": {
            "name": "train_loss",
            "location": 92,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.runtime_loss": {
            "name": "runtime_loss",
            "location": 96,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.cost": {
            "name": "cost",
            "location": 100,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.logits": {
            "name": "logits",
            "location": 111,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDecoder.feed_dict": {
            "name": "feed_dict",
            "location": 142,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/decoder.py": {
        "Decoder.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoders": [
                    "List[Stateful]"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "max_output_len": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "embedding_size": [
                    "int"
                ],
                "embeddings_source": [
                    "EmbeddedSequence"
                ],
                "tie_embeddings": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ],
                "rnn_size": [
                    "int"
                ],
                "output_projection": [
                    "OutputProjectionSpec"
                ],
                "encoder_projection": [
                    "EncoderProjection"
                ],
                "attentions": [
                    "List[BaseAttention]"
                ],
                "attention_on_input": [
                    "bool"
                ],
                "rnn_cell": [
                    "str"
                ],
                "conditional_gru": [
                    "bool"
                ],
                "supress_unk": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "Decoder.encoder_projection": {
            "name": "encoder_projection",
            "location": 177,
            "return": [
                "EncoderProjection"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.rnn_size": {
            "name": "rnn_size",
            "location": 194,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.output_projection_spec": {
            "name": "output_projection_spec",
            "location": 205,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.output_projection": {
            "name": "output_projection",
            "location": 218,
            "return": [
                "OutputProjection"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.output_dimension": {
            "name": "output_dimension",
            "location": 222,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.initial_state": {
            "name": "initial_state",
            "location": 227,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder._get_rnn_cell": {
            "name": "_get_rnn_cell",
            "location": 254,
            "return": [
                "tf.contrib.rnn.RNNCell"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder._get_conditional_gru_cell": {
            "name": "_get_conditional_gru_cell",
            "location": 257,
            "return": [
                "tf.contrib.rnn.GRUCell"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.input_plus_attention": {
            "name": "input_plus_attention",
            "location": 264,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.next_state": {
            "name": "next_state",
            "location": 279,
            "return": [
                "Tuple[(tf.Tensor, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "loop_state": [
                    "LoopState"
                ]
            }
        },
        "Decoder.get_initial_feedables": {
            "name": "get_initial_feedables",
            "location": 360,
            "return": [
                "DecoderFeedables"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.get_initial_histories": {
            "name": "get_initial_histories",
            "location": 371,
            "return": [
                "DecoderHistories"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.finalize_loop": {
            "name": "finalize_loop",
            "location": 384,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "final_loop_state": [
                    "LoopState"
                ],
                "train_mode": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/encoder_projection.py": {
        "empty_initial_state": {
            "name": "empty_initial_state",
            "location": 37,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "train_mode": [
                    "tf.Tensor"
                ],
                "rnn_size": [
                    "int"
                ],
                "encoders": [
                    "List[Stateful]"
                ]
            }
        },
        "linear_encoder_projection": {
            "name": "linear_encoder_projection",
            "location": 47,
            "return": [
                "EncoderProjection"
            ],
            "arguments": {
                "dropout_keep_prob": [
                    "float"
                ]
            }
        },
        "concat_encoder_projection": {
            "name": "concat_encoder_projection",
            "location": 76,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "train_mode": [
                    "tf.Tensor"
                ],
                "rnn_size": [
                    "int"
                ],
                "encoders": [
                    "List[Stateful]"
                ]
            }
        },
        "nematus_projection": {
            "name": "nematus_projection",
            "location": 99,
            "return": [
                "EncoderProjection"
            ],
            "arguments": {
                "dropout_keep_prob": [
                    "float"
                ]
            }
        },
        "linear_encoder_projection.func": {
            "name": "func",
            "location": 59,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "train_mode": [
                    "tf.Tensor"
                ],
                "rnn_size": [
                    "int"
                ],
                "encoders": [
                    "List[Stateful]"
                ]
            }
        },
        "nematus_projection.func": {
            "name": "func",
            "location": 111,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "train_mode": [
                    "tf.Tensor"
                ],
                "rnn_size": [
                    "int"
                ],
                "encoders": [
                    "List[TemporalStatefulWithOutput]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/output_projection.py": {
        "_legacy_linear": {
            "name": "_legacy_linear",
            "location": 35,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "output_size": [
                    "int"
                ]
            }
        },
        "_legacy_relu": {
            "name": "_legacy_relu",
            "location": 55,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "output_size": [
                    "int"
                ]
            }
        },
        "nematus_output": {
            "name": "nematus_output",
            "location": 76,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "output_size": [
                    "int"
                ],
                "activation_fn": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_keep_prob": [
                    "float"
                ]
            }
        },
        "nonlinear_output": {
            "name": "nonlinear_output",
            "location": 115,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "output_size": [
                    "int"
                ],
                "activation_fn": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_keep_prob": [
                    "float"
                ]
            }
        },
        "maxout_output": {
            "name": "maxout_output",
            "location": 133,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "maxout_size": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ]
            }
        },
        "mlp_output": {
            "name": "mlp_output",
            "location": 163,
            "return": [
                "Tuple[(OutputProjection, int)]"
            ],
            "arguments": {
                "layer_sizes": [
                    "List[int]"
                ],
                "activation": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_keep_prob": [
                    "float"
                ]
            }
        },
        "_legacy_linear._projection": {
            "name": "_projection",
            "location": 46,
            "return": [],
            "arguments": {
                "prev_state": [],
                "prev_output": [],
                "ctx_tensors": [],
                "train_mode": []
            }
        },
        "_legacy_relu._projection": {
            "name": "_projection",
            "location": 66,
            "return": [],
            "arguments": {
                "prev_state": [],
                "prev_output": [],
                "ctx_tensors": [],
                "train_mode": []
            }
        },
        "nematus_output._projection": {
            "name": "_projection",
            "location": 91,
            "return": [],
            "arguments": {
                "prev_state": [],
                "prev_output": [],
                "ctx_tensors": [],
                "train_mode": []
            }
        },
        "nonlinear_output._projection": {
            "name": "_projection",
            "location": 122,
            "return": [],
            "arguments": {
                "prev_state": [],
                "prev_output": [],
                "ctx_tensors": [],
                "train_mode": []
            }
        },
        "maxout_output._projection": {
            "name": "_projection",
            "location": 154,
            "return": [],
            "arguments": {
                "prev_state": [],
                "prev_output": [],
                "ctx_tensors": [],
                "train_mode": []
            }
        },
        "mlp_output._projection": {
            "name": "_projection",
            "location": 179,
            "return": [],
            "arguments": {
                "prev_state": [],
                "prev_output": [],
                "ctx_tensors": [],
                "train_mode": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/sequence_labeler.py": {
        "SequenceLabeler.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoders": [
                    "List[TemporalStateful]"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "max_output_len": [
                    "int"
                ],
                "hidden_dim": [
                    "int"
                ],
                "activation": [
                    "Callable"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "add_start_symbol": [
                    "bool"
                ],
                "add_end_symbol": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SequenceLabeler.input_types": {
            "name": "input_types",
            "location": 52,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.input_shapes": {
            "name": "input_shapes",
            "location": 56,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.input_mask": {
            "name": "input_mask",
            "location": 60,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.target_tokens": {
            "name": "target_tokens",
            "location": 74,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.train_targets": {
            "name": "train_targets",
            "location": 78,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.train_mask": {
            "name": "train_mask",
            "location": 83,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.concatenated_inputs": {
            "name": "concatenated_inputs",
            "location": 94,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.states": {
            "name": "states",
            "location": 101,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.logits": {
            "name": "logits",
            "location": 110,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.logprobs": {
            "name": "logprobs",
            "location": 115,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.decoded": {
            "name": "decoded",
            "location": 119,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.train_xents": {
            "name": "train_xents",
            "location": 123,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.cost": {
            "name": "cost",
            "location": 132,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.train_loss": {
            "name": "train_loss",
            "location": 139,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.runtime_loss": {
            "name": "runtime_loss",
            "location": 143,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabeler.feed_dict": {
            "name": "feed_dict",
            "location": 146,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "EmbeddingsLabeler.__init__": {
            "name": "__init__",
            "location": 162,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoders": [
                    "List[TemporalStateful]"
                ],
                "embedded_sequence": [
                    "EmbeddedSequence"
                ],
                "data_id": [
                    "str"
                ],
                "max_output_len": [
                    "int"
                ],
                "hidden_dim": [
                    "int"
                ],
                "activation": [
                    "Callable"
                ],
                "train_embeddings": [
                    "bool"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "add_start_symbol": [
                    "bool"
                ],
                "add_end_symbol": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "EmbeddingsLabeler.logits": {
            "name": "logits",
            "location": 193,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/sequence_regressor.py": {
        "SequenceRegressor.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoders": [
                    "List[Stateful]"
                ],
                "data_id": [
                    "str"
                ],
                "layers": [
                    "List[int]"
                ],
                "activation_fn": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "dimension": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SequenceRegressor.input_types": {
            "name": "input_types",
            "location": 50,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.input_shapes": {
            "name": "input_shapes",
            "location": 54,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.train_inputs": {
            "name": "train_inputs",
            "location": 58,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor._mlp_input": {
            "name": "_mlp_input",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor._mlp_output": {
            "name": "_mlp_output",
            "location": 66,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.predictions": {
            "name": "predictions",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.cost": {
            "name": "cost",
            "location": 77,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.train_loss": {
            "name": "train_loss",
            "location": 87,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.runtime_loss": {
            "name": "runtime_loss",
            "location": 91,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.decoded": {
            "name": "decoded",
            "location": 95,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequenceRegressor.feed_dict": {
            "name": "feed_dict",
            "location": 98,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/transformer.py": {
        "TransformerDecoder.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "encoders": [
                    "List[Attendable]"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "ff_hidden_size": [
                    "int"
                ],
                "n_heads_self": [
                    "int"
                ],
                "n_heads_enc": [
                    "Union[(List[int], int)]"
                ],
                "depth": [
                    "int"
                ],
                "max_output_len": [
                    "int"
                ],
                "attention_combination_strategy": [
                    "str"
                ],
                "n_heads_hier": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "embedding_size": [
                    "int"
                ],
                "embeddings_source": [
                    "EmbeddedSequence"
                ],
                "tie_embeddings": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ],
                "self_attention_dropout_keep_prob": [
                    "float"
                ],
                "attention_dropout_keep_prob": [
                    "Union[(float, List[float])]"
                ],
                "use_att_transform_bias": [
                    "bool"
                ],
                "supress_unk": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "TransformerDecoder.dimension": {
            "name": "dimension",
            "location": 210,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerDecoder.output_dimension": {
            "name": "output_dimension",
            "location": 237,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerDecoder.embed_input_symbol": {
            "name": "embed_input_symbol",
            "location": 240,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerDecoder.train_input_symbols": {
            "name": "train_input_symbols",
            "location": 259,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerDecoder.self_attention_sublayer": {
            "name": "self_attention_sublayer",
            "location": 270,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "prev_layer": [
                    "TransformerLayer"
                ]
            }
        },
        "TransformerDecoder.encoder_attention_sublayer": {
            "name": "encoder_attention_sublayer",
            "location": 297,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "queries": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerDecoder.feedforward_sublayer": {
            "name": "feedforward_sublayer",
            "location": 342,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "layer_input": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerDecoder.layer": {
            "name": "layer",
            "location": 365,
            "return": [
                "TransformerLayer"
            ],
            "arguments": {
                "self": [],
                "level": [
                    "int"
                ],
                "inputs": [
                    "tf.Tensor"
                ],
                "mask": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerDecoder.train_loop_result": {
            "name": "train_loop_result",
            "location": 394,
            "return": [
                "LoopState"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerDecoder.get_initial_feedables": {
            "name": "get_initial_feedables",
            "location": 455,
            "return": [
                "DecoderFeedables"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerDecoder.get_initial_histories": {
            "name": "get_initial_histories",
            "location": 470,
            "return": [
                "DecoderHistories"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerDecoder.next_state": {
            "name": "next_state",
            "location": 487,
            "return": [
                "Tuple[(tf.Tensor, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "loop_state": [
                    "LoopState"
                ]
            }
        },
        "TransformerDecoder.encoder_attention_sublayer.make_attn_callback": {
            "name": "make_attn_callback",
            "location": 306,
            "return": [
                "Callable[([tf.Tensor], tf.Tensor)]"
            ],
            "arguments": {
                "prob": [
                    "float"
                ]
            }
        },
        "TransformerDecoder.encoder_attention_sublayer.make_attn_callback.callback": {
            "name": "callback",
            "location": 308,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/word_alignment_decoder.py": {
        "WordAlignmentDecoder.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "RecurrentEncoder"
                ],
                "decoder": [
                    "Decoder"
                ],
                "data_id": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "WordAlignmentDecoder.enc_input": {
            "name": "enc_input",
            "location": 40,
            "return": [
                "Sequence"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.input_types": {
            "name": "input_types",
            "location": 47,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.input_shapes": {
            "name": "input_shapes",
            "location": 51,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.ref_alignment": {
            "name": "ref_alignment",
            "location": 56,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.alignment_target": {
            "name": "alignment_target",
            "location": 60,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.train_loss": {
            "name": "train_loss",
            "location": 65,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.decoded": {
            "name": "decoded",
            "location": 75,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.runtime_loss": {
            "name": "runtime_loss",
            "location": 79,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.runtime_outputs": {
            "name": "runtime_outputs",
            "location": 84,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder._make_decoder": {
            "name": "_make_decoder",
            "location": 87,
            "return": [],
            "arguments": {
                "self": [],
                "runtime_mode": []
            }
        },
        "WordAlignmentDecoder.cost": {
            "name": "cost",
            "location": 113,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentDecoder.feed_dict": {
            "name": "feed_dict",
            "location": 116,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/decoders/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/encoders/attentive.py": {
        "AttentiveEncoder.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_sequence": [
                    "Attendable"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_heads": [
                    "int"
                ],
                "output_size": [
                    "int"
                ],
                "state_proj_size": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "AttentiveEncoder._attention_states_dropped": {
            "name": "_attention_states_dropped",
            "location": 56,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttentiveEncoder.attention_weights": {
            "name": "attention_weights",
            "location": 61,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttentiveEncoder.temporal_states": {
            "name": "temporal_states",
            "location": 78,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttentiveEncoder.temporal_mask": {
            "name": "temporal_mask",
            "location": 90,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttentiveEncoder.output": {
            "name": "output",
            "location": 94,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/cnn_encoder.py": {
        "plain_convolution": {
            "name": "plain_convolution",
            "location": 209,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor, int)]"
            ],
            "arguments": {
                "prev_layer": [
                    "tf.Tensor"
                ],
                "prev_mask": [
                    "tf.Tensor"
                ],
                "specification": [
                    "ConvSpec"
                ],
                "batch_norm_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "layer_num": [
                    "int"
                ]
            }
        },
        "residual_block": {
            "name": "residual_block",
            "location": 244,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor, int)]"
            ],
            "arguments": {
                "prev_layer": [
                    "tf.Tensor"
                ],
                "prev_mask": [
                    "tf.Tensor"
                ],
                "prev_channels": [
                    "int"
                ],
                "specification": [
                    "ResNetSpec"
                ],
                "batch_norm_callback": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "layer_num": [
                    "int"
                ]
            }
        },
        "pooling": {
            "name": "pooling",
            "location": 289,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor)]"
            ],
            "arguments": {
                "prev_layer": [
                    "tf.Tensor"
                ],
                "prev_mask": [
                    "tf.Tensor"
                ],
                "specification": [
                    "MaxPoolSpec"
                ],
                "layer_num": [
                    "int"
                ]
            }
        },
        "CNNEncoder.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "data_id": [
                    "str"
                ],
                "convolutions": [
                    "List[Union[(ConvSpec, ResNetSpec, MaxPoolSpec)]]"
                ],
                "image_height": [
                    "int"
                ],
                "image_width": [
                    "int"
                ],
                "pixel_dim": [
                    "int"
                ],
                "fully_connected": [
                    "List[int]"
                ],
                "batch_normalize": [
                    "bool"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "CNNEncoder.input_types": {
            "name": "input_types",
            "location": 87,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.input_shapes": {
            "name": "input_shapes",
            "location": 91,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.image_input": {
            "name": "image_input",
            "location": 96,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.image_mask": {
            "name": "image_mask",
            "location": 100,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.batch_norm_callback": {
            "name": "batch_norm_callback",
            "location": 105,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "layer_output": [
                    "tf.Tensor"
                ]
            }
        },
        "CNNEncoder.image_processing_layers": {
            "name": "image_processing_layers",
            "location": 112,
            "return": [
                "List[Tuple[(tf.Tensor, tf.Tensor)]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.spatial_states": {
            "name": "spatial_states",
            "location": 156,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.spatial_mask": {
            "name": "spatial_mask",
            "location": 162,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.output": {
            "name": "output",
            "location": 168,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNEncoder.feed_dict": {
            "name": "feed_dict",
            "location": 199,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "CNNTemporalView.__init__": {
            "name": "__init__",
            "location": 326,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "cnn": [
                    "CNNEncoder"
                ]
            }
        },
        "CNNTemporalView.output": {
            "name": "output",
            "location": 335,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNTemporalView.temporal_states": {
            "name": "temporal_states",
            "location": 339,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CNNTemporalView.temporal_mask": {
            "name": "temporal_mask",
            "location": 347,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CNNTemporalView.dependencies": {
            "name": "dependencies",
            "location": 353,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/facebook_conv.py": {
        "SentenceEncoder.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_sequence": [
                    "EmbeddedSequence"
                ],
                "conv_features": [
                    "int"
                ],
                "encoder_layers": [
                    "int"
                ],
                "kernel_width": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SentenceEncoder.temporal_states": {
            "name": "temporal_states",
            "location": 60,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceEncoder.output": {
            "name": "output",
            "location": 76,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceEncoder.temporal_mask": {
            "name": "temporal_mask",
            "location": 82,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceEncoder.order_embeddings": {
            "name": "order_embeddings",
            "location": 86,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceEncoder.ordered_embedded_inputs": {
            "name": "ordered_embedded_inputs",
            "location": 94,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceEncoder._residual_conv": {
            "name": "_residual_conv",
            "location": 102,
            "return": [],
            "arguments": {
                "self": [],
                "input_signals": [
                    "tf.Tensor"
                ],
                "name": [
                    "str"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/imagenet_encoder.py": {
        "get_alexnet": {
            "name": "get_alexnet",
            "location": 43,
            "return": [
                "ImageNetSpec"
            ],
            "arguments": {}
        },
        "get_vgg_by_type": {
            "name": "get_vgg_by_type",
            "location": 52,
            "return": [
                "Callable[([], ImageNetSpec)]"
            ],
            "arguments": {
                "vgg_type": [
                    "str"
                ]
            }
        },
        "get_resnet_by_type": {
            "name": "get_resnet_by_type",
            "location": 71,
            "return": [
                "Callable[([], ImageNetSpec)]"
            ],
            "arguments": {
                "resnet_type": [
                    "str"
                ]
            }
        },
        "get_vgg_by_type.get_vgg": {
            "name": "get_vgg",
            "location": 53,
            "return": [
                "ImageNetSpec"
            ],
            "arguments": {}
        },
        "get_resnet_by_type.get_resnet": {
            "name": "get_resnet",
            "location": 72,
            "return": [
                "ImageNetSpec"
            ],
            "arguments": {}
        },
        "ImageNet.__init__": {
            "name": "__init__",
            "location": 115,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "data_id": [
                    "str"
                ],
                "network_type": [
                    "str"
                ],
                "slim_models_path": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "spatial_layer": [
                    "str"
                ],
                "encoded_layer": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "ImageNet.input_types": {
            "name": "input_types",
            "location": 162,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.input_shapes": {
            "name": "input_shapes",
            "location": 166,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.input_image": {
            "name": "input_image",
            "location": 171,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.end_points": {
            "name": "end_points",
            "location": 175,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.spatial_states": {
            "name": "spatial_states",
            "location": 204,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.spatial_mask": {
            "name": "spatial_mask",
            "location": 216,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.output": {
            "name": "output",
            "location": 226,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet._init_saver": {
            "name": "_init_saver",
            "location": 237,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageNet.feed_dict": {
            "name": "feed_dict",
            "location": 247,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/numpy_stateful_filler.py": {
        "StatefulFiller.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "dimension": [
                    "int"
                ],
                "data_id": [
                    "str"
                ],
                "output_shape": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "StatefulFiller.input_types": {
            "name": "input_types",
            "location": 58,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulFiller.input_shapes": {
            "name": "input_shapes",
            "location": 62,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulFiller.vector": {
            "name": "vector",
            "location": 66,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulFiller.output": {
            "name": "output",
            "location": 70,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulFiller.feed_dict": {
            "name": "feed_dict",
            "location": 76,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "TemporalFiller.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "data_id": [
                    "str"
                ],
                "input_size": [
                    "int"
                ],
                "max_input_len": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "TemporalFiller.input_types": {
            "name": "input_types",
            "location": 110,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalFiller.input_shapes": {
            "name": "input_shapes",
            "location": 114,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalFiller.temporal_states": {
            "name": "temporal_states",
            "location": 118,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalFiller._input_lengths": {
            "name": "_input_lengths",
            "location": 123,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalFiller.temporal_mask": {
            "name": "temporal_mask",
            "location": 128,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalFiller.feed_dict": {
            "name": "feed_dict",
            "location": 131,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "SpatialFiller.__init__": {
            "name": "__init__",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_shape": [
                    "List[int]"
                ],
                "data_id": [
                    "str"
                ],
                "projection_dim": [
                    "int"
                ],
                "ff_hidden_dim": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SpatialFiller.input_types": {
            "name": "input_types",
            "location": 201,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialFiller.input_shapes": {
            "name": "input_shapes",
            "location": 205,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialFiller.spatial_input": {
            "name": "spatial_input",
            "location": 210,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialFiller.output": {
            "name": "output",
            "location": 214,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialFiller.spatial_states": {
            "name": "spatial_states",
            "location": 219,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialFiller.spatial_mask": {
            "name": "spatial_mask",
            "location": 239,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialFiller.feed_dict": {
            "name": "feed_dict",
            "location": 242,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/pooling.py": {
        "SequencePooling.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_sequence": [
                    "TemporalStateful"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SequencePooling._masked_input": {
            "name": "_masked_input",
            "location": 29,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequencePooling._input_mask": {
            "name": "_input_mask",
            "location": 33,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceMaxPooling.output": {
            "name": "output",
            "location": 45,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceAveragePooling.output": {
            "name": "output",
            "location": 61,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/recurrent.py": {
        "_make_rnn_spec": {
            "name": "_make_rnn_spec",
            "location": 48,
            "return": [
                "RNNSpec"
            ],
            "arguments": {
                "size": [
                    "int"
                ],
                "direction": [
                    "str"
                ],
                "cell_type": [
                    "str"
                ]
            }
        },
        "_make_rnn_cell": {
            "name": "_make_rnn_cell",
            "location": 66,
            "return": [
                "Callable[([], tf.nn.rnn_cell.RNNCell)]"
            ],
            "arguments": {
                "spec": [
                    "RNNSpec"
                ]
            }
        },
        "rnn_layer": {
            "name": "rnn_layer",
            "location": 71,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor)]"
            ],
            "arguments": {
                "rnn_input": [
                    "tf.Tensor"
                ],
                "lengths": [
                    "tf.Tensor"
                ],
                "rnn_spec": [
                    "RNNSpec"
                ]
            }
        },
        "RecurrentEncoder.__init__": {
            "name": "__init__",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_sequence": [
                    "TemporalStateful"
                ],
                "rnn_layers": [
                    "List[RNNSpecTuple]"
                ],
                "add_residual": [
                    "bool"
                ],
                "add_layer_norm": [
                    "bool"
                ],
                "include_final_layer_norm": [
                    "bool"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "RecurrentEncoder.rnn_input": {
            "name": "rnn_input",
            "location": 175,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "RecurrentEncoder.rnn": {
            "name": "rnn",
            "location": 180,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RecurrentEncoder.temporal_states": {
            "name": "temporal_states",
            "location": 220,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "RecurrentEncoder.temporal_mask": {
            "name": "temporal_mask",
            "location": 226,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "RecurrentEncoder.output": {
            "name": "output",
            "location": 230,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceEncoder.__init__": {
            "name": "__init__",
            "location": 238,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "embedding_size": [
                    "int"
                ],
                "rnn_size": [
                    "int"
                ],
                "rnn_cell": [
                    "str"
                ],
                "rnn_direction": [
                    "str"
                ],
                "add_residual": [
                    "bool"
                ],
                "add_layer_norm": [
                    "bool"
                ],
                "max_input_len": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ],
                "embedding_initializer": [
                    "Callable"
                ]
            }
        },
        "FactoredEncoder.__init__": {
            "name": "__init__",
            "location": 319,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "vocabularies": [
                    "List[Vocabulary]"
                ],
                "data_ids": [
                    "List[str]"
                ],
                "embedding_sizes": [
                    "List[int]"
                ],
                "rnn_size": [
                    "int"
                ],
                "rnn_cell": [
                    "str"
                ],
                "rnn_direction": [
                    "str"
                ],
                "add_residual": [
                    "bool"
                ],
                "add_layer_norm": [
                    "bool"
                ],
                "max_input_len": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ],
                "input_initializers": [
                    "InitializerSpecs"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/sentence_cnn_encoder.py": {
        "SentenceCNNEncoder.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_sequence": [
                    "Sequence"
                ],
                "segment_size": [
                    "int"
                ],
                "highway_depth": [
                    "int"
                ],
                "rnn_size": [
                    "int"
                ],
                "filters": [
                    "List[Tuple[(int, int)]]"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "use_noisy_activations": [
                    "bool"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SentenceCNNEncoder.cnn_encoded": {
            "name": "cnn_encoded",
            "location": 104,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceCNNEncoder.highway_layer": {
            "name": "highway_layer",
            "location": 146,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceCNNEncoder.bidirectional_rnn": {
            "name": "bidirectional_rnn",
            "location": 161,
            "return": [
                "Tuple[(Tuple[(tf.Tensor, tf.Tensor)], Tuple[(tf.Tensor, tf.Tensor)])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceCNNEncoder.temporal_states": {
            "name": "temporal_states",
            "location": 175,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceCNNEncoder.output": {
            "name": "output",
            "location": 181,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceCNNEncoder.temporal_mask": {
            "name": "temporal_mask",
            "location": 187,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceCNNEncoder.rnn_cells": {
            "name": "rnn_cells",
            "location": 198,
            "return": [
                "RNNCellTuple"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/sequence_cnn_encoder.py": {
        "SequenceCNNEncoder.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "embedding_size": [
                    "int"
                ],
                "filters": [
                    "List[Tuple[(int, int)]]"
                ],
                "max_input_len": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "SequenceCNNEncoder.input_types": {
            "name": "input_types",
            "location": 64,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.input_shapes": {
            "name": "input_shapes",
            "location": 68,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.inputs": {
            "name": "inputs",
            "location": 72,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.input_tokens": {
            "name": "input_tokens",
            "location": 76,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.input_mask": {
            "name": "input_mask",
            "location": 80,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.embedded_inputs": {
            "name": "embedded_inputs",
            "location": 84,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.output": {
            "name": "output",
            "location": 97,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceCNNEncoder.feed_dict": {
            "name": "feed_dict",
            "location": 127,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/transformer.py": {
        "position_signal": {
            "name": "position_signal",
            "location": 23,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "dimension": [
                    "int"
                ],
                "length": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerLayer.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "states": [
                    "tf.Tensor"
                ],
                "mask": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerLayer.temporal_states": {
            "name": "temporal_states",
            "location": 54,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerLayer.temporal_mask": {
            "name": "temporal_mask",
            "location": 58,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "input_sequence": [
                    "TemporalStateful"
                ],
                "ff_hidden_size": [
                    "int"
                ],
                "depth": [
                    "int"
                ],
                "n_heads": [
                    "int"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "attention_dropout_keep_prob": [
                    "float"
                ],
                "target_space_id": [
                    "int"
                ],
                "use_att_transform_bias": [
                    "bool"
                ],
                "use_positional_encoding": [
                    "bool"
                ],
                "input_for_cross_attention": [
                    "Attendable"
                ],
                "n_cross_att_heads": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "TransformerEncoder.model_dimension": {
            "name": "model_dimension",
            "location": 157,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.output": {
            "name": "output",
            "location": 171,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.modality_matrix": {
            "name": "modality_matrix",
            "location": 175,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.target_modality_embedding": {
            "name": "target_modality_embedding",
            "location": 190,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.encoder_inputs": {
            "name": "encoder_inputs",
            "location": 199,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.self_attention_sublayer": {
            "name": "self_attention_sublayer",
            "location": 212,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "prev_layer": [
                    "TransformerLayer"
                ]
            }
        },
        "TransformerEncoder.cross_attention_sublayer": {
            "name": "cross_attention_sublayer",
            "location": 237,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "queries": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerEncoder.feedforward_sublayer": {
            "name": "feedforward_sublayer",
            "location": 266,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": [],
                "layer_input": [
                    "tf.Tensor"
                ]
            }
        },
        "TransformerEncoder.layer": {
            "name": "layer",
            "location": 290,
            "return": [
                "TransformerLayer"
            ],
            "arguments": {
                "self": [],
                "level": [
                    "int"
                ]
            }
        },
        "TransformerEncoder.temporal_states": {
            "name": "temporal_states",
            "location": 317,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.temporal_mask": {
            "name": "temporal_mask",
            "location": 321,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformerEncoder.dependencies": {
            "name": "dependencies",
            "location": 325,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/encoders/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/evaluators/accuracy.py": {},
    "neuralmonkey-master/neuralmonkey/evaluators/average.py": {
        "AverageEvaluator.score_instance": {
            "name": "score_instance",
            "location": 9,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "float"
                ],
                "reference": [
                    "float"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/beer.py": {
        "BeerWrapper.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "wrapper": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "encoding": [
                    "str"
                ]
            }
        },
        "BeerWrapper.serialize_to_bytes": {
            "name": "serialize_to_bytes",
            "location": 34,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "BeerWrapper.score_batch": {
            "name": "score_batch",
            "location": 39,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/bleu.py": {
        "BLEUEvaluator.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int"
                ],
                "deduplicate": [
                    "bool"
                ],
                "name": [
                    "str"
                ],
                "multiple_references_separator": [
                    "str"
                ]
            }
        },
        "BLEUEvaluator.score_batch": {
            "name": "score_batch",
            "location": 37,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        },
        "BLEUEvaluator.ngram_counts": {
            "name": "ngram_counts",
            "location": 63,
            "return": [
                "Counter"
            ],
            "arguments": {
                "sentence": [
                    "List[str]"
                ],
                "n": [
                    "int"
                ],
                "lowercase": [
                    "bool"
                ],
                "delimiter": [
                    "str"
                ]
            }
        },
        "BLEUEvaluator.merge_max_counters": {
            "name": "merge_max_counters",
            "location": 87,
            "return": [
                "Counter"
            ],
            "arguments": {
                "counters": [
                    "List[Counter]"
                ]
            }
        },
        "BLEUEvaluator.modified_ngram_precision": {
            "name": "modified_ngram_precision",
            "location": 98,
            "return": [
                "Tuple[(float, int)]"
            ],
            "arguments": {
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references_list": [
                    "List[List[List[str]]]"
                ],
                "n": [
                    "int"
                ],
                "case_sensitive": [
                    "bool"
                ]
            }
        },
        "BLEUEvaluator.effective_reference_length": {
            "name": "effective_reference_length",
            "location": 136,
            "return": [
                "int"
            ],
            "arguments": {
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references_list": [
                    "List[List[List[str]]]"
                ]
            }
        },
        "BLEUEvaluator.minimum_reference_length": {
            "name": "minimum_reference_length",
            "location": 170,
            "return": [
                "int"
            ],
            "arguments": {
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references_list": [
                    "List[List[str]]"
                ]
            }
        },
        "BLEUEvaluator.bleu": {
            "name": "bleu",
            "location": 196,
            "return": [],
            "arguments": {
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[List[str]]]"
                ],
                "ngrams": [
                    "int"
                ],
                "case_sensitive": [
                    "bool"
                ]
            }
        },
        "BLEUEvaluator.deduplicate_sentences": {
            "name": "deduplicate_sentences",
            "location": 239,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "sentences": [
                    "List[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/bleu_ref.py": {
        "BLEUReferenceImplWrapper.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [],
            "arguments": {
                "self": [],
                "wrapper": [],
                "name": [],
                "encoding": []
            }
        },
        "BLEUReferenceImplWrapper.serialize_to_bytes": {
            "name": "serialize_to_bytes",
            "location": 20,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "BLEUReferenceImplWrapper.score_batch": {
            "name": "score_batch",
            "location": 25,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/chrf.py": {
        "_get_ngrams": {
            "name": "_get_ngrams",
            "location": 89,
            "return": [
                "NGramDicts"
            ],
            "arguments": {
                "tokens": [
                    "List[str]"
                ],
                "n": [
                    "int"
                ]
            }
        },
        "ChrFEvaluator.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int"
                ],
                "beta": [
                    "float"
                ],
                "ignored_symbols": [
                    "List[str]"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "ChrFEvaluator.score_instance": {
            "name": "score_instance",
            "location": 35,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "List[str]"
                ],
                "reference": [
                    "List[str]"
                ]
            }
        },
        "ChrFEvaluator.chr_r": {
            "name": "chr_r",
            "location": 60,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hyp_ngrams": [
                    "NGramDicts"
                ],
                "ref_ngrams": [
                    "NGramDicts"
                ]
            }
        },
        "ChrFEvaluator.chr_p": {
            "name": "chr_p",
            "location": 74,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hyp_ngrams": [
                    "NGramDicts"
                ],
                "ref_ngrams": [
                    "NGramDicts"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/edit_distance.py": {
        "EditDistanceEvaluator.score_instance": {
            "name": "score_instance",
            "location": 10,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "List[str]"
                ],
                "reference": [
                    "List[str]"
                ]
            }
        },
        "EditDistanceEvaluator.score_batch": {
            "name": "score_batch",
            "location": 20,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        },
        "EditDistanceEvaluator.compare_scores": {
            "name": "compare_scores",
            "location": 27,
            "return": [
                "int"
            ],
            "arguments": {
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/evaluator.py": {
        "check_lengths": {
            "name": "check_lengths",
            "location": 12,
            "return": [],
            "arguments": {
                "scorer": []
            }
        },
        "check_lengths.decorate": {
            "name": "decorate",
            "location": 14,
            "return": [],
            "arguments": {
                "self": [],
                "hypotheses": [],
                "references": []
            }
        },
        "Evaluator.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Evaluator.name": {
            "name": "name",
            "location": 44,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Evaluator.score_instance": {
            "name": "score_instance",
            "location": 49,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "EvalType"
                ],
                "reference": [
                    "EvalType"
                ]
            }
        },
        "Evaluator.score_batch": {
            "name": "score_batch",
            "location": 70,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[EvalType]"
                ],
                "references": [
                    "List[EvalType]"
                ]
            }
        },
        "Evaluator.__call__": {
            "name": "__call__",
            "location": 88,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[EvalType]"
                ],
                "references": [
                    "List[EvalType]"
                ]
            }
        },
        "Evaluator.compare_scores": {
            "name": "compare_scores",
            "location": 106,
            "return": [
                "int"
            ],
            "arguments": {
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        },
        "SequenceEvaluator.__init__": {
            "name": "__init__",
            "location": 125,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "mask_symbol": [
                    "EvalType"
                ]
            }
        },
        "SequenceEvaluator.score_token": {
            "name": "score_token",
            "location": 139,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hyp_token": [
                    "EvalType"
                ],
                "ref_token": [
                    "EvalType"
                ]
            }
        },
        "SequenceEvaluator.score_batch": {
            "name": "score_batch",
            "location": 158,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[Sequence[EvalType]]"
                ],
                "references": [
                    "List[Sequence[EvalType]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/f1_bio.py": {
        "F1Evaluator.score_instance": {
            "name": "score_instance",
            "location": 12,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "List[str]"
                ],
                "reference": [
                    "List[str]"
                ]
            }
        },
        "F1Evaluator.chunk2set": {
            "name": "chunk2set",
            "location": 26,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "seq": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/gleu.py": {
        "GLEUEvaluator.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int"
                ],
                "deduplicate": [
                    "bool"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "GLEUEvaluator.score_batch": {
            "name": "score_batch",
            "location": 36,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        },
        "GLEUEvaluator.total_precision_recall": {
            "name": "total_precision_recall",
            "location": 47,
            "return": [
                "Tuple[(float, float)]"
            ],
            "arguments": {
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references_list": [
                    "List[List[List[str]]]"
                ],
                "ngrams": [
                    "int"
                ],
                "case_sensitive": [
                    "bool"
                ]
            }
        },
        "GLEUEvaluator.gleu": {
            "name": "gleu",
            "location": 94,
            "return": [
                "float"
            ],
            "arguments": {
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[List[str]]]"
                ],
                "ngrams": [
                    "int"
                ],
                "case_sensitive": [
                    "bool"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/mse.py": {
        "MeanSquaredErrorEvaluator.score_token": {
            "name": "score_token",
            "location": 15,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hyp_elem": [
                    "float"
                ],
                "ref_elem": [
                    "float"
                ]
            }
        },
        "MeanSquaredErrorEvaluator.compare_scores": {
            "name": "compare_scores",
            "location": 20,
            "return": [
                "int"
            ],
            "arguments": {
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        },
        "PairwiseMeanSquaredErrorEvaluator.score_instance": {
            "name": "score_instance",
            "location": 31,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "List[float]"
                ],
                "reference": [
                    "List[float]"
                ]
            }
        },
        "PairwiseMeanSquaredErrorEvaluator.compare_scores": {
            "name": "compare_scores",
            "location": 40,
            "return": [
                "int"
            ],
            "arguments": {
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/multeval.py": {
        "MultEvalWrapper.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "wrapper": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "encoding": [
                    "str"
                ],
                "metric": [
                    "str"
                ],
                "language": [
                    "str"
                ]
            }
        },
        "MultEvalWrapper.score_batch": {
            "name": "score_batch",
            "location": 42,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        },
        "MultEvalWrapper.serialize_to_bytes": {
            "name": "serialize_to_bytes",
            "location": 86,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/perplexity.py": {
        "PerplexityEvaluator.score_batch": {
            "name": "score_batch",
            "location": 14,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[float]]"
                ],
                "references": [
                    "List[List[float]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/rouge.py": {
        "RougeEvaluator.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rouge_type": [
                    "str"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "RougeEvaluator.score_batch": {
            "name": "score_batch",
            "location": 26,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/sacrebleu.py": {
        "SacreBLEUEvaluator.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "smooth_method": [
                    "str"
                ],
                "smooth_value": [
                    "float"
                ],
                "force": [
                    "bool"
                ],
                "lowercase": [
                    "bool"
                ],
                "tokenize": [
                    "str"
                ],
                "use_effective_order": [
                    "bool"
                ]
            }
        },
        "SacreBLEUEvaluator.score_batch": {
            "name": "score_batch",
            "location": 44,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/ter.py": {
        "TEREvaluator.score_instance": {
            "name": "score_instance",
            "location": 11,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "List[str]"
                ],
                "reference": [
                    "List[str]"
                ]
            }
        },
        "TEREvaluator.compare_scores": {
            "name": "compare_scores",
            "location": 22,
            "return": [
                "int"
            ],
            "arguments": {
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/wer.py": {
        "WEREvaluator.score_instance": {
            "name": "score_instance",
            "location": 10,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypothesis": [
                    "List[str]"
                ],
                "reference": [
                    "List[str]"
                ]
            }
        },
        "WEREvaluator.score_batch": {
            "name": "score_batch",
            "location": 21,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "hypotheses": [
                    "List[List[str]]"
                ],
                "references": [
                    "List[List[str]]"
                ]
            }
        },
        "WEREvaluator.compare_scores": {
            "name": "compare_scores",
            "location": 32,
            "return": [
                "int"
            ],
            "arguments": {
                "score1": [
                    "float"
                ],
                "score2": [
                    "float"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/evaluators/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/logbook/logbook.py": {
        "root_dir": {
            "name": "root_dir",
            "location": 21,
            "return": [],
            "arguments": {}
        },
        "get_file": {
            "name": "get_file",
            "location": 25,
            "return": [],
            "arguments": {
                "filename": []
            }
        },
        "index": {
            "name": "index",
            "location": 31,
            "return": [],
            "arguments": {}
        },
        "list_experiments": {
            "name": "list_experiments",
            "location": 37,
            "return": [],
            "arguments": {}
        },
        "get_experiment": {
            "name": "get_experiment",
            "location": 57,
            "return": [],
            "arguments": {
                "path": []
            }
        },
        "get_ansiconv_css": {
            "name": "get_ansiconv_css",
            "location": 76,
            "return": [],
            "arguments": {}
        },
        "get_resource": {
            "name": "get_resource",
            "location": 82,
            "return": [],
            "arguments": {
                "path": []
            }
        },
        "main": {
            "name": "main",
            "location": 98,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/neuralmonkey/model/feedable.py": {
        "Feedable.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Feedable.feed_dict": {
            "name": "feed_dict",
            "location": 36,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "Feedable.input_types": {
            "name": "input_types",
            "location": 52,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Feedable.input_shapes": {
            "name": "input_shapes",
            "location": 56,
            "return": [
                "Dict[(str, List[int])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Feedable.dataset": {
            "name": "dataset",
            "location": 60,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Feedable.register_input": {
            "name": "register_input",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dict[(str, tf.Tensor)]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/gradient_blocking.py": {
        "StatefulView.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "blocked_object": [
                    "Stateful"
                ]
            }
        },
        "StatefulView.output": {
            "name": "output",
            "location": 19,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulView.dependencies": {
            "name": "dependencies",
            "location": 23,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStatefulView.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "blocked_object": [
                    "TemporalStateful"
                ]
            }
        },
        "TemporalStatefulView.temporal_states": {
            "name": "temporal_states",
            "location": 35,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStatefulView.temporal_mask": {
            "name": "temporal_mask",
            "location": 39,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStatefulView.dependencies": {
            "name": "dependencies",
            "location": 43,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStatefulView.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "blocked_object": [
                    "SpatialStateful"
                ]
            }
        },
        "SpatialStatefulView.spatial_states": {
            "name": "spatial_states",
            "location": 55,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStatefulView.spatial_mask": {
            "name": "spatial_mask",
            "location": 59,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStatefulView.dependencies": {
            "name": "dependencies",
            "location": 63,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/gradient_reversal.py": {
        "_reverse_gradient": {
            "name": "_reverse_gradient",
            "location": 15,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "x": [
                    "tf.Tensor"
                ]
            }
        },
        "_reverse_gradient._flip_gradients": {
            "name": "_flip_gradients",
            "location": 22,
            "return": [],
            "arguments": {
                "op": [],
                "grad": []
            }
        },
        "StatefulView.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "reversed_object": [
                    "Stateful"
                ]
            }
        },
        "StatefulView.output": {
            "name": "output",
            "location": 42,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatefulView.dependencies": {
            "name": "dependencies",
            "location": 46,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStatefulView.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "reversed_object": [
                    "TemporalStateful"
                ]
            }
        },
        "TemporalStatefulView.temporal_states": {
            "name": "temporal_states",
            "location": 58,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStatefulView.temporal_mask": {
            "name": "temporal_mask",
            "location": 62,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStatefulView.dependencies": {
            "name": "dependencies",
            "location": 66,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStatefulView.__init__": {
            "name": "__init__",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "reversed_object": [
                    "SpatialStateful"
                ]
            }
        },
        "SpatialStatefulView.spatial_states": {
            "name": "spatial_states",
            "location": 78,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStatefulView.spatial_mask": {
            "name": "spatial_mask",
            "location": 82,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStatefulView.dependencies": {
            "name": "dependencies",
            "location": 86,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/model_part.py": {
        "GenericModelPart.dependencies": {
            "name": "dependencies",
            "location": 30,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericModelPart.__get_deps": {
            "name": "__get_deps",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "attr": [
                    "str"
                ],
                "feedables": [
                    "MutableSet[Feedable]"
                ],
                "parameterizeds": [
                    "MutableSet[Parameterized]"
                ]
            }
        },
        "GenericModelPart.get_dependencies": {
            "name": "get_dependencies",
            "location": 57,
            "return": [
                "Tuple[(Set[Feedable], Set[Parameterized])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelPart.__init__": {
            "name": "__init__",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "reuse": [
                    "'ModelPart'"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/parameterized.py": {
        "Parameterized.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "reuse": [
                    "'Parameterized'"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "Parameterized.name": {
            "name": "name",
            "location": 75,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Parameterized.__str__": {
            "name": "__str__",
            "location": 79,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Parameterized.use_scope": {
            "name": "use_scope",
            "location": 84,
            "return": [
                "Iterator[None]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Parameterized._init_saver": {
            "name": "_init_saver",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Parameterized.save": {
            "name": "save",
            "location": 109,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "session": [
                    "tf.Session"
                ]
            }
        },
        "Parameterized.load": {
            "name": "load",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "session": [
                    "tf.Session"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/sequence.py": {
        "Sequence.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "max_length": [
                    "int"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "EmbeddedFactorSequence.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "vocabularies": [
                    "List[Vocabulary]"
                ],
                "data_ids": [
                    "List[str]"
                ],
                "embedding_sizes": [
                    "List[int]"
                ],
                "max_length": [
                    "int"
                ],
                "add_start_symbol": [
                    "bool"
                ],
                "add_end_symbol": [
                    "bool"
                ],
                "scale_embeddings_by_depth": [
                    "bool"
                ],
                "trainable": [
                    "bool"
                ],
                "embeddings_source": [
                    "'EmbeddedFactorSequence'"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "EmbeddedFactorSequence.input_types": {
            "name": "input_types",
            "location": 135,
            "return": [
                "Dict[(str, tf.DType)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.input_shapes": {
            "name": "input_shapes",
            "location": 139,
            "return": [
                "Dict[(str, tf.TensorShape)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.input_factor_indices": {
            "name": "input_factor_indices",
            "location": 143,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.input_factors": {
            "name": "input_factors",
            "location": 148,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.embedding_matrices": {
            "name": "embedding_matrices",
            "location": 152,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.temporal_states": {
            "name": "temporal_states",
            "location": 171,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.temporal_mask": {
            "name": "temporal_mask",
            "location": 198,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedFactorSequence.feed_dict": {
            "name": "feed_dict",
            "location": 202,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "EmbeddedSequence.__init__": {
            "name": "__init__",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "vocabulary": [
                    "Vocabulary"
                ],
                "data_id": [
                    "str"
                ],
                "embedding_size": [
                    "int"
                ],
                "max_length": [
                    "int"
                ],
                "add_start_symbol": [
                    "bool"
                ],
                "add_end_symbol": [
                    "bool"
                ],
                "scale_embeddings_by_depth": [
                    "bool"
                ],
                "trainable": [
                    "bool"
                ],
                "embeddings_source": [
                    "'EmbeddedSequence'"
                ],
                "reuse": [
                    "ModelPart"
                ],
                "save_checkpoint": [
                    "str"
                ],
                "load_checkpoint": [
                    "str"
                ],
                "initializers": [
                    "InitializerSpecs"
                ]
            }
        },
        "EmbeddedSequence.inputs": {
            "name": "inputs",
            "location": 282,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedSequence.embedding_matrix": {
            "name": "embedding_matrix",
            "location": 287,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedSequence.vocabulary": {
            "name": "vocabulary",
            "location": 293,
            "return": [
                "Vocabulary"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbeddedSequence.data_id": {
            "name": "data_id",
            "location": 298,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/sequence_split.py": {
        "split_by_factor": {
            "name": "split_by_factor",
            "location": 76,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "tensor_3d": [
                    "tf.Tensor"
                ],
                "batch_size": [
                    "tf.Tensor"
                ],
                "factor": [
                    "int"
                ]
            }
        },
        "SequenceSplitter.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parent": [
                    "TemporalStateful"
                ],
                "factor": [
                    "int"
                ],
                "projection_size": [
                    "int"
                ],
                "projection_activation": [
                    "Activation"
                ]
            }
        },
        "SequenceSplitter.temporal_states": {
            "name": "temporal_states",
            "location": 52,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceSplitter.temporal_mask": {
            "name": "temporal_mask",
            "location": 61,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceSplitter.feed_dict": {
            "name": "feed_dict",
            "location": 68,
            "return": [
                "FeedDict"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dataset"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "SequenceSplitter.dependencies": {
            "name": "dependencies",
            "location": 72,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/stateful.py": {
        "Stateful.output": {
            "name": "output",
            "location": 24,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStateful.temporal_states": {
            "name": "temporal_states",
            "location": 36,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStateful.temporal_mask": {
            "name": "temporal_mask",
            "location": 46,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStateful.lengths": {
            "name": "lengths",
            "location": 56,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TemporalStateful.dimension": {
            "name": "dimension",
            "location": 65,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStateful.spatial_states": {
            "name": "spatial_states",
            "location": 72,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStateful.spatial_mask": {
            "name": "spatial_mask",
            "location": 82,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpatialStateful.dimension": {
            "name": "dimension",
            "location": 92,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/model/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/nn/highway.py": {
        "highway": {
            "name": "highway",
            "location": 6,
            "return": [],
            "arguments": {
                "inputs": [],
                "activation": [],
                "scope": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/mlp.py": {
        "MultilayerPerceptron.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mlp_input": [
                    "tf.Tensor"
                ],
                "layer_configuration": [
                    "List[int]"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "output_size": [
                    "int"
                ],
                "train_mode": [
                    "tf.Tensor"
                ],
                "activation_fn": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "MultilayerPerceptron.softmax": {
            "name": "softmax",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MultilayerPerceptron.classification": {
            "name": "classification",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/noisy_gru_cell.py": {
        "noisy_activation": {
            "name": "noisy_activation",
            "location": 48,
            "return": [],
            "arguments": {
                "x": [],
                "generic": [],
                "linearized": [],
                "training": [],
                "alpha": [
                    "float"
                ],
                "c": [
                    "float"
                ]
            }
        },
        "noisy_sigmoid": {
            "name": "noisy_sigmoid",
            "location": 95,
            "return": [],
            "arguments": {
                "x": [],
                "training": []
            }
        },
        "noisy_tanh": {
            "name": "noisy_tanh",
            "location": 104,
            "return": [],
            "arguments": {
                "x": [],
                "training": []
            }
        },
        "NoisyGRUCell.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_units": [
                    "int"
                ],
                "training": []
            }
        },
        "NoisyGRUCell.output_size": {
            "name": "output_size",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "NoisyGRUCell.state_size": {
            "name": "state_size",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "NoisyGRUCell.__call__": {
            "name": "__call__",
            "location": 29,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [],
                "state": [],
                "scope": []
            }
        },
        "noisy_sigmoid.lin_sigmoid": {
            "name": "lin_sigmoid",
            "location": 96,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "noisy_sigmoid.hard_sigmoid": {
            "name": "hard_sigmoid",
            "location": 99,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "noisy_tanh.hard_tanh": {
            "name": "hard_tanh",
            "location": 105,
            "return": [],
            "arguments": {
                "x": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/ortho_gru_cell.py": {
        "orthogonal_initializer": {
            "name": "orthogonal_initializer",
            "location": 4,
            "return": [],
            "arguments": {}
        },
        "orthogonal_initializer.func": {
            "name": "func",
            "location": 20,
            "return": [],
            "arguments": {
                "shape": [],
                "dtype": [],
                "partition_info": []
            }
        },
        "OrthoGRUCell.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [],
            "arguments": {
                "self": [],
                "num_units": [],
                "activation": [],
                "reuse": []
            }
        },
        "OrthoGRUCell.__call__": {
            "name": "__call__",
            "location": 52,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [],
                "state": [],
                "scope": []
            }
        },
        "NematusGRUCell.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [],
            "arguments": {
                "self": [],
                "rnn_size": [],
                "use_state_bias": [],
                "use_input_bias": []
            }
        },
        "NematusGRUCell.call": {
            "name": "call",
            "location": 73,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [],
                "state": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/pervasive_dropout_wrapper.py": {
        "PervasiveDropoutWrapper.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cell": [],
                "mask": [],
                "scale": []
            }
        },
        "PervasiveDropoutWrapper.state_size": {
            "name": "state_size",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PervasiveDropoutWrapper.output_size": {
            "name": "output_size",
            "location": 19,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PervasiveDropoutWrapper.__call__": {
            "name": "__call__",
            "location": 22,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [],
                "state": [],
                "scope": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/projection.py": {
        "maxout": {
            "name": "maxout",
            "location": 7,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "inputs": [
                    "tf.Tensor"
                ],
                "size": [
                    "int"
                ],
                "scope": [
                    "str"
                ]
            }
        },
        "multilayer_projection": {
            "name": "multilayer_projection",
            "location": 38,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "input_": [
                    "tf.Tensor"
                ],
                "layer_sizes": [
                    "List[int]"
                ],
                "train_mode": [
                    "tf.Tensor"
                ],
                "activation": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ],
                "dropout_keep_prob": [
                    "float"
                ],
                "scope": [
                    "str"
                ]
            }
        },
        "glu": {
            "name": "glu",
            "location": 60,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "input_": [
                    "tf.Tensor"
                ],
                "gating_fn": [
                    "Callable[([tf.Tensor], tf.Tensor)]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/utils.py": {
        "dropout": {
            "name": "dropout",
            "location": 6,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "variable": [
                    "tf.Tensor"
                ],
                "keep_prob": [
                    "float"
                ],
                "train_mode": [
                    "tf.Tensor"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/nn/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/processors/alignment.py": {
        "WordAlignmentPreprocessor.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [],
            "arguments": {
                "self": [],
                "source_len": [],
                "target_len": [],
                "dtype": [],
                "normalize": [],
                "zero_based": []
            }
        },
        "WordAlignmentPreprocessor.__call__": {
            "name": "__call__",
            "location": 37,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/bpe.py": {
        "BPEPreprocessor.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "merge_file": [
                    "str"
                ],
                "separator": [
                    "str"
                ],
                "encoding": [
                    "str"
                ]
            }
        },
        "BPEPreprocessor.__call__": {
            "name": "__call__",
            "location": 26,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "List[str]"
                ]
            }
        },
        "BPEPostprocessor.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "separator": [
                    "str"
                ]
            }
        },
        "BPEPostprocessor.__call__": {
            "name": "__call__",
            "location": 52,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "self": [],
                "decoded_sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "BPEPostprocessor.decode": {
            "name": "decode",
            "location": 55,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/editops.py": {
        "convert_to_edits": {
            "name": "convert_to_edits",
            "location": 61,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "source": [
                    "List[str]"
                ],
                "target": [
                    "List[str]"
                ]
            }
        },
        "reconstruct": {
            "name": "reconstruct",
            "location": 99,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "source": [
                    "List[str]"
                ],
                "edits": [
                    "List[str]"
                ]
            }
        },
        "Preprocess.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "source_id": [
                    "str"
                ],
                "target_id": [
                    "str"
                ]
            }
        },
        "Preprocess.__call__": {
            "name": "__call__",
            "location": 14,
            "return": [
                "Iterator[List[str]]"
            ],
            "arguments": {
                "self": [],
                "iterators": [
                    "Dict[(str, Callable[([], Iterator[List[str]])])]"
                ]
            }
        },
        "Postprocess.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "source_id": [
                    "str"
                ],
                "edits_id": [
                    "str"
                ]
            }
        },
        "Postprocess.__call__": {
            "name": "__call__",
            "location": 36,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Dict[(str, Iterable[Any])]"
                ],
                "generated": [
                    "Dict[(str, Iterable[Any])]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/german.py": {
        "GermanPreprocessor.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [],
            "arguments": {
                "self": [],
                "compounding": [],
                "contracting": [],
                "pronouns": []
            }
        },
        "GermanPreprocessor.__call__": {
            "name": "__call__",
            "location": 36,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        },
        "GermanPostprocessor.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [],
            "arguments": {
                "self": [],
                "compounding": [],
                "contracting": [],
                "pronouns": []
            }
        },
        "GermanPostprocessor.__call__": {
            "name": "__call__",
            "location": 71,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "self": [],
                "decoded_sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "GermanPostprocessor.decode": {
            "name": "decode",
            "location": 74,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/helpers.py": {
        "preprocess_char_based": {
            "name": "preprocess_char_based",
            "location": 5,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "sentence": [
                    "List[str]"
                ]
            }
        },
        "preprocess_add_noise": {
            "name": "preprocess_add_noise",
            "location": 9,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "sentence": [
                    "List[str]"
                ]
            }
        },
        "postprocess_char_based": {
            "name": "postprocess_char_based",
            "location": 21,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "untruecase": {
            "name": "untruecase",
            "location": 32,
            "return": [
                "Generator[(List[str], None, None)]"
            ],
            "arguments": {
                "sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "pipeline": {
            "name": "pipeline",
            "location": 41,
            "return": [
                "Callable"
            ],
            "arguments": {
                "processors": [
                    "List[Callable]"
                ]
            }
        },
        "pipeline.process": {
            "name": "process",
            "location": 44,
            "return": [
                "Any"
            ],
            "arguments": {
                "data": [
                    "Any"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/speech.py": {
        "SpeechFeaturesPreprocessor": {
            "name": "SpeechFeaturesPreprocessor",
            "location": 10,
            "return": [
                "Callable"
            ],
            "arguments": {
                "feature_type": [
                    "str"
                ],
                "delta_order": [
                    "int"
                ],
                "delta_window": [
                    "int"
                ]
            }
        },
        "_fbank": {
            "name": "_fbank",
            "location": 52,
            "return": [
                "np.ndarray"
            ],
            "arguments": {}
        },
        "SpeechFeaturesPreprocessor.preprocess": {
            "name": "preprocess",
            "location": 40,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "audio": [
                    "Audio"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/wordpiece.py": {
        "escape_token": {
            "name": "escape_token",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "token": [
                    "str"
                ],
                "alphabet": [
                    "Set[str]"
                ]
            }
        },
        "unescape_token": {
            "name": "unescape_token",
            "location": 40,
            "return": [
                "str"
            ],
            "arguments": {
                "escaped_token": [
                    "str"
                ]
            }
        },
        "wordpiece_encode": {
            "name": "wordpiece_encode",
            "location": 60,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "sentence": [
                    "List[str]"
                ],
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "wordpiece_decode": {
            "name": "wordpiece_decode",
            "location": 99,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "sentence": [
                    "List[str]"
                ]
            }
        },
        "wordpiece_decode_batch": {
            "name": "wordpiece_decode_batch",
            "location": 110,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "sentences": [
                    "List[List[str]]"
                ]
            }
        },
        "get_wordpiece_preprocessor": {
            "name": "get_wordpiece_preprocessor",
            "location": 114,
            "return": [
                "Callable[([List[str]], List[str])]"
            ],
            "arguments": {
                "vocabulary": [
                    "Vocabulary"
                ]
            }
        },
        "unescape_token.match": {
            "name": "match",
            "location": 47,
            "return": [],
            "arguments": {
                "m": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/processors/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/readers/audio_reader.py": {
        "audio_reader": {
            "name": "audio_reader",
            "location": 21,
            "return": [
                "Callable"
            ],
            "arguments": {
                "prefix": [
                    "str"
                ],
                "audio_format": [
                    "str"
                ]
            }
        },
        "_load_wav": {
            "name": "_load_wav",
            "location": 51,
            "return": [
                "Audio"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "_load_sph": {
            "name": "_load_sph",
            "location": 56,
            "return": [
                "Audio"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "audio_reader.load": {
            "name": "load",
            "location": 41,
            "return": [
                "Iterable[Audio]"
            ],
            "arguments": {
                "list_files": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/readers/image_reader.py": {
        "image_reader": {
            "name": "image_reader",
            "location": 14,
            "return": [
                "Callable"
            ],
            "arguments": {
                "pad_w": [
                    "int"
                ],
                "pad_h": [
                    "int"
                ],
                "channels": [
                    "int"
                ],
                "prefix": [
                    "str"
                ],
                "rescale_w": [
                    "bool"
                ],
                "rescale_h": [
                    "bool"
                ],
                "keep_aspect_ratio": [
                    "bool"
                ],
                "mode": [
                    "str"
                ]
            }
        },
        "imagenet_reader": {
            "name": "imagenet_reader",
            "location": 102,
            "return": [
                "Callable"
            ],
            "arguments": {
                "prefix": [
                    "str"
                ],
                "target_width": [
                    "int"
                ],
                "target_height": [
                    "int"
                ],
                "vgg_normalization": [
                    "bool"
                ],
                "zero_one_normalization": [
                    "bool"
                ]
            }
        },
        "single_image_for_imagenet": {
            "name": "single_image_for_imagenet",
            "location": 147,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "target_height": [
                    "int"
                ],
                "target_width": [
                    "int"
                ],
                "vgg_normalization": [
                    "bool"
                ],
                "zero_one_normalization": [
                    "bool"
                ]
            }
        },
        "_rescale_or_crop": {
            "name": "_rescale_or_crop",
            "location": 180,
            "return": [
                "Image.Image"
            ],
            "arguments": {
                "image": [
                    "Image.Image"
                ],
                "pad_w": [
                    "int"
                ],
                "pad_h": [
                    "int"
                ],
                "rescale_w": [
                    "bool"
                ],
                "rescale_h": [
                    "bool"
                ],
                "keep_aspect_ratio": [
                    "bool"
                ]
            }
        },
        "_crop": {
            "name": "_crop",
            "location": 206,
            "return": [
                "Image.Image"
            ],
            "arguments": {
                "image": [
                    "Image.Image"
                ],
                "pad_w": [
                    "int"
                ],
                "pad_h": [
                    "int"
                ]
            }
        },
        "_pad": {
            "name": "_pad",
            "location": 219,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "image": [
                    "np.ndarray"
                ],
                "pad_w": [
                    "int"
                ],
                "pad_h": [
                    "int"
                ],
                "channels": [
                    "int"
                ]
            }
        },
        "image_reader.load": {
            "name": "load",
            "location": 53,
            "return": [
                "Iterable[np.ndarray]"
            ],
            "arguments": {
                "list_files": [
                    "List[str]"
                ]
            }
        },
        "imagenet_reader.load": {
            "name": "load",
            "location": 128,
            "return": [
                "Iterable[np.ndarray]"
            ],
            "arguments": {
                "list_files": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/readers/numpy_reader.py": {
        "single_tensor": {
            "name": "single_tensor",
            "location": 8,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        },
        "from_file_list": {
            "name": "from_file_list",
            "location": 17,
            "return": [
                "Callable"
            ],
            "arguments": {
                "prefix": [
                    "str"
                ],
                "shape": [
                    "List[int]"
                ],
                "suffix": [
                    "str"
                ],
                "default_tensor_name": [
                    "str"
                ]
            }
        },
        "from_file_list.load": {
            "name": "load",
            "location": 34,
            "return": [
                "Iterable[np.ndarray]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/readers/plain_text_reader.py": {
        "string_reader": {
            "name": "string_reader",
            "location": 23,
            "return": [
                "Callable[([List[str]], Iterable[str])]"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "tokenized_text_reader": {
            "name": "tokenized_text_reader",
            "location": 39,
            "return": [
                "PlainTextFileReader"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "t2t_tokenized_text_reader": {
            "name": "t2t_tokenized_text_reader",
            "location": 49,
            "return": [
                "PlainTextFileReader"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "column_separated_reader": {
            "name": "column_separated_reader",
            "location": 91,
            "return": [
                "PlainTextFileReader"
            ],
            "arguments": {
                "column": [
                    "int"
                ],
                "delimiter": [
                    "str"
                ],
                "quotechar": [
                    "str"
                ],
                "encoding": [
                    "str"
                ]
            }
        },
        "csv_reader": {
            "name": "csv_reader",
            "location": 128,
            "return": [],
            "arguments": {
                "column": [
                    "int"
                ]
            }
        },
        "tsv_reader": {
            "name": "tsv_reader",
            "location": 132,
            "return": [],
            "arguments": {
                "column": [
                    "int"
                ]
            }
        },
        "string_reader.reader": {
            "name": "reader",
            "location": 25,
            "return": [
                "Iterable[str]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        },
        "tokenized_text_reader.reader": {
            "name": "reader",
            "location": 41,
            "return": [
                "Iterable[List[str]]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        },
        "t2t_tokenized_text_reader.reader": {
            "name": "reader",
            "location": 60,
            "return": [
                "Iterable[List[str]]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        },
        "column_separated_reader.reader": {
            "name": "reader",
            "location": 99,
            "return": [
                "Iterable[List[str]]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/readers/string_vector_reader.py": {
        "get_string_vector_reader": {
            "name": "get_string_vector_reader",
            "location": 6,
            "return": [],
            "arguments": {
                "dtype": [
                    "Type"
                ],
                "columns": [
                    "int"
                ]
            }
        },
        "get_string_vector_reader.process_line": {
            "name": "process_line",
            "location": 8,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "line": [
                    "str"
                ],
                "lineno": [
                    "int"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "get_string_vector_reader.reader": {
            "name": "reader",
            "location": 16,
            "return": [
                "Iterable[List[np.ndarray]]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/readers/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/runners/base_runner.py": {
        "GraphExecutor.__init__": {
            "name": "__init__",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dependencies": [
                    "Set[GenericModelPart]"
                ]
            }
        },
        "GraphExecutor.get_executable": {
            "name": "get_executable",
            "location": 119,
            "return": [
                "'GraphExecutor.Executable'"
            ],
            "arguments": {
                "self": [],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ],
                "num_sessions": [
                    "int"
                ]
            }
        },
        "GraphExecutor.fetches": {
            "name": "fetches",
            "location": 128,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.dependencies": {
            "name": "dependencies",
            "location": 132,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.feedables": {
            "name": "feedables",
            "location": 136,
            "return": [
                "Set[Feedable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.parameterizeds": {
            "name": "parameterizeds",
            "location": 140,
            "return": [
                "Set[Parameterized]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseRunner.__init__": {
            "name": "__init__",
            "location": 181,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "MP"
                ]
            }
        },
        "BaseRunner.decoder_data_id": {
            "name": "decoder_data_id",
            "location": 190,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseRunner.loss_names": {
            "name": "loss_names",
            "location": 194,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.Executable.__init__": {
            "name": "__init__",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "executor": [
                    "Executor"
                ],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ],
                "num_sessions": [
                    "int"
                ]
            }
        },
        "GraphExecutor.Executable.set_result": {
            "name": "set_result",
            "location": 91,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "outputs": [
                    "Dict[(str, OutputSeries)]"
                ],
                "losses": [
                    "Dict[(str, float)]"
                ],
                "size": [
                    "int"
                ],
                "summaries": [
                    "List[tf.Summary]"
                ]
            }
        },
        "GraphExecutor.Executable.result": {
            "name": "result",
            "location": 99,
            "return": [
                "Optional[ExecutionResult]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.Executable.executor": {
            "name": "executor",
            "location": 103,
            "return": [
                "Executor"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.Executable.next_to_execute": {
            "name": "next_to_execute",
            "location": 106,
            "return": [
                "NextExecute"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphExecutor.Executable.collect_results": {
            "name": "collect_results",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        },
        "BaseRunner.Executable.next_to_execute": {
            "name": "next_to_execute",
            "location": 156,
            "return": [
                "NextExecute"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseRunner.Executable.set_runner_result": {
            "name": "set_runner_result",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "outputs": [
                    "OutputSeries"
                ],
                "losses": [
                    "List[float]"
                ],
                "size": [
                    "int"
                ],
                "summaries": [
                    "List[tf.Summary]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/beamsearch_runner.py": {
        "beam_search_runner_range": {
            "name": "beam_search_runner_range",
            "location": 156,
            "return": [
                "List[BeamSearchRunner]"
            ],
            "arguments": {
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "BeamSearchDecoder"
                ],
                "max_rank": [
                    "int"
                ],
                "postprocess": [
                    "Callable[([List[str]], List[str])]"
                ]
            }
        },
        "BeamSearchRunner.__init__": {
            "name": "__init__",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "BeamSearchDecoder"
                ],
                "rank": [
                    "int"
                ],
                "postprocess": [
                    "Callable[([List[str]], List[str])]"
                ]
            }
        },
        "BeamSearchRunner.fetches": {
            "name": "fetches",
            "location": 146,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchRunner.loss_names": {
            "name": "loss_names",
            "location": 150,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchRunner.Executable.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "executor": [
                    "'BeamSearchRunner'"
                ],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ],
                "num_sessions": [
                    "int"
                ]
            }
        },
        "BeamSearchRunner.Executable.next_to_execute": {
            "name": "next_to_execute",
            "location": 44,
            "return": [
                "NextExecute"
            ],
            "arguments": {
                "self": []
            }
        },
        "BeamSearchRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        },
        "BeamSearchRunner.Executable.prepare_results": {
            "name": "prepare_results",
            "location": 84,
            "return": [],
            "arguments": {
                "self": [],
                "output": []
            }
        },
        "BeamSearchRunner.Executable._is_finished": {
            "name": "_is_finished",
            "location": 108,
            "return": [],
            "arguments": {
                "self": [],
                "results": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/ctc_debug_runner.py": {
        "CTCDebugRunner.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "CTCDecoder"
                ]
            }
        },
        "CTCDebugRunner.fetches": {
            "name": "fetches",
            "location": 49,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDebugRunner.loss_names": {
            "name": "loss_names",
            "location": 53,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CTCDebugRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/dataset_runner.py": {
        "DatasetRunner.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetRunner.fetches": {
            "name": "fetches",
            "location": 25,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/label_runner.py": {
        "LabelRunner.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "SequenceLabeler"
                ],
                "postprocess": [
                    "Postprocessor"
                ]
            }
        },
        "LabelRunner.fetches": {
            "name": "fetches",
            "location": 60,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelRunner.loss_names": {
            "name": "loss_names",
            "location": 67,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/logits_runner.py": {
        "LogitsRunner.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "Classifier"
                ],
                "normalize": [
                    "bool"
                ],
                "pick_index": [
                    "int"
                ],
                "pick_value": [
                    "str"
                ]
            }
        },
        "LogitsRunner.fetches": {
            "name": "fetches",
            "location": 98,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogitsRunner.loss_names": {
            "name": "loss_names",
            "location": 104,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogitsRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/plain_runner.py": {
        "PlainRunner.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "SupportedDecoder"
                ],
                "postprocess": [
                    "Postprocessor"
                ]
            }
        },
        "PlainRunner.fetches": {
            "name": "fetches",
            "location": 56,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PlainRunner.loss_names": {
            "name": "loss_names",
            "location": 62,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PlainRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/regression_runner.py": {
        "RegressionRunner.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "SequenceRegressor"
                ],
                "postprocess": [
                    "Postprocessor"
                ]
            }
        },
        "RegressionRunner.fetches": {
            "name": "fetches",
            "location": 50,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RegressionRunner.loss_names": {
            "name": "loss_names",
            "location": 55,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RegressionRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/runner.py": {
        "GreedyRunner.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "SupportedDecoder"
                ],
                "postprocess": [
                    "Postprocessor"
                ]
            }
        },
        "GreedyRunner.fetches": {
            "name": "fetches",
            "location": 76,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GreedyRunner.loss_names": {
            "name": "loss_names",
            "location": 89,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GreedyRunner.Executable.next_to_execute": {
            "name": "next_to_execute",
            "location": 22,
            "return": [
                "NextExecute"
            ],
            "arguments": {
                "self": []
            }
        },
        "GreedyRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/tensor_runner.py": {
        "TensorRunner.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "modelparts": [
                    "List[GenericModelPart]"
                ],
                "tensors": [
                    "List[str]"
                ],
                "batch_dims": [
                    "List[int]"
                ],
                "tensors_by_name": [
                    "List[str]"
                ],
                "batch_dims_by_name": [
                    "List[int]"
                ],
                "select_session": [
                    "int"
                ],
                "single_tensor": [
                    "bool"
                ]
            }
        },
        "TensorRunner.fetches": {
            "name": "fetches",
            "location": 136,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorRunner.loss_names": {
            "name": "loss_names",
            "location": 162,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepresentationRunner.__init__": {
            "name": "__init__",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "encoder": [
                    "GenericModelPart"
                ],
                "attribute": [
                    "str"
                ],
                "select_session": [
                    "int"
                ]
            }
        },
        "TensorRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        },
        "TensorRunner.Executable._fetch_values_from_session": {
            "name": "_fetch_values_from_session",
            "location": 43,
            "return": [
                "List"
            ],
            "arguments": {
                "self": [],
                "sess_results": [
                    "Dict"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/word_alignment_runner.py": {
        "WordAlignmentRunner.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "attention": [
                    "BaseAttention"
                ],
                "decoder": [
                    "Decoder"
                ]
            }
        },
        "WordAlignmentRunner.fetches": {
            "name": "fetches",
            "location": 32,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentRunner.loss_names": {
            "name": "loss_names",
            "location": 43,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "WordAlignmentRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/xent_runner.py": {
        "XentRunner.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_series": [
                    "str"
                ],
                "decoder": [
                    "SupportedDecoders"
                ]
            }
        },
        "XentRunner.fetches": {
            "name": "fetches",
            "location": 34,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "XentRunner.loss_names": {
            "name": "loss_names",
            "location": 38,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "XentRunner.Executable.collect_results": {
            "name": "collect_results",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/runners/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/server/server.py": {
        "root_dir": {
            "name": "root_dir",
            "location": 24,
            "return": [],
            "arguments": {}
        },
        "get_file": {
            "name": "get_file",
            "location": 28,
            "return": [],
            "arguments": {
                "filename": []
            }
        },
        "run": {
            "name": "run",
            "location": 33,
            "return": [],
            "arguments": {
                "data": []
            }
        },
        "index": {
            "name": "index",
            "location": 45,
            "return": [],
            "arguments": {}
        },
        "post_request": {
            "name": "post_request",
            "location": 60,
            "return": [],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_bleu.py": {
        "TestBLEU.test_empty_decoded": {
            "name": "test_empty_decoded",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_empty_reference": {
            "name": "test_empty_reference",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_identical": {
            "name": "test_identical",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_empty_sentence": {
            "name": "test_empty_sentence",
            "location": 44,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_bleu": {
            "name": "test_bleu",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_chrf.py": {
        "TestChrF.test_empty_decoded": {
            "name": "test_empty_decoded",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestChrF.test_empty_reference": {
            "name": "test_empty_reference",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestChrF.test_identical": {
            "name": "test_identical",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestChrF.test_empty_sentence": {
            "name": "test_empty_sentence",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestChrF.test_chrf": {
            "name": "test_chrf",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestChrF.test_get_ngrams": {
            "name": "test_get_ngrams",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_config.py": {
        "test_splitter_gen": {
            "name": "test_splitter_gen",
            "location": 42,
            "return": [],
            "arguments": {
                "a": [],
                "b": []
            }
        },
        "TestParsing.test_splitter_bad_brackets": {
            "name": "test_splitter_bad_brackets",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParsing.test_parse_value_int": {
            "name": "test_parse_value_int",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParsing.test_parse_value_float": {
            "name": "test_parse_value_float",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestParsing.test_parse_value_string": {
            "name": "test_parse_value_string",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "test_splitter_gen.test_case_fun": {
            "name": "test_case_fun",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_dataset.py": {
        "TestDataset.test_nonexistent_file": {
            "name": "test_nonexistent_file",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_lazy_dataset": {
            "name": "test_lazy_dataset",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_glob": {
            "name": "test_glob",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_batching_eager_noshuffle": {
            "name": "test_batching_eager_noshuffle",
            "location": 66,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_batching_lazy_noshuffle": {
            "name": "test_batching_lazy_noshuffle",
            "location": 90,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_batching_eager_shuffle": {
            "name": "test_batching_eager_shuffle",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_batching_lazy_shuffle": {
            "name": "test_batching_lazy_shuffle",
            "location": 141,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_bucketing": {
            "name": "test_bucketing",
            "location": 169,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_bucketing_no_leftovers": {
            "name": "test_bucketing_no_leftovers",
            "location": 204,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_buckets_similar_size": {
            "name": "test_buckets_similar_size",
            "location": 234,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_lazy_dataset.reader": {
            "name": "reader",
            "location": 27,
            "return": [
                "Iterable[List[str]]"
            ],
            "arguments": {
                "files": [
                    "List[str]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_decoder.py": {
        "TestDecoder.setUpClass": {
            "name": "setUpClass",
            "location": 15,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "TestDecoder.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecoder.tearDownClass": {
            "name": "tearDownClass",
            "location": 30,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "TestDecoder.test_init": {
            "name": "test_init",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecoder.test_max_output_len": {
            "name": "test_max_output_len",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecoder.test_dropout": {
            "name": "test_dropout",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecoder.test_embedding_size": {
            "name": "test_embedding_size",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDecoder.test_cell_type": {
            "name": "test_cell_type",
            "location": 64,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_encoders_init.py": {
        "traverse_combinations": {
            "name": "traverse_combinations",
            "location": 83,
            "return": [
                "Iterable[Dict[(str, Any)]]"
            ],
            "arguments": {
                "params": [
                    "Dict[(str, List[Any])]"
                ],
                "partial_params": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "TestEncodersInit._run_constructors": {
            "name": "_run_constructors",
            "location": 100,
            "return": [],
            "arguments": {
                "self": [],
                "encoder_type": [],
                "good_params": [],
                "bad_params": []
            }
        },
        "TestEncodersInit.test_sentence_encoder": {
            "name": "test_sentence_encoder",
            "location": 136,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestEncodersInit.test_sentence_cnn_encoder": {
            "name": "test_sentence_cnn_encoder",
            "location": 147,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_eval_wrappers.py": {
        "TestExternalEvaluators.test_multeval_bleu": {
            "name": "test_multeval_bleu",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestExternalEvaluators.test_multeval_ter": {
            "name": "test_multeval_ter",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestExternalEvaluators.test_multeval_meteor": {
            "name": "test_multeval_meteor",
            "location": 52,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestExternalEvaluators.test_beer": {
            "name": "test_beer",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestExternalEvaluators.test_gleu": {
            "name": "test_gleu",
            "location": 77,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestExternalEvaluators.test_f1": {
            "name": "test_f1",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAccuracyEvaluator.setUp": {
            "name": "setUp",
            "location": 94,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAccuracyEvaluator.test_word_level_acc": {
            "name": "test_word_level_acc",
            "location": 98,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestAccuracyEvaluator.test_seq_level_acc": {
            "name": "test_seq_level_acc",
            "location": 107,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_functions.py": {
        "TestPiecewiseFunction.test_piecewise_constant": {
            "name": "test_piecewise_constant",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_model_part.py": {
        "Test.setUpClass": {
            "name": "setUpClass",
            "location": 21,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "Test.test_reuse": {
            "name": "test_reuse",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Test.test_save_and_load": {
            "name": "test_save_and_load",
            "location": 68,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_nn_utils.py": {
        "TestDropout.test_invalid_keep_prob": {
            "name": "test_invalid_keep_prob",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDropout.test_keep_prob": {
            "name": "test_keep_prob",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestDropout.test_train_false": {
            "name": "test_train_false",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_readers.py": {
        "_make_file": {
            "name": "_make_file",
            "location": 40,
            "return": [],
            "arguments": {
                "from_var": []
            }
        },
        "TestStringVectorReader.setUp": {
            "name": "setUp",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStringVectorReader.test_reader": {
            "name": "test_reader",
            "location": 54,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStringVectorReader.test_columns": {
            "name": "test_columns",
            "location": 70,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestStringVectorReader.tearDown": {
            "name": "tearDown",
            "location": 94,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestT2TReader.setUp": {
            "name": "setUp",
            "location": 102,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestT2TReader.test_reader": {
            "name": "test_reader",
            "location": 105,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_ter.py": {
        "TestBLEU.test_empty_decoded": {
            "name": "test_empty_decoded",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_empty_reference": {
            "name": "test_empty_reference",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_identical": {
            "name": "test_identical",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_empty_sentence": {
            "name": "test_empty_sentence",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestBLEU.test_ter": {
            "name": "test_ter",
            "location": 27,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_vocabulary.py": {
        "TestVocabulary.setUpClass": {
            "name": "setUpClass",
            "location": 11,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "TestVocabulary.tearDownClass": {
            "name": "tearDownClass",
            "location": 30,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "TestVocabulary.test_all_words_in": {
            "name": "test_all_words_in",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_unknown_word": {
            "name": "test_unknown_word",
            "location": 38,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_padding": {
            "name": "test_padding",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_weights": {
            "name": "test_weights",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_there_and_back_self": {
            "name": "test_there_and_back_self",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/test_wordpiece.py": {
        "TestWordpieces.setUpClass": {
            "name": "setUpClass",
            "location": 12,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "TestWordpieces.test_preprocess_ok": {
            "name": "test_preprocess_ok",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordpieces.test_preprocess_split": {
            "name": "test_preprocess_split",
            "location": 44,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordpieces.test_preprocess_unk": {
            "name": "test_preprocess_unk",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordpieces.test_postprocess_ok": {
            "name": "test_postprocess_ok",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordpieces.test_postprocess_split": {
            "name": "test_postprocess_split",
            "location": 65,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordpieces.test_postprocess_unk": {
            "name": "test_postprocess_unk",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestWordpieces.test_make_wordpieces": {
            "name": "test_make_wordpieces",
            "location": 81,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/tests/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/trainers/cross_entropy_trainer.py": {
        "xent_objective": {
            "name": "xent_objective",
            "location": 13,
            "return": [
                "Objective"
            ],
            "arguments": {
                "decoder": [],
                "weight": []
            }
        },
        "CrossEntropyTrainer.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "decoders": [
                    "List[Any]"
                ],
                "decoder_weights": [
                    "List[ObjectiveWeight]"
                ],
                "l1_weight": [
                    "float"
                ],
                "l2_weight": [
                    "float"
                ],
                "clip_norm": [
                    "float"
                ],
                "optimizer": [
                    "tf.train.Optimizer"
                ],
                "var_scopes": [
                    "List[str]"
                ],
                "var_collection": [
                    "str"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/delayed_update_trainer.py": {
        "DelayedUpdateTrainer.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batches_per_update": [
                    "int"
                ],
                "objectives": [
                    "List[Objective]"
                ],
                "l1_weight": [
                    "float"
                ],
                "l2_weight": [
                    "float"
                ],
                "clip_norm": [
                    "float"
                ],
                "optimizer": [
                    "tf.train.Optimizer"
                ],
                "var_scopes": [
                    "List[str]"
                ],
                "var_collection": [
                    "str"
                ]
            }
        },
        "DelayedUpdateTrainer.existing_grads_and_vars": {
            "name": "existing_grads_and_vars",
            "location": 103,
            "return": [
                "Tuple[(List[tf.Tensor], List[tf.Variable])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.gradient_buffers": {
            "name": "gradient_buffers",
            "location": 116,
            "return": [
                "List[tf.Variable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.objective_buffers": {
            "name": "objective_buffers",
            "location": 127,
            "return": [
                "List[tf.Variable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.diff_buffer": {
            "name": "diff_buffer",
            "location": 133,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.cumulator_counter": {
            "name": "cumulator_counter",
            "location": 137,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.accumulate_ops": {
            "name": "accumulate_ops",
            "location": 142,
            "return": [
                "List[tf.Operation]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.reset_ops": {
            "name": "reset_ops",
            "location": 167,
            "return": [
                "List[tf.Operation]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.raw_gradients": {
            "name": "raw_gradients",
            "location": 181,
            "return": [
                "Gradients"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.summaries": {
            "name": "summaries",
            "location": 207,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.Executable.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "executor": [
                    "'DelayedUpdateTrainer'"
                ],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ],
                "num_sessions": [
                    "int"
                ]
            }
        },
        "DelayedUpdateTrainer.Executable.next_to_execute": {
            "name": "next_to_execute",
            "location": 33,
            "return": [
                "NextExecute"
            ],
            "arguments": {
                "self": []
            }
        },
        "DelayedUpdateTrainer.Executable.collect_results": {
            "name": "collect_results",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/generic_trainer.py": {
        "GenericTrainer.default_optimizer": {
            "name": "default_optimizer",
            "location": 56,
            "return": [],
            "arguments": {}
        },
        "GenericTrainer.__init__": {
            "name": "__init__",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "objectives": [
                    "Sequence[Objective]"
                ],
                "l1_weight": [
                    "float"
                ],
                "l2_weight": [
                    "float"
                ],
                "clip_norm": [
                    "float"
                ],
                "optimizer": [
                    "tf.train.Optimizer"
                ],
                "var_scopes": [
                    "List[str]"
                ],
                "var_collection": [
                    "str"
                ]
            }
        },
        "GenericTrainer.regularization_losses": {
            "name": "regularization_losses",
            "location": 85,
            "return": [
                "Tuple[(tf.Tensor, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.objective_values": {
            "name": "objective_values",
            "location": 105,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.differentiable_loss_sum": {
            "name": "differentiable_loss_sum",
            "location": 118,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.raw_gradients": {
            "name": "raw_gradients",
            "location": 137,
            "return": [
                "Gradients"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.gradients": {
            "name": "gradients",
            "location": 176,
            "return": [
                "Gradients"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.train_op": {
            "name": "train_op",
            "location": 191,
            "return": [
                "tf.Operation"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.var_list": {
            "name": "var_list",
            "location": 198,
            "return": [
                "List[tf.Variable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.summaries": {
            "name": "summaries",
            "location": 209,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.fetches": {
            "name": "fetches",
            "location": 246,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.Executable.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "executor": [
                    "'GenericTrainer'"
                ],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ],
                "num_sessions": [
                    "int"
                ]
            }
        },
        "GenericTrainer.Executable.next_to_execute": {
            "name": "next_to_execute",
            "location": 31,
            "return": [
                "NextExecute"
            ],
            "arguments": {
                "self": []
            }
        },
        "GenericTrainer.Executable.collect_results": {
            "name": "collect_results",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "List[Dict]"
                ]
            }
        },
        "GenericTrainer.raw_gradients.scale_grads": {
            "name": "scale_grads",
            "location": 143,
            "return": [
                "Gradients"
            ],
            "arguments": {
                "gradients": [
                    "Gradients"
                ],
                "weight": [
                    "ObjectiveWeight"
                ]
            }
        },
        "GenericTrainer.raw_gradients.sum_grads": {
            "name": "sum_grads",
            "location": 158,
            "return": [
                "Gradients"
            ],
            "arguments": {
                "gradients_list": [
                    "List[Gradients]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/multitask_trainer.py": {
        "MultitaskTrainer.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "trainers": [
                    "List[GenericTrainer]"
                ]
            }
        },
        "MultitaskTrainer.var_list": {
            "name": "var_list",
            "location": 29,
            "return": [
                "List[tf.Variable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultitaskTrainer.get_executable": {
            "name": "get_executable",
            "location": 32,
            "return": [
                "GraphExecutor.Executable"
            ],
            "arguments": {
                "self": [],
                "compute_losses": [
                    "bool"
                ],
                "summaries": [
                    "bool"
                ],
                "num_sessions": [
                    "int"
                ]
            }
        },
        "MultitaskTrainer.fetches": {
            "name": "fetches",
            "location": 43,
            "return": [
                "Dict[(str, tf.Tensor)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/objective.py": {
        "Objective.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "decoder": [
                    "MP"
                ]
            }
        },
        "Objective.decoder": {
            "name": "decoder",
            "location": 30,
            "return": [
                "MP"
            ],
            "arguments": {
                "self": []
            }
        },
        "Objective.name": {
            "name": "name",
            "location": 35,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Objective.loss": {
            "name": "loss",
            "location": 40,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "Objective.gradients": {
            "name": "gradients",
            "location": 45,
            "return": [
                "Optional[Gradients]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Objective.weight": {
            "name": "weight",
            "location": 50,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CostObjective.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "decoder": [
                    "GenericModelPart"
                ],
                "weight": [
                    "ObjectiveWeight"
                ]
            }
        },
        "CostObjective.loss": {
            "name": "loss",
            "location": 91,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "CostObjective.weight": {
            "name": "weight",
            "location": 95,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/rl_trainer.py": {
        "rl_objective": {
            "name": "rl_objective",
            "location": 196,
            "return": [
                "ReinforceObjective"
            ],
            "arguments": {}
        },
        "ReinforceObjective.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "decoder": [
                    "Decoder"
                ],
                "reward_function": [
                    "RewardFunction"
                ],
                "subtract_baseline": [
                    "bool"
                ],
                "normalize": [
                    "bool"
                ],
                "temperature": [
                    "float"
                ],
                "ce_smoothing": [
                    "float"
                ],
                "alpha": [
                    "float"
                ],
                "sample_size": [
                    "int"
                ]
            }
        },
        "ReinforceObjective.loss": {
            "name": "loss",
            "location": 79,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "ReinforceObjective.loss._score_with_reward_function": {
            "name": "_score_with_reward_function",
            "location": 83,
            "return": [
                "np.array"
            ],
            "arguments": {
                "references": [
                    "np.array"
                ],
                "hypotheses": [
                    "np.array"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/self_critical_objective.py": {
        "reinforce_score": {
            "name": "reinforce_score",
            "location": 95,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "reward": [
                    "tf.Tensor"
                ],
                "baseline": [
                    "tf.Tensor"
                ],
                "decoded": [
                    "tf.Tensor"
                ],
                "logits": [
                    "tf.Tensor"
                ]
            }
        },
        "sentence_bleu": {
            "name": "sentence_bleu",
            "location": 124,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "references": [
                    "np.ndarray"
                ],
                "hypotheses": [
                    "np.ndarray"
                ]
            }
        },
        "sentence_gleu": {
            "name": "sentence_gleu",
            "location": 165,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "references": [
                    "np.ndarray"
                ],
                "hypotheses": [
                    "np.ndarray"
                ]
            }
        },
        "_count_matching_n_grams": {
            "name": "_count_matching_n_grams",
            "location": 203,
            "return": [
                "Tuple[(int, int, int)]"
            ],
            "arguments": {
                "ref": [
                    "np.ndarray"
                ],
                "hyp": [
                    "np.ndarray"
                ],
                "n": [
                    "int"
                ]
            }
        },
        "_get_n_grams": {
            "name": "_get_n_grams",
            "location": 228,
            "return": [
                "Iterable[np.ndarray]"
            ],
            "arguments": {
                "indices": [
                    "np.ndarray"
                ],
                "order": [
                    "int"
                ]
            }
        },
        "SelfCriticalObjective.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "decoder": [
                    "Decoder"
                ],
                "reward_function": [
                    "RewardFunction"
                ],
                "weight": [
                    "float"
                ]
            }
        },
        "SelfCriticalObjective.weight": {
            "name": "weight",
            "location": 50,
            "return": [
                "Optional[tf.Tensor]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SelfCriticalObjective.loss": {
            "name": "loss",
            "location": 56,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/test_multitask_trainer.py": {
        "TestMP.var": {
            "name": "var",
            "location": 19,
            "return": [
                "tf.Variable"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMP.loss": {
            "name": "loss",
            "location": 24,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "DummyObjective.loss": {
            "name": "loss",
            "location": 31,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultitaskTrainer.setUpClass": {
            "name": "setUpClass",
            "location": 39,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "TestMultitaskTrainer.setUp": {
            "name": "setUp",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestMultitaskTrainer.test_mt_trainer": {
            "name": "test_mt_trainer",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/trainers/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/util/match_type.py": {
        "match_type": {
            "name": "match_type",
            "location": 5,
            "return": [
                "bool"
            ],
            "arguments": {
                "value": [
                    "Any"
                ],
                "type_": [
                    "Type"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/util/word2vec.py": {
        "get_word2vec_initializer": {
            "name": "get_word2vec_initializer",
            "location": 76,
            "return": [
                "Callable"
            ],
            "arguments": {
                "w2v": [
                    "Word2Vec"
                ]
            }
        },
        "word2vec_vocabulary": {
            "name": "word2vec_vocabulary",
            "location": 94,
            "return": [
                "Vocabulary"
            ],
            "arguments": {
                "w2v": [
                    "Word2Vec"
                ]
            }
        },
        "Word2Vec.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ],
                "encoding": [
                    "str"
                ]
            }
        },
        "Word2Vec.vocabulary": {
            "name": "vocabulary",
            "location": 66,
            "return": [
                "Vocabulary"
            ],
            "arguments": {
                "self": []
            }
        },
        "Word2Vec.embeddings": {
            "name": "embeddings",
            "location": 71,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "get_word2vec_initializer.init": {
            "name": "init",
            "location": 83,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "shape": [
                    "List[int]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/util/__init__.py": {},
    "neuralmonkey-master/neuralmonkey/writers/auto.py": {
        "_check_savable_dict": {
            "name": "_check_savable_dict",
            "location": 12,
            "return": [
                "bool"
            ],
            "arguments": {
                "data": [
                    "Any"
                ]
            }
        },
        "auto_writer": {
            "name": "auto_writer",
            "location": 31,
            "return": [
                "Writer"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "auto_writer.writer": {
            "name": "writer",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "data": [
                    "Any"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/writers/numpy_writer.py": {
        "numpy_array_writer": {
            "name": "numpy_array_writer",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "data": [
                    "np.ndarray"
                ]
            }
        },
        "numpy_dict_writer": {
            "name": "numpy_dict_writer",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "data": [
                    "Iterator[Dict[(str, np.ndarray)]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/writers/plain_text_writer.py": {
        "t2t_detokenize": {
            "name": "t2t_detokenize",
            "location": 12,
            "return": [
                "Iterator[str]"
            ],
            "arguments": {
                "data": [
                    "Iterator[List[str]]"
                ]
            }
        },
        "text_writer": {
            "name": "text_writer",
            "location": 28,
            "return": [
                "Writer"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "tokenized_text_writer": {
            "name": "tokenized_text_writer",
            "location": 39,
            "return": [
                "Writer"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "t2t_tokenized_text_writer": {
            "name": "t2t_tokenized_text_writer",
            "location": 48,
            "return": [
                "Writer"
            ],
            "arguments": {
                "encoding": [
                    "str"
                ]
            }
        },
        "text_writer.writer": {
            "name": "writer",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "data": [
                    "Iterator"
                ]
            }
        },
        "tokenized_text_writer.writer": {
            "name": "writer",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "data": [
                    "Iterator[List[str]]"
                ]
            }
        },
        "t2t_tokenized_text_writer.writer": {
            "name": "writer",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "data": [
                    "Iterator[List[str]]"
                ]
            }
        }
    },
    "neuralmonkey-master/neuralmonkey/writers/__init__.py": {},
    "neuralmonkey-master/scripts/avg_checkpoints.py": {
        "log": {
            "name": "log",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/build_config.py": {
        "_patch_config_builder": {
            "name": "_patch_config_builder",
            "location": 17,
            "return": [],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "_patch_config_builder.get_class_name": {
            "name": "get_class_name",
            "location": 21,
            "return": [],
            "arguments": {
                "symbol": [
                    "ClassSymbol"
                ]
            }
        },
        "_patch_config_builder.build_object": {
            "name": "build_object",
            "location": 30,
            "return": [
                "Any"
            ],
            "arguments": {
                "value": [
                    "str"
                ],
                "all_dicts": [
                    "Dict[(str, Any)]"
                ],
                "existing_objects": [
                    "Dict[(str, Any)]"
                ],
                "depth": [
                    "int"
                ]
            }
        }
    },
    "neuralmonkey-master/scripts/caffe_image_features.py": {
        "crop_image": {
            "name": "crop_image",
            "location": 10,
            "return": [],
            "arguments": {
                "x": [],
                "target_height": [],
                "target_width": []
            }
        },
        "shape": {
            "name": "shape",
            "location": 83,
            "return": [],
            "arguments": {
                "string": []
            }
        },
        "CNN.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [],
            "arguments": {
                "self": [],
                "deploy": [],
                "model": [],
                "mean": [],
                "batch_size": [],
                "width": [],
                "height": []
            }
        },
        "CNN.get_net": {
            "name": "get_net",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CNN.get_features": {
            "name": "get_features",
            "location": 61,
            "return": [],
            "arguments": {
                "self": [],
                "image_list": [],
                "layers": [],
                "layer_sizes": []
            }
        }
    },
    "neuralmonkey-master/scripts/column_selector.py": {
        "main": {
            "name": "main",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/decompound_truecased.py": {
        "main": {
            "name": "main",
            "location": 9,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/estimate_scheduled_sampling.py": {
        "main": {
            "name": "main",
            "location": 15,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/export_embeddings_to_w2v.py": {
        "log": {
            "name": "log",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/extract_model_part_from_ckpt.py": {
        "log": {
            "name": "log",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/imagenet_features.py": {
        "main": {
            "name": "main",
            "location": 28,
            "return": [],
            "arguments": {}
        },
        "main.process_images": {
            "name": "process_images",
            "location": 93,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/import_nematus.py": {
        "log": {
            "name": "log",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "check_shape": {
            "name": "check_shape",
            "location": 28,
            "return": [],
            "arguments": {
                "var1_tf": [
                    "tf.Variable"
                ],
                "var2_np": [
                    "np.ndarray"
                ]
            }
        },
        "emb_fix_dim1": {
            "name": "emb_fix_dim1",
            "location": 35,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "variables": [
                    "List[np.ndarray]"
                ]
            }
        },
        "emb_fix": {
            "name": "emb_fix",
            "location": 39,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "variables": [
                    "List[np.ndarray]"
                ],
                "dim": [
                    "int"
                ]
            }
        },
        "sum_vars": {
            "name": "sum_vars",
            "location": 72,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "variables": [
                    "List[np.ndarray]"
                ]
            }
        },
        "concat_vars": {
            "name": "concat_vars",
            "location": 76,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "variables": [
                    "List[np.ndarray]"
                ]
            }
        },
        "squeeze": {
            "name": "squeeze",
            "location": 80,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "variables": [
                    "List[np.ndarray]"
                ]
            }
        },
        "load_nematus_json": {
            "name": "load_nematus_json",
            "location": 138,
            "return": [
                "Dict"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "build_encoder": {
            "name": "build_encoder",
            "location": 205,
            "return": [
                "Tuple[(RecurrentEncoder, str)]"
            ],
            "arguments": {
                "config": [
                    "Dict"
                ]
            }
        },
        "build_attention": {
            "name": "build_attention",
            "location": 242,
            "return": [
                "Tuple[(Attention, str)]"
            ],
            "arguments": {
                "config": [
                    "Dict"
                ],
                "encoder": [
                    "RecurrentEncoder"
                ]
            }
        },
        "build_decoder": {
            "name": "build_decoder",
            "location": 282,
            "return": [
                "Tuple[(Decoder, str)]"
            ],
            "arguments": {
                "config": [
                    "Dict"
                ],
                "attention": [
                    "Attention"
                ],
                "encoder": [
                    "RecurrentEncoder"
                ]
            }
        },
        "build_model": {
            "name": "build_model",
            "location": 315,
            "return": [
                "Tuple[(RecurrentEncoder, Attention, Decoder, str)]"
            ],
            "arguments": {
                "config": [
                    "Dict"
                ]
            }
        },
        "load_nematus_file": {
            "name": "load_nematus_file",
            "location": 326,
            "return": [
                "Dict[(str, np.ndarray)]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "assign_vars": {
            "name": "assign_vars",
            "location": 333,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "variables": [
                    "Dict[(str, np.ndarray)]"
                ]
            }
        },
        "write_config": {
            "name": "write_config",
            "location": 422,
            "return": [
                "None"
            ],
            "arguments": {
                "experiment_dir": [
                    "str"
                ],
                "ini": [
                    "str"
                ]
            }
        },
        "prepare_output_dir": {
            "name": "prepare_output_dir",
            "location": 429,
            "return": [
                "bool"
            ],
            "arguments": {
                "output_dir": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 438,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/import_transformer.1.2.9.py": {
        "create_variable_map": {
            "name": "create_variable_map",
            "location": 135,
            "return": [
                "Dict"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "np_vars": []
            }
        },
        "log": {
            "name": "log",
            "location": 200,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "check_shape": {
            "name": "check_shape",
            "location": 203,
            "return": [],
            "arguments": {
                "var1_tf": [
                    "tf.Variable"
                ],
                "var2_np": [
                    "np.ndarray"
                ]
            }
        },
        "get_shared_emb_vars": {
            "name": "get_shared_emb_vars",
            "location": 207,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "np_vars": [
                    "Dict"
                ]
            }
        },
        "emb_fix": {
            "name": "emb_fix",
            "location": 217,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "variables": [
                    "List[tf.Tensor]"
                ]
            }
        },
        "reshape4d2d": {
            "name": "reshape4d2d",
            "location": 232,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "variables": [
                    "List[tf.Tensor]"
                ]
            }
        },
        "create_transform_matrix_getter": {
            "name": "create_transform_matrix_getter",
            "location": 235,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "num_of_splits": [
                    "int"
                ],
                "matrix_pos": [
                    "int"
                ]
            }
        },
        "build_encoder": {
            "name": "build_encoder",
            "location": 248,
            "return": [
                "Tuple[(TransformerEncoder, str)]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "vocab_path": [
                    "str"
                ]
            }
        },
        "build_decoder": {
            "name": "build_decoder",
            "location": 282,
            "return": [
                "Tuple[(TransformerDecoder, str)]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "encoder": [
                    "TransformerEncoder"
                ],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "build_model": {
            "name": "build_model",
            "location": 307,
            "return": [
                "Tuple[(TransformerEncoder, TransformerDecoder, str)]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "vocab_path": [
                    "str"
                ]
            }
        },
        "load_hparams": {
            "name": "load_hparams",
            "location": 318,
            "return": [
                "Dict"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "get_assign_ops": {
            "name": "get_assign_ops",
            "location": 339,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "np_vars": [
                    "Dict"
                ]
            }
        },
        "write_config": {
            "name": "write_config",
            "location": 380,
            "return": [
                "None"
            ],
            "arguments": {
                "experiment_dir": [
                    "str"
                ],
                "ini": [
                    "str"
                ]
            }
        },
        "prepare_output_dir": {
            "name": "prepare_output_dir",
            "location": 387,
            "return": [
                "bool"
            ],
            "arguments": {
                "output_dir": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 396,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "create_transform_matrix_getter.get_transform_matrix": {
            "name": "get_transform_matrix",
            "location": 237,
            "return": [],
            "arguments": {
                "variables": [
                    "List[tf.Tensor]"
                ]
            }
        }
    },
    "neuralmonkey-master/scripts/import_transformer.1.3.2.py": {
        "create_variable_map": {
            "name": "create_variable_map",
            "location": 133,
            "return": [
                "Dict"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "np_vars": []
            }
        },
        "log": {
            "name": "log",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "check_shape": {
            "name": "check_shape",
            "location": 189,
            "return": [],
            "arguments": {
                "var1_tf": [
                    "tf.Variable"
                ],
                "var2_np": [
                    "np.ndarray"
                ]
            }
        },
        "get_shared_emb_vars": {
            "name": "get_shared_emb_vars",
            "location": 193,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "np_vars": [
                    "Dict"
                ]
            }
        },
        "emb_fix": {
            "name": "emb_fix",
            "location": 203,
            "return": [
                "tf.Tensor"
            ],
            "arguments": {
                "variables": [
                    "List[tf.Tensor]"
                ]
            }
        },
        "build_encoder": {
            "name": "build_encoder",
            "location": 220,
            "return": [
                "Tuple[(TransformerEncoder, str)]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "vocab_path": [
                    "str"
                ]
            }
        },
        "build_decoder": {
            "name": "build_decoder",
            "location": 253,
            "return": [
                "Tuple[(TransformerDecoder, str)]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "encoder": [
                    "TransformerEncoder"
                ],
                "vocab": [
                    "Vocabulary"
                ]
            }
        },
        "build_model": {
            "name": "build_model",
            "location": 277,
            "return": [
                "Tuple[(TransformerEncoder, TransformerDecoder, str)]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "vocab_path": [
                    "str"
                ]
            }
        },
        "load_hparams": {
            "name": "load_hparams",
            "location": 288,
            "return": [
                "Dict"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "get_assign_ops": {
            "name": "get_assign_ops",
            "location": 307,
            "return": [
                "List[tf.Tensor]"
            ],
            "arguments": {
                "hparams": [
                    "Dict"
                ],
                "np_vars": [
                    "Dict"
                ]
            }
        },
        "write_config": {
            "name": "write_config",
            "location": 348,
            "return": [
                "None"
            ],
            "arguments": {
                "experiment_dir": [
                    "str"
                ],
                "ini": [
                    "str"
                ]
            }
        },
        "prepare_output_dir": {
            "name": "prepare_output_dir",
            "location": 355,
            "return": [
                "bool"
            ],
            "arguments": {
                "output_dir": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 364,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/max_column_finder.py": {
        "main": {
            "name": "main",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/postedit_prepare_data.py": {
        "load_tokenized": {
            "name": "load_tokenized",
            "location": 25,
            "return": [],
            "arguments": {
                "text_file": [],
                "preprocess": []
            }
        },
        "convert_to_edits": {
            "name": "convert_to_edits",
            "location": 31,
            "return": [],
            "arguments": {
                "source": [],
                "target": []
            }
        },
        "main": {
            "name": "main",
            "location": 72,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/postedit_reconstruct_data.py": {
        "reconstruct": {
            "name": "reconstruct",
            "location": 17,
            "return": [],
            "arguments": {
                "source": [],
                "edits": []
            }
        },
        "main": {
            "name": "main",
            "location": 41,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/prepare_str_images.py": {
        "main": {
            "name": "main",
            "location": 12,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/preprocess_bert.py": {
        "log": {
            "name": "log",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "message": [
                    "str"
                ],
                "color": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/speech_features.py": {
        "try_parse_number": {
            "name": "try_parse_number",
            "location": 20,
            "return": [
                "Union[(str, float, int)]"
            ],
            "arguments": {
                "str_value": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 31,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/tf_save_images.py": {
        "main": {
            "name": "main",
            "location": 29,
            "return": [],
            "arguments": {}
        }
    },
    "neuralmonkey-master/scripts/tokenize_data.py": {
        "get_decompounder": {
            "name": "get_decompounder",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "normalize_quotes": {
            "name": "normalize_quotes",
            "location": 50,
            "return": [],
            "arguments": {
                "token": []
            }
        }
    }
}
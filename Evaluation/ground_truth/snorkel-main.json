{
    "snorkel-main/setup.py": {},
    "snorkel-main/docs/conf.py": {
        "linkcode_resolve": {
            "name": "linkcode_resolve",
            "location": 115,
            "return": [],
            "arguments": {
                "domain": [],
                "info": []
            }
        },
        "skip_torch_module_member": {
            "name": "skip_torch_module_member",
            "location": 130,
            "return": [],
            "arguments": {
                "app": [],
                "what": [],
                "name": [],
                "obj": [],
                "skip": [],
                "options": []
            }
        },
        "setup": {
            "name": "setup",
            "location": 138,
            "return": [],
            "arguments": {
                "app": []
            }
        }
    },
    "snorkel-main/scripts/check_requirements.py": {
        "parse_section_name": {
            "name": "parse_section_name",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "line": [
                    "str"
                ]
            }
        },
        "parse_package": {
            "name": "parse_package",
            "location": 26,
            "return": [
                "Tuple[(str, Optional[str])]"
            ],
            "arguments": {
                "line": [
                    "str"
                ]
            }
        },
        "parse_requirements": {
            "name": "parse_requirements",
            "location": 33,
            "return": [
                "Tuple[(PackagesType, PackagesType, Set[str])]"
            ],
            "arguments": {}
        },
        "parse_setup": {
            "name": "parse_setup",
            "location": 64,
            "return": [
                "Tuple[(PackagesType, PackagesType, Set[str], Set[str])]"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 103,
            "return": [
                "int"
            ],
            "arguments": {}
        }
    },
    "snorkel-main/scripts/sync_api_docs.py": {
        "get_title_and_underscore": {
            "name": "get_title_and_underscore",
            "location": 35,
            "return": [
                "str"
            ],
            "arguments": {
                "package_name": [
                    "str"
                ]
            }
        },
        "get_package_members": {
            "name": "get_package_members",
            "location": 41,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "package": [
                    "Any"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "check": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/version.py": {},
    "snorkel-main/snorkel/__init__.py": {},
    "snorkel-main/snorkel/analysis/error_analysis.py": {
        "get_label_buckets": {
            "name": "get_label_buckets",
            "location": 10,
            "return": [
                "Dict[(Tuple[(int, ...)], np.ndarray)]"
            ],
            "arguments": {}
        },
        "get_label_instances": {
            "name": "get_label_instances",
            "location": 61,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "bucket": [
                    "Tuple[(int, ...)]"
                ],
                "x": [
                    "np.ndarray"
                ]
            }
        }
    },
    "snorkel-main/snorkel/analysis/metrics.py": {
        "metric_score": {
            "name": "metric_score",
            "location": 16,
            "return": [
                "float"
            ],
            "arguments": {
                "golds": [
                    "Optional[np.ndarray]"
                ],
                "preds": [
                    "Optional[np.ndarray]"
                ],
                "probs": [
                    "Optional[np.ndarray]"
                ],
                "metric": [
                    "str"
                ],
                "filter_dict": [
                    "Optional[Dict[(str, List[int])]]"
                ]
            }
        },
        "_coverage_score": {
            "name": "_coverage_score",
            "location": 85,
            "return": [
                "float"
            ],
            "arguments": {
                "preds": [
                    "np.ndarray"
                ]
            }
        },
        "_roc_auc_score": {
            "name": "_roc_auc_score",
            "location": 89,
            "return": [
                "float"
            ],
            "arguments": {
                "golds": [
                    "np.ndarray"
                ],
                "probs": [
                    "np.ndarray"
                ]
            }
        },
        "_f1_score": {
            "name": "_f1_score",
            "location": 97,
            "return": [
                "float"
            ],
            "arguments": {
                "golds": [
                    "np.ndarray"
                ],
                "preds": [
                    "np.ndarray"
                ]
            }
        },
        "_f1_micro_score": {
            "name": "_f1_micro_score",
            "location": 106,
            "return": [
                "float"
            ],
            "arguments": {
                "golds": [
                    "np.ndarray"
                ],
                "preds": [
                    "np.ndarray"
                ]
            }
        },
        "_f1_macro_score": {
            "name": "_f1_macro_score",
            "location": 110,
            "return": [
                "float"
            ],
            "arguments": {
                "golds": [
                    "np.ndarray"
                ],
                "preds": [
                    "np.ndarray"
                ]
            }
        }
    },
    "snorkel-main/snorkel/analysis/scorer.py": {
        "Scorer.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metrics": [
                    "Optional[List[str]]"
                ],
                "custom_metric_funcs": [
                    "Optional[Mapping[(str, Callable[(..., float)])]]"
                ],
                "abstain_label": [
                    "Optional[int]"
                ]
            }
        },
        "Scorer.score": {
            "name": "score",
            "location": 71,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "golds": [
                    "np.ndarray"
                ],
                "preds": [
                    "Optional[np.ndarray]"
                ],
                "probs": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "Scorer.score_slices": {
            "name": "score_slices",
            "location": 116,
            "return": [
                "Union[(Dict[(str, Dict[(str, float)])], pd.DataFrame)]"
            ],
            "arguments": {
                "self": [],
                "S": [
                    "np.recarray"
                ],
                "golds": [
                    "np.ndarray"
                ],
                "preds": [
                    "np.ndarray"
                ],
                "probs": [
                    "np.ndarray"
                ],
                "as_dataframe": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/analysis/__init__.py": {},
    "snorkel-main/snorkel/augmentation/tf.py": {},
    "snorkel-main/snorkel/augmentation/__init__.py": {},
    "snorkel-main/snorkel/augmentation/apply/core.py": {
        "BaseTFApplier.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tfs": [
                    "List[BaseTransformationFunction]"
                ],
                "policy": [
                    "Policy"
                ]
            }
        },
        "BaseTFApplier._apply_policy_to_data_point": {
            "name": "_apply_policy_to_data_point",
            "location": 38,
            "return": [
                "DataPoints"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "BaseTFApplier.__repr__": {
            "name": "__repr__",
            "location": 57,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TFApplier.apply_generator": {
            "name": "apply_generator",
            "location": 69,
            "return": [
                "Iterator[List[DataPoint]]"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "DataPoints"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "TFApplier.apply": {
            "name": "apply",
            "location": 98,
            "return": [
                "List[DataPoint]"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "DataPoints"
                ],
                "progress_bar": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/augmentation/apply/pandas.py": {
        "PandasTFApplier.apply_generator": {
            "name": "apply_generator",
            "location": 18,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "pd.DataFrame"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "PandasTFApplier.apply": {
            "name": "apply",
            "location": 47,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "pd.DataFrame"
                ],
                "progress_bar": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/augmentation/apply/__init__.py": {},
    "snorkel-main/snorkel/augmentation/policy/core.py": {
        "Policy.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_tfs": [
                    "int"
                ],
                "n_per_original": [
                    "int"
                ],
                "keep_original": [
                    "bool"
                ]
            }
        },
        "Policy.generate_for_example": {
            "name": "generate_for_example",
            "location": 44,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Policy.generate": {
            "name": "generate",
            "location": 63,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ApplyAllPolicy.generate": {
            "name": "generate",
            "location": 113,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ApplyOnePolicy.__init__": {
            "name": "__init__",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_per_original": [
                    "int"
                ],
                "keep_original": [
                    "bool"
                ]
            }
        },
        "ApplyEachPolicy.__init__": {
            "name": "__init__",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_tfs": [
                    "int"
                ],
                "keep_original": [
                    "bool"
                ]
            }
        },
        "ApplyEachPolicy.generate_for_example": {
            "name": "generate_for_example",
            "location": 168,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/snorkel/augmentation/policy/sampling.py": {
        "MeanFieldPolicy.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_tfs": [
                    "int"
                ],
                "sequence_length": [
                    "int"
                ],
                "p": [
                    "Optional[Sequence[float]]"
                ],
                "n_per_original": [
                    "int"
                ],
                "keep_original": [
                    "bool"
                ]
            }
        },
        "MeanFieldPolicy.generate": {
            "name": "generate",
            "location": 59,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RandomPolicy.__init__": {
            "name": "__init__",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_tfs": [
                    "int"
                ],
                "sequence_length": [
                    "int"
                ],
                "n_per_original": [
                    "int"
                ],
                "keep_original": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/augmentation/policy/__init__.py": {},
    "snorkel-main/snorkel/classification/data.py": {
        "collate_dicts": {
            "name": "collate_dicts",
            "location": 122,
            "return": [
                "Batch"
            ],
            "arguments": {
                "batch": [
                    "List[Batch]"
                ]
            }
        },
        "DictDataset.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "split": [
                    "str"
                ],
                "X_dict": [
                    "XDict"
                ],
                "Y_dict": [
                    "YDict"
                ]
            }
        },
        "DictDataset.__getitem__": {
            "name": "__getitem__",
            "location": 63,
            "return": [
                "Tuple[(XDict, YDict)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "DictDataset.__len__": {
            "name": "__len__",
            "location": 68,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "DictDataset.__repr__": {
            "name": "__repr__",
            "location": 74,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DictDataset.from_tensors": {
            "name": "from_tensors",
            "location": 83,
            "return": [
                "'DictDataset'"
            ],
            "arguments": {
                "cls": [],
                "X_tensor": [
                    "Tensor"
                ],
                "Y_tensor": [
                    "Tensor"
                ],
                "split": [
                    "str"
                ],
                "input_data_key": [
                    "str"
                ],
                "task_name": [
                    "str"
                ],
                "dataset_name": [
                    "str"
                ]
            }
        },
        "DictDataLoader.__init__": {
            "name": "__init__",
            "location": 170,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "DictDataset"
                ],
                "collate_fn": [
                    "Callable[(..., Any)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/loss.py": {
        "cross_entropy_with_probs": {
            "name": "cross_entropy_with_probs",
            "location": 9,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "input": [
                    "torch.Tensor"
                ],
                "target": [
                    "torch.Tensor"
                ],
                "weight": [
                    "Optional[torch.Tensor]"
                ],
                "reduction": [
                    "str"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/multitask_classifier.py": {
        "MultitaskClassifier.__init__": {
            "name": "__init__",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tasks": [
                    "List[Task]"
                ],
                "name": [
                    "Optional[str]"
                ]
            }
        },
        "MultitaskClassifier.__repr__": {
            "name": "__repr__",
            "location": 114,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultitaskClassifier._build_network": {
            "name": "_build_network",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tasks": [
                    "List[Task]"
                ]
            }
        },
        "MultitaskClassifier.add_task": {
            "name": "add_task",
            "location": 136,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "task": [
                    "Task"
                ]
            }
        },
        "MultitaskClassifier.forward": {
            "name": "forward",
            "location": 165,
            "return": [
                "OutputDict"
            ],
            "arguments": {
                "self": [],
                "X_dict": [
                    "Dict[(str, Any)]"
                ],
                "task_names": [
                    "Iterable[str]"
                ]
            }
        },
        "MultitaskClassifier.calculate_loss": {
            "name": "calculate_loss",
            "location": 232,
            "return": [
                "Tuple[(Dict[(str, torch.Tensor)], Dict[(str, float)])]"
            ],
            "arguments": {
                "self": [],
                "X_dict": [
                    "Dict[(str, Any)]"
                ],
                "Y_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        },
        "MultitaskClassifier._calculate_probs": {
            "name": "_calculate_probs",
            "location": 286,
            "return": [
                "Dict[(str, Iterable[torch.Tensor])]"
            ],
            "arguments": {
                "self": [],
                "X_dict": [
                    "Dict[(str, Any)]"
                ],
                "task_names": [
                    "Iterable[str]"
                ]
            }
        },
        "MultitaskClassifier.predict": {
            "name": "predict",
            "location": 318,
            "return": [
                "Dict[(str, Dict[(str, torch.Tensor)])]"
            ],
            "arguments": {
                "self": [],
                "dataloader": [
                    "DictDataLoader"
                ],
                "return_preds": [
                    "bool"
                ],
                "remap_labels": [
                    "Dict[(str, Optional[str])]"
                ]
            }
        },
        "MultitaskClassifier.score": {
            "name": "score",
            "location": 383,
            "return": [
                "Union[(Dict[(str, float)], pd.DataFrame)]"
            ],
            "arguments": {
                "self": [],
                "dataloaders": [
                    "List[DictDataLoader]"
                ],
                "remap_labels": [
                    "Dict[(str, Optional[str])]"
                ],
                "as_dataframe": [
                    "bool"
                ]
            }
        },
        "MultitaskClassifier._get_labels_to_tasks": {
            "name": "_get_labels_to_tasks",
            "location": 458,
            "return": [
                "Dict[(str, str)]"
            ],
            "arguments": {
                "self": [],
                "label_names": [
                    "Iterable[str]"
                ],
                "remap_labels": [
                    "Dict[(str, Optional[str])]"
                ]
            }
        },
        "MultitaskClassifier._move_to_device": {
            "name": "_move_to_device",
            "location": 481,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultitaskClassifier.save": {
            "name": "save",
            "location": 491,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_path": [
                    "str"
                ]
            }
        },
        "MultitaskClassifier.load": {
            "name": "load",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_path": [
                    "str"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/task.py": {
        "Operation.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module_name": [
                    "str"
                ],
                "inputs": [
                    "Sequence[Union[(str, Tuple[(str, str)])]]"
                ],
                "name": [
                    "Optional[str]"
                ]
            }
        },
        "Operation.__repr__": {
            "name": "__repr__",
            "location": 58,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Task.__init__": {
            "name": "__init__",
            "location": 105,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "module_pool": [
                    "nn.ModuleDict"
                ],
                "op_sequence": [
                    "Sequence[Operation]"
                ],
                "scorer": [
                    "Scorer"
                ],
                "loss_func": [
                    "Optional[Callable[(..., torch.Tensor)]]"
                ],
                "output_func": [
                    "Optional[Callable[(..., torch.Tensor)]]"
                ]
            }
        },
        "Task.__repr__": {
            "name": "__repr__",
            "location": 123,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/snorkel/classification/utils.py": {
        "list_to_tensor": {
            "name": "list_to_tensor",
            "location": 10,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "item_list": [
                    "List[torch.Tensor]"
                ]
            }
        },
        "pad_batch": {
            "name": "pad_batch",
            "location": 29,
            "return": [
                "Tuple[(torch.Tensor, torch.Tensor)]"
            ],
            "arguments": {
                "batch": [
                    "List[torch.Tensor]"
                ],
                "max_len": [
                    "int"
                ],
                "pad_value": [
                    "int"
                ],
                "left_padded": [
                    "bool"
                ]
            }
        },
        "move_to_device": {
            "name": "move_to_device",
            "location": 76,
            "return": [
                "TensorCollection"
            ],
            "arguments": {
                "obj": [
                    "TensorCollection"
                ],
                "device": [
                    "int"
                ]
            }
        },
        "collect_flow_outputs_by_suffix": {
            "name": "collect_flow_outputs_by_suffix",
            "location": 111,
            "return": [
                "List[torch.Tensor]"
            ],
            "arguments": {
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ],
                "suffix": [
                    "str"
                ]
            }
        },
        "metrics_dict_to_dataframe": {
            "name": "metrics_dict_to_dataframe",
            "location": 122,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "metrics_dict": [
                    "Dict[(str, float)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/__init__.py": {},
    "snorkel-main/snorkel/classification/training/trainer.py": {
        "Trainer.__init__": {
            "name": "__init__",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Optional[str]"
                ]
            }
        },
        "Trainer.fit": {
            "name": "fit",
            "location": 144,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "MultitaskClassifier"
                ],
                "dataloaders": [
                    "List['DictDataLoader']"
                ]
            }
        },
        "Trainer._check_dataloaders": {
            "name": "_check_dataloaders",
            "location": 250,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataloaders": [
                    "List['DictDataLoader']"
                ]
            }
        },
        "Trainer._set_log_writer": {
            "name": "_set_log_writer",
            "location": 266,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._set_checkpointer": {
            "name": "_set_checkpointer",
            "location": 280,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._set_log_manager": {
            "name": "_set_log_manager",
            "location": 293,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._set_optimizer": {
            "name": "_set_optimizer",
            "location": 301,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "nn.Module"
                ]
            }
        },
        "Trainer._set_lr_scheduler": {
            "name": "_set_lr_scheduler",
            "location": 337,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._set_warmup_scheduler": {
            "name": "_set_warmup_scheduler",
            "location": 369,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._update_lr_scheduler": {
            "name": "_update_lr_scheduler",
            "location": 406,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "step": [
                    "int"
                ]
            }
        },
        "Trainer._set_batch_scheduler": {
            "name": "_set_batch_scheduler",
            "location": 415,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._evaluate": {
            "name": "_evaluate",
            "location": 422,
            "return": [
                "Metrics"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "MultitaskClassifier"
                ],
                "dataloaders": [
                    "List['DictDataLoader']"
                ],
                "split": [
                    "str"
                ]
            }
        },
        "Trainer._logging": {
            "name": "_logging",
            "location": 432,
            "return": [
                "Metrics"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "MultitaskClassifier"
                ],
                "dataloaders": [
                    "List['DictDataLoader']"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "Trainer._log_metrics": {
            "name": "_log_metrics",
            "location": 468,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metric_dict": [
                    "Metrics"
                ]
            }
        },
        "Trainer._checkpoint_model": {
            "name": "_checkpoint_model",
            "location": 475,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "MultitaskClassifier"
                ],
                "metric_dict": [
                    "Metrics"
                ]
            }
        },
        "Trainer._aggregate_losses": {
            "name": "_aggregate_losses",
            "location": 484,
            "return": [
                "Metrics"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._reset_losses": {
            "name": "_reset_losses",
            "location": 509,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.save": {
            "name": "save",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "trainer_path": [
                    "str"
                ]
            }
        },
        "Trainer.load": {
            "name": "load",
            "location": 540,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "trainer_path": [
                    "str"
                ],
                "model": [
                    "Optional[MultitaskClassifier]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/training/__init__.py": {},
    "snorkel-main/snorkel/classification/training/loggers/checkpointer.py": {
        "Checkpointer.__init__": {
            "name": "__init__",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "counter_unit": [
                    "str"
                ],
                "evaluation_freq": [
                    "float"
                ]
            }
        },
        "Checkpointer.checkpoint": {
            "name": "checkpoint",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "iteration": [
                    "float"
                ],
                "model": [
                    "MultitaskClassifier"
                ],
                "metric_dict": [
                    "Metrics"
                ]
            }
        },
        "Checkpointer._is_new_best": {
            "name": "_is_new_best",
            "location": 153,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "metric_dict": [
                    "Metrics"
                ]
            }
        },
        "Checkpointer.clear": {
            "name": "clear",
            "location": 178,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Checkpointer.load_best_model": {
            "name": "load_best_model",
            "location": 186,
            "return": [
                "MultitaskClassifier"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "MultitaskClassifier"
                ]
            }
        },
        "Checkpointer._validate_config": {
            "name": "_validate_config",
            "location": 201,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Checkpointer._make_metric_map": {
            "name": "_make_metric_map",
            "location": 214,
            "return": [
                "Dict[(str, str)]"
            ],
            "arguments": {
                "self": [],
                "metric_mode_iter": [
                    "Optional[Iterable[str]]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/training/loggers/log_manager.py": {
        "LogManager.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_batches_per_epoch": [
                    "int"
                ],
                "log_writer": [
                    "Optional[LogWriter]"
                ],
                "checkpointer": [
                    "Optional[Checkpointer]"
                ]
            }
        },
        "LogManager.update": {
            "name": "update",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int"
                ]
            }
        },
        "LogManager.trigger_evaluation": {
            "name": "trigger_evaluation",
            "location": 106,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogManager.trigger_checkpointing": {
            "name": "trigger_checkpointing",
            "location": 114,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogManager.reset": {
            "name": "reset",
            "location": 123,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogManager.cleanup": {
            "name": "cleanup",
            "location": 130,
            "return": [
                "MultitaskClassifier"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "MultitaskClassifier"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/training/loggers/log_writer.py": {
        "LogWriter.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogWriter.add_scalar": {
            "name": "add_scalar",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "value": [
                    "float"
                ],
                "step": [
                    "float"
                ]
            }
        },
        "LogWriter.write_config": {
            "name": "write_config",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "Config"
                ],
                "config_filename": [
                    "str"
                ]
            }
        },
        "LogWriter.write_log": {
            "name": "write_log",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "log_filename": [
                    "str"
                ]
            }
        },
        "LogWriter.write_text": {
            "name": "write_text",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "filename": [
                    "str"
                ]
            }
        },
        "LogWriter.write_json": {
            "name": "write_json",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dict_to_write": [
                    "Mapping[(str, Any)]"
                ],
                "filename": [
                    "str"
                ]
            }
        },
        "LogWriter.cleanup": {
            "name": "cleanup",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/snorkel/classification/training/loggers/tensorboard_writer.py": {
        "TensorBoardWriter.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorBoardWriter.add_scalar": {
            "name": "add_scalar",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "value": [
                    "float"
                ],
                "step": [
                    "float"
                ]
            }
        },
        "TensorBoardWriter.write_config": {
            "name": "write_config",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "Config"
                ],
                "config_filename": [
                    "str"
                ]
            }
        },
        "TensorBoardWriter.cleanup": {
            "name": "cleanup",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/snorkel/classification/training/loggers/__init__.py": {},
    "snorkel-main/snorkel/classification/training/schedulers/scheduler.py": {
        "Scheduler.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scheduler.get_batches": {
            "name": "get_batches",
            "location": 20,
            "return": [
                "BatchIterator"
            ],
            "arguments": {
                "self": [],
                "dataloaders": [
                    "Sequence['DictDataLoader']"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/training/schedulers/sequential_scheduler.py": {
        "SequentialScheduler.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequentialScheduler.get_batches": {
            "name": "get_batches",
            "location": 14,
            "return": [
                "BatchIterator"
            ],
            "arguments": {
                "self": [],
                "dataloaders": [
                    "Sequence[DictDataLoader]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/training/schedulers/shuffled_scheduler.py": {
        "ShuffledScheduler.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ShuffledScheduler.get_batches": {
            "name": "get_batches",
            "location": 15,
            "return": [
                "BatchIterator"
            ],
            "arguments": {
                "self": [],
                "dataloaders": [
                    "Sequence[DictDataLoader]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/classification/training/schedulers/__init__.py": {},
    "snorkel-main/snorkel/contrib/__init__.py": {},
    "snorkel-main/snorkel/labeling/analysis.py": {
        "LFAnalysis.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "lfs": [
                    "Optional[List[LabelingFunction]]"
                ]
            }
        },
        "LFAnalysis._covered_data_points": {
            "name": "_covered_data_points",
            "location": 51,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis._overlapped_data_points": {
            "name": "_overlapped_data_points",
            "location": 55,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis._conflicted_data_points": {
            "name": "_conflicted_data_points",
            "location": 59,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis.label_coverage": {
            "name": "label_coverage",
            "location": 68,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis.label_overlap": {
            "name": "label_overlap",
            "location": 90,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis.label_conflict": {
            "name": "label_conflict",
            "location": 112,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis.lf_polarities": {
            "name": "lf_polarities",
            "location": 134,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis.lf_coverages": {
            "name": "lf_coverages",
            "location": 159,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFAnalysis.lf_overlaps": {
            "name": "lf_overlaps",
            "location": 181,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "normalize_by_coverage": [
                    "bool"
                ]
            }
        },
        "LFAnalysis.lf_conflicts": {
            "name": "lf_conflicts",
            "location": 224,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "normalize_by_overlaps": [
                    "bool"
                ]
            }
        },
        "LFAnalysis.lf_empirical_accuracies": {
            "name": "lf_empirical_accuracies",
            "location": 267,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "Y": [
                    "np.ndarray"
                ]
            }
        },
        "LFAnalysis.lf_empirical_probs": {
            "name": "lf_empirical_probs",
            "location": 291,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "Y": [
                    "np.ndarray"
                ],
                "k": [
                    "int"
                ]
            }
        },
        "LFAnalysis.lf_summary": {
            "name": "lf_summary",
            "location": 323,
            "return": [
                "DataFrame"
            ],
            "arguments": {
                "self": [],
                "Y": [
                    "Optional[np.ndarray]"
                ],
                "est_weights": [
                    "Optional[np.ndarray]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/utils.py": {
        "filter_unlabeled_dataframe": {
            "name": "filter_unlabeled_dataframe",
            "location": 7,
            "return": [
                "Tuple[(pd.DataFrame, np.ndarray)]"
            ],
            "arguments": {
                "X": [
                    "pd.DataFrame"
                ],
                "y": [
                    "np.ndarray"
                ],
                "L": [
                    "np.ndarray"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/__init__.py": {},
    "snorkel-main/snorkel/labeling/apply/core.py": {
        "apply_lfs_to_data_point": {
            "name": "apply_lfs_to_data_point",
            "location": 84,
            "return": [
                "RowData"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "index": [
                    "int"
                ],
                "lfs": [
                    "List[LabelingFunction]"
                ],
                "f_caller": [
                    "_FunctionCaller"
                ]
            }
        },
        "_FunctionCaller.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [],
            "arguments": {
                "self": [],
                "fault_tolerant": [
                    "bool"
                ]
            }
        },
        "_FunctionCaller.__call__": {
            "name": "__call__",
            "location": 26,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "LabelingFunction"
                ],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "BaseLFApplier.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lfs": [
                    "List[LabelingFunction]"
                ]
            }
        },
        "BaseLFApplier._numpy_from_row_data": {
            "name": "_numpy_from_row_data",
            "location": 62,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "List[RowData]"
                ]
            }
        },
        "BaseLFApplier.__repr__": {
            "name": "__repr__",
            "location": 80,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LFApplier.apply": {
            "name": "apply",
            "location": 140,
            "return": [
                "Union[(np.ndarray, Tuple[(np.ndarray, ApplierMetadata)])]"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "Union[(DataPoints, np.ndarray)]"
                ],
                "progress_bar": [
                    "bool"
                ],
                "fault_tolerant": [
                    "bool"
                ],
                "return_meta": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/apply/dask.py": {
        "DaskLFApplier.apply": {
            "name": "apply",
            "location": 23,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "dd.DataFrame"
                ],
                "scheduler": [
                    "Scheduler"
                ],
                "fault_tolerant": [
                    "bool"
                ]
            }
        },
        "PandasParallelLFApplier.apply": {
            "name": "apply",
            "location": 62,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "pd.DataFrame"
                ],
                "n_parallel": [
                    "int"
                ],
                "scheduler": [
                    "Scheduler"
                ],
                "fault_tolerant": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/apply/pandas.py": {
        "apply_lfs_to_data_point": {
            "name": "apply_lfs_to_data_point",
            "location": 16,
            "return": [
                "PandasRowData"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "lfs": [
                    "List[LabelingFunction]"
                ],
                "f_caller": [
                    "_FunctionCaller"
                ]
            }
        },
        "rows_to_triplets": {
            "name": "rows_to_triplets",
            "location": 43,
            "return": [
                "List[RowData]"
            ],
            "arguments": {
                "labels": [
                    "List[PandasRowData]"
                ]
            }
        },
        "PandasLFApplier.apply": {
            "name": "apply",
            "location": 75,
            "return": [
                "Union[(np.ndarray, Tuple[(np.ndarray, ApplierMetadata)])]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "pd.DataFrame"
                ],
                "progress_bar": [
                    "bool"
                ],
                "fault_tolerant": [
                    "bool"
                ],
                "return_meta": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/apply/spark.py": {
        "SparkLFApplier.apply": {
            "name": "apply",
            "location": 21,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "RDD"
                ],
                "fault_tolerant": [
                    "bool"
                ]
            }
        },
        "SparkLFApplier.apply.map_fn": {
            "name": "map_fn",
            "location": 38,
            "return": [
                "RowData"
            ],
            "arguments": {
                "args": [
                    "Tuple[(DataPoint, int)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/apply/__init__.py": {},
    "snorkel-main/snorkel/labeling/lf/core.py": {
        "LabelingFunction.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "f": [
                    "Callable[(..., int)]"
                ],
                "resources": [
                    "Optional[Mapping[(str, Any)]]"
                ],
                "pre": [
                    "Optional[List[BasePreprocessor]]"
                ]
            }
        },
        "LabelingFunction._preprocess_data_point": {
            "name": "_preprocess_data_point",
            "location": 54,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "LabelingFunction.__call__": {
            "name": "__call__",
            "location": 61,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "LabelingFunction.__repr__": {
            "name": "__repr__",
            "location": 79,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "labeling_function.__init__": {
            "name": "__init__",
            "location": 115,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Optional[str]"
                ],
                "resources": [
                    "Optional[Mapping[(str, Any)]]"
                ],
                "pre": [
                    "Optional[List[BasePreprocessor]]"
                ]
            }
        },
        "labeling_function.__call__": {
            "name": "__call__",
            "location": 127,
            "return": [
                "LabelingFunction"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "Callable[(..., int)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/lf/nlp.py": {
        "BaseNLPLabelingFunction._create_preprocessor": {
            "name": "_create_preprocessor",
            "location": 39,
            "return": [
                "SpacyPreprocessor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "SpacyPreprocessorParameters"
                ]
            }
        },
        "BaseNLPLabelingFunction._create_or_check_preprocessor": {
            "name": "_create_or_check_preprocessor",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [],
                "text_field": [
                    "str"
                ],
                "doc_field": [
                    "str"
                ],
                "language": [
                    "str"
                ],
                "disable": [
                    "Optional[List[str]]"
                ],
                "pre": [
                    "List[BasePreprocessor]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ],
                "gpu": [
                    "bool"
                ]
            }
        },
        "BaseNLPLabelingFunction.__init__": {
            "name": "__init__",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "f": [
                    "Callable[(..., int)]"
                ],
                "resources": [
                    "Optional[Mapping[(str, Any)]]"
                ],
                "pre": [
                    "Optional[List[BasePreprocessor]]"
                ],
                "text_field": [
                    "str"
                ],
                "doc_field": [
                    "str"
                ],
                "language": [
                    "str"
                ],
                "disable": [
                    "Optional[List[str]]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ],
                "gpu": [
                    "bool"
                ]
            }
        },
        "NLPLabelingFunction._create_preprocessor": {
            "name": "_create_preprocessor",
            "location": 178,
            "return": [
                "SpacyPreprocessor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "SpacyPreprocessorParameters"
                ]
            }
        },
        "base_nlp_labeling_function.__init__": {
            "name": "__init__",
            "location": 189,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Optional[str]"
                ],
                "resources": [
                    "Optional[Mapping[(str, Any)]]"
                ],
                "pre": [
                    "Optional[List[BasePreprocessor]]"
                ],
                "text_field": [
                    "str"
                ],
                "doc_field": [
                    "str"
                ],
                "language": [
                    "str"
                ],
                "disable": [
                    "Optional[List[str]]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ],
                "gpu": [
                    "bool"
                ]
            }
        },
        "base_nlp_labeling_function.__call__": {
            "name": "__call__",
            "location": 211,
            "return": [
                "BaseNLPLabelingFunction"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "Callable[(..., int)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/lf/nlp_spark.py": {
        "SparkNLPLabelingFunction._create_preprocessor": {
            "name": "_create_preprocessor",
            "location": 56,
            "return": [
                "SpacyPreprocessor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "SpacyPreprocessorParameters"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/lf/__init__.py": {},
    "snorkel-main/snorkel/labeling/model/baselines.py": {
        "RandomVoter.predict_proba": {
            "name": "predict_proba",
            "location": 18,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        },
        "MajorityClassVoter.fit": {
            "name": "fit",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "balance": [
                    "np.ndarray"
                ]
            }
        },
        "MajorityClassVoter.predict_proba": {
            "name": "predict_proba",
            "location": 61,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        },
        "MajorityLabelVoter.predict_proba": {
            "name": "predict_proba",
            "location": 100,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/model/base_labeler.py": {
        "BaseLabeler.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cardinality": [
                    "int"
                ]
            }
        },
        "BaseLabeler.predict_proba": {
            "name": "predict_proba",
            "location": 19,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        },
        "BaseLabeler.predict": {
            "name": "predict",
            "location": 34,
            "return": [
                "Union[(np.ndarray, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "return_probs": [
                    "Optional[bool]"
                ],
                "tie_break_policy": [
                    "str"
                ]
            }
        },
        "BaseLabeler.score": {
            "name": "score",
            "location": 74,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "metrics": [
                    "Optional[List[str]]"
                ],
                "tie_break_policy": [
                    "str"
                ]
            }
        },
        "BaseLabeler.save": {
            "name": "save",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "destination": [
                    "str"
                ]
            }
        },
        "BaseLabeler.load": {
            "name": "load",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "source": [
                    "str"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/model/graph_utils.py": {
        "get_clique_tree": {
            "name": "get_clique_tree",
            "location": 6,
            "return": [
                "nx.Graph"
            ],
            "arguments": {
                "nodes": [
                    "Iterable[int]"
                ],
                "edges": [
                    "List[Tuple[(int, int)]]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/model/label_model.py": {
        "LabelModel.__init__": {
            "name": "__init__",
            "location": 136,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cardinality": [
                    "int"
                ]
            }
        },
        "LabelModel._create_L_ind": {
            "name": "_create_L_ind",
            "location": 148,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        },
        "LabelModel._get_augmented_label_matrix": {
            "name": "_get_augmented_label_matrix",
            "location": 168,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "higher_order": [
                    "bool"
                ]
            }
        },
        "LabelModel._build_mask": {
            "name": "_build_mask",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._generate_O": {
            "name": "_generate_O",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "higher_order": [
                    "bool"
                ]
            }
        },
        "LabelModel._init_params": {
            "name": "_init_params",
            "location": 260,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._get_conditional_probs": {
            "name": "_get_conditional_probs",
            "location": 315,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "mu": [
                    "np.ndarray"
                ]
            }
        },
        "LabelModel.get_conditional_probs": {
            "name": "get_conditional_probs",
            "location": 349,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel.get_weights": {
            "name": "get_weights",
            "location": 367,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel.predict_proba": {
            "name": "predict_proba",
            "location": 389,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        },
        "LabelModel.predict": {
            "name": "predict",
            "location": 423,
            "return": [
                "Union[(np.ndarray, Tuple[(np.ndarray, np.ndarray)])]"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "return_probs": [
                    "Optional[bool]"
                ],
                "tie_break_policy": [
                    "str"
                ]
            }
        },
        "LabelModel.score": {
            "name": "score",
            "location": 469,
            "return": [
                "Dict[(str, float)]"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "Y": [
                    "np.ndarray"
                ],
                "metrics": [
                    "Optional[List[str]]"
                ],
                "tie_break_policy": [
                    "str"
                ]
            }
        },
        "LabelModel._loss_l2": {
            "name": "_loss_l2",
            "location": 515,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "l2": [
                    "float"
                ]
            }
        },
        "LabelModel._loss_mu": {
            "name": "_loss_mu",
            "location": 541,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "l2": [
                    "float"
                ]
            }
        },
        "LabelModel._set_class_balance": {
            "name": "_set_class_balance",
            "location": 559,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "class_balance": [
                    "Optional[List[float]]"
                ],
                "Y_dev": [
                    "Optional[np.ndarray]"
                ]
            }
        },
        "LabelModel._set_constants": {
            "name": "_set_constants",
            "location": 594,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ]
            }
        },
        "LabelModel._create_tree": {
            "name": "_create_tree",
            "location": 600,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._execute_logging": {
            "name": "_execute_logging",
            "location": 604,
            "return": [
                "Metrics"
            ],
            "arguments": {
                "self": [],
                "loss": [
                    "torch.Tensor"
                ]
            }
        },
        "LabelModel._set_logger": {
            "name": "_set_logger",
            "location": 625,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._set_optimizer": {
            "name": "_set_optimizer",
            "location": 630,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._set_lr_scheduler": {
            "name": "_set_lr_scheduler",
            "location": 663,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._set_warmup_scheduler": {
            "name": "_set_warmup_scheduler",
            "location": 695,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._update_lr_scheduler": {
            "name": "_update_lr_scheduler",
            "location": 733,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "step": [
                    "int"
                ]
            }
        },
        "LabelModel._clamp_params": {
            "name": "_clamp_params",
            "location": 742,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel._break_col_permutation_symmetry": {
            "name": "_break_col_permutation_symmetry",
            "location": 763,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelModel.fit": {
            "name": "fit",
            "location": 812,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "L_train": [
                    "np.ndarray"
                ],
                "Y_dev": [
                    "Optional[np.ndarray]"
                ],
                "class_balance": [
                    "Optional[List[float]]"
                ],
                "progress_bar": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/model/logger.py": {
        "Logger.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "log_freq": [
                    "int"
                ]
            }
        },
        "Logger.check": {
            "name": "check",
            "location": 26,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Logger.log": {
            "name": "log",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metrics_dict": [
                    "Dict[(str, float)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/labeling/model/__init__.py": {},
    "snorkel-main/snorkel/map/core.py": {
        "get_parameters": {
            "name": "get_parameters",
            "location": 15,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "f": [
                    "Callable[(..., Any)]"
                ],
                "allow_args": [
                    "bool"
                ],
                "allow_kwargs": [
                    "bool"
                ]
            }
        },
        "is_hashable": {
            "name": "is_hashable",
            "location": 27,
            "return": [
                "bool"
            ],
            "arguments": {
                "obj": [
                    "Any"
                ]
            }
        },
        "get_hashable": {
            "name": "get_hashable",
            "location": 41,
            "return": [
                "Hashable"
            ],
            "arguments": {
                "obj": [
                    "Any"
                ]
            }
        },
        "BaseMapper.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "pre": [
                    "List['BaseMapper']"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ]
            }
        },
        "BaseMapper.reset_cache": {
            "name": "reset_cache",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseMapper._generate_mapped_data_point": {
            "name": "_generate_mapped_data_point",
            "location": 130,
            "return": [
                "Optional[DataPoint]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "BaseMapper.__call__": {
            "name": "__call__",
            "location": 133,
            "return": [
                "Optional[DataPoint]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "BaseMapper.__repr__": {
            "name": "__repr__",
            "location": 168,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Mapper.__init__": {
            "name": "__init__",
            "location": 231,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "field_names": [
                    "Optional[Mapping[(str, str)]]"
                ],
                "mapped_field_names": [
                    "Optional[Mapping[(str, str)]]"
                ],
                "pre": [
                    "Optional[List[BaseMapper]]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ]
            }
        },
        "Mapper.run": {
            "name": "run",
            "location": 247,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Mapper._update_fields": {
            "name": "_update_fields",
            "location": 267,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ],
                "mapped_fields": [
                    "FieldMap"
                ]
            }
        },
        "Mapper._generate_mapped_data_point": {
            "name": "_generate_mapped_data_point",
            "location": 274,
            "return": [
                "Optional[DataPoint]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "LambdaMapper.__init__": {
            "name": "__init__",
            "location": 309,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "f": [
                    "MapFunction"
                ],
                "pre": [
                    "Optional[List[BaseMapper]]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ]
            }
        },
        "LambdaMapper._generate_mapped_data_point": {
            "name": "_generate_mapped_data_point",
            "location": 320,
            "return": [
                "Optional[DataPoint]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "DataPoint"
                ]
            }
        },
        "lambda_mapper.__init__": {
            "name": "__init__",
            "location": 357,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Optional[str]"
                ],
                "pre": [
                    "Optional[List[BaseMapper]]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ]
            }
        },
        "lambda_mapper.__call__": {
            "name": "__call__",
            "location": 371,
            "return": [
                "LambdaMapper"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "MapFunction"
                ]
            }
        }
    },
    "snorkel-main/snorkel/map/spark.py": {
        "_update_fields": {
            "name": "_update_fields",
            "location": 8,
            "return": [
                "Row"
            ],
            "arguments": {
                "x": [
                    "Row"
                ],
                "mapped_fields": [
                    "FieldMap"
                ]
            }
        },
        "make_spark_mapper": {
            "name": "make_spark_mapper",
            "location": 16,
            "return": [
                "Mapper"
            ],
            "arguments": {
                "mapper": [
                    "Mapper"
                ]
            }
        }
    },
    "snorkel-main/snorkel/map/__init__.py": {},
    "snorkel-main/snorkel/preprocess/core.py": {},
    "snorkel-main/snorkel/preprocess/nlp.py": {
        "SpacyPreprocessor.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text_field": [
                    "str"
                ],
                "doc_field": [
                    "str"
                ],
                "language": [
                    "str"
                ],
                "disable": [
                    "Optional[List[str]]"
                ],
                "pre": [
                    "Optional[List[BasePreprocessor]]"
                ],
                "memoize": [
                    "bool"
                ],
                "memoize_key": [
                    "Optional[HashingFunction]"
                ],
                "gpu": [
                    "bool"
                ]
            }
        },
        "SpacyPreprocessor.run": {
            "name": "run",
            "location": 74,
            "return": [
                "FieldMap"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        }
    },
    "snorkel-main/snorkel/preprocess/spark.py": {},
    "snorkel-main/snorkel/preprocess/__init__.py": {},
    "snorkel-main/snorkel/slicing/monitor.py": {
        "slice_dataframe": {
            "name": "slice_dataframe",
            "location": 8,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "df": [
                    "pd.DataFrame"
                ],
                "slicing_function": [
                    "SlicingFunction"
                ]
            }
        }
    },
    "snorkel-main/snorkel/slicing/sliceaware_classifier.py": {
        "SliceAwareClassifier.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "base_architecture": [
                    "nn.Module"
                ],
                "head_dim": [
                    "int"
                ],
                "slice_names": [
                    "List[str]"
                ],
                "input_data_key": [
                    "str"
                ],
                "task_name": [
                    "str"
                ],
                "scorer": [
                    "Scorer"
                ]
            }
        },
        "SliceAwareClassifier.make_slice_dataloader": {
            "name": "make_slice_dataloader",
            "location": 94,
            "return": [
                "DictDataLoader"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "DictDataset"
                ],
                "S": [
                    "np.recarray"
                ]
            }
        },
        "SliceAwareClassifier.score_slices": {
            "name": "score_slices",
            "location": 129,
            "return": [
                "Union[(Dict[(str, float)], pd.DataFrame)]"
            ],
            "arguments": {
                "self": [],
                "dataloaders": [
                    "List[DictDataLoader]"
                ],
                "as_dataframe": [
                    "bool"
                ]
            }
        }
    },
    "snorkel-main/snorkel/slicing/utils.py": {
        "add_slice_labels": {
            "name": "add_slice_labels",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "dataloader": [
                    "DictDataLoader"
                ],
                "base_task": [
                    "Task"
                ],
                "S": [
                    "np.recarray"
                ]
            }
        },
        "convert_to_slice_tasks": {
            "name": "convert_to_slice_tasks",
            "location": 58,
            "return": [
                "List[Task]"
            ],
            "arguments": {
                "base_task": [
                    "Task"
                ],
                "slice_names": [
                    "List[str]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/slicing/__init__.py": {},
    "snorkel-main/snorkel/slicing/apply/core.py": {},
    "snorkel-main/snorkel/slicing/apply/dask.py": {},
    "snorkel-main/snorkel/slicing/apply/spark.py": {},
    "snorkel-main/snorkel/slicing/apply/__init__.py": {},
    "snorkel-main/snorkel/slicing/modules/slice_combiner.py": {
        "SliceCombinerModule.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "slice_ind_key": [
                    "str"
                ],
                "slice_pred_key": [
                    "str"
                ],
                "slice_pred_feat_key": [
                    "str"
                ],
                "temperature": [
                    "float"
                ]
            }
        },
        "SliceCombinerModule.forward": {
            "name": "forward",
            "location": 56,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[(str, torch.Tensor)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/slicing/modules/__init__.py": {},
    "snorkel-main/snorkel/slicing/sf/core.py": {
        "slicing_function.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Optional[str]"
                ],
                "resources": [
                    "Optional[Mapping[(str, Any)]]"
                ],
                "pre": [
                    "Optional[List[BasePreprocessor]]"
                ]
            }
        },
        "slicing_function.__call__": {
            "name": "__call__",
            "location": 59,
            "return": [
                "SlicingFunction"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "Callable[(..., int)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/slicing/sf/nlp.py": {
        "NLPSlicingFunction._create_preprocessor": {
            "name": "_create_preprocessor",
            "location": 81,
            "return": [
                "SpacyPreprocessor"
            ],
            "arguments": {
                "cls": [],
                "parameters": [
                    "SpacyPreprocessorParameters"
                ]
            }
        }
    },
    "snorkel-main/snorkel/slicing/sf/__init__.py": {},
    "snorkel-main/snorkel/synthetic/synthetic_data.py": {
        "generate_simple_label_matrix": {
            "name": "generate_simple_label_matrix",
            "location": 6,
            "return": [
                "Tuple[(np.ndarray, np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "n": [
                    "int"
                ],
                "m": [
                    "int"
                ],
                "cardinality": [
                    "int"
                ],
                "abstain_multiplier": [
                    "float"
                ]
            }
        }
    },
    "snorkel-main/snorkel/synthetic/__init__.py": {},
    "snorkel-main/snorkel/types/classifier.py": {},
    "snorkel-main/snorkel/types/data.py": {},
    "snorkel-main/snorkel/types/hashing.py": {},
    "snorkel-main/snorkel/types/__init__.py": {},
    "snorkel-main/snorkel/utils/config_utils.py": {
        "merge_config": {
            "name": "merge_config",
            "location": 6,
            "return": [
                "Config"
            ],
            "arguments": {
                "config": [
                    "Config"
                ],
                "config_updates": [
                    "Dict[(str, Any)]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/utils/core.py": {
        "_hash": {
            "name": "_hash",
            "location": 7,
            "return": [
                "int"
            ],
            "arguments": {
                "i": [
                    "int"
                ]
            }
        },
        "probs_to_preds": {
            "name": "probs_to_preds",
            "location": 13,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "probs": [
                    "np.ndarray"
                ],
                "tie_break_policy": [
                    "str"
                ],
                "tol": [
                    "float"
                ]
            }
        },
        "preds_to_probs": {
            "name": "preds_to_probs",
            "location": 75,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "preds": [
                    "np.ndarray"
                ],
                "num_classes": [
                    "int"
                ]
            }
        },
        "to_int_label_array": {
            "name": "to_int_label_array",
            "location": 94,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "X": [
                    "np.ndarray"
                ],
                "flatten_vector": [
                    "bool"
                ]
            }
        },
        "filter_labels": {
            "name": "filter_labels",
            "location": 131,
            "return": [
                "Dict[(str, np.ndarray)]"
            ],
            "arguments": {
                "label_dict": [
                    "Dict[(str, Optional[np.ndarray])]"
                ],
                "filter_dict": [
                    "Dict[(str, List[int])]"
                ]
            }
        },
        "_get_mask": {
            "name": "_get_mask",
            "location": 185,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "label_array": [
                    "np.ndarray"
                ],
                "filter_values": [
                    "List[int]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/utils/data_operators.py": {
        "check_unique_names": {
            "name": "check_unique_names",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "names": [
                    "List[str]"
                ]
            }
        }
    },
    "snorkel-main/snorkel/utils/lr_schedulers.py": {},
    "snorkel-main/snorkel/utils/optimizers.py": {},
    "snorkel-main/snorkel/utils/__init__.py": {},
    "snorkel-main/test/__init__.py": {},
    "snorkel-main/test/analysis/test_error_analysis.py": {
        "ErrorAnalysisTest.test_get_label_buckets": {
            "name": "test_get_label_buckets",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ErrorAnalysisTest.test_get_label_buckets_multi": {
            "name": "test_get_label_buckets_multi",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ErrorAnalysisTest.test_get_label_buckets_bad_shape": {
            "name": "test_get_label_buckets_bad_shape",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ErrorAnalysisTest.test_get_label_instances": {
            "name": "test_get_label_instances",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ErrorAnalysisTest.test_get_label_instances_exceptions": {
            "name": "test_get_label_instances_exceptions",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/analysis/test_metrics.py": {
        "MetricsTest.test_accuracy_basic": {
            "name": "test_accuracy_basic",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_bad_inputs": {
            "name": "test_bad_inputs",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_ignores": {
            "name": "test_ignores",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_coverage": {
            "name": "test_coverage",
            "location": 64,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_precision": {
            "name": "test_precision",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_recall": {
            "name": "test_recall",
            "location": 80,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_f1": {
            "name": "test_f1",
            "location": 86,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_f1_multiclass": {
            "name": "test_f1_multiclass",
            "location": 97,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_fbeta": {
            "name": "test_fbeta",
            "location": 106,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_matthews": {
            "name": "test_matthews",
            "location": 122,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_roc_auc": {
            "name": "test_roc_auc",
            "location": 133,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "MetricsTest.test_missing_preds": {
            "name": "test_missing_preds",
            "location": 157,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/analysis/test_scorer.py": {
        "ScorerTest._get_labels": {
            "name": "_get_labels",
            "location": 14,
            "return": [
                "Tuple[(np.ndarray, np.ndarray, np.ndarray)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_scorer": {
            "name": "test_scorer",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_dict_metric": {
            "name": "test_dict_metric",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_invalid_metric": {
            "name": "test_invalid_metric",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_no_metrics": {
            "name": "test_no_metrics",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_no_labels": {
            "name": "test_no_labels",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_no_probs": {
            "name": "test_no_probs",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_abstain_labels": {
            "name": "test_abstain_labels",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_score_slices": {
            "name": "test_score_slices",
            "location": 94,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ScorerTest.test_scorer.pred_sum": {
            "name": "pred_sum",
            "location": 21,
            "return": [],
            "arguments": {
                "golds": [],
                "preds": [],
                "probs": []
            }
        },
        "ScorerTest.test_dict_metric.dict_metric": {
            "name": "dict_metric",
            "location": 33,
            "return": [],
            "arguments": {
                "golds": [],
                "preds": [],
                "probs": []
            }
        },
        "ScorerTest.test_score_slices.sf": {
            "name": "sf",
            "location": 98,
            "return": [],
            "arguments": {
                "x": []
            }
        }
    },
    "snorkel-main/test/augmentation/__init__.py": {},
    "snorkel-main/test/augmentation/apply/test_tf_applier.py": {
        "square": {
            "name": "square",
            "location": 18,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "square_returns_none": {
            "name": "square_returns_none",
            "location": 24,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "modify_in_place": {
            "name": "modify_in_place",
            "location": 32,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "make_df": {
            "name": "make_df",
            "location": 42,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "values": [
                    "list"
                ],
                "index": [
                    "list"
                ],
                "key": [
                    "str"
                ]
            }
        },
        "get_data_dict": {
            "name": "get_data_dict",
            "location": 47,
            "return": [],
            "arguments": {
                "data": [
                    "List[int]"
                ]
            }
        },
        "TestTFApplier._get_x_namespace": {
            "name": "_get_x_namespace",
            "location": 52,
            "return": [
                "List[SimpleNamespace]"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "List[int]"
                ]
            }
        },
        "TestTFApplier._get_x_namespace_dict": {
            "name": "_get_x_namespace_dict",
            "location": 55,
            "return": [
                "List[SimpleNamespace]"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "List[int]"
                ]
            }
        },
        "TestTFApplier.test_tf_applier": {
            "name": "test_tf_applier",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_keep_original": {
            "name": "test_tf_applier_keep_original",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_returns_none": {
            "name": "test_tf_applier_returns_none",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_keep_original_modify_in_place": {
            "name": "test_tf_applier_keep_original_modify_in_place",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_generator": {
            "name": "test_tf_applier_generator",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_keep_original_generator": {
            "name": "test_tf_applier_keep_original_generator",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_returns_none_generator": {
            "name": "test_tf_applier_returns_none_generator",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTFApplier.test_tf_applier_keep_original_modify_in_place_generator": {
            "name": "test_tf_applier_keep_original_modify_in_place_generator",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier._get_x_df": {
            "name": "_get_x_df",
            "location": 152,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier._get_x_df_with_str": {
            "name": "_get_x_df_with_str",
            "location": 155,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier._get_x_df_dict": {
            "name": "_get_x_df_dict",
            "location": 158,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_pandas": {
            "name": "test_tf_applier_pandas",
            "location": 161,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_pandas_keep_original": {
            "name": "test_tf_applier_pandas_keep_original",
            "location": 182,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_returns_none": {
            "name": "test_tf_applier_returns_none",
            "location": 196,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_pandas_modify_in_place": {
            "name": "test_tf_applier_pandas_modify_in_place",
            "location": 210,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_pandas_generator": {
            "name": "test_tf_applier_pandas_generator",
            "location": 222,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_pandas_keep_original_generator": {
            "name": "test_tf_applier_pandas_keep_original_generator",
            "location": 241,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_returns_none_generator": {
            "name": "test_tf_applier_returns_none_generator",
            "location": 256,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPandasTFApplier.test_tf_applier_pandas_modify_in_place_generator": {
            "name": "test_tf_applier_pandas_modify_in_place_generator",
            "location": 271,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/augmentation/apply/__init__.py": {},
    "snorkel-main/test/augmentation/policy/test_core.py": {
        "TestPolicy.test_apply_each_policy": {
            "name": "test_apply_each_policy",
            "location": 7,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestPolicy.test_apply_all_policy": {
            "name": "test_apply_all_policy",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/augmentation/policy/test_sampling.py": {
        "TestSamplingPolicy.test_random_policy": {
            "name": "test_random_policy",
            "location": 7,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestSamplingPolicy.test_mean_field_policy": {
            "name": "test_mean_field_policy",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/augmentation/policy/__init__.py": {},
    "snorkel-main/test/classification/test_classifier_convergence.py": {
        "create_data": {
            "name": "create_data",
            "location": 78,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "n": [
                    "int"
                ],
                "offset": []
            }
        },
        "create_dataloader": {
            "name": "create_dataloader",
            "location": 90,
            "return": [
                "DictDataLoader"
            ],
            "arguments": {
                "df": [
                    "pd.DataFrame"
                ],
                "split": [
                    "str"
                ],
                "task_name": [
                    "str"
                ]
            }
        },
        "create_task": {
            "name": "create_task",
            "location": 108,
            "return": [
                "Task"
            ],
            "arguments": {
                "task_name": [
                    "str"
                ],
                "module_suffixes": [
                    "List[str]"
                ]
            }
        },
        "ClassifierConvergenceTest.setUpClass": {
            "name": "setUpClass",
            "location": 27,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "ClassifierConvergenceTest.test_convergence": {
            "name": "test_convergence",
            "location": 34,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/test_data.py": {
        "DatasetTest.test_classifier_dataset": {
            "name": "test_classifier_dataset",
            "location": 14,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "DatasetTest.test_classifier_dataloader": {
            "name": "test_classifier_dataloader",
            "location": 47,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/test_loss.py": {
        "SoftCrossEntropyTest.test_sce_equals_ce": {
            "name": "test_sce_equals_ce",
            "location": 12,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SoftCrossEntropyTest.test_perfect_predictions": {
            "name": "test_perfect_predictions",
            "location": 39,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SoftCrossEntropyTest.test_lower_loss": {
            "name": "test_lower_loss",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SoftCrossEntropyTest.test_equal_loss": {
            "name": "test_equal_loss",
            "location": 60,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SoftCrossEntropyTest.test_invalid_reduction": {
            "name": "test_invalid_reduction",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SoftCrossEntropyTest.test_loss_weights": {
            "name": "test_loss_weights",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/test_multitask_classifier.py": {
        "create_dataloader": {
            "name": "create_dataloader",
            "location": 249,
            "return": [],
            "arguments": {
                "task_name": [],
                "split": []
            }
        },
        "create_task": {
            "name": "create_task",
            "location": 261,
            "return": [],
            "arguments": {
                "task_name": [],
                "module_suffixes": []
            }
        },
        "ClassifierTest.setUpClass": {
            "name": "setUpClass",
            "location": 25,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "ClassifierTest.setUp": {
            "name": "setUp",
            "location": 30,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_onetask_model": {
            "name": "test_onetask_model",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_twotask_none_overlap_model": {
            "name": "test_twotask_none_overlap_model",
            "location": 41,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_twotask_all_overlap_model": {
            "name": "test_twotask_all_overlap_model",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_twotask_partial_overlap_model": {
            "name": "test_twotask_partial_overlap_model",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_bad_tasks": {
            "name": "test_bad_tasks",
            "location": 66,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_no_data_parallel": {
            "name": "test_no_data_parallel",
            "location": 78,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_no_input_spec": {
            "name": "test_no_input_spec",
            "location": 83,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_predict": {
            "name": "test_predict",
            "location": 95,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_empty_batch": {
            "name": "test_empty_batch",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_partially_empty_batch": {
            "name": "test_partially_empty_batch",
            "location": 122,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_remapped_labels": {
            "name": "test_remapped_labels",
            "location": 129,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_score": {
            "name": "test_score",
            "location": 162,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_score_shuffled": {
            "name": "test_score_shuffled",
            "location": 173,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_save_load": {
            "name": "test_save_load",
            "location": 215,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ClassifierTest.test_score_shuffled.SimpleVoter.forward": {
            "name": "forward",
            "location": 177,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        }
    },
    "snorkel-main/test/classification/test_task.py": {
        "TaskTest.test_task_creation": {
            "name": "test_task_creation",
            "location": 11,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/test_utils.py": {
        "UtilsTest.test_pad_batch": {
            "name": "test_pad_batch",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_list_to_tensor": {
            "name": "test_list_to_tensor",
            "location": 58,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_collect_flow_outputs_by_suffix": {
            "name": "test_collect_flow_outputs_by_suffix",
            "location": 118,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/__init__.py": {},
    "snorkel-main/test/classification/training/test_trainer.py": {
        "create_dataloader": {
            "name": "create_dataloader",
            "location": 29,
            "return": [],
            "arguments": {
                "task_name": [],
                "split": []
            }
        },
        "create_task": {
            "name": "create_task",
            "location": 41,
            "return": [],
            "arguments": {
                "task_name": [],
                "module_suffixes": []
            }
        },
        "TrainerTest.test_trainer_onetask": {
            "name": "test_trainer_onetask",
            "location": 71,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_trainer_twotask": {
            "name": "test_trainer_twotask",
            "location": 76,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_trainer_errors": {
            "name": "test_trainer_errors",
            "location": 82,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_checkpointer_init": {
            "name": "test_checkpointer_init",
            "location": 96,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_log_writer_init": {
            "name": "test_log_writer_init",
            "location": 116,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_log_writer_json": {
            "name": "test_log_writer_json",
            "location": 148,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_optimizer_init": {
            "name": "test_optimizer_init",
            "location": 166,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_scheduler_init": {
            "name": "test_scheduler_init",
            "location": 183,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_warmup": {
            "name": "test_warmup",
            "location": 204,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.test_save_load": {
            "name": "test_save_load",
            "location": 220,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainerTest.dict_check": {
            "name": "dict_check",
            "location": 246,
            "return": [],
            "arguments": {
                "self": [],
                "dict1": [],
                "dict2": []
            }
        }
    },
    "snorkel-main/test/classification/training/loggers/test_checkpointer.py": {
        "TestLogManager.setUp": {
            "name": "setUp",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.tearDown": {
            "name": "tearDown",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_checkpointer": {
            "name": "test_checkpointer",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_checkpointer_min": {
            "name": "test_checkpointer_min",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_checkpointer_clear": {
            "name": "test_checkpointer_clear",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_checkpointer_load_best": {
            "name": "test_checkpointer_load_best",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_bad_checkpoint_runway": {
            "name": "test_bad_checkpoint_runway",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_no_zero_frequency": {
            "name": "test_no_zero_frequency",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_bad_metric_name": {
            "name": "test_bad_metric_name",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/training/loggers/test_log_manager.py": {
        "TestLogManager.setUp": {
            "name": "setUp",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.tearDown": {
            "name": "tearDown",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_log_manager_points": {
            "name": "test_log_manager_points",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_log_manager_batch": {
            "name": "test_log_manager_batch",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_log_manager_epoch": {
            "name": "test_log_manager_epoch",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_load_on_cleanup": {
            "name": "test_load_on_cleanup",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogManager.test_bad_unit": {
            "name": "test_bad_unit",
            "location": 123,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/training/loggers/test_log_writer.py": {
        "TestLogWriter.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLogWriter.tearDown": {
            "name": "tearDown",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLogWriter.test_log_writer": {
            "name": "test_log_writer",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLogWriter.test_write_text": {
            "name": "test_write_text",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLogWriter.test_write_config": {
            "name": "test_write_config",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/training/loggers/test_tensorboard_writer.py": {
        "TestTensorBoardWriter.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTensorBoardWriter.tearDown": {
            "name": "tearDown",
            "location": 20,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestTensorBoardWriter.test_tensorboard_writer": {
            "name": "test_tensorboard_writer",
            "location": 23,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/classification/training/loggers/__init__.py": {},
    "snorkel-main/test/classification/training/schedulers/test_schedulers.py": {
        "SequentialTest.test_sequential": {
            "name": "test_sequential",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SequentialTest.test_shuffled": {
            "name": "test_shuffled",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/test_analysis.py": {
        "f": {
            "name": "f",
            "location": 29,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "TestAnalysis.setUp": {
            "name": "setUp",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_label_coverage": {
            "name": "test_label_coverage",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_label_overlap": {
            "name": "test_label_overlap",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_label_conflict": {
            "name": "test_label_conflict",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_polarities": {
            "name": "test_lf_polarities",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_coverages": {
            "name": "test_lf_coverages",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_overlaps": {
            "name": "test_lf_overlaps",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_conflicts": {
            "name": "test_lf_conflicts",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_empirical_accuracies": {
            "name": "test_lf_empirical_accuracies",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_empirical_probs": {
            "name": "test_lf_empirical_probs",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_summary": {
            "name": "test_lf_summary",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_wrong_number_of_lfs": {
            "name": "test_wrong_number_of_lfs",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAnalysis.test_lf_summary_without_abstain": {
            "name": "test_lf_summary_without_abstain",
            "location": 144,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/test_convergence.py": {
        "create_data": {
            "name": "create_data",
            "location": 15,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "get_positive_labeling_function": {
            "name": "get_positive_labeling_function",
            "location": 26,
            "return": [
                "LabelingFunction"
            ],
            "arguments": {
                "divisor": [
                    "int"
                ]
            }
        },
        "get_negative_labeling_function": {
            "name": "get_negative_labeling_function",
            "location": 35,
            "return": [
                "LabelingFunction"
            ],
            "arguments": {
                "divisor": [
                    "int"
                ]
            }
        },
        "copy_features": {
            "name": "copy_features",
            "location": 45,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "f": {
            "name": "f",
            "location": 52,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "divisor": [
                    "int"
                ]
            }
        },
        "get_positive_labeling_function.f": {
            "name": "f",
            "location": 29,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "get_negative_labeling_function.f": {
            "name": "f",
            "location": 38,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "LabelingConvergenceTest.setUpClass": {
            "name": "setUpClass",
            "location": 59,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "LabelingConvergenceTest.test_labeling_convergence": {
            "name": "test_labeling_convergence",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/test_utils.py": {
        "TestAnalysis.test_filter_unlabeled_dataframe": {
            "name": "test_filter_unlabeled_dataframe",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/__init__.py": {},
    "snorkel-main/test/labeling/apply/lf_applier_spark_test_script.py": {
        "f": {
            "name": "f",
            "location": 45,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g": {
            "name": "g",
            "location": 50,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "build_lf_matrix": {
            "name": "build_lf_matrix",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "snorkel-main/test/labeling/apply/test_lf_applier.py": {
        "square": {
            "name": "square",
            "location": 19,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "f": {
            "name": "f",
            "location": 34,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "fp": {
            "name": "fp",
            "location": 39,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g": {
            "name": "g",
            "location": 44,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "h": {
            "name": "h",
            "location": 49,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "f_np": {
            "name": "f_np",
            "location": 54,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g_np": {
            "name": "g_np",
            "location": 59,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "f_bad": {
            "name": "f_bad",
            "location": 64,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "SquareHitTracker.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SquareHitTracker.__call__": {
            "name": "__call__",
            "location": 28,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ]
            }
        },
        "TestLFApplier.test_lf_applier": {
            "name": "test_lf_applier",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLFApplier.test_lf_applier_fault": {
            "name": "test_lf_applier_fault",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLFApplier.test_lf_applier_preprocessor": {
            "name": "test_lf_applier_preprocessor",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLFApplier.test_lf_applier_preprocessor_memoized": {
            "name": "test_lf_applier_preprocessor_memoized",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLFApplier.test_lf_applier_no_labels": {
            "name": "test_lf_applier_no_labels",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLFApplier.test_lf_applier_numpy": {
            "name": "test_lf_applier_numpy",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasApplier.test_lf_applier_pandas": {
            "name": "test_lf_applier_pandas",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_fault": {
            "name": "test_lf_applier_pandas_fault",
            "location": 151,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_preprocessor": {
            "name": "test_lf_applier_pandas_preprocessor",
            "location": 164,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_preprocessor_memoized": {
            "name": "test_lf_applier_pandas_preprocessor_memoized",
            "location": 170,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_spacy_preprocessor": {
            "name": "test_lf_applier_pandas_spacy_preprocessor",
            "location": 188,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_spacy_preprocessor_memoized": {
            "name": "test_lf_applier_pandas_spacy_preprocessor_memoized",
            "location": 204,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_dask": {
            "name": "test_lf_applier_dask",
            "location": 224,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_dask_fault": {
            "name": "test_lf_applier_dask_fault",
            "location": 231,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_dask_preprocessor": {
            "name": "test_lf_applier_dask_preprocessor",
            "location": 240,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_preprocessor_memoized": {
            "name": "test_lf_applier_pandas_preprocessor_memoized",
            "location": 247,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_dask_spacy_preprocessor": {
            "name": "test_lf_applier_dask_spacy_preprocessor",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_spacy_preprocessor_memoized": {
            "name": "test_lf_applier_pandas_spacy_preprocessor_memoized",
            "location": 282,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_parallel": {
            "name": "test_lf_applier_pandas_parallel",
            "location": 300,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_parallel_raises": {
            "name": "test_lf_applier_pandas_parallel_raises",
            "location": 306,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLFApplier.test_lf_applier_preprocessor_memoized.square_memoize": {
            "name": "square_memoize",
            "location": 113,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestLFApplier.test_lf_applier_preprocessor_memoized.fp_memoized": {
            "name": "fp_memoized",
            "location": 118,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_preprocessor_memoized.square_memoize": {
            "name": "square_memoize",
            "location": 174,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_preprocessor_memoized.fp_memoized": {
            "name": "fp_memoized",
            "location": 179,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_spacy_preprocessor.first_is_name": {
            "name": "first_is_name",
            "location": 192,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_spacy_preprocessor.has_verb": {
            "name": "has_verb",
            "location": 196,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_spacy_preprocessor_memoized.first_is_name": {
            "name": "first_is_name",
            "location": 209,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestPandasApplier.test_lf_applier_pandas_spacy_preprocessor_memoized.has_verb": {
            "name": "has_verb",
            "location": 213,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_preprocessor_memoized.square_memoize": {
            "name": "square_memoize",
            "location": 249,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_preprocessor_memoized.fp_memoized": {
            "name": "fp_memoized",
            "location": 254,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestDaskApplier.test_lf_applier_dask_spacy_preprocessor.first_is_name": {
            "name": "first_is_name",
            "location": 268,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestDaskApplier.test_lf_applier_dask_spacy_preprocessor.has_verb": {
            "name": "has_verb",
            "location": 272,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_spacy_preprocessor_memoized.first_is_name": {
            "name": "first_is_name",
            "location": 287,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestDaskApplier.test_lf_applier_pandas_spacy_preprocessor_memoized.has_verb": {
            "name": "has_verb",
            "location": 291,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/labeling/apply/test_spark.py": {
        "square": {
            "name": "square",
            "location": 17,
            "return": [
                "Row"
            ],
            "arguments": {
                "x": [
                    "Row"
                ]
            }
        },
        "f": {
            "name": "f",
            "location": 22,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "fp": {
            "name": "fp",
            "location": 27,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g": {
            "name": "g",
            "location": 32,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "f_bad": {
            "name": "f_bad",
            "location": 37,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestSparkApplier.test_lf_applier_spark": {
            "name": "test_lf_applier_spark",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSparkApplier.test_lf_applier_spark_fault": {
            "name": "test_lf_applier_spark_fault",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSparkApplier.test_lf_applier_spark_preprocessor": {
            "name": "test_lf_applier_spark_preprocessor",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSparkApplier.test_lf_applier_spark_preprocessor_memoized": {
            "name": "test_lf_applier_spark_preprocessor_memoized",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSparkApplier.test_lf_applier_spark_preprocessor_memoized.square_memoize": {
            "name": "square_memoize",
            "location": 93,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestSparkApplier.test_lf_applier_spark_preprocessor_memoized.fp_memoized": {
            "name": "fp_memoized",
            "location": 97,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/labeling/apply/__init__.py": {},
    "snorkel-main/test/labeling/lf/test_core.py": {
        "square": {
            "name": "square",
            "location": 12,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "returns_none": {
            "name": "returns_none",
            "location": 18,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "f": {
            "name": "f",
            "location": 22,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g": {
            "name": "g",
            "location": 26,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "TestLabelingFunction._run_lf": {
            "name": "_run_lf",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lf": [
                    "LabelingFunction"
                ]
            }
        },
        "TestLabelingFunction.test_labeling_function": {
            "name": "test_labeling_function",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_resources": {
            "name": "test_labeling_function_resources",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_preprocessor": {
            "name": "test_labeling_function_preprocessor",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_returns_none": {
            "name": "test_labeling_function_returns_none",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_serialize": {
            "name": "test_labeling_function_serialize",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_decorator": {
            "name": "test_labeling_function_decorator",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_decorator_args": {
            "name": "test_labeling_function_decorator_args",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_decorator_no_parens": {
            "name": "test_labeling_function_decorator_no_parens",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelingFunction.test_labeling_function_decorator.lf": {
            "name": "lf",
            "location": 69,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestLabelingFunction.test_labeling_function_decorator_args.lf": {
            "name": "lf",
            "location": 80,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "TestLabelingFunction.test_labeling_function_decorator_no_parens.lf": {
            "name": "lf",
            "location": 91,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/labeling/lf/test_nlp.py": {
        "combine_text": {
            "name": "combine_text",
            "location": 13,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "has_person_mention": {
            "name": "has_person_mention",
            "location": 18,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestNLPLabelingFunction._run_lf": {
            "name": "_run_lf",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lf": [
                    "NLPLabelingFunction"
                ]
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function": {
            "name": "test_nlp_labeling_function",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_memoized": {
            "name": "test_nlp_labeling_function_memoized",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_labeling_function_serialize": {
            "name": "test_labeling_function_serialize",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_decorator": {
            "name": "test_nlp_labeling_function_decorator",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_decorator_no_parens": {
            "name": "test_nlp_labeling_function_decorator_no_parens",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_shared_cache": {
            "name": "test_nlp_labeling_function_shared_cache",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_raises": {
            "name": "test_nlp_labeling_function_raises",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_decorator.has_person_mention": {
            "name": "has_person_mention",
            "location": 53,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_shared_cache.lf2": {
            "name": "lf2",
            "location": 73,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_decorator_no_parens.has_person_mention": {
            "name": "has_person_mention",
            "location": 65,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_raises.has_person_mention": {
            "name": "has_person_mention",
            "location": 91,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/labeling/lf/test_nlp_spark.py": {
        "has_person_mention": {
            "name": "has_person_mention",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestNLPLabelingFunction._run_lf": {
            "name": "_run_lf",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lf": [
                    "SparkNLPLabelingFunction"
                ]
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function": {
            "name": "test_nlp_labeling_function",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_decorator": {
            "name": "test_nlp_labeling_function_decorator",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_spark_nlp_labeling_function_with_nlp_labeling_function": {
            "name": "test_spark_nlp_labeling_function_with_nlp_labeling_function",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPLabelingFunction.test_nlp_labeling_function_decorator.has_person_mention": {
            "name": "has_person_mention",
            "location": 34,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/labeling/model/test_baseline.py": {
        "BaselineModelTest.test_random_vote": {
            "name": "test_random_vote",
            "location": 9,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BaselineModelTest.test_majority_class_vote": {
            "name": "test_majority_class_vote",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BaselineModelTest.test_majority_label_vote": {
            "name": "test_majority_label_vote",
            "location": 28,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/model/test_label_model.py": {
        "LabelModelTest._set_up_model": {
            "name": "_set_up_model",
            "location": 18,
            "return": [],
            "arguments": {
                "self": [],
                "L": [
                    "np.ndarray"
                ],
                "class_balance": [
                    "List[float]"
                ]
            }
        },
        "LabelModelTest.test_L_form": {
            "name": "test_L_form",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_mv_default": {
            "name": "test_mv_default",
            "location": 46,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_prec_init": {
            "name": "test_prec_init",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_class_balance": {
            "name": "test_class_balance",
            "location": 111,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_generate_O": {
            "name": "test_generate_O",
            "location": 132,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_augmented_L_construction": {
            "name": "test_augmented_L_construction",
            "location": 174,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_conditional_probs": {
            "name": "test_conditional_probs",
            "location": 208,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_get_weight": {
            "name": "test_get_weight",
            "location": 215,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_build_mask": {
            "name": "test_build_mask",
            "location": 238,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_init_params": {
            "name": "test_init_params",
            "location": 259,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_predict_proba": {
            "name": "test_predict_proba",
            "location": 284,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_predict": {
            "name": "test_predict",
            "location": 295,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_score": {
            "name": "test_score",
            "location": 317,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_progress_bar": {
            "name": "test_progress_bar",
            "location": 342,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_loss": {
            "name": "test_loss",
            "location": 355,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_model_loss": {
            "name": "test_model_loss",
            "location": 368,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_optimizer": {
            "name": "test_optimizer",
            "location": 383,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_lr_scheduler": {
            "name": "test_lr_scheduler",
            "location": 392,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_save_and_load": {
            "name": "test_save_and_load",
            "location": 403,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_optimizer_init": {
            "name": "test_optimizer_init",
            "location": 420,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_scheduler_init": {
            "name": "test_scheduler_init",
            "location": 436,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_warmup": {
            "name": "test_warmup",
            "location": 454,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_set_mu_eps": {
            "name": "test_set_mu_eps",
            "location": 470,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_symmetry_breaking": {
            "name": "test_symmetry_breaking",
            "location": 480,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LabelModelTest.test_symmetry_breaking_multiclass": {
            "name": "test_symmetry_breaking_multiclass",
            "location": 513,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestLabelModelAdvanced.setUp": {
            "name": "setUp",
            "location": 556,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelModelAdvanced.test_label_model_basic": {
            "name": "test_label_model_basic",
            "location": 562,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelModelAdvanced.test_label_model_sparse": {
            "name": "test_label_model_sparse",
            "location": 582,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/model/test_logger.py": {
        "LoggerTest.test_basic": {
            "name": "test_basic",
            "location": 7,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LoggerTest.test_bad_metrics_dict": {
            "name": "test_bad_metrics_dict",
            "location": 16,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LoggerTest.test_valid_metrics_dict": {
            "name": "test_valid_metrics_dict",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/model/__init__.py": {},
    "snorkel-main/test/labeling/preprocess/test_nlp.py": {
        "TestSpacyPreprocessor.test_spacy_preprocessor": {
            "name": "test_spacy_preprocessor",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/labeling/preprocess/__init__.py": {},
    "snorkel-main/test/map/test_core.py": {
        "square": {
            "name": "square",
            "location": 66,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "modify_in_place": {
            "name": "modify_in_place",
            "location": 72,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "SplitWordsMapper.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "text_field": [
                    "str"
                ],
                "lower_field": [
                    "str"
                ],
                "words_field": [
                    "str"
                ]
            }
        },
        "SplitWordsMapper.run": {
            "name": "run",
            "location": 22,
            "return": [
                "FieldMap"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "SplitWordsMapperDefaultArgs.run": {
            "name": "run",
            "location": 27,
            "return": [
                "FieldMap"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "MapperReturnsNone.run": {
            "name": "run",
            "location": 32,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "MapperWithArgs.run": {
            "name": "run",
            "location": 37,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "MapperWithKwargs.run": {
            "name": "run",
            "location": 42,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "MapperWithPre.run": {
            "name": "run",
            "location": 47,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": [],
                "num_squared": [
                    "float"
                ]
            }
        },
        "MapperWithPre2.run": {
            "name": "run",
            "location": 52,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": [],
                "double_num_squared": [
                    "float"
                ]
            }
        },
        "SquareHitTracker.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SquareHitTracker.__call__": {
            "name": "__call__",
            "location": 60,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ]
            }
        },
        "TestMapperCore._get_x": {
            "name": "_get_x",
            "location": 79,
            "return": [
                "SimpleNamespace"
            ],
            "arguments": {
                "self": [],
                "num": [],
                "text": []
            }
        },
        "TestMapperCore._get_x_dict": {
            "name": "_get_x_dict",
            "location": 82,
            "return": [
                "SimpleNamespace"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_numeric_mapper": {
            "name": "test_numeric_mapper",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_text_mapper": {
            "name": "test_text_mapper",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_same_field": {
            "name": "test_mapper_same_field",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_default_args": {
            "name": "test_mapper_default_args",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_in_place": {
            "name": "test_mapper_in_place",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_returns_none": {
            "name": "test_mapper_returns_none",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_pre": {
            "name": "test_mapper_pre",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_pre_decorator": {
            "name": "test_mapper_pre_decorator",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized": {
            "name": "test_decorator_mapper_memoized",
            "location": 215,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized_none": {
            "name": "test_decorator_mapper_memoized_none",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized_use_memoize_key": {
            "name": "test_decorator_mapper_memoized_use_memoize_key",
            "location": 266,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_not_memoized": {
            "name": "test_decorator_mapper_not_memoized",
            "location": 289,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_pre_memoized": {
            "name": "test_mapper_pre_memoized",
            "location": 316,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_decorator_no_parens": {
            "name": "test_mapper_decorator_no_parens",
            "location": 354,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_with_args_kwargs": {
            "name": "test_mapper_with_args_kwargs",
            "location": 362,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_hashable": {
            "name": "test_get_hashable_hashable",
            "location": 371,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_dict": {
            "name": "test_get_hashable_dict",
            "location": 376,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_list": {
            "name": "test_get_hashable_list",
            "location": 384,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_series": {
            "name": "test_get_hashable_series",
            "location": 391,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_series_with_doc": {
            "name": "test_get_hashable_series_with_doc",
            "location": 399,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_ndarray": {
            "name": "test_get_hashable_ndarray",
            "location": 408,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGetHashable.test_get_hashable_unhashable": {
            "name": "test_get_hashable_unhashable",
            "location": 415,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_pre_decorator.mapper_no_pre": {
            "name": "mapper_no_pre",
            "location": 175,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_mapper_pre_decorator.mapper_pre": {
            "name": "mapper_pre",
            "location": 184,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_mapper_pre_decorator.mapper_pre_2": {
            "name": "mapper_pre_2",
            "location": 198,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized.square": {
            "name": "square",
            "location": 219,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized_none.square": {
            "name": "square",
            "location": 252,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized_use_memoize_key.square": {
            "name": "square",
            "location": 270,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_decorator_mapper_not_memoized.square": {
            "name": "square",
            "location": 293,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_mapper_pre_memoized.square": {
            "name": "square",
            "location": 320,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_mapper_pre_memoized.mapper_pre": {
            "name": "mapper_pre",
            "location": 325,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_mapper_decorator_no_parens.square": {
            "name": "square",
            "location": 358,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/map/test_spark.py": {
        "square": {
            "name": "square",
            "location": 44,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "modify_in_place": {
            "name": "modify_in_place",
            "location": 51,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "SplitWordsMapper.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "text_field": [
                    "str"
                ],
                "lower_field": [
                    "str"
                ],
                "words_field": [
                    "str"
                ]
            }
        },
        "SplitWordsMapper.run": {
            "name": "run",
            "location": 20,
            "return": [
                "FieldMap"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "SplitWordsMapperDefaultArgs.run": {
            "name": "run",
            "location": 25,
            "return": [
                "FieldMap"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "MapperReturnsNone.run": {
            "name": "run",
            "location": 30,
            "return": [
                "Optional[FieldMap]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "SquareHitTracker.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SquareHitTracker.__call__": {
            "name": "__call__",
            "location": 38,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ]
            }
        },
        "TestMapperCore._get_x": {
            "name": "_get_x",
            "location": 57,
            "return": [
                "Row"
            ],
            "arguments": {
                "self": [],
                "num": [],
                "text": []
            }
        },
        "TestMapperCore._get_x_dict": {
            "name": "_get_x_dict",
            "location": 60,
            "return": [
                "Row"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_numeric_mapper": {
            "name": "test_numeric_mapper",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_text_mapper": {
            "name": "test_text_mapper",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_same_field": {
            "name": "test_mapper_same_field",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_default_args": {
            "name": "test_mapper_default_args",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_in_place": {
            "name": "test_mapper_in_place",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_mapper_returns_none": {
            "name": "test_mapper_returns_none",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized": {
            "name": "test_decorator_mapper_memoized",
            "location": 131,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized_none": {
            "name": "test_decorator_mapper_memoized_none",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_not_memoized": {
            "name": "test_decorator_mapper_not_memoized",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized.square": {
            "name": "square",
            "location": 135,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_decorator_mapper_memoized_none.square": {
            "name": "square",
            "location": 170,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestMapperCore.test_decorator_mapper_not_memoized.square": {
            "name": "square",
            "location": 190,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/map/__init__.py": {},
    "snorkel-main/test/slicing/test_convergence.py": {
        "f": {
            "name": "f",
            "location": 31,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g": {
            "name": "g",
            "location": 39,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "h": {
            "name": "h",
            "location": 47,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "create_data": {
            "name": "create_data",
            "location": 177,
            "return": [
                "pd.DataFrame"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "create_dataloader": {
            "name": "create_dataloader",
            "location": 185,
            "return": [
                "DictDataLoader"
            ],
            "arguments": {
                "df": [
                    "pd.DataFrame"
                ],
                "split": [
                    "str"
                ]
            }
        },
        "create_task": {
            "name": "create_task",
            "location": 203,
            "return": [
                "Task"
            ],
            "arguments": {
                "task_name": [
                    "str"
                ],
                "module_suffixes": [
                    "List[str]"
                ]
            }
        },
        "SlicingConvergenceTest.setUpClass": {
            "name": "setUpClass",
            "location": 56,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "SlicingConvergenceTest.test_convergence": {
            "name": "test_convergence",
            "location": 70,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SlicingConvergenceTest.test_performance": {
            "name": "test_performance",
            "location": 124,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/slicing/test_monitor.py": {
        "sf": {
            "name": "sf",
            "location": 12,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "PandasSlicerTest.setUpClass": {
            "name": "setUpClass",
            "location": 18,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "PandasSlicerTest.test_slice": {
            "name": "test_slice",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/slicing/test_sliceaware_classifier.py": {
        "f": {
            "name": "f",
            "location": 13,
            "return": [
                "int"
            ],
            "arguments": {
                "x": []
            }
        },
        "g": {
            "name": "g",
            "location": 18,
            "return": [
                "int"
            ],
            "arguments": {
                "x": []
            }
        },
        "create_dataset": {
            "name": "create_dataset",
            "location": 26,
            "return": [],
            "arguments": {
                "X": [],
                "Y": [],
                "split": [],
                "dataset_name": [],
                "input_name": [],
                "task_name": []
            }
        },
        "SliceCombinerTest.setUp": {
            "name": "setUp",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_slice_tasks": {
            "name": "test_slice_tasks",
            "location": 75,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_make_slice_dataloader": {
            "name": "test_make_slice_dataloader",
            "location": 92,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_scores_pipeline": {
            "name": "test_scores_pipeline",
            "location": 117,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/slicing/test_slice_combiner.py": {
        "SliceCombinerTest.setUpClass": {
            "name": "setUpClass",
            "location": 12,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "SliceCombinerTest.test_forward_shape": {
            "name": "test_forward_shape",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_average_reweighting": {
            "name": "test_average_reweighting",
            "location": 77,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_average_reweighting_by_ind": {
            "name": "test_average_reweighting_by_ind",
            "location": 95,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_average_reweighting_by_pred_confidence": {
            "name": "test_average_reweighting_by_pred_confidence",
            "location": 113,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_many_slices": {
            "name": "test_many_slices",
            "location": 144,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_combiner_multiclass": {
            "name": "test_combiner_multiclass",
            "location": 176,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SliceCombinerTest.test_temperature": {
            "name": "test_temperature",
            "location": 220,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/slicing/test_utils.py": {
        "f": {
            "name": "f",
            "location": 17,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "create_dummy_task": {
            "name": "create_dummy_task",
            "location": 112,
            "return": [],
            "arguments": {
                "task_name": []
            }
        },
        "UtilsTest.test_add_slice_labels": {
            "name": "test_add_slice_labels",
            "location": 22,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_convert_to_slice_tasks": {
            "name": "test_convert_to_slice_tasks",
            "location": 71,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/slicing/__init__.py": {},
    "snorkel-main/test/slicing/apply/test_sf_applier.py": {
        "square": {
            "name": "square",
            "location": 11,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "f": {
            "name": "f",
            "location": 26,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "fp": {
            "name": "fp",
            "location": 31,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "g": {
            "name": "g",
            "location": 36,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ],
                "db": [
                    "List[int]"
                ]
            }
        },
        "SquareHitTracker.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SquareHitTracker.__call__": {
            "name": "__call__",
            "location": 20,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ]
            }
        },
        "TestSFApplier.test_sf_applier": {
            "name": "test_sf_applier",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSFApplier.test_sf_applier_preprocessor": {
            "name": "test_sf_applier_preprocessor",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/slicing/apply/__init__.py": {},
    "snorkel-main/test/slicing/sf/test_core.py": {
        "TestSlicingFunction._run_sf": {
            "name": "_run_sf",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sf": [
                    "SlicingFunction"
                ]
            }
        },
        "TestSlicingFunction._run_sf_raise": {
            "name": "_run_sf_raise",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sf": [
                    "SlicingFunction"
                ]
            }
        },
        "TestSlicingFunction.test_slicing_function_decorator": {
            "name": "test_slicing_function_decorator",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSlicingFunction.test_slicing_function_decorator_no_parens": {
            "name": "test_slicing_function_decorator_no_parens",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSlicingFunction.test_slicing_function_decorator.sf": {
            "name": "sf",
            "location": 21,
            "return": [
                "int"
            ],
            "arguments": {
                "x": []
            }
        },
        "TestSlicingFunction.test_slicing_function_decorator_no_parens.sf": {
            "name": "sf",
            "location": 33,
            "return": [
                "int"
            ],
            "arguments": {
                "x": []
            }
        }
    },
    "snorkel-main/test/slicing/sf/test_nlp.py": {
        "combine_text": {
            "name": "combine_text",
            "location": 10,
            "return": [
                "DataPoint"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "has_person_mention": {
            "name": "has_person_mention",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        },
        "TestNLPSlicingFunction._run_sf": {
            "name": "_run_sf",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sf": [
                    "NLPSlicingFunction"
                ]
            }
        },
        "TestNLPSlicingFunction.test_nlp_slicing_function": {
            "name": "test_nlp_slicing_function",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPSlicingFunction.test_nlp_slicing_function_decorator": {
            "name": "test_nlp_slicing_function_decorator",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNLPSlicingFunction.test_nlp_slicing_function_decorator.has_person_mention": {
            "name": "has_person_mention",
            "location": 35,
            "return": [
                "int"
            ],
            "arguments": {
                "x": [
                    "DataPoint"
                ]
            }
        }
    },
    "snorkel-main/test/slicing/sf/__init__.py": {},
    "snorkel-main/test/synthetic/test_synthetic_data.py": {
        "TestGenerateSimpleLabelMatrix.setUp": {
            "name": "setUp",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGenerateSimpleLabelMatrix._test_generate_L": {
            "name": "_test_generate_L",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "int"
                ],
                "decimal": [
                    "Optional[int]"
                ]
            }
        },
        "TestGenerateSimpleLabelMatrix.test_generate_L": {
            "name": "test_generate_L",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestGenerateSimpleLabelMatrix.test_generate_L_multiclass": {
            "name": "test_generate_L_multiclass",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/synthetic/__init__.py": {},
    "snorkel-main/test/utils/test_config_utils.py": {
        "UtilsTest.test_merge_config": {
            "name": "test_merge_config",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/utils/test_core.py": {
        "UtilsTest.test_to_int_label_array": {
            "name": "test_to_int_label_array",
            "location": 18,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_preds_to_probs": {
            "name": "test_preds_to_probs",
            "location": 40,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_probs_to_preds": {
            "name": "test_probs_to_preds",
            "location": 43,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_filter_labels": {
            "name": "test_filter_labels",
            "location": 88,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "UtilsTest.test_filter_labels_probs": {
            "name": "test_filter_labels_probs",
            "location": 98,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/utils/test_data_operators.py": {
        "DataOperatorsTest.test_check_unique_names": {
            "name": "test_check_unique_names",
            "location": 7,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "snorkel-main/test/utils/__init__.py": {}
}
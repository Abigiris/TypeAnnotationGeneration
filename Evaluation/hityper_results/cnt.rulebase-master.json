{
    "cnt.rulebase-master/setup.py": {
        "load_requirements": {
            "name": "load_requirements",
            "location": 9,
            "return": [
                "list[]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/chinese_chars.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/cjk_compatibility_ideographs.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/delimiters.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/digits.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/english_chars.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/utils.py": {
        "sorted_chain": {
            "name": "sorted_chain",
            "location": 7,
            "return": [
                "list[]"
            ],
            "arguments": {}
        },
        "normalize_cjk_fullwidth_ascii": {
            "name": "normalize_cjk_fullwidth_ascii",
            "location": 12,
            "return": [
                "str"
            ],
            "arguments": {
                "seq": [
                    "str",
                    "int",
                    "float",
                    "list[int]"
                ]
            }
        },
        "normalize_cjk_compatibility_ideographs": {
            "name": "normalize_cjk_compatibility_ideographs",
            "location": 27,
            "return": [
                "str"
            ],
            "arguments": {
                "seq": [
                    "str",
                    "dict[str, typing.Any]",
                    "dict[, ]",
                    "dict[str, dict[str, str]]"
                ]
            }
        },
        "normalize_cjk_fullwidth_ascii.convert": {
            "name": "convert",
            "location": 18,
            "return": [
                "str"
            ],
            "arguments": {
                "char": []
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/const/whitespaces.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/rules/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/basic_operation.py": {
        "_generate_interval_labeler_class": {
            "name": "_generate_interval_labeler_class",
            "location": 61,
            "return": [
                "DerivedIntervalLabeler"
            ],
            "arguments": {}
        },
        "IntervalBasedOperationLabelProcessor.result": {
            "name": "result",
            "location": 11,
            "return": [
                "None",
                "typing.Generator[tuple[bool]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedOperationOutputGenerator.continuous_intervals": {
            "name": "continuous_intervals",
            "location": 34,
            "return": [
                "None",
                "typing.Generator[tuple[tuple[]]]",
                "typing.Generator[tuple[tuple[int]]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicIntervalBasedOperation.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "intervals": [
                    "int",
                    "str"
                ]
            }
        },
        "BasicIntervalBasedOperation.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicIntervalBasedOperation._generate_workflow": {
            "name": "_generate_workflow",
            "location": 89,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedOperation.__init__": {
            "name": "__init__",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "intervals_collection": [
                    "dict[str, typing.Any]",
                    "str"
                ]
            }
        },
        "IntervalsCollectionBasedOperation.initialize_label_processor_class": {
            "name": "initialize_label_processor_class",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedOperation.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedOperation._generate_workflow": {
            "name": "_generate_workflow",
            "location": 128,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/builtin_application.py": {
        "BuiltInCollector.generate_collector_lazy": {
            "name": "generate_collector_lazy",
            "location": 16,
            "return": [
                "IntervalBasedCollectorLazy"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ],
                "intervals_collection": [
                    "typing.Type",
                    "float"
                ]
            }
        },
        "BuiltInCollector.generate_collector": {
            "name": "generate_collector",
            "location": 25,
            "return": [
                "IntervalBasedCollector"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ],
                "intervals_collection": [
                    "typing.Type",
                    "float"
                ]
            }
        },
        "BuiltInCollector.setup_collector": {
            "name": "setup_collector",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [],
                "name": [
                    "str"
                ],
                "intervals_collection": [
                    "str",
                    "typing.Callable[typing.Any, bool]",
                    "dict[str, str]"
                ]
            }
        },
        "BuiltInReplacer.generate_param": {
            "name": "generate_param",
            "location": 67,
            "return": [
                "dict[typing.Union[str,set[str],dict[typing.Any, str],dict[str, tuple[typing.Union[str,str,str]]]], ]"
            ],
            "arguments": {
                "cls": [
                    "typing.Type",
                    "str"
                ],
                "repl_with_intervals_collection": [
                    "dict[, ]"
                ]
            }
        },
        "BuiltInReplacer.generate_replacer_lazy": {
            "name": "generate_replacer_lazy",
            "location": 94,
            "return": [
                "IntervalsCollectionBasedReplacerLazy"
            ],
            "arguments": {
                "cls": [],
                "repl_with_intervals_collection": [
                    "str",
                    "typing.Iterable[typing.Any]",
                    "typing.Callable[, ]"
                ]
            }
        },
        "BuiltInReplacer.generate_replacer": {
            "name": "generate_replacer",
            "location": 104,
            "return": [
                "IntervalsCollectionBasedReplacer"
            ],
            "arguments": {
                "cls": [],
                "repl_with_intervals_collection": [
                    "str",
                    "typing.Iterable[typing.Any]",
                    "typing.Callable[, ]"
                ]
            }
        },
        "BuiltInReplacer.generate_replacer_to_string": {
            "name": "generate_replacer_to_string",
            "location": 114,
            "return": [
                "IntervalsCollectionBasedReplacerToString"
            ],
            "arguments": {
                "cls": [],
                "repl_with_intervals_collection": [
                    "typing.Type",
                    "str",
                    "typing.Callable[..., T]",
                    "bool",
                    "list[typing.Union[str,\"SqlFile\"]]"
                ]
            }
        },
        "BuiltInReplacer.setup_replacer": {
            "name": "setup_replacer",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [],
                "name": [
                    "str"
                ],
                "repl": [
                    "str",
                    "typing.Callable[typing.Any, bool]",
                    "bool"
                ],
                "intervals_collection": [
                    "str",
                    "typing.Callable[typing.Any, bool]",
                    "bool"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/interval_based_collector.py": {
        "_IntervalBasedCollectorOutputGenerator._result": {
            "name": "_result",
            "location": 16,
            "return": [
                "typing.Generator[tuple[]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorOutputGeneratorLazy.result": {
            "name": "result",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorOutputGenerator.result": {
            "name": "result",
            "location": 31,
            "return": [
                "list[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorLazy.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorLazy.result": {
            "name": "result",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "list[str]",
                    "None"
                ]
            }
        },
        "IntervalBasedCollector.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollector.result": {
            "name": "result",
            "location": 49,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "dict[str, str]"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/interval_based_replacer.py": {
        "IntervalsCollectionBasedReplacerConfig.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labeler2repl": [
                    "int",
                    "float"
                ]
            }
        },
        "IntervalsCollectionBasedReplacerLabelProcessor.result": {
            "name": "result",
            "location": 29,
            "return": [
                "None",
                "typing.Generator[tuple[None]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_IntervalsCollectionBasedReplacerOutputGenerator._result": {
            "name": "_result",
            "location": 48,
            "return": [
                "typing.Generator[tuple[tuple[tuple[]]]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerOutputGeneratorLazy.result": {
            "name": "result",
            "location": 81,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerOutputGenerator.result": {
            "name": "result",
            "location": 88,
            "return": [
                "list[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerOperation.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "replacer_intervals": [
                    "dict[str, typing.Any]",
                    "dict[, ]"
                ]
            }
        },
        "IntervalsCollectionBasedReplacerOperation.initialize_label_processor_class": {
            "name": "initialize_label_processor_class",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerLazy.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerLazy.result": {
            "name": "result",
            "location": 120,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool"
                ]
            }
        },
        "IntervalsCollectionBasedReplacer.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacer.result": {
            "name": "result",
            "location": 129,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "typing.Mapping"
                ]
            }
        },
        "IntervalsCollectionBasedReplacerToString.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 135,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerToString.result": {
            "name": "result",
            "location": 138,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/rules/sentence_segmentation/const.py": {
        "_flatten_nested": {
            "name": "_flatten_nested",
            "location": 9,
            "return": [
                "list[]"
            ],
            "arguments": {
                "seq": [],
                "ret": [
                    "None"
                ]
            }
        },
        "_append_code_points_to_text": {
            "name": "_append_code_points_to_text",
            "location": 20,
            "return": [
                "list[]"
            ],
            "arguments": {
                "text": []
            }
        },
        "_append_code_points_to_seq": {
            "name": "_append_code_points_to_seq",
            "location": 24,
            "return": [],
            "arguments": {
                "seq": []
            }
        },
        "_append_single_quotation": {
            "name": "_append_single_quotation",
            "location": 30,
            "return": [],
            "arguments": {
                "seq": []
            }
        },
        "_append_double_quotation": {
            "name": "_append_double_quotation",
            "location": 34,
            "return": [],
            "arguments": {
                "seq": []
            }
        },
        "_generate_sentence_ends": {
            "name": "_generate_sentence_ends",
            "location": 38,
            "return": [],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/sentence_segmentation/sentence_segmenter.py": {
        "_generate_sentseg_workflow": {
            "name": "_generate_sentseg_workflow",
            "location": 193,
            "return": [],
            "arguments": {
                "lazy": [
                    "bool",
                    "float",
                    "list[int]"
                ]
            }
        },
        "_sentseg": {
            "name": "_sentseg",
            "location": 213,
            "return": [],
            "arguments": {
                "sentseg_workflow": [],
                "text": [
                    "str",
                    "bool",
                    "list[str]",
                    "None",
                    "typing.Type"
                ],
                "enable_strict_sentence_charset": [
                    "str",
                    "int"
                ],
                "enable_comma_ending": [
                    "str",
                    "int"
                ],
                "extend_ending_with_delimiters": [
                    "str",
                    "int"
                ],
                "dynamic_endings": [
                    "str",
                    "int"
                ]
            }
        },
        "sentseg": {
            "name": "sentseg",
            "location": 231,
            "return": [],
            "arguments": {
                "text": [
                    "bool",
                    "list[str]",
                    "None",
                    "str",
                    "typing.Type"
                ],
                "enable_strict_sentence_charset": [
                    "bool"
                ],
                "enable_comma_ending": [
                    "bool"
                ],
                "extend_ending_with_delimiters": [
                    "bool"
                ],
                "dynamic_endings": [
                    "None",
                    "bool",
                    "list[str]",
                    "str",
                    "typing.Type"
                ]
            }
        },
        "sentseg_lazy": {
            "name": "sentseg_lazy",
            "location": 250,
            "return": [],
            "arguments": {
                "text": [
                    "bool",
                    "str",
                    "list[str]",
                    "None"
                ],
                "enable_strict_sentence_charset": [
                    "bool"
                ],
                "enable_comma_ending": [
                    "bool"
                ],
                "extend_ending_with_delimiters": [
                    "bool"
                ],
                "dynamic_endings": [
                    "None",
                    "bool",
                    "str",
                    "list[str]"
                ]
            }
        },
        "SentenceSegementationConfig.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "enable_strict_sentence_charset": [
                    "int",
                    "float"
                ],
                "enable_comma_ending": [
                    "int",
                    "float"
                ],
                "extend_ending_with_delimiters": [
                    "int",
                    "float"
                ],
                "dynamic_endings": [
                    "int",
                    "float"
                ]
            }
        },
        "DynamicSentenceEndingLabeler.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "dict[str, typing.Any]",
                    "str",
                    "dict[, ]"
                ],
                "config": [
                    "dict[str, typing.Any]",
                    "dict[, ]"
                ]
            }
        },
        "DynamicSentenceEndingLabeler.intervals_generator": {
            "name": "intervals_generator",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CommaLabeler.label": {
            "name": "label",
            "location": 69,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "str"
                ]
            }
        },
        "SentenceSegementationLabelProcessor._labels_indicate_sentence_ending": {
            "name": "_labels_indicate_sentence_ending",
            "location": 102,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "str"
                ]
            }
        },
        "SentenceSegementationLabelProcessor.result": {
            "name": "result",
            "location": 108,
            "return": [
                "None",
                "typing.Generator[tuple[typing.Union[int,int]]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_SentenceSegementationOutputGeneratorLazy._result": {
            "name": "_result",
            "location": 176,
            "return": [
                "typing.Generator[tuple[tuple[]]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceSegementationOutputGeneratorLazy.result": {
            "name": "result",
            "location": 183,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SentenceSegementationOutputGenerator.result": {
            "name": "result",
            "location": 189,
            "return": [
                "list[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DynamicSentenceEndingLabeler.intervals_generator.mocker_generator": {
            "name": "mocker_generator",
            "location": 50,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/sentence_segmentation/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/workflow/basic_workflow.py": {
        "BasicSequentialLabeler.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "str",
                    "list[]",
                    "dict[, ]"
                ],
                "config": [
                    "dict[, ]",
                    "int"
                ]
            }
        },
        "BasicSequentialLabeler.label": {
            "name": "label",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "str",
                    "dict[str, typing.Any]",
                    "typing.Sequence[str]"
                ]
            }
        },
        "BasicLabelProcessor.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "str",
                    "bool",
                    "None",
                    "list[]"
                ],
                "index_labels_generator": [
                    "str",
                    "dict[str, typing.Any]",
                    "typing.Callable[dict[, ], None]",
                    "float"
                ],
                "config": [
                    "list[]",
                    "str",
                    "None",
                    "dict[str, str]"
                ]
            }
        },
        "BasicLabelProcessor.result": {
            "name": "result",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicOutputGenerator.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "int",
                    "str",
                    "tuple[typing.Union[str,str,str]]",
                    "None"
                ],
                "label_processor_result": [
                    "bool"
                ],
                "config": [
                    "bool",
                    "str",
                    "list[]",
                    "None",
                    "dict[, ]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "BasicOutputGenerator.result": {
            "name": "result",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicWorkflow.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sequential_labeler_classes": [
                    "tuple[typing.Hashable]",
                    "dict[typing.Union[str,str,str,str,str,str,str], ]",
                    "str"
                ],
                "label_processor_class": [
                    "bool"
                ],
                "output_generator_class": [
                    "str",
                    "None",
                    "typing.Sequence[str]",
                    "int"
                ]
            }
        },
        "BasicWorkflow.result": {
            "name": "result",
            "location": 103,
            "return": [],
            "arguments": {
                "self": [],
                "input_sequence": [],
                "config": [
                    "None",
                    "dict[str, typing.Any]"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/workflow/exact_match_labeler.py": {
        "_ac_automation_match": {
            "name": "_ac_automation_match",
            "location": 9,
            "return": [
                "typing.Generator[tuple[typing.Union[int,int]]]"
            ],
            "arguments": {
                "text": [
                    "str",
                    "tuple[typing.Union[int,int]]"
                ],
                "ac_automation": []
            }
        },
        "ExactMatchLabeler.build_ac_automation_from_strings": {
            "name": "build_ac_automation_from_strings",
            "location": 42,
            "return": [],
            "arguments": {
                "cls": [
                    "str",
                    "bytes",
                    "int"
                ],
                "keys": [
                    "list[str]",
                    "str"
                ]
            }
        },
        "ExactMatchLabeler.build_and_bind_ac_automation_from_strings": {
            "name": "build_and_bind_ac_automation_from_strings",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [],
                "keys": [
                    "list[str]",
                    "str",
                    "set[str]"
                ]
            }
        },
        "ExactMatchLabeler.intervals_generator": {
            "name": "intervals_generator",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/workflow/interval_labeler.py": {
        "_next_interval": {
            "name": "_next_interval",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "intervals": []
            }
        },
        "build_re_pattern_from_intervals": {
            "name": "build_re_pattern_from_intervals",
            "location": 17,
            "return": [],
            "arguments": {
                "intervals": [
                    "dict[str, typing.Any]",
                    "str"
                ]
            }
        },
        "IntervalLabeler.initialize_by_regular_expression": {
            "name": "initialize_by_regular_expression",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Exception"
                ],
                "pattern": [
                    "str",
                    "Exception"
                ]
            }
        },
        "IntervalLabeler.initialize_by_intervals": {
            "name": "initialize_by_intervals",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "list[str]"
                ],
                "intervals": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "IntervalLabeler.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "dict[str, typing.Any]",
                    "str",
                    "dict[, ]"
                ],
                "config": [
                    "dict[str, typing.Any]",
                    "str",
                    "dict[, ]"
                ]
            }
        },
        "IntervalLabeler.intervals_generator": {
            "name": "intervals_generator",
            "location": 59,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalLabeler.label": {
            "name": "label",
            "location": 64,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "index": []
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/workflow/type_annotations.py": {},
    "cnt.rulebase-master/cnt/rulebase/workflow/__init__.py": {},
    "cnt.rulebase-master/docs/conf.py": {},
    "cnt.rulebase-master/tasks/tasks.py": {
        "variant_mapping": {
            "name": "variant_mapping",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {
                "c": [
                    "str",
                    "bool",
                    "list[str]"
                ],
                "unihan_variant_path": [
                    "str"
                ],
                "output": [
                    "str"
                ]
            }
        }
    },
    "cnt.rulebase-master/tests/test_const_utils.py": {
        "test_normalize_cjk_fullwidth_ascii": {
            "name": "test_normalize_cjk_fullwidth_ascii",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_normalize_cjk_compatibility_ideographs": {
            "name": "test_normalize_cjk_compatibility_ideographs",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/tests/test_interval_based_collector.py": {
        "test_interval_based_collector": {
            "name": "test_interval_based_collector",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_chinese_sentence_chars_collector": {
            "name": "test_chinese_sentence_chars_collector",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/tests/test_interval_based_replacer.py": {
        "test_replacer": {
            "name": "test_replacer",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_replacer_intervals": {
            "name": "test_replacer_intervals",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_built_in_replacer": {
            "name": "test_built_in_replacer",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/tests/test_sentseg.py": {
        "test_sentence_ending_labler": {
            "name": "test_sentence_ending_labler",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_whitespace_labeler": {
            "name": "test_whitespace_labeler",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sentence_valid_character_labeler": {
            "name": "test_sentence_valid_character_labeler",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sentseg": {
            "name": "test_sentseg",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sentseg_lazy": {
            "name": "test_sentseg_lazy",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    }
}
{
    "kaggle-master/digit-recognizer/keras_convnet.py": {
        "build_model": {
            "name": "build_model",
            "location": 9,
            "return": [],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/digit-recognizer/pytorch_convnet.py": {
        "train_model": {
            "name": "train_model",
            "location": 32,
            "return": [],
            "arguments": {
                "model": [],
                "optimizer": [],
                "loader": []
            }
        },
        "evaluate_model": {
            "name": "evaluate_model",
            "location": 49,
            "return": [],
            "arguments": {
                "model": [],
                "loader": []
            }
        },
        "main": {
            "name": "main",
            "location": 63,
            "return": [],
            "arguments": {}
        },
        "ConvNet.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ConvNet.forward": {
            "name": "forward",
            "location": 23,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        }
    },
    "kaggle-master/digit-recognizer/tensorflow_convnet.py": {
        "weight_variable": {
            "name": "weight_variable",
            "location": 10,
            "return": [],
            "arguments": {
                "shape": [
                    "str",
                    "typing.Iterator",
                    "dict[str, typing.Any]",
                    "int"
                ]
            }
        },
        "bias_variable": {
            "name": "bias_variable",
            "location": 14,
            "return": [],
            "arguments": {
                "shape": [
                    "str",
                    "typing.Iterator",
                    "dict[str, typing.Any]",
                    "int"
                ]
            }
        },
        "conv2d": {
            "name": "conv2d",
            "location": 19,
            "return": [],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "bytes",
                    "bytearray",
                    "memoryview"
                ],
                "W": [
                    "float",
                    "int",
                    "bytes",
                    "bytearray",
                    "memoryview"
                ]
            }
        },
        "max_pool": {
            "name": "max_pool",
            "location": 22,
            "return": [],
            "arguments": {
                "x": [
                    "int",
                    "list[int]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/digit-recognizer/util.py": {
        "load_train_data": {
            "name": "load_train_data",
            "location": 9,
            "return": [
                "tuple[int]"
            ],
            "arguments": {}
        },
        "load_test_data": {
            "name": "load_test_data",
            "location": 16,
            "return": [
                "int"
            ],
            "arguments": {}
        },
        "save_predictions": {
            "name": "save_predictions",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "labels": [
                    "str",
                    "int"
                ],
                "output_file": [
                    "str"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/config.py": {
        "Config.save": {
            "name": "save",
            "location": 37,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        },
        "Config.load": {
            "name": "load",
            "location": 43,
            "return": [],
            "arguments": {
                "self": [],
                "file_path": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/data.py": {
        "load_train_val_examples": {
            "name": "load_train_val_examples",
            "location": 44,
            "return": [],
            "arguments": {
                "random_seed": [],
                "train_size": []
            }
        },
        "load_test_examples": {
            "name": "load_test_examples",
            "location": 55,
            "return": [],
            "arguments": {
                "tsv_path": []
            }
        },
        "_load_gap": {
            "name": "_load_gap",
            "location": 60,
            "return": [],
            "arguments": {
                "tsv_path": []
            }
        },
        "_create_example": {
            "name": "_create_example",
            "location": 70,
            "return": [],
            "arguments": {
                "row": []
            }
        },
        "_word_tokenizer": {
            "name": "_word_tokenizer",
            "location": 107,
            "return": [],
            "arguments": {
                "text": []
            }
        },
        "_char_to_token_offset": {
            "name": "_char_to_token_offset",
            "location": 120,
            "return": [],
            "arguments": {
                "text": [],
                "mention": [],
                "char_offset": [],
                "text_tokens": []
            }
        },
        "GAPDataset.__init__": {
            "name": "__init__",
            "location": 137,
            "return": [],
            "arguments": {
                "self": [],
                "examples": [],
                "flip_prob": []
            }
        },
        "GAPDataset.__getitem__": {
            "name": "__getitem__",
            "location": 143,
            "return": [],
            "arguments": {
                "self": [],
                "index": []
            }
        },
        "GAPDataset.__len__": {
            "name": "__len__",
            "location": 151,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "GAPDataset._flip_example": {
            "name": "_flip_example",
            "location": 154,
            "return": [],
            "arguments": {
                "self": [],
                "example": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/ensemble.py": {
        "ensemble": {
            "name": "ensemble",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "models_dir": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/hyperparam_search.py": {
        "objective": {
            "name": "objective",
            "location": 22,
            "return": [],
            "arguments": {
                "config_dict": [],
                "device": [],
                "progress_bar": [],
                "base_output_dir": []
            }
        },
        "load_config_space": {
            "name": "load_config_space",
            "location": 65,
            "return": [],
            "arguments": {
                "config_space_file": []
            }
        },
        "main": {
            "name": "main",
            "location": 79,
            "return": [],
            "arguments": {
                "args": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/model.py": {
        "init_weights": {
            "name": "init_weights",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "module": [
                    "str",
                    "dict[int, int]",
                    "typing.Type"
                ]
            }
        },
        "BertFeatures.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_name": [
                    "str"
                ],
                "cache_dir": [
                    "str"
                ],
                "device": [
                    "bool",
                    "str",
                    "typing.Callable[, ]"
                ]
            }
        },
        "BertFeatures._wordpiece_tokenizer": {
            "name": "_wordpiece_tokenizer",
            "location": 48,
            "return": [
                "tuple[OrderedDict]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "list[str]",
                    "str",
                    "tuple[typing.Union[int,str]]"
                ]
            }
        },
        "BertFeatures._prepare_input": {
            "name": "_prepare_input",
            "location": 62,
            "return": [
                "tuple[list[int]]"
            ],
            "arguments": {
                "self": [],
                "wordpiece_tokens": [],
                "padding_length": []
            }
        },
        "BertFeatures.generate": {
            "name": "generate",
            "location": 89,
            "return": [
                "tuple[list[typing.Union[str,bool]]]"
            ],
            "arguments": {
                "self": [],
                "tokens_batch": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "FeedForward.__init__": {
            "name": "__init__",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "float"
                ],
                "output_size": [
                    "int",
                    "float"
                ],
                "hidden_layers": [
                    "int"
                ],
                "hidden_size": [
                    "None",
                    "int",
                    "float"
                ],
                "dropout": [
                    "float"
                ],
                "activation": [
                    "typing.Text"
                ]
            }
        },
        "FeedForward.forward": {
            "name": "forward",
            "location": 151,
            "return": [
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "dict[, ]"
                ],
                "device": [
                    "dict[str, typing.Any]",
                    "str"
                ]
            }
        },
        "Model.forward": {
            "name": "forward",
            "location": 194,
            "return": [],
            "arguments": {
                "self": [],
                "batch": [
                    "str"
                ]
            }
        },
        "Model._calculate_mention_vector": {
            "name": "_calculate_mention_vector",
            "location": 235,
            "return": [],
            "arguments": {
                "self": [],
                "input_tokens": [],
                "input_length": [
                    "list[int]",
                    "str",
                    "bool"
                ],
                "pronoun_index": [
                    "list[int]",
                    "str",
                    "bool"
                ],
                "spans": [
                    "list[tuple[typing.Union[int,int]]]",
                    "list[int]"
                ]
            }
        },
        "Model._calculate_context_vector": {
            "name": "_calculate_context_vector",
            "location": 254,
            "return": [],
            "arguments": {
                "self": [],
                "input_tokens": [],
                "input_length": [
                    "list[int]",
                    "float",
                    "list[tuple[typing.Union[int,int]]]",
                    "None"
                ],
                "pronoun_index": [
                    "float"
                ]
            }
        },
        "Model._calculate_pronoun_mention_distance": {
            "name": "_calculate_pronoun_mention_distance",
            "location": 287,
            "return": [],
            "arguments": {
                "self": [],
                "pronoun_index": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ],
                "mention_span": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "Model._calculate_features": {
            "name": "_calculate_features",
            "location": 297,
            "return": [
                "list[]",
                "list[str]"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "str"
                ]
            }
        },
        "Model.calculate_loss": {
            "name": "calculate_loss",
            "location": 316,
            "return": [
                "int",
                "dict[, ]",
                "list[int]",
                "list[list[int]]",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "list[torch.Tensor]",
                    "bytes",
                    "float"
                ],
                "reduction": [
                    "typing.Text"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/optim.py": {
        "lr_schedule": {
            "name": "lr_schedule",
            "location": 13,
            "return": [
                "float",
                "int"
            ],
            "arguments": {
                "step": [
                    "int"
                ],
                "total_steps": [
                    "int"
                ],
                "lr": [
                    "int"
                ],
                "lr_warmup": [
                    "int",
                    "float",
                    "typing.Iterable[typing.Optional[typing.Any]]",
                    "None"
                ],
                "lr_cooldown": [
                    "int",
                    "str",
                    "typing.Iterable['Context']"
                ]
            }
        },
        "Adam.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "named_parameters": [
                    "str",
                    "list[str]"
                ],
                "lr": [
                    "float"
                ],
                "beta1": [
                    "float"
                ],
                "beta2": [
                    "float"
                ],
                "eps": [
                    "float"
                ],
                "weight_decay": [
                    "bool"
                ],
                "max_grad_norm": [
                    "int",
                    "float"
                ],
                "lr_warmup": [
                    "int"
                ],
                "lr_cooldown": [
                    "None",
                    "int",
                    "str",
                    "float"
                ],
                "total_steps": [
                    "int"
                ]
            }
        },
        "Adam.step": {
            "name": "step",
            "location": 113,
            "return": [
                "None",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "closure": [
                    "None",
                    "str",
                    "int",
                    "float"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/optim_test.py": {
        "LRScheduleTest.test_constant": {
            "name": "test_constant",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LRScheduleTest.test_warmup_only": {
            "name": "test_warmup_only",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LRScheduleTest.test_warmup_and_linear_cooldown": {
            "name": "test_warmup_and_linear_cooldown",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AdamTest.assertListAlmostEqual": {
            "name": "assertListAlmostEqual",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "list_a": [],
                "list_b": []
            }
        },
        "AdamTest.test_sphere": {
            "name": "test_sphere",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/predict.py": {
        "generate_predictions": {
            "name": "generate_predictions",
            "location": 22,
            "return": [],
            "arguments": {
                "model": [
                    "dict[str, model.Integration]",
                    "int"
                ],
                "config": [
                    "dict[, ]"
                ],
                "examples": []
            }
        },
        "optimize_thresholds": {
            "name": "optimize_thresholds",
            "location": 59,
            "return": [
                "dict[, typing.Union[int,list[],tuple[typing.Union[int,int]]]]"
            ],
            "arguments": {
                "predictions": [
                    "dict[str, typing.Any]"
                ],
                "threshold_steps": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "apply_thresholds": {
            "name": "apply_thresholds",
            "location": 83,
            "return": [
                "list[int]"
            ],
            "arguments": {
                "predictions": [
                    "list[int]"
                ],
                "thresholds": [
                    "dict[str, object]",
                    "dict[str, dict[str, int]]",
                    "dict[str, str]"
                ]
            }
        },
        "calculate_losses": {
            "name": "calculate_losses",
            "location": 92,
            "return": [],
            "arguments": {
                "predictions": []
            }
        },
        "predict": {
            "name": "predict",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "model_dir": [
                    "bool"
                ],
                "device": [
                    "list[tuple[typing.Union[str,str]]]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/train.py": {
        "train": {
            "name": "train",
            "location": 24,
            "return": [],
            "arguments": {
                "config": [
                    "dict[, ]",
                    "tuple[typing.Union[pathlib.Path,pathlib.Path]]",
                    "str",
                    "list[str]"
                ],
                "device": [
                    "str",
                    "None",
                    "bool",
                    "float",
                    "dict[str, typing.Any]"
                ],
                "output_dir": []
            }
        },
        "main": {
            "name": "main",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/clean_data.py": {
        "_InputCSV.count": {
            "name": "count",
            "location": 18,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "_InputCSV.output": {
            "name": "output",
            "location": 23,
            "return": [],
            "arguments": {
                "cls": [
                    "str",
                    "typing.Match",
                    "typing.Callable[, ]",
                    "None"
                ]
            }
        },
        "_InputCSV.read": {
            "name": "read",
            "location": 28,
            "return": [],
            "arguments": {
                "cls": [
                    "str",
                    "dict[str, typing.Any]",
                    "bool",
                    "bytes"
                ]
            }
        },
        "_OrdersTask.requires": {
            "name": "requires",
            "location": 44,
            "return": [
                "dict[typing.Text, typing.Union[OrdersInput,list[OrderProductsInput]]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OrdersTask._read_orders_input": {
            "name": "_read_orders_input",
            "location": 50,
            "return": [
                "str",
                "None",
                "int",
                "dict[str, str]",
                "list[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OrdersTask._read_order_products_input": {
            "name": "_read_order_products_input",
            "location": 63,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "_OrdersTask._write_orders": {
            "name": "_write_orders",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "orders": []
            }
        },
        "_OrdersTask.read": {
            "name": "read",
            "location": 106,
            "return": [
                "list[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompleteOrders.output": {
            "name": "output",
            "location": 117,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CompleteOrders.run": {
            "name": "run",
            "location": 121,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SubmissionOrders.output": {
            "name": "output",
            "location": 133,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "SubmissionOrders.run": {
            "name": "run",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_SplitOrdersTask.requires": {
            "name": "requires",
            "location": 152,
            "return": [
                "CompleteOrders"
            ],
            "arguments": {
                "self": []
            }
        },
        "_SplitOrdersTask._run": {
            "name": "_run",
            "location": 155,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "op": [
                    "str",
                    "float",
                    "int",
                    "set[str]"
                ]
            }
        },
        "TestOrders.output": {
            "name": "output",
            "location": 166,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TestOrders.run": {
            "name": "run",
            "location": 170,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingOrders.output": {
            "name": "output",
            "location": 176,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "TrainingOrders.run": {
            "name": "run",
            "location": 180,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/config.py": {},
    "kaggle-master/instacart-basket-analysis/pipelines/evaluation.py": {
        "EvaluateModel.requires": {
            "name": "requires",
            "location": 18,
            "return": [
                "dict[typing.Text, typing.Union[TestOrders,ModelPredictions]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluateModel.output": {
            "name": "output",
            "location": 24,
            "return": [
                "dict[typing.Text, ]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluateModel.run": {
            "name": "run",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluateAllModels.requires": {
            "name": "requires",
            "location": 85,
            "return": [
                "typing.Generator[EvaluateModel]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/input_data.py": {
        "OrdersInput.output": {
            "name": "output",
            "location": 10,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "OrderProductsInput.output": {
            "name": "output",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/submissions.py": {
        "Submission.requires": {
            "name": "requires",
            "location": 14,
            "return": [
                "dict[typing.Text, ModelPredictions]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Submission.output": {
            "name": "output",
            "location": 19,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Submission.run": {
            "name": "run",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/__init__.py": {},
    "kaggle-master/instacart-basket-analysis/pipelines/models/empty.py": {
        "PredictEmpty.model_name": {
            "name": "model_name",
            "location": 13,
            "return": [
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictEmpty.run": {
            "name": "run",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/f1_maximization.py": {
        "get_expectations": {
            "name": "get_expectations",
            "location": 11,
            "return": [],
            "arguments": {
                "P": []
            }
        },
        "maximize_expected_f1": {
            "name": "maximize_expected_f1",
            "location": 40,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "P": [
                    "str",
                    "int",
                    "list[]"
                ]
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/frequent_products.py": {
        "PredictFrequentProducts.model_name": {
            "name": "model_name",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictFrequentProducts.run": {
            "name": "run",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/lightfm_v1.py": {
        "LightFMv1.model_name": {
            "name": "model_name",
            "location": 32,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LightFMv1._generate_row": {
            "name": "_generate_row",
            "location": 39,
            "return": [
                "tuple[set[int]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [],
                "prior_orders": [
                    "str"
                ]
            }
        },
        "LightFMv1._generate_rows": {
            "name": "_generate_rows",
            "location": 52,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "str"
                ],
                "training": [
                    "dict[, ]",
                    "None",
                    "int",
                    "str"
                ]
            }
        },
        "LightFMv1._generate_matrices": {
            "name": "_generate_matrices",
            "location": 61,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "training": [
                    "str",
                    "int"
                ]
            }
        },
        "FitLightFMv1._fit_ranking_model": {
            "name": "_fit_ranking_model",
            "location": 96,
            "return": [
                "LightFMv1"
            ],
            "arguments": {
                "self": [],
                "user_features": [
                    "dict[, ]",
                    "dict[str, typing.Any]"
                ],
                "interactions": [
                    "dict[, ]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "FitLightFMv1._f1_score": {
            "name": "_f1_score",
            "location": 105,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "y_true": [],
                "y_pred": []
            }
        },
        "FitLightFMv1._fit_threshold_model": {
            "name": "_fit_threshold_model",
            "location": 111,
            "return": [],
            "arguments": {
                "self": [],
                "user_features": [],
                "interactions": [],
                "ranking_model": []
            }
        },
        "FitLightFMv1.run": {
            "name": "run",
            "location": 167,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv1.requires": {
            "name": "requires",
            "location": 187,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv1.run": {
            "name": "run",
            "location": 196,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/lightfm_v2.py": {
        "LightFMv2.model_name": {
            "name": "model_name",
            "location": 30,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LightFMv2._generate_row": {
            "name": "_generate_row",
            "location": 37,
            "return": [
                "tuple[set[int]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [],
                "prior_orders": [
                    "str"
                ]
            }
        },
        "LightFMv2._generate_rows": {
            "name": "_generate_rows",
            "location": 50,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [],
                "max_prior_orders": [
                    "int"
                ]
            }
        },
        "LightFMv2._generate_matrices": {
            "name": "_generate_matrices",
            "location": 62,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "max_prior_orders": [
                    "str",
                    "int",
                    "typing.Callable[int,int, None]",
                    "float"
                ]
            }
        },
        "FitLightFMv2.run": {
            "name": "run",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv2ReorderSizeKnown.requires": {
            "name": "requires",
            "location": 114,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv2ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 124,
            "return": [
                "int"
            ],
            "arguments": {
                "order": [
                    "list[dict[str, str]]",
                    "str"
                ]
            }
        },
        "PredictLightFMv2ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 131,
            "return": [
                "dict[int, ]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "PredictLightFMv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/lightfm_v3.py": {
        "FitLightFMv3Embeddings.model_name": {
            "name": "model_name",
            "location": 31,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings.read": {
            "name": "read",
            "location": 36,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings._load_products": {
            "name": "_load_products",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings._get_num_items": {
            "name": "_get_num_items",
            "location": 50,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings._get_item_id": {
            "name": "_get_item_id",
            "location": 59,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "product_id": [
                    "int"
                ]
            }
        },
        "FitLightFMv3Embeddings._generate_row": {
            "name": "_generate_row",
            "location": 68,
            "return": [
                "tuple[set[typing.Union[dict[, ],str,list[]]]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [],
                "prior_orders": [
                    "str"
                ]
            }
        },
        "FitLightFMv3Embeddings._generate_rows": {
            "name": "_generate_rows",
            "location": 83,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "list[dict[typing.Any, typing.Any]]",
                    "list[]"
                ],
                "num_orders": [
                    "bool"
                ]
            }
        },
        "FitLightFMv3Embeddings._generate_matrices": {
            "name": "_generate_matrices",
            "location": 95,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "FitLightFMv3Embeddings.run": {
            "name": "run",
            "location": 125,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitAllLightFMv3Embeddings.run": {
            "name": "run",
            "location": 157,
            "return": [
                "typing.Generator[FitLightFMv3Embeddings]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/mlp_v1.py": {
        "MLPv1.model_name": {
            "name": "model_name",
            "location": 27,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv1._generate_user_features": {
            "name": "_generate_user_features",
            "location": 34,
            "return": [
                "bytearray",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "dict[, ]",
                    "str"
                ]
            }
        },
        "MLPv1._generate_product_features": {
            "name": "_generate_product_features",
            "location": 70,
            "return": [
                "int",
                "float",
                "list[float]"
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "typing.Any",
                    "None",
                    "typing.Sequence[int]",
                    "bool",
                    "typing.Callable[..., None]"
                ]
            }
        },
        "MLPv1._generate_user_product_features": {
            "name": "_generate_user_product_features",
            "location": 108,
            "return": [
                "list[int]"
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "list[tuple[typing.Union[int,int]]]",
                    "str"
                ]
            }
        },
        "MLPv1._load_data": {
            "name": "_load_data",
            "location": 155,
            "return": [
                "tuple[list[]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitMLPv1.run": {
            "name": "run",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitMLPv1._split_data": {
            "name": "_split_data",
            "location": 225,
            "return": [
                "tuple[tuple[list[]]]"
            ],
            "arguments": {
                "self": [],
                "order_ids": [],
                "product_ids": [
                    "list[]",
                    "int",
                    "list[int]",
                    "list[C]"
                ],
                "inputs": [
                    "int",
                    "str",
                    "typing.Sequence[typing.Sequence[str]]",
                    "list[int]",
                    "typing.Callable[, ]",
                    "None"
                ],
                "predictions": [
                    "int",
                    "str",
                    "typing.Sequence[typing.Sequence[str]]",
                    "list[int]",
                    "typing.Callable[, ]",
                    "None"
                ],
                "training_size": [
                    "int",
                    "str"
                ]
            }
        },
        "FitMLPv1._tapered_layers": {
            "name": "_tapered_layers",
            "location": 260,
            "return": [
                "list[int]"
            ],
            "arguments": {
                "from_dim": [
                    "int",
                    "typing.Sequence[int]"
                ],
                "to_dim": [
                    "int",
                    "typing.Sequence[int]"
                ],
                "num_layers": [
                    "int"
                ]
            }
        },
        "FitMLPv1._build_model": {
            "name": "_build_model",
            "location": 264,
            "return": [
                "Model"
            ],
            "arguments": {
                "self": [],
                "training_inputs": [
                    "bool"
                ]
            }
        },
        "PredictMLPv1.requires": {
            "name": "requires",
            "location": 286,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv1.run": {
            "name": "run",
            "location": 295,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv1._load_data.add_example": {
            "name": "add_example",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "user_id": [],
                "order_id": [],
                "product_id": [],
                "prediction": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/mlp_v2.py": {
        "MLPv2.model_name": {
            "name": "model_name",
            "location": 45,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv2._count_lines": {
            "name": "_count_lines",
            "location": 57,
            "return": [
                "int"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "MLPv2._open_shuffled": {
            "name": "_open_shuffled",
            "location": 62,
            "return": [
                "typing.Generator[typing.IO]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "MLPv2._generate_examples": {
            "name": "_generate_examples",
            "location": 67,
            "return": [
                "typing.Generator[tuple[typing.Union[str,dict[typing.Text, typing.Union[int,list[float]]],float]]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "str"
                ],
                "prior_orders": [
                    "int",
                    "list[str]",
                    "None",
                    "list[list[int]]"
                ]
            }
        },
        "MLPv2._generate_user_examples": {
            "name": "_generate_user_examples",
            "location": 104,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [],
                "num_orders_per_user": [
                    "bool"
                ]
            }
        },
        "MLPv2._load_data": {
            "name": "_load_data",
            "location": 118,
            "return": [
                "tuple[list[]]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "num_orders_per_user": [
                    "int"
                ]
            }
        },
        "MLPv2._create_data_generator": {
            "name": "_create_data_generator",
            "location": 147,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "num_orders_per_user": [
                    "bool",
                    "str",
                    "typing.Iterable[int]"
                ],
                "batch_size": [
                    "bool"
                ]
            }
        },
        "MLPv2._hidden_layer_units": {
            "name": "_hidden_layer_units",
            "location": 204,
            "return": [
                "int",
                "typing.Counter",
                "float"
            ],
            "arguments": {
                "self": [],
                "num_layers": [
                    "int"
                ],
                "from_dim": [
                    "int"
                ],
                "to_dim": [
                    "int"
                ]
            }
        },
        "MLPv2._build_model": {
            "name": "_build_model",
            "location": 209,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FitMLPv2.run": {
            "name": "run",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_PredictMLPv2.requires": {
            "name": "requires",
            "location": 288,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 307,
            "return": [
                "int"
            ],
            "arguments": {
                "order": [
                    "list[dict[str, str]]",
                    "str"
                ]
            }
        },
        "PredictMLPv2ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 314,
            "return": [
                "dict[int, ]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 324,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeMLPv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 362,
            "return": [
                "typing.Generator[PredictMLPv2ReorderSizeKnown]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2Threshold.model_name": {
            "name": "model_name",
            "location": 381,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2Threshold.run": {
            "name": "run",
            "location": 386,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictMLPv2Threshold.run": {
            "name": "run",
            "location": 415,
            "return": [
                "typing.Generator[PredictMLPv2Threshold]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ThresholdVariable.model_name": {
            "name": "model_name",
            "location": 424,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ThresholdVariable._determine_reorder_thresholds": {
            "name": "_determine_reorder_thresholds",
            "location": 429,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "str"
                ],
                "scores": [
                    "typing.Mapping",
                    "typing.OrderedDict",
                    "str"
                ]
            }
        },
        "PredictMLPv2ThresholdVariable.run": {
            "name": "run",
            "location": 483,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeMLPv2ThresholdVariable.run": {
            "name": "run",
            "location": 522,
            "return": [
                "typing.Generator[PredictMLPv2ThresholdVariable]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ExpectedF1.model_name": {
            "name": "model_name",
            "location": 539,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ExpectedF1._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 544,
            "return": [
                "dict[, ]"
            ],
            "arguments": {
                "self": [],
                "scores": []
            }
        },
        "PredictMLPv2ExpectedF1.run": {
            "name": "run",
            "location": 554,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv2._load_data.add_example": {
            "name": "add_example",
            "location": 125,
            "return": [
                "None"
            ],
            "arguments": {
                "user_id": [],
                "order_id": [],
                "product_id": [],
                "inputs": [],
                "prediction": []
            }
        },
        "MLPv2._create_data_generator.generator": {
            "name": "generator",
            "location": 159,
            "return": [
                "typing.Generator[tuple[dict[, ]]]"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/previous_order.py": {
        "PredictPreviousOrder.model_name": {
            "name": "model_name",
            "location": 12,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictPreviousOrder.run": {
            "name": "run",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/product_name_vectors.py": {
        "ProductNameVectors.model_name": {
            "name": "model_name",
            "location": 20,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ProductNameVectors.read": {
            "name": "read",
            "location": 24,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ProductNameVectors.run": {
            "name": "run",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitAllProductNameVectors.run": {
            "name": "run",
            "location": 53,
            "return": [
                "typing.Generator[ProductNameVectors]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ProductNameVectors.run.get_vector": {
            "name": "get_vector",
            "location": 34,
            "return": [
                "int"
            ],
            "arguments": {
                "product_name": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v1.py": {
        "hinge_loss": {
            "name": "hinge_loss",
            "location": 24,
            "return": [],
            "arguments": {
                "y_true": [
                    "int",
                    "dict[, ]"
                ],
                "y_pred": [
                    "int",
                    "float"
                ],
                "margin": [
                    "float"
                ]
            }
        },
        "RNNv1.model_name": {
            "name": "model_name",
            "location": 43,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv1._count_lines": {
            "name": "_count_lines",
            "location": 54,
            "return": [
                "int"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "RNNv1._open_shuffled": {
            "name": "_open_shuffled",
            "location": 59,
            "return": [
                "typing.Generator[typing.IO]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "RNNv1._generate_order_samples": {
            "name": "_generate_order_samples",
            "location": 64,
            "return": [
                "typing.Generator[tuple[typing.Text]]",
                "typing.Generator[tuple[typing.Union[str,dict[int, str]]]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "list[str]"
                ],
                "prior_orders": [
                    "list[str]"
                ]
            }
        },
        "RNNv1._generate_samples": {
            "name": "_generate_samples",
            "location": 96,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [],
                "include_prior_orders": [
                    "bool"
                ]
            }
        },
        "RNNv1.create_generator": {
            "name": "create_generator",
            "location": 104,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str",
                    "bool",
                    "list[str]"
                ],
                "users_per_batch": [
                    "bool"
                ],
                "shuffle": [
                    "bool"
                ],
                "include_prior_orders": [
                    "bool"
                ]
            }
        },
        "FitRNNv1._build_model": {
            "name": "_build_model",
            "location": 139,
            "return": [
                "Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitRNNv1.run": {
            "name": "run",
            "location": 162,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv1.requires": {
            "name": "requires",
            "location": 204,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv1.run": {
            "name": "run",
            "location": 214,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv1.create_generator.generator": {
            "name": "generator",
            "location": 109,
            "return": [
                "typing.Generator[tuple[dict[typing.Text, ]]]"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v2.py": {
        "RNNv2.model_name": {
            "name": "model_name",
            "location": 46,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._count_lines": {
            "name": "_count_lines",
            "location": 63,
            "return": [
                "int"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "RNNv2._open_shuffled": {
            "name": "_open_shuffled",
            "location": 68,
            "return": [
                "typing.Generator[typing.IO]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "RNNv2._generate_order_examples": {
            "name": "_generate_order_examples",
            "location": 73,
            "return": [
                "typing.Generator[tuple[float]]",
                "typing.Generator[tuple[typing.Union[int,str,bytes,float]]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [],
                "prior_orders": [
                    "int",
                    "list[str]",
                    "None",
                    "list[list[int]]"
                ]
            }
        },
        "RNNv2._generate_user_examples": {
            "name": "_generate_user_examples",
            "location": 105,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [],
                "max_prior_orders": [
                    "int"
                ]
            }
        },
        "RNNv2._load_data": {
            "name": "_load_data",
            "location": 117,
            "return": [
                "tuple[list[]]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "RNNv2._create_data_generator": {
            "name": "_create_data_generator",
            "location": 142,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "int",
                    "str"
                ],
                "users_per_batch": [
                    "int"
                ],
                "max_prior_orders": [
                    "int",
                    "str"
                ]
            }
        },
        "RNNv2._hidden_layer_units": {
            "name": "_hidden_layer_units",
            "location": 173,
            "return": [
                "int",
                "typing.Counter",
                "float"
            ],
            "arguments": {
                "self": [],
                "num_layers": [
                    "int"
                ],
                "from_dim": [
                    "int"
                ],
                "to_dim": [
                    "int"
                ]
            }
        },
        "RNNv2._build_product_embedding_submodel": {
            "name": "_build_product_embedding_submodel",
            "location": 178,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._build_days_attention_submodel": {
            "name": "_build_days_attention_submodel",
            "location": 186,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._build_model": {
            "name": "_build_model",
            "location": 198,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FitRNNv2.run": {
            "name": "run",
            "location": 255,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_PredictRNNv2.requires": {
            "name": "requires",
            "location": 297,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 321,
            "return": [
                "int"
            ],
            "arguments": {
                "order": [
                    "list[dict[str, str]]",
                    "str"
                ]
            }
        },
        "PredictRNNv2ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 328,
            "return": [
                "dict[int, ]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 339,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeRNNv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 381,
            "return": [
                "typing.Generator[PredictRNNv2ReorderSizeKnown]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizePercentile.model_name": {
            "name": "model_name",
            "location": 409,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizePercentile._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 414,
            "return": [
                "dict[int, int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictRNNv2ReorderSizePercentile.run": {
            "name": "run",
            "location": 431,
            "return": [
                "typing.Generator[PredictRNNv2ReorderSizePercentile]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2Threshold.model_name": {
            "name": "model_name",
            "location": 441,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2Threshold.run": {
            "name": "run",
            "location": 446,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictRNNv2Threshold.run": {
            "name": "run",
            "location": 473,
            "return": [
                "typing.Generator[PredictRNNv2Threshold]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._load_data.add_example": {
            "name": "add_example",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "order_id": [],
                "product": [],
                "orders": [],
                "prediction": []
            }
        },
        "RNNv2._create_data_generator.generator": {
            "name": "generator",
            "location": 146,
            "return": [
                "typing.Generator[tuple[dict[typing.Text, ]]]"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v3.py": {
        "RNNv3.model_name": {
            "name": "model_name",
            "location": 71,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv3._count_lines": {
            "name": "_count_lines",
            "location": 86,
            "return": [
                "int"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "RNNv3._open_shuffled": {
            "name": "_open_shuffled",
            "location": 91,
            "return": [
                "typing.Generator[typing.IO]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "RNNv3._generate_examples": {
            "name": "_generate_examples",
            "location": 96,
            "return": [
                "typing.Generator[tuple[float]]",
                "typing.Generator[tuple[typing.Union[int,str,bytes,float]]]"
            ],
            "arguments": {
                "self": [],
                "last_order": [],
                "prior_orders": [
                    "int",
                    "list[str]",
                    "None",
                    "list[list[int]]"
                ]
            }
        },
        "RNNv3._generate_user_examples": {
            "name": "_generate_user_examples",
            "location": 126,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "user_data": [],
                "max_prior_orders": [
                    "bool"
                ]
            }
        },
        "RNNv3._load_data": {
            "name": "_load_data",
            "location": 138,
            "return": [
                "tuple[list[]]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "RNNv3._create_data_generator": {
            "name": "_create_data_generator",
            "location": 164,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "max_prior_orders": [
                    "bool",
                    "str",
                    "list[str]"
                ],
                "batch_size": [
                    "bool"
                ]
            }
        },
        "RNNv3._hidden_layer_units": {
            "name": "_hidden_layer_units",
            "location": 215,
            "return": [
                "int",
                "typing.Counter",
                "float"
            ],
            "arguments": {
                "self": [],
                "num_layers": [
                    "int"
                ],
                "from_dim": [
                    "int"
                ],
                "to_dim": [
                    "int"
                ]
            }
        },
        "RNNv3._build_model": {
            "name": "_build_model",
            "location": 220,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FitRNNv3.run": {
            "name": "run",
            "location": 277,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_PredictRNNv3.requires": {
            "name": "requires",
            "location": 320,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 342,
            "return": [
                "int"
            ],
            "arguments": {
                "order": [
                    "list[dict[str, str]]",
                    "str"
                ]
            }
        },
        "PredictRNNv3ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 349,
            "return": [
                "dict[int, ]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3ReorderSizeKnown.run": {
            "name": "run",
            "location": 360,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeRNNv3ReorderSizeKnown.run": {
            "name": "run",
            "location": 402,
            "return": [
                "typing.Generator[PredictRNNv3ReorderSizeKnown]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3Threshold.model_name": {
            "name": "model_name",
            "location": 427,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3Threshold.run": {
            "name": "run",
            "location": 432,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictRNNv3Threshold.run": {
            "name": "run",
            "location": 461,
            "return": [
                "typing.Generator[PredictRNNv3Threshold]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv3._load_data.add_example": {
            "name": "add_example",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "order_id": [],
                "product": [],
                "orders": [],
                "prediction": []
            }
        },
        "RNNv3._create_data_generator.generator": {
            "name": "generator",
            "location": 176,
            "return": [
                "typing.Generator[tuple[dict[typing.Text, ]]]"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v4.py": {
        "open_shuffled": {
            "name": "open_shuffled",
            "location": 33,
            "return": [
                "typing.Generator[typing.IO]"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "list[str]"
                ]
            }
        },
        "layer_units": {
            "name": "layer_units",
            "location": 187,
            "return": [
                "list[]"
            ],
            "arguments": {
                "input_size": [
                    "int",
                    "list[int]"
                ],
                "output_size": [
                    "int",
                    "list[int]"
                ],
                "num_layers": [
                    "int"
                ]
            }
        },
        "RNNv4.model_name": {
            "name": "model_name",
            "location": 54,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv4._init_random_state": {
            "name": "_init_random_state",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv4._iter_user_data": {
            "name": "_iter_user_data",
            "location": 70,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "RNNv4._generate_example": {
            "name": "_generate_example",
            "location": 76,
            "return": [
                "tuple[typing.Union[list[dict[typing.Text, typing.Union[str,int]]],list[int]]]"
            ],
            "arguments": {
                "self": [],
                "prior_orders": [
                    "str",
                    "set[str]"
                ],
                "last_order": [
                    "str"
                ]
            }
        },
        "RNNv4._generate_examples": {
            "name": "_generate_examples",
            "location": 121,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "target_orders": [],
                "shuffle": [
                    "bool"
                ]
            }
        },
        "RNNv4._format_as_tensors": {
            "name": "_format_as_tensors",
            "location": 147,
            "return": [
                "tuple[typing.Union[dict[typing.Text, ],Variable]]"
            ],
            "arguments": {
                "self": [],
                "product_history": [
                    "int"
                ],
                "next_products": [
                    "int",
                    "bytes"
                ],
                "next_products_targets": [
                    "bool",
                    "typing.Callable[, ]",
                    "list[]"
                ]
            }
        },
        "RNNv4._load_model": {
            "name": "_load_model",
            "location": 172,
            "return": [
                "Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "Projection.__init__": {
            "name": "__init__",
            "location": 195,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "None",
                    "float"
                ],
                "output_size": [
                    "int",
                    "None",
                    "float"
                ],
                "hidden_layers": [
                    "int",
                    "None",
                    "float"
                ],
                "nonlinearity": [
                    "int"
                ],
                "dropout": [
                    "list[]",
                    "list[int]",
                    "int",
                    "typing.Type"
                ]
            }
        },
        "Projection.forward": {
            "name": "forward",
            "location": 223,
            "return": [],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weekday_dim": [
                    "int"
                ],
                "department_dim": [
                    "int"
                ],
                "aisle_dim": [
                    "int"
                ],
                "product_dim": [
                    "int"
                ],
                "scoring_dim": [
                    "str",
                    "bool"
                ],
                "hidden_layers": [
                    "str",
                    "bool"
                ],
                "hidden_nonlinearily": [
                    "str",
                    "bool"
                ],
                "dropout": [
                    "str",
                    "bool"
                ]
            }
        },
        "Model._init_embeddings": {
            "name": "_init_embeddings",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weekday_dim": [
                    "bool"
                ],
                "department_dim": [
                    "bool"
                ],
                "aisle_dim": [
                    "bool"
                ],
                "product_dim": [
                    "bool",
                    "list[typing.Any]",
                    "None"
                ]
            }
        },
        "Model._init_lstm": {
            "name": "_init_lstm",
            "location": 260,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scoring_dim": [
                    "typing.Iterable[T]",
                    "None",
                    "bool",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "Model.forward": {
            "name": "forward",
            "location": 277,
            "return": [
                "int",
                "tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]]",
                "typing.Type"
            ],
            "arguments": {
                "self": [],
                "product_history": [
                    "str"
                ],
                "next_products": [
                    "list[int]",
                    "str"
                ]
            }
        },
        "FitRNNv4._split_orders": {
            "name": "_split_orders",
            "location": 327,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "FitRNNv4._train_model": {
            "name": "_train_model",
            "location": 341,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "float",
                    "int",
                    "dict[str, str]"
                ],
                "optimizer": [],
                "orders_path": [
                    "str",
                    "None",
                    "int",
                    "dict[, ]"
                ]
            }
        },
        "FitRNNv4._evaluate_model": {
            "name": "_evaluate_model",
            "location": 356,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "list[str]",
                    "dict[str, str]"
                ],
                "orders_path": [
                    "typing.IO",
                    "list[]",
                    "str"
                ]
            }
        },
        "FitRNNv4.run": {
            "name": "run",
            "location": 368,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv4._format_as_tensors.create_tensor": {
            "name": "create_tensor",
            "location": 149,
            "return": [
                "Variable"
            ],
            "arguments": {
                "tensor_type": [],
                "orders": [],
                "field": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v5.py": {},
    "kaggle-master/instacart-basket-analysis/pipelines/models/__init__.py": {
        "FitModel.requires": {
            "name": "requires",
            "location": 17,
            "return": [
                "dict[typing.Text, typing.Union[TrainingOrders,CompleteOrders]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.model_name": {
            "name": "model_name",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.output": {
            "name": "output",
            "location": 26,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.requires": {
            "name": "requires",
            "location": 33,
            "return": [
                "dict[typing.Text, typing.Union[TestOrders,SubmissionOrders]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.model_name": {
            "name": "model_name",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.output": {
            "name": "output",
            "location": 42,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.output": {
            "name": "output",
            "location": 52,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.read": {
            "name": "read",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/common.py": {
        "pack_example": {
            "name": "pack_example",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "example": [
                    "str"
                ],
                "fout": [
                    "str"
                ]
            }
        },
        "unpack_example": {
            "name": "unpack_example",
            "location": 50,
            "return": [
                "dict[typing.Text, typing.Union[str,list[]]]"
            ],
            "arguments": {
                "fin": []
            }
        },
        "unpack_examples": {
            "name": "unpack_examples",
            "location": 68,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "fin": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/convnet_data.py": {
        "_process_strokes": {
            "name": "_process_strokes",
            "location": 12,
            "return": [],
            "arguments": {
                "strokes": [
                    "bool",
                    "typing.Iterable[str]",
                    "float"
                ],
                "image_size": [
                    "str",
                    "typing.IO",
                    "tuple[typing.Union[numpy.ndarray,numpy.ndarray]]",
                    "tuple[]"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        },
        "_process_drawing": {
            "name": "_process_drawing",
            "location": 25,
            "return": [
                "int",
                "float",
                "list[tuple[typing.Union[typing.Any,typing.Any]]]"
            ],
            "arguments": {
                "drawing": [
                    "list[str]",
                    "bytes",
                    "list[]",
                    "int",
                    "ValueError"
                ],
                "image_size": [
                    "float",
                    "tuple[typing.Union[int,int]]",
                    "int",
                    "str"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        },
        "_csv_generator": {
            "name": "_csv_generator",
            "location": 31,
            "return": [
                "typing.Generator[tuple[]]"
            ],
            "arguments": {
                "csv_file": [
                    "str"
                ],
                "image_size": [
                    "int",
                    "str",
                    "float"
                ],
                "augmentation": [
                    "bool"
                ],
                "read_label": [
                    "bool"
                ]
            }
        },
        "_bin_generator": {
            "name": "_bin_generator",
            "location": 43,
            "return": [
                "typing.Generator[tuple[]]"
            ],
            "arguments": {
                "bin_file": [
                    "str"
                ],
                "image_size": [
                    "int",
                    "str",
                    "float"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        },
        "_load_train_sample": {
            "name": "_load_train_sample",
            "location": 50,
            "return": [
                "typing.TextIO"
            ],
            "arguments": {
                "random_seed": [
                    "str",
                    "int",
                    "None"
                ],
                "name": [
                    "str",
                    "int",
                    "None"
                ],
                "image_size": [
                    "str",
                    "bool"
                ],
                "augmentation": [
                    "str",
                    "bool"
                ]
            }
        },
        "load_train_val_datasets": {
            "name": "load_train_val_datasets",
            "location": 79,
            "return": [
                "tuple[typing.Union[int,float,list[],str,dict[, ],list[tuple[]],list[int]]]"
            ],
            "arguments": {
                "image_size": [
                    "int",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "float"
                ],
                "augmentation": [
                    "int",
                    "float"
                ],
                "random_seed": [
                    "int",
                    "float"
                ]
            }
        },
        "load_test_dataset": {
            "name": "load_test_dataset",
            "location": 93,
            "return": [
                "int"
            ],
            "arguments": {
                "image_size": [
                    "float",
                    "int"
                ],
                "batch_size": [
                    "float",
                    "int"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/drawing.py": {
        "parse_drawing": {
            "name": "parse_drawing",
            "location": 9,
            "return": [
                "list[]",
                "list[float]",
                "float",
                "int"
            ],
            "arguments": {
                "drawing": [
                    "dict[str, typing.Any]",
                    "str"
                ],
                "normalize": [
                    "bool"
                ]
            }
        },
        "normalize_strokes": {
            "name": "normalize_strokes",
            "location": 19,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "list[str]"
                ]
            }
        },
        "simplify_strokes": {
            "name": "simplify_strokes",
            "location": 31,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "str"
                ],
                "epsilon": [
                    "float",
                    "str"
                ]
            }
        },
        "rotate_strokes": {
            "name": "rotate_strokes",
            "location": 37,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "dict[str, typing.Any]",
                    "str",
                    "list[dict[, ]]"
                ],
                "degrees": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "mirror_strokes": {
            "name": "mirror_strokes",
            "location": 45,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "dict[str, typing.Any]",
                    "str",
                    "list[dict[, ]]"
                ]
            }
        },
        "render_image": {
            "name": "render_image",
            "location": 63,
            "return": [],
            "arguments": {
                "strokes": [
                    "str"
                ],
                "image_size": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/generate_train_sample.py": {
        "write_partitions": {
            "name": "write_partitions",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "bool"
                ],
                "output_dir": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "generate_train_sample": {
            "name": "generate_train_sample",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "spark": [
                    "bool",
                    "str",
                    "list[str]",
                    "None"
                ],
                "train_examples_per_class": [
                    "int"
                ],
                "val_examples_per_class": [
                    "int"
                ],
                "random_seed": [
                    "list[int]",
                    "int",
                    "None"
                ]
            }
        },
        "write_partitions.write_partition": {
            "name": "write_partition",
            "location": 16,
            "return": [
                "list[]"
            ],
            "arguments": {
                "i": [],
                "iterator": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/models.py": {
        "get_model_wrapper": {
            "name": "get_model_wrapper",
            "location": 9,
            "return": [
                "ConvNetWrapper"
            ],
            "arguments": {
                "_config": [
                    "str"
                ]
            }
        },
        "_BaseModelWrapper.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "_config": []
            }
        },
        "_BaseModelWrapper.train": {
            "name": "train",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "int",
                    "str",
                    "typing.Iterable[C]"
                ],
                "dataset": [
                    "int",
                    "str",
                    "typing.Iterable[C]"
                ]
            }
        },
        "_BaseModelWrapper.validate": {
            "name": "validate",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "str",
                    "typing.Iterable[C]"
                ]
            }
        },
        "_BaseModelWrapper.predict": {
            "name": "predict",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "str",
                    "typing.Iterable[C]"
                ]
            }
        },
        "_BaseModelWrapper.calculate_map": {
            "name": "calculate_map",
            "location": 32,
            "return": [
                "str",
                "tuple[float]",
                "typing.Final",
                "list[int]",
                "list[None]"
            ],
            "arguments": {
                "self": [],
                "scores": [
                    "int",
                    "typing.Callable[, ]",
                    "typing.Type",
                    "dict[str, dict[str, typing.Any]]"
                ],
                "labels": [
                    "int",
                    "float",
                    "list[numpy.array]"
                ],
                "k": [
                    "int"
                ]
            }
        },
        "CustomFlatten.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "tuple[_]",
                    "int"
                ]
            }
        },
        "CustomFlatten.call": {
            "name": "call",
            "location": 59,
            "return": [
                "int",
                "dict[int, str]",
                "list[]",
                "float"
            ],
            "arguments": {
                "self": [],
                "input_tensor": [
                    "int",
                    "str"
                ],
                "training": [
                    "bool"
                ]
            }
        },
        "ConvNetWrapper.__init__": {
            "name": "__init__",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "_config": []
            }
        },
        "ConvNetWrapper.calculate_loss": {
            "name": "calculate_loss",
            "location": 109,
            "return": [
                "str",
                "list[str]",
                "list[tuple[typing.Union[str,int]]]",
                "list[]"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "bool"
                ],
                "labels": [
                    "bool"
                ]
            }
        },
        "ConvNetWrapper.train": {
            "name": "train",
            "location": 115,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "int",
                    "str",
                    "dict[int, typing.Any]"
                ],
                "dataset": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "ConvNetWrapper.validate": {
            "name": "validate",
            "location": 143,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "ConvNetWrapper.predict": {
            "name": "predict",
            "location": 164,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/submit.py": {
        "submit": {
            "name": "submit",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "experiment_name": [
                    "str",
                    "dict[str, str]"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/train_convnet.py": {
        "config": {
            "name": "config",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "_run": [],
                "_config": [
                    "str"
                ],
                "_log": []
            }
        },
        "generate_predictions": {
            "name": "generate_predictions",
            "location": 149,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "_config": [],
                "_log": [],
                "model_wrapper": [
                    "str",
                    "dict[, ]"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/common.py": {
        "pack_example": {
            "name": "pack_example",
            "location": 360,
            "return": [
                "None"
            ],
            "arguments": {
                "image": [
                    "int",
                    "tuple[typing.Union[numpy.ndarray,float]]"
                ],
                "label": [
                    "str",
                    "list[str]",
                    "memoryview"
                ],
                "fout": [
                    "list[str]",
                    "dict[, ]",
                    "tuple[typing.Union[int,int]]",
                    "bytes"
                ]
            }
        },
        "unpack_example": {
            "name": "unpack_example",
            "location": 365,
            "return": [
                "dict[typing.Text, typing.Union[str,int,list[],list[int]]]"
            ],
            "arguments": {
                "fin": []
            }
        },
        "unpack_examples": {
            "name": "unpack_examples",
            "location": 374,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "fin": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "roundrobin": {
            "name": "roundrobin",
            "location": 383,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "iterables": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/convnet.py": {
        "get_model": {
            "name": "get_model",
            "location": 6,
            "return": [],
            "arguments": {}
        },
        "CustomFlatten.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "tuple[rl_algorithms.common.abstraclearner.TensorTuple]",
                    "int"
                ]
            }
        },
        "CustomFlatten.call": {
            "name": "call",
            "location": 62,
            "return": [
                "int",
                "dict[int, str]",
                "list[]",
                "float"
            ],
            "arguments": {
                "self": [],
                "input_tensor": [
                    "int",
                    "str"
                ],
                "training": [
                    "bool"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/drawing.py": {
        "process_drawing": {
            "name": "process_drawing",
            "location": 6,
            "return": [
                "int",
                "float",
                "list[tuple[typing.Union[typing.Any,typing.Any]]]"
            ],
            "arguments": {
                "drawing": [
                    "list[str]",
                    "bytes",
                    "list[]",
                    "int",
                    "ValueError"
                ],
                "image_size": [
                    "float",
                    "tuple[typing.Union[int,int]]",
                    "int",
                    "str"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        },
        "process_strokes": {
            "name": "process_strokes",
            "location": 12,
            "return": [],
            "arguments": {
                "strokes": [
                    "bool",
                    "typing.Iterable[str]",
                    "float"
                ],
                "image_size": [
                    "str",
                    "typing.IO",
                    "tuple[typing.Union[numpy.ndarray,numpy.ndarray]]",
                    "tuple[]"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        },
        "parse_drawing": {
            "name": "parse_drawing",
            "location": 25,
            "return": [
                "list[]",
                "list[float]",
                "float",
                "int"
            ],
            "arguments": {
                "drawing": [
                    "dict[str, typing.Any]",
                    "str"
                ],
                "normalize": [
                    "bool"
                ]
            }
        },
        "rotate_strokes": {
            "name": "rotate_strokes",
            "location": 35,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "dict[str, typing.Any]",
                    "str",
                    "list[dict[, ]]"
                ],
                "degrees": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ]
            }
        },
        "mirror_strokes": {
            "name": "mirror_strokes",
            "location": 43,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "dict[str, typing.Any]",
                    "str",
                    "list[dict[, ]]"
                ]
            }
        },
        "normalize_strokes": {
            "name": "normalize_strokes",
            "location": 49,
            "return": [
                "list[]"
            ],
            "arguments": {
                "strokes": [
                    "list[str]"
                ]
            }
        },
        "render_image": {
            "name": "render_image",
            "location": 61,
            "return": [],
            "arguments": {
                "strokes": [
                    "str"
                ],
                "image_size": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/generate_train_data.py": {
        "write_partitions": {
            "name": "write_partitions",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "bool"
                ],
                "output_dir": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "generate_train_data": {
            "name": "generate_train_data",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "spark": [
                    "bytes",
                    "typing.Any",
                    "None",
                    "str",
                    "int"
                ],
                "num_partitions": [
                    "int",
                    "None",
                    "typing.Callable[, ]"
                ]
            }
        },
        "write_partitions.write_partition": {
            "name": "write_partition",
            "location": 16,
            "return": [
                "list[]"
            ],
            "arguments": {
                "i": [],
                "iterator": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/onecycle.py": {
        "OneCycleLR.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int"
                ],
                "num_epochs": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ],
                "max_lr": [
                    "int",
                    "float",
                    "None",
                    "str"
                ],
                "end_percentage": [
                    "float"
                ],
                "scale_percentage": [
                    "int"
                ],
                "maximum_momentum": [
                    "float"
                ],
                "minimum_momentum": [
                    "float"
                ],
                "verbose": [
                    "bool"
                ]
            }
        },
        "OneCycleLR._reset": {
            "name": "_reset",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OneCycleLR.compute_lr": {
            "name": "compute_lr",
            "location": 83,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "OneCycleLR.compute_momentum": {
            "name": "compute_momentum",
            "location": 113,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "OneCycleLR.on_train_begin": {
            "name": "on_train_begin",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "logs": [
                    "dict[, ]"
                ]
            }
        },
        "OneCycleLR.on_batch_end": {
            "name": "on_batch_end",
            "location": 151,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "dict[, ]",
                    "None",
                    "str",
                    "list[float]"
                ],
                "logs": [
                    "None",
                    "int",
                    "dict[, ]",
                    "str",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "OneCycleLR.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 172,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "dict[, ]",
                    "None",
                    "str",
                    "list[float]"
                ],
                "logs": [
                    "None",
                    "int",
                    "dict[, ]",
                    "str",
                    "list[float]"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/predict_convnet.py": {
        "get_test_generator": {
            "name": "get_test_generator",
            "location": 16,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "list[str]",
                    "str"
                ],
                "augmentation": [
                    "bool"
                ]
            }
        },
        "generate_predictions": {
            "name": "generate_predictions",
            "location": 34,
            "return": [
                "float"
            ],
            "arguments": {
                "model": [
                    "float",
                    "None",
                    "int"
                ],
                "augmented_images": [
                    "float"
                ]
            }
        },
        "write_submission": {
            "name": "write_submission",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "predictions": [
                    "str",
                    "bool",
                    "dict[str, str]"
                ],
                "output_file": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/train_convnet.py": {
        "bin_generator": {
            "name": "bin_generator",
            "location": 12,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "bin_file": [
                    "str"
                ]
            }
        },
        "get_train_generator": {
            "name": "get_train_generator",
            "location": 17,
            "return": [
                "typing.Generator[tuple[]]"
            ],
            "arguments": {
                "batch_size": [
                    "float",
                    "list[int]",
                    "list[]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/titanic/util.py": {
        "get_random_seed": {
            "name": "get_random_seed",
            "location": 9,
            "return": [],
            "arguments": {
                "num_bytes": []
            }
        },
        "ModelImputer.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "y_column": [],
                "X_columns": []
            }
        },
        "ModelImputer._get_X_columns": {
            "name": "_get_X_columns",
            "location": 21,
            "return": [],
            "arguments": {
                "self": [],
                "X": []
            }
        },
        "ModelImputer.fit": {
            "name": "fit",
            "location": 25,
            "return": [],
            "arguments": {
                "self": [],
                "X": [],
                "y": []
            }
        },
        "ModelImputer.transform": {
            "name": "transform",
            "location": 32,
            "return": [],
            "arguments": {
                "self": [],
                "X": []
            }
        },
        "ColumnSelector.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [],
            "arguments": {
                "self": [],
                "columns": []
            }
        },
        "ColumnSelector.fit": {
            "name": "fit",
            "location": 47,
            "return": [],
            "arguments": {
                "self": [],
                "X": [],
                "y": []
            }
        },
        "ColumnSelector._get_support_mask": {
            "name": "_get_support_mask",
            "location": 51,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/base.py": {
        "CommentsDataset.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "tuple[numpy.dtype]"
                ],
                "fields": [
                    "typing.Type",
                    "tuple[typing.Union[typing.Type,...]]",
                    "dict[str, typing.Any]",
                    "dict[str, typing.Iterable[typing.Any]]"
                ]
            }
        },
        "BaseModel.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "int"
                ],
                "random_seed": [
                    "int",
                    "str"
                ]
            }
        },
        "BaseModel.main": {
            "name": "main",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.load_preprocessed_data": {
            "name": "load_preprocessed_data",
            "location": 117,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.build_fields_and_vocab": {
            "name": "build_fields_and_vocab",
            "location": 121,
            "return": [
                "tuple[list[tuple[typing.Union[typing.Text,Field]]]]"
            ],
            "arguments": {
                "self": [],
                "preprocessed_data": [
                    "str",
                    "int",
                    "None"
                ]
            }
        },
        "BaseModel.train": {
            "name": "train",
            "location": 154,
            "return": [],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "dict[str, typing.Any]",
                    "float"
                ],
                "train_df": [
                    "bool",
                    "list[dict[typing.Any, typing.Any]]",
                    "tuple[int]"
                ],
                "val_df": [
                    "typing.Callable[numpy.ndarray,numpy.ndarray, numpy.ndarray]",
                    "int",
                    "float",
                    "None"
                ]
            }
        },
        "BaseModel.predict": {
            "name": "predict",
            "location": 236,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [],
                "df": [
                    "str",
                    "typing.Sequence[str]"
                ],
                "output_path": [
                    "str",
                    "None"
                ]
            }
        },
        "BaseModel.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 250,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "bool",
                    "list[]"
                ]
            }
        },
        "BaseModel.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "bool",
                    "list[]"
                ]
            }
        },
        "BaseModel.build_model": {
            "name": "build_model",
            "location": 256,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.calculate_loss": {
            "name": "calculate_loss",
            "location": 259,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "typing.Mapping",
                    "str"
                ],
                "batch": [
                    "str",
                    "typing.Type",
                    "bool"
                ]
            }
        },
        "BaseModel.update_parameters": {
            "name": "update_parameters",
            "location": 265,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "list[]",
                    "list[tuple[typing.Union[str,str]]]",
                    "typing.Type",
                    "str",
                    "list[str]"
                ],
                "optimizer": [],
                "loss": [
                    "list[]",
                    "list[tuple[typing.Union[str,str]]]",
                    "typing.Type",
                    "str",
                    "list[str]"
                ]
            }
        },
        "BaseModel.evaluate_model": {
            "name": "evaluate_model",
            "location": 268,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "batch_iter": []
            }
        },
        "BaseModel.save_model": {
            "name": "save_model",
            "location": 281,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int"
                ],
                "model": []
            }
        },
        "BaseModel.load_model": {
            "name": "load_model",
            "location": 285,
            "return": [
                "dict[str, typing.Any]",
                "list[str]"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int"
                ]
            }
        },
        "BaseModule.__init__": {
            "name": "__init__",
            "location": 294,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "bytes",
                    "float"
                ]
            }
        },
        "Dense.__init__": {
            "name": "__init__",
            "location": 311,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "list[None]",
                    "str"
                ],
                "output_size": [
                    "int",
                    "list[None]",
                    "str"
                ],
                "output_nonlinearity": [
                    "None",
                    "list[]"
                ],
                "hidden_layers": [
                    "int"
                ],
                "hidden_nonlinearity": [
                    "None",
                    "str",
                    "typing.Iterable[]",
                    "int"
                ],
                "input_dropout": [
                    "int"
                ],
                "hidden_dropout": [
                    "int"
                ],
                "dropout": [
                    "int"
                ]
            }
        },
        "Dense.forward": {
            "name": "forward",
            "location": 359,
            "return": [],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "WeightDrop.__init__": {
            "name": "__init__",
            "location": 366,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "None",
                    "bool"
                ],
                "weights": [
                    "str",
                    "None",
                    "bool"
                ],
                "dropout": [
                    "int"
                ]
            }
        },
        "WeightDrop.no_op": {
            "name": "no_op",
            "location": 373,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "WeightDrop._setup": {
            "name": "_setup",
            "location": 376,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "WeightDrop._setweights": {
            "name": "_setweights",
            "location": 386,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "WeightDrop.forward": {
            "name": "forward",
            "location": 392,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.build_fields_and_vocab.getitem": {
            "name": "getitem",
            "location": 146,
            "return": [],
            "arguments": {
                "self": [],
                "token": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/common.py": {
        "params_str": {
            "name": "params_str",
            "location": 24,
            "return": [
                "str"
            ],
            "arguments": {
                "params": [
                    "dict[int, dict[str, typing.Any]]"
                ]
            }
        },
        "load_raw_data": {
            "name": "load_raw_data",
            "location": 31,
            "return": [
                "dict[, ]"
            ],
            "arguments": {}
        },
        "load_data": {
            "name": "load_data",
            "location": 43,
            "return": [],
            "arguments": {
                "dataset": [
                    "str",
                    "bool"
                ]
            }
        },
        "stratified_kfold": {
            "name": "stratified_kfold",
            "location": 50,
            "return": [
                "typing.Generator[tuple[typing.Union[set[],set[]]]]"
            ],
            "arguments": {
                "df": [
                    "list[int]"
                ],
                "random_seed": [
                    "int",
                    "list[str]",
                    "None",
                    "float"
                ],
                "k": [
                    "int"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/dpcnn.py": {
        "ConvBlock.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "channels": [
                    "int",
                    "float",
                    "None",
                    "str"
                ],
                "dropout": [
                    "int"
                ]
            }
        },
        "ConvBlock._init_batchnorm": {
            "name": "_init_batchnorm",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "bool",
                    "None",
                    "typing.Callable[, ]"
                ]
            }
        },
        "ConvBlock._init_conv": {
            "name": "_init_conv",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "None",
                    "typing.Callable[, ]"
                ]
            }
        },
        "ConvBlock.forward": {
            "name": "forward",
            "location": 40,
            "return": [
                "int",
                "list[list[int]]",
                "float",
                "list[typing.Type]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "list[]",
                    "list[float]",
                    "float"
                ]
            }
        },
        "DPCNNModule.__init__": {
            "name": "__init__",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "bool",
                    "str"
                ],
                "conv_blocks": [
                    "int"
                ],
                "conv_dropout": [
                    "list[float]",
                    "None",
                    "int",
                    "tuple[int]",
                    "typing.Type",
                    "str",
                    "float"
                ],
                "dense_layers": [
                    "int"
                ],
                "dense_nonlinearily": [
                    "int"
                ],
                "dense_dropout": [
                    "int"
                ]
            }
        },
        "DPCNNModule.forward": {
            "name": "forward",
            "location": 72,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "typing.Sequence[dict[str, str]]",
                    "dict[str, typing.Any]",
                    "None"
                ],
                "text_lengths": [
                    "str",
                    "bool",
                    "list[typing.Any]"
                ]
            }
        },
        "DPCNN.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 90,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "typing.Iterable[I]",
                    "bool"
                ]
            }
        },
        "DPCNN.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 97,
            "return": [
                "tuple[typing.Union[list[],Iterator]]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str"
                ]
            }
        },
        "DPCNN.build_model": {
            "name": "build_model",
            "location": 105,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/evaluation.py": {
        "main": {
            "name": "main",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "kaggle-master/toxic-comment-classification/gcnn.py": {
        "GLU.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "in_channels": [
                    "int",
                    "float"
                ],
                "out_channels": [
                    "int"
                ],
                "kernel_size": [
                    "int",
                    "dict[str, torch.LongTensor]"
                ]
            }
        },
        "GLU._init_conv": {
            "name": "_init_conv",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "None",
                    "typing.Callable[, ]"
                ]
            }
        },
        "GLU.forward": {
            "name": "forward",
            "location": 34,
            "return": [],
            "arguments": {
                "self": [],
                "x": [
                    "tuple[int]"
                ]
            }
        },
        "ResidualBlock.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "in_channels": [
                    "bool",
                    "float"
                ],
                "out_channels": [
                    "bool",
                    "float"
                ],
                "kernel_size": [
                    "bool",
                    "float"
                ],
                "num_layers": [
                    "int"
                ]
            }
        },
        "ResidualBlock.forward": {
            "name": "forward",
            "location": 59,
            "return": [
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ]
            }
        },
        "GCNNModule.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str"
                ],
                "num_blocks": [
                    "int"
                ],
                "num_layers": [
                    "int",
                    "None",
                    "float"
                ],
                "num_channels": [
                    "int",
                    "float",
                    "None"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "None"
                ],
                "dense_layers": [
                    "int",
                    "None",
                    "str",
                    "list[int]"
                ],
                "dense_dropout": [
                    "int",
                    "None",
                    "str",
                    "list[int]"
                ]
            }
        },
        "GCNNModule.forward": {
            "name": "forward",
            "location": 90,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "typing.Sequence[dict[str, str]]",
                    "dict[str, typing.Any]",
                    "None"
                ],
                "text_lengths": [
                    "str",
                    "bool",
                    "list[typing.Any]"
                ]
            }
        },
        "GCNN.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 107,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "typing.Iterable[I]",
                    "bool"
                ]
            }
        },
        "GCNN.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 114,
            "return": [
                "tuple[typing.Union[list[],Iterator]]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str"
                ]
            }
        },
        "GCNN.build_model": {
            "name": "build_model",
            "location": 122,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "GCNN.update_parameters": {
            "name": "update_parameters",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [],
                "optimizer": [],
                "loss": [
                    "list[]",
                    "list[tuple[typing.Union[str,str]]]",
                    "typing.Type",
                    "str",
                    "list[str]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/gru.py": {
        "minimal_preprocessing": {
            "name": "minimal_preprocessing",
            "location": 25,
            "return": [
                "tuple[typing.Union[str,list[typing.Text]]]"
            ],
            "arguments": {
                "row": [
                    "list[str]"
                ]
            }
        },
        "GRUModule.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str"
                ],
                "annotation_dropout": [
                    "int",
                    "float",
                    "None"
                ],
                "prediction_dropout": [
                    "int",
                    "str"
                ]
            }
        },
        "GRUModule.forward": {
            "name": "forward",
            "location": 84,
            "return": [],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "typing.Sequence[dict[str, str]]",
                    "dict[str, typing.Any]",
                    "None"
                ],
                "text_lengths": []
            }
        },
        "GRU.load_preprocessed_data": {
            "name": "load_preprocessed_data",
            "location": 112,
            "return": [
                "dict[, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GRU.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 142,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "typing.Iterable[I]",
                    "bool"
                ]
            }
        },
        "GRU.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 151,
            "return": [
                "tuple[typing.Union[list[],Iterator]]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str"
                ]
            }
        },
        "GRU.build_model": {
            "name": "build_model",
            "location": 163,
            "return": [
                "GRUModule"
            ],
            "arguments": {
                "self": []
            }
        },
        "GRU.update_parameters": {
            "name": "update_parameters",
            "location": 172,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [],
                "optimizer": [],
                "loss": [
                    "list[]",
                    "list[tuple[typing.Union[str,str]]]",
                    "typing.Type",
                    "str",
                    "list[str]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/label_stacking.py": {
        "LabelStacking.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bool",
                    "None",
                    "dict[, ]"
                ],
                "params": [
                    "str",
                    "bool",
                    "None",
                    "dict[, ]",
                    "bytes"
                ],
                "random_seed": [
                    "bool",
                    "str",
                    "None",
                    "dict[, ]"
                ]
            }
        },
        "LabelStacking.main": {
            "name": "main",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelStacking.load_inputs": {
            "name": "load_inputs",
            "location": 199,
            "return": [],
            "arguments": {
                "self": [],
                "ids": [
                    "str",
                    "typing.Iterable[int]"
                ],
                "dataset": [
                    "str",
                    "int",
                    "list[str]"
                ]
            }
        },
        "LabelStacking.train": {
            "name": "train",
            "location": 210,
            "return": [],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "float",
                    "list[]"
                ],
                "label": [
                    "int",
                    "float",
                    "list[]"
                ],
                "X_train": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ],
                "y_train": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ],
                "X_val": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ],
                "y_val": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ]
            }
        },
        "LabelStacking.save_model": {
            "name": "save_model",
            "location": 230,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "float",
                    "str",
                    "None"
                ],
                "label": [
                    "int",
                    "float",
                    "str",
                    "None"
                ],
                "model": [
                    "bool",
                    "float"
                ]
            }
        },
        "LabelStacking.load_model": {
            "name": "load_model",
            "location": 234,
            "return": [],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "bool",
                    "None"
                ],
                "label": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "LabelStacking.predict": {
            "name": "predict",
            "location": 239,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "bool",
                    "list[float]"
                ],
                "X": [
                    "bool",
                    "list[float]"
                ]
            }
        },
        "Stacking.__init__": {
            "name": "__init__",
            "location": 246,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "bool",
                    "None",
                    "list[str]"
                ],
                "params": [
                    "str"
                ],
                "random_seed": [
                    "str",
                    "dict[, ]",
                    "bool"
                ]
            }
        },
        "Stacking.main": {
            "name": "main",
            "location": 257,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/lstm.py": {
        "LSTMModule.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [],
            "arguments": {
                "self": [],
                "vocab": [],
                "rnn_size": [],
                "rnn_layers": [],
                "rnn_dropout": [],
                "dense_layers": [],
                "dense_nonlinearily": [],
                "dense_dropout": []
            }
        },
        "LSTMModule.forward": {
            "name": "forward",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "text": [],
                "text_lengths": []
            }
        },
        "LSTM.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 70,
            "return": [],
            "arguments": {
                "self": [],
                "df": []
            }
        },
        "LSTM.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 78,
            "return": [],
            "arguments": {
                "self": [],
                "df": []
            }
        },
        "LSTM.build_model": {
            "name": "build_model",
            "location": 89,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LSTM.update_parameters": {
            "name": "update_parameters",
            "location": 100,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "optimizer": [],
                "loss": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/mlp.py": {
        "MLPModule.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "typing.Callable[, ]",
                    "str",
                    "None"
                ],
                "hidden_layers": [
                    "bool",
                    "float"
                ],
                "hidden_units": [
                    "str",
                    "bool",
                    "list[list[T]]",
                    "float"
                ],
                "hidden_nonlinearity": [
                    "str",
                    "bool",
                    "list[list[T]]",
                    "float"
                ],
                "input_dropout": [
                    "int"
                ],
                "hidden_dropout": [
                    "int"
                ]
            }
        },
        "MLPModule.forward": {
            "name": "forward",
            "location": 23,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "typing.Sequence[dict[str, str]]",
                    "dict[str, typing.Any]",
                    "None"
                ],
                "text_lengths": []
            }
        },
        "MLP.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 33,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "typing.Iterable[I]",
                    "bool"
                ]
            }
        },
        "MLP.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 40,
            "return": [
                "tuple[typing.Union[list[],Iterator]]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str"
                ]
            }
        },
        "MLP.build_model": {
            "name": "build_model",
            "location": 48,
            "return": [
                "MLPModule",
                "str",
                "dict[str, str]",
                "list[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/ngram.py": {
        "NGram.main": {
            "name": "main",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "NGram.train": {
            "name": "train",
            "location": 84,
            "return": [
                "dict[, LogisticRegression]"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int",
                    "None"
                ],
                "vectorizer": [],
                "train_df": [
                    "str"
                ],
                "val_df": [
                    "bool",
                    "typing.Iterable[T]",
                    "typing.Sequence[str]",
                    "float"
                ]
            }
        },
        "NGram.predict": {
            "name": "predict",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "models": [
                    "bool",
                    "str"
                ],
                "vectorizer": [],
                "df": [
                    "str"
                ],
                "output_path": [
                    "str",
                    "typing.MutableMapping"
                ]
            }
        },
        "NGram.build_vectorizer": {
            "name": "build_vectorizer",
            "location": 118,
            "return": [
                "TfidfVectorizer"
            ],
            "arguments": {
                "self": [],
                "train_df": [],
                "test_df": [
                    "tuple[int]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/preprocessing.py": {
        "load": {
            "name": "load",
            "location": 25,
            "return": [
                "dict[, str]"
            ],
            "arguments": {
                "params": [
                    "str"
                ]
            }
        },
        "preprocess_row": {
            "name": "preprocess_row",
            "location": 67,
            "return": [
                "tuple[int]"
            ],
            "arguments": {
                "row": [
                    "list[int]"
                ]
            }
        },
        "preprocess": {
            "name": "preprocess",
            "location": 71,
            "return": [
                "list[typing.Text]"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/stacking.py": {
        "Stacking.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "bool"
                ],
                "random_seed": [
                    "int",
                    "str"
                ]
            }
        },
        "Stacking.main": {
            "name": "main",
            "location": 144,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stacking.load_inputs": {
            "name": "load_inputs",
            "location": 218,
            "return": [],
            "arguments": {
                "self": [],
                "label": [
                    "int"
                ],
                "ids": [
                    "typing.Iterable[int]",
                    "str",
                    "None",
                    "int"
                ],
                "dataset": [
                    "str"
                ]
            }
        },
        "Stacking.train": {
            "name": "train",
            "location": 233,
            "return": [],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "float",
                    "list[]"
                ],
                "label": [
                    "int",
                    "float",
                    "list[]"
                ],
                "X_train": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ],
                "y_train": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ],
                "X_val": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ],
                "y_val": [
                    "list[numpy.array]",
                    "list[str]",
                    "int",
                    "str"
                ]
            }
        },
        "Stacking.save_model": {
            "name": "save_model",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "float",
                    "str",
                    "None"
                ],
                "label": [
                    "int",
                    "float",
                    "str",
                    "None"
                ],
                "model": [
                    "bool",
                    "float"
                ]
            }
        },
        "Stacking.load_model": {
            "name": "load_model",
            "location": 257,
            "return": [],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "bool",
                    "None"
                ],
                "label": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "Stacking.predict": {
            "name": "predict",
            "location": 262,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "bool",
                    "list[float]"
                ],
                "X": [
                    "bool",
                    "list[float]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/xgb.py": {
        "XGB.main": {
            "name": "main",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "XGB.train": {
            "name": "train",
            "location": 83,
            "return": [
                "dict[, ]"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int",
                    "None"
                ],
                "vectorizer": [
                    "str",
                    "int",
                    "float"
                ],
                "train_df": [],
                "val_df": []
            }
        },
        "XGB.predict": {
            "name": "predict",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "models": [
                    "bool",
                    "str"
                ],
                "vectorizer": [],
                "df": [
                    "str"
                ],
                "output_path": [
                    "str",
                    "typing.MutableMapping"
                ]
            }
        },
        "XGB.build_vectorizer": {
            "name": "build_vectorizer",
            "location": 125,
            "return": [
                "TfidfVectorizer"
            ],
            "arguments": {
                "self": [],
                "preprocessed_data": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/config.py": {},
    "kaggle-master/web-traffic-forecasting/pipelines/data.py": {
        "get_data_dir": {
            "name": "get_data_dir",
            "location": 127,
            "return": [
                "str"
            ],
            "arguments": {
                "stage": [
                    "str",
                    "None"
                ],
                "imputation": [
                    "str",
                    "None"
                ],
                "sample_ratio": [
                    "str",
                    "None"
                ],
                "random_seed": [
                    "str",
                    "None"
                ],
                "deploy_date": [
                    "str",
                    "None"
                ],
                "from_date": [
                    "str",
                    "None"
                ],
                "to_date": [
                    "str",
                    "None"
                ]
            }
        },
        "Key.output": {
            "name": "output",
            "location": 17,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Key.read": {
            "name": "read",
            "location": 21,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "InputData.output": {
            "name": "output",
            "location": 29,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "InputData.read": {
            "name": "read",
            "location": 33,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.requires": {
            "name": "requires",
            "location": 42,
            "return": [
                "InputData"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.output": {
            "name": "output",
            "location": 45,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.read": {
            "name": "read",
            "location": 49,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.run": {
            "name": "run",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData._interpolate": {
            "name": "_interpolate",
            "location": 76,
            "return": [],
            "arguments": {
                "self": [],
                "page_data": []
            }
        },
        "ImputedDataSample.requires": {
            "name": "requires",
            "location": 101,
            "return": [
                "ImputedData"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedDataSample.output": {
            "name": "output",
            "location": 104,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ImputedDataSample.read": {
            "name": "read",
            "location": 110,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ImputedDataSample.run": {
            "name": "run",
            "location": 115,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/evaluation.py": {
        "calculate_smape": {
            "name": "calculate_smape",
            "location": 14,
            "return": [],
            "arguments": {
                "y_true": [
                    "str",
                    "list[Exception]"
                ],
                "y_pred": [
                    "str",
                    "tuple[str]"
                ]
            }
        },
        "ModelEvaluation.requires": {
            "name": "requires",
            "location": 26,
            "return": [
                "dict[typing.Text, typing.Union[InputData,ModelPredictions]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelEvaluation.output": {
            "name": "output",
            "location": 32,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ModelEvaluation.run": {
            "name": "run",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.complete": {
            "name": "complete",
            "location": 65,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.output": {
            "name": "output",
            "location": 68,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.requires": {
            "name": "requires",
            "location": 72,
            "return": [
                "list[ModelEvaluation]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.run": {
            "name": "run",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/submissions.py": {
        "Submission.requires": {
            "name": "requires",
            "location": 17,
            "return": [
                "dict[typing.Text, typing.Union[Key,list[ModelPredictions]]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Submission.output": {
            "name": "output",
            "location": 25,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Submission.run": {
            "name": "run",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/__init__.py": {},
    "kaggle-master/web-traffic-forecasting/pipelines/models/common.py": {
        "init_random_state": {
            "name": "init_random_state",
            "location": 14,
            "return": [
                "RandomState"
            ],
            "arguments": {
                "random_seed": [
                    "float",
                    "list[int]",
                    "str",
                    "bool",
                    "list[]"
                ]
            }
        },
        "layer_units": {
            "name": "layer_units",
            "location": 21,
            "return": [
                "list[]"
            ],
            "arguments": {
                "input_size": [
                    "int",
                    "list[int]"
                ],
                "output_size": [
                    "int",
                    "list[int]"
                ],
                "num_layers": [
                    "int"
                ]
            }
        },
        "generate_training_data": {
            "name": "generate_training_data",
            "location": 87,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "data": [
                    "str"
                ],
                "deploy_date": [],
                "from_date": [],
                "to_date": [
                    "int"
                ],
                "num_days_before": [
                    "float",
                    "int"
                ]
            }
        },
        "generate_training_sample": {
            "name": "generate_training_sample",
            "location": 148,
            "return": [
                "tuple[typing.Union[int,float,dict[tuple[typing.Union[str,str]], int],dict[str, int]]]"
            ],
            "arguments": {
                "page": [
                    "bool",
                    "list[str]",
                    "str"
                ],
                "page_data": [
                    "list[str]"
                ],
                "last_year_f": [
                    "str"
                ],
                "last_year_t": [
                    "str"
                ],
                "d": [
                    "str"
                ],
                "f": [],
                "t": [],
                "num_days_target": [
                    "typing.Sequence[int]",
                    "int",
                    "None"
                ],
                "num_days_before": [
                    "int",
                    "typing.Hashable",
                    "float",
                    "None",
                    "str"
                ]
            }
        },
        "generate_prediction_data": {
            "name": "generate_prediction_data",
            "location": 167,
            "return": [
                "tuple[list[]]"
            ],
            "arguments": {
                "data": [],
                "deploy_date": [
                    "str",
                    "None",
                    "int"
                ],
                "from_date": [],
                "to_date": [],
                "num_days_before": []
            }
        },
        "generate_prediction_sample": {
            "name": "generate_prediction_sample",
            "location": 203,
            "return": [
                "tuple[typing.Union[str,None,bool,dict[typing.Union[str,None], str],list[int],dict[int, int]]]"
            ],
            "arguments": {
                "page": [
                    "str",
                    "None",
                    "bool"
                ],
                "page_data": [
                    "bytes"
                ],
                "last_year_from_date": [],
                "last_year_to_date": [],
                "deploy_date": [],
                "num_days_target": [
                    "int",
                    "None",
                    "list[str]",
                    "str"
                ],
                "num_days_before": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "list[]"
                ]
            }
        },
        "Projection.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "list[tuple[typing.Union[typing.Any,float]]]",
                    "list[str]",
                    "list[None]"
                ],
                "output_size": [
                    "int",
                    "list[tuple[typing.Union[typing.Any,float]]]",
                    "list[str]",
                    "list[None]"
                ],
                "output_nonlinearity": [
                    "None",
                    "str",
                    "list[]",
                    "dict[int, str]"
                ],
                "hidden_layers": [
                    "int"
                ],
                "hidden_nonlinearity": [
                    "None",
                    "list[str]",
                    "list[]",
                    "list[float]",
                    "list[int]",
                    "int",
                    "str"
                ],
                "dropout": [
                    "int"
                ]
            }
        },
        "Projection.forward": {
            "name": "forward",
            "location": 66,
            "return": [],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "MultiTensorDataset.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "target_tensor": [
                    "bytes"
                ]
            }
        },
        "MultiTensorDataset.__getitem__": {
            "name": "__getitem__",
            "location": 78,
            "return": [
                "list[]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "dict[, ]",
                    "float",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "MultiTensorDataset.__len__": {
            "name": "__len__",
            "location": 83,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/models/historical_median.py": {
        "FitHistoricalMedian.run": {
            "name": "run",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictHistoricalMedian.requires": {
            "name": "requires",
            "location": 37,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictHistoricalMedian.run": {
            "name": "run",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/models/rnn_v1.py": {},
    "kaggle-master/web-traffic-forecasting/pipelines/models/__init__.py": {
        "_ModelTask.requires": {
            "name": "requires",
            "location": 20,
            "return": [
                "dict[typing.Text, typing.Union[ImputedData,ImputedDataSample]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ModelTask.data_dir": {
            "name": "data_dir",
            "location": 31,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "FitModel.model_name": {
            "name": "model_name",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.output": {
            "name": "output",
            "location": 48,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.model_name": {
            "name": "model_name",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.output": {
            "name": "output",
            "location": 62,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.output": {
            "name": "output",
            "location": 74,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.read": {
            "name": "read",
            "location": 78,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    }
}
{
    "adversarialnlp-master/setup.py": {},
    "adversarialnlp-master/adversarialnlp/run.py": {},
    "adversarialnlp-master/adversarialnlp/version.py": {},
    "adversarialnlp-master/adversarialnlp/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/commands/test_install.py": {
        "_get_module_root": {
            "name": "_get_module_root",
            "location": 46,
            "return": [
                "pathlib.Path",
                "str"
            ],
            "arguments": {}
        },
        "_run_test": {
            "name": "_run_test",
            "location": 50,
            "return": [
                ""
            ],
            "arguments": {
                "args": []
            }
        },
        "TestInstall.add_subparser": {
            "name": "add_subparser",
            "location": 31,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/commands/__init__.py": {
        "main": {
            "name": "main",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "prog": [
                    "str",
                    "List[str]"
                ],
                "subcommand_overrides": [
                    "Dict[str, allennlp.commands.subcommand.Subcommand]",
                    "List[str]",
                    "int",
                    "bool",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/common/file_utils.py": {
        "built": {
            "name": "built",
            "location": 74,
            "return": [
                "bool"
            ],
            "arguments": {
                "path": [
                    "str",
                    "norfs.fs.base.Path"
                ],
                "version_string": [
                    "str",
                    "pathlib.Path",
                    "dict"
                ]
            }
        },
        "mark_done": {
            "name": "mark_done",
            "location": 93,
            "return": [
                ""
            ],
            "arguments": {
                "path": [
                    "str",
                    "pathlib.Path"
                ],
                "fnames": [
                    "bool",
                    "str",
                    "types.Path",
                    "List[str]"
                ],
                "version_string": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "download": {
            "name": "download",
            "location": 105,
            "return": [
                ""
            ],
            "arguments": {
                "url": [
                    "str",
                    "Dict[str, Any]"
                ],
                "path": [
                    "str"
                ],
                "fname": [
                    "str",
                    "norfs.fs.base.Path"
                ],
                "redownload": [
                    "str"
                ]
            }
        },
        "make_dir": {
            "name": "make_dir",
            "location": 180,
            "return": [
                ""
            ],
            "arguments": {
                "path": [
                    "str",
                    "bool",
                    "int",
                    "Union[str, pathlib.Path]",
                    "pathlib.Path",
                    "Dict[str, Any]"
                ]
            }
        },
        "move": {
            "name": "move",
            "location": 187,
            "return": [
                ""
            ],
            "arguments": {
                "path1": [
                    "str",
                    "list",
                    "List[pathlib.Path]"
                ],
                "path2": [
                    "str",
                    "list",
                    "List[pathlib.Path]"
                ]
            }
        },
        "remove_dir": {
            "name": "remove_dir",
            "location": 192,
            "return": [
                ""
            ],
            "arguments": {
                "path": [
                    "str",
                    "os.PathLike",
                    "paradigm.catalog.Path"
                ]
            }
        },
        "untar": {
            "name": "untar",
            "location": 197,
            "return": [
                ""
            ],
            "arguments": {
                "path": [
                    "str",
                    "Optional[str]",
                    "pathlib.Path"
                ],
                "fname": [
                    "str",
                    "pathlib.Path",
                    "Optional[bool]"
                ],
                "deleteTar": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Any]"
                ]
            }
        },
        "cat": {
            "name": "cat",
            "location": 211,
            "return": [
                ""
            ],
            "arguments": {
                "file1": [
                    "pathlib.Path",
                    "str",
                    "List[pathlib.Path]"
                ],
                "file2": [
                    "pathlib.Path",
                    "str",
                    "List[pathlib.Path]"
                ],
                "outfile": [
                    "str",
                    "int",
                    "bool",
                    "List[str]"
                ],
                "deleteFiles": [
                    "bool",
                    "str"
                ]
            }
        },
        "_get_confirm_token": {
            "name": "_get_confirm_token",
            "location": 222,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[List[\"custom_index\"]]",
                "int",
                "str"
            ],
            "arguments": {
                "response": [
                    "dict",
                    "list",
                    "Dict[str, float]",
                    "Dict[bytes, bytes]"
                ]
            }
        },
        "download_from_google_drive": {
            "name": "download_from_google_drive",
            "location": 228,
            "return": [
                ""
            ],
            "arguments": {
                "gd_id": [
                    "int",
                    "dict",
                    "str"
                ],
                "destination": [
                    "str",
                    "int",
                    "List[str]",
                    "Dict[str, str]",
                    "Optional[str]"
                ]
            }
        },
        "download_files": {
            "name": "download_files",
            "location": 249,
            "return": [
                "str",
                "bool",
                "pathlib.Path"
            ],
            "arguments": {
                "fnames": [
                    "List[Optional[str]]",
                    "int",
                    "pathlib.Path",
                    "List[pathlib.Path]"
                ],
                "local_folder": [
                    "str",
                    "Union[pathlib.Path, str]",
                    "Path"
                ],
                "version": [
                    "str",
                    "List[float]",
                    "int",
                    "bool"
                ],
                "paths": [
                    "pathlib.Path",
                    "Union[pathlib.Path, str]"
                ]
            }
        },
        "ProgressLogger.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "throttle": [
                    "int",
                    "bool",
                    "float"
                ],
                "should_humanize": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "ProgressLogger.humanize": {
            "name": "humanize",
            "location": 37,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "num": [
                    "int",
                    "float",
                    "Optional[int]",
                    "str"
                ],
                "suffix": [
                    "str",
                    "List[str]",
                    "int"
                ]
            }
        },
        "ProgressLogger.log": {
            "name": "log",
            "location": 47,
            "return": [
                "Iterator[List[T]]",
                "Iterator[bytes]",
                "Iterable[Sequence[T]]",
                "Generator",
                "Iterator[int]"
            ],
            "arguments": {
                "self": [],
                "curr": [
                    "int",
                    "Tuple[int, int]",
                    "Tuple[int, int, int]",
                    "str",
                    "bool"
                ],
                "total": [
                    "int",
                    "Tuple[int, int]",
                    "Tuple[int, int, int]",
                    "str",
                    "bool"
                ],
                "width": [
                    "int",
                    "str",
                    "List[float]",
                    "List[str]"
                ],
                "force": [
                    "Union[float, int]",
                    "Optional[int]",
                    "int",
                    "float",
                    "Optional[str]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/common/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/generator.py": {
        "Generator.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "default_seeds": [
                    "int",
                    "tuple",
                    "float",
                    "bool"
                ],
                "quiet": [
                    "bool",
                    "int",
                    "List[List[int]]",
                    "Optional[int]"
                ]
            }
        },
        "Generator.generate_from_seed": {
            "name": "generate_from_seed",
            "location": 60,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "seed": []
            }
        },
        "Generator.__call__": {
            "name": "__call__",
            "location": 65,
            "return": [],
            "arguments": {
                "self": [],
                "seeds": [
                    "list",
                    "Sequence[str]",
                    "str",
                    "bool",
                    "Optional[Dict]",
                    "dict"
                ],
                "num_epochs": [
                    "int",
                    "float"
                ],
                "shuffle": [
                    "bool",
                    "int",
                    "List[int]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/addsent/addsent_generator.py": {
        "AddSentGenerator.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "alteration_strategy": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Dict[str, str]",
                    "int"
                ],
                "prepend": [
                    "bool",
                    "List[str]",
                    "Optional[Union[Any, Any]]"
                ],
                "use_answer_placeholder": [
                    "bool",
                    "Optional[Union[Any, Any]]",
                    "List[str]"
                ],
                "default_seeds": [
                    "Iterable",
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str, str]]",
                    "int",
                    "bool"
                ],
                "quiet": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "AddSentGenerator.close": {
            "name": "close",
            "location": 86,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "AddSentGenerator._annotate": {
            "name": "_annotate",
            "location": 89,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "Dict[str, str]",
                    "Callable",
                    "int",
                    "bool"
                ],
                "annotators": [
                    "str"
                ]
            }
        },
        "AddSentGenerator._alter_question": {
            "name": "_alter_question",
            "location": 96,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "List[str]",
                    "float",
                    "str"
                ],
                "tokens": [
                    "int",
                    "str"
                ],
                "const_parse": [
                    "List[List[Any]]",
                    "List[List[str]]",
                    "Callable",
                    "Dict[str, float]",
                    "Hashable"
                ]
            }
        },
        "AddSentGenerator.generate_from_seed": {
            "name": "generate_from_seed",
            "location": 155,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "float",
                    "Sequence[float]",
                    "Tuple[int, int]",
                    "tuple"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/corenlp.py": {
        "StanfordCoreNLP.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "path_or_host": [
                    "str",
                    "bool"
                ],
                "port": [
                    "str",
                    "Union[str, os.PathLike]"
                ],
                "memory": [
                    "str",
                    "int"
                ],
                "lang": [
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Optional[List[str]]",
                    "tuple",
                    "Union[bool, List[str]]",
                    "Optional[str]",
                    "BinaryIO"
                ],
                "timeout": [
                    "bool",
                    "int",
                    "str",
                    "Optional[bool]",
                    "Optional[List[str]]",
                    "float"
                ],
                "quiet": [
                    "bool",
                    "int",
                    "str",
                    "Optional[bool]",
                    "Optional[List[str]]",
                    "float"
                ],
                "logging_level": [
                    "str",
                    "int",
                    "Optional[List[str]]",
                    "Optional[int]"
                ],
                "max_retries": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "StanfordCoreNLP.__enter__": {
            "name": "__enter__",
            "location": 130,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "StanfordCoreNLP.__exit__": {
            "name": "__exit__",
            "location": 133,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "exc_type": [
                    "Optional[Type[BaseException]]",
                    "str",
                    "BaseException",
                    "Optional[BaseException]",
                    "Exception"
                ],
                "exc_val": [
                    "Optional[Type[BaseException]]",
                    "str",
                    "BaseException",
                    "Optional[BaseException]",
                    "Exception"
                ],
                "exc_tb": [
                    "Optional[Type[BaseException]]",
                    "str",
                    "BaseException",
                    "Optional[BaseException]",
                    "Exception"
                ]
            }
        },
        "StanfordCoreNLP.close": {
            "name": "close",
            "location": 136,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": []
            }
        },
        "StanfordCoreNLP.annotate": {
            "name": "annotate",
            "location": 159,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "dict",
                    "int"
                ],
                "properties": [
                    "str",
                    "int"
                ]
            }
        },
        "StanfordCoreNLP.tregex": {
            "name": "tregex",
            "location": 167,
            "return": [
                "OrderedDict",
                "List[float]",
                "str",
                "List[Dict[str, Any]]",
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "dict"
                ],
                "pattern": [
                    "str",
                    "dict"
                ]
            }
        },
        "StanfordCoreNLP.tokensregex": {
            "name": "tokensregex",
            "location": 172,
            "return": [
                "OrderedDict",
                "List[float]",
                "str",
                "List[Dict[str, Any]]",
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "dict"
                ],
                "pattern": [
                    "str",
                    "dict"
                ]
            }
        },
        "StanfordCoreNLP.semgrex": {
            "name": "semgrex",
            "location": 177,
            "return": [
                "OrderedDict",
                "List[float]",
                "str",
                "List[Dict[str, Any]]",
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "dict"
                ],
                "pattern": [
                    "str",
                    "dict"
                ]
            }
        },
        "StanfordCoreNLP.word_tokenize": {
            "name": "word_tokenize",
            "location": 182,
            "return": [
                "str",
                "bool",
                "dict"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "Optional[bool]",
                    "Optional[str]",
                    "Optional[Dict]",
                    "bytes"
                ],
                "span": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "StanfordCoreNLP.pos_tag": {
            "name": "pos_tag",
            "location": 194,
            "return": [
                "bool",
                "Type",
                "str"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "StanfordCoreNLP.ner": {
            "name": "ner",
            "location": 204,
            "return": [
                "List[str]",
                "str",
                "Optional[Iterable[str]]",
                "Dict[str, Set[str]]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "dict",
                    "Tuple[str, int]"
                ]
            }
        },
        "StanfordCoreNLP.parse": {
            "name": "parse",
            "location": 214,
            "return": [
                "List[str]",
                "str",
                "Optional[List[str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "dict",
                    "Tuple[str, int]"
                ]
            }
        },
        "StanfordCoreNLP.dependency_parse": {
            "name": "dependency_parse",
            "location": 218,
            "return": [
                "int",
                "str",
                "list",
                "List[T]",
                "List[float]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "dict",
                    "Tuple[str, int]"
                ]
            }
        },
        "StanfordCoreNLP.coref": {
            "name": "coref",
            "location": 223,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "dict"
                ]
            }
        },
        "StanfordCoreNLP.switch_language": {
            "name": "switch_language",
            "location": 234,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "language": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "StanfordCoreNLP._request": {
            "name": "_request",
            "location": 238,
            "return": [
                "Optional[str]",
                "bool",
                "str",
                "Sequence",
                "Optional[List[str]]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "url": [
                    "str",
                    "Optional[Dict[str, str]]",
                    "Optional[MutableMapping[Any, Any]]",
                    "requests.Response"
                ],
                "annotators": [
                    "Optional[Dict]",
                    "Optional[flask_dialogflow.json.JSON]",
                    "\"Future[None]\"",
                    "list",
                    "bool",
                    "List[Callable]",
                    "str"
                ],
                "data": [
                    "str",
                    "dict",
                    "Optional[Dict[str, str]]",
                    "Optional[MutableMapping[Any, Any]]"
                ]
            }
        },
        "StanfordCoreNLP._check_args": {
            "name": "_check_args",
            "location": 253,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "StanfordCoreNLP._check_language": {
            "name": "_check_language",
            "location": 258,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "lang": [
                    "str",
                    "int",
                    "float",
                    "Union[float, int]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/squad_reader.py": {
        "squad_reader": {
            "name": "squad_reader",
            "location": 10,
            "return": [
                "Optional[float]",
                "int",
                "str"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/utils.py": {
        "rejoin": {
            "name": "rejoin",
            "location": 108,
            "return": [
                "str"
            ],
            "arguments": {
                "tokens": [
                    "str"
                ],
                "sep": [
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str, str]]",
                    "Hashable",
                    "dict"
                ]
            }
        },
        "get_tokens_for_answers": {
            "name": "get_tokens_for_answers",
            "location": 125,
            "return": [
                "int",
                "Union[Dict, List]",
                "List[str]",
                "Dict[str, int]",
                "Optional[Set[str]]"
            ],
            "arguments": {
                "answer_objs": [
                    "dict",
                    "int",
                    "str",
                    "List[Dict]",
                    "MutableMapping[str, str]",
                    "bool",
                    "Optional[str]"
                ],
                "corenlp_obj": [
                    "str",
                    "bool",
                    "list",
                    "int"
                ]
            }
        },
        "get_determiner_for_answers": {
            "name": "get_determiner_for_answers",
            "location": 148,
            "return": [
                "Optional[str]",
                "bool",
                "str"
            ],
            "arguments": {
                "answer_objs": [
                    "str",
                    "bool"
                ]
            }
        },
        "compress_whnp": {
            "name": "compress_whnp",
            "location": 157,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "tree": [
                    "Union[\"RangeSet[T]\", Iterable[Any]]",
                    "int",
                    "Mapping[str, Any]"
                ],
                "inside_whnp": [
                    "Optional[Tuple[int, Any]]",
                    "str",
                    "int"
                ]
            }
        },
        "read_const_parse": {
            "name": "read_const_parse",
            "location": 195,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "parse_str": [
                    "str",
                    "Callable"
                ]
            }
        },
        "ConstituencyParse.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "Optional[Exception]",
                    "Optional[Callable]",
                    "Optional[int]",
                    "Optional[Dict[str, str]]",
                    "Optional[str]"
                ],
                "children": [
                    "bool",
                    "Optional[str]",
                    "list",
                    "Optional[List[Any]]",
                    "Tuple[List[str], Optional[Any], Optional[Any]]"
                ],
                "word": [
                    "str"
                ],
                "index": [
                    "str"
                ]
            }
        },
        "ConstituencyParse._recursive_parse_corenlp": {
            "name": "_recursive_parse_corenlp",
            "location": 20,
            "return": [
                "List[str]",
                "Set[str]",
                "bool",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "Dict[str, Any]",
                    "dict"
                ],
                "tokens": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Callable[..., T]"
                ],
                "i": [
                    "str",
                    "Callable",
                    "Mapping[str, Any]",
                    "float",
                    "Callable[..., None]"
                ],
                "j": [
                    "str",
                    "\"Reference\""
                ]
            }
        },
        "ConstituencyParse.from_corenlp": {
            "name": "from_corenlp",
            "location": 41,
            "return": [
                "float",
                "Set[str]",
                "list",
                "Dict[str, List[str]]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]"
                ],
                "s": [
                    "str"
                ]
            }
        },
        "ConstituencyParse.is_singleton": {
            "name": "is_singleton",
            "location": 51,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse.print_tree": {
            "name": "print_tree",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "indent": [
                    "dict",
                    "int",
                    "tuple",
                    "bool"
                ]
            }
        },
        "ConstituencyParse.get_phrase": {
            "name": "get_phrase",
            "location": 67,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse.get_start_index": {
            "name": "get_start_index",
            "location": 79,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse.get_end_index": {
            "name": "get_end_index",
            "location": 84,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstituencyParse._recursive_replace_words": {
            "name": "_recursive_replace_words",
            "location": 90,
            "return": [
                "Optional[str]",
                "str",
                "Optional[int]",
                "Optional[Iterable[str]]",
                "Optional[BaseException]"
            ],
            "arguments": {
                "cls": [
                    "List[Type]",
                    "int",
                    "List[int]"
                ],
                "tree": [],
                "new_words": [
                    "Optional[str]",
                    "T",
                    "Tuple[int]",
                    "int"
                ],
                "i": [
                    "bool",
                    "Optional[str]",
                    "List[str]",
                    "int"
                ]
            }
        },
        "ConstituencyParse.replace_words": {
            "name": "replace_words",
            "location": 101,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "cls": [],
                "tree": [],
                "new_words": [
                    "Tuple[Any, Any]",
                    "Tuple[int, str, List[str]]",
                    "Set[str]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/alteration_rules.py": {
        "alter_special": {
            "name": "alter_special",
            "location": 18,
            "return": [
                "str",
                "list",
                "Optional[BaseException]"
            ],
            "arguments": {
                "token": [
                    "List[str]",
                    "str",
                    "Tuple[int, str]"
                ]
            }
        },
        "alter_nearby": {
            "name": "alter_nearby",
            "location": 24,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "pos_list": [
                    "bool",
                    "List[str]",
                    "str",
                    "Optional[bool]",
                    "Callable"
                ],
                "ignore_pos": [
                    "bool",
                    "List[str]",
                    "str",
                    "Optional[bool]",
                    "Callable"
                ],
                "is_ner": [
                    "bool",
                    "List[str]",
                    "str",
                    "Optional[bool]",
                    "Callable"
                ]
            }
        },
        "alter_entity_glove": {
            "name": "alter_entity_glove",
            "location": 48,
            "return": [
                "str",
                "Optional[bool]",
                "Optional[str]",
                "Optional[int]",
                "Optional[dict]"
            ],
            "arguments": {
                "token": [
                    "str",
                    "List[str]",
                    "Optional[str]"
                ],
                "nearby_word_dict": [
                    "Sequence[int]",
                    "List[Dict[str, Any]]",
                    "list",
                    "Tuple['cirq.Qid']",
                    "Counter",
                    "dict"
                ]
            }
        },
        "alter_entity_type": {
            "name": "alter_entity_type",
            "location": 62,
            "return": [
                "Optional[Callable[[bool], None]]",
                "str"
            ],
            "arguments": {
                "token": [
                    "bytes",
                    "Union[str, bytes]",
                    "int",
                    "dict"
                ]
            }
        },
        "alter_wordnet_antonyms": {
            "name": "alter_wordnet_antonyms",
            "location": 88,
            "return": [
                "Optional[str]",
                "type",
                "Optional[List[Any]]",
                "list"
            ],
            "arguments": {
                "token": [
                    "str",
                    "List[str]",
                    "bytes"
                ]
            }
        },
        "alter_nearby.func": {
            "name": "func",
            "location": 25,
            "return": [
                "Optional[str]",
                "Optional[bool]",
                "Optional[int]",
                "str"
            ],
            "arguments": {
                "token": [
                    "list",
                    "List[str]",
                    "List[int]",
                    "List[Dict[str, Any]]"
                ],
                "nearby_word_dict": [
                    "Sequence[int]",
                    "dict",
                    "Tuple['cirq.Qid']",
                    "Tuple[Dict[str, Any], int]",
                    "Dict[str, Dict[str, float]]"
                ],
                "postag_dict": [
                    "list",
                    "List[int]",
                    "List[dict]",
                    "List[Dict]",
                    "Callable[[], bool]",
                    "bool"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/answer_rules.py": {
        "ans_number": {
            "name": "ans_number",
            "location": 8,
            "return": [
                "str",
                "bytes",
                "bool"
            ],
            "arguments": {
                "a": [
                    "bool",
                    "Sequence[T]",
                    "tuple",
                    "List[int]"
                ],
                "tokens": [
                    "bool",
                    "Sequence[T]",
                    "tuple",
                    "List[int]"
                ],
                "q": [
                    "bool",
                    "Sequence[T]",
                    "tuple",
                    "List[int]"
                ]
            }
        },
        "ans_date": {
            "name": "ans_date",
            "location": 78,
            "return": [
                "Optional[int]",
                "Optional[float]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "a": [
                    "str",
                    "tests.utils.Strategy[paradigm.hints.Domain]",
                    "int"
                ],
                "tokens": [
                    "str",
                    "Set[int]",
                    "keras.utils.Sequence"
                ],
                "q": [
                    "Sequence[str]",
                    "int",
                    "Tuple[Sequence[Any], Sequence[str], Sequence[Any]]",
                    "Tuple[str, Sequence[str], Sequence[str]]",
                    "bool",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "ans_entity_full": {
            "name": "ans_entity_full",
            "location": 104,
            "return": [
                "int",
                "str",
                "bool",
                "Callable"
            ],
            "arguments": {
                "ner_tag": [
                    "str",
                    "bool",
                    "List[Dict[str, Any]]",
                    "int",
                    "List[str]"
                ],
                "new_ans": [
                    "str",
                    "bool",
                    "List[Dict[str, Any]]",
                    "int",
                    "List[str]"
                ]
            }
        },
        "ans_abbrev": {
            "name": "ans_abbrev",
            "location": 112,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "new_ans": [
                    "bool",
                    "List[Dict[str, Any]]",
                    "float"
                ]
            }
        },
        "ans_match_wh": {
            "name": "ans_match_wh",
            "location": 120,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "int",
                "bool"
            ],
            "arguments": {
                "wh_word": [
                    "List[float]",
                    "Optional[List[str]]",
                    "str",
                    "List[Tuple[str, str]]"
                ],
                "new_ans": [
                    "List[float]",
                    "Optional[List[str]]",
                    "str",
                    "List[Tuple[str, str]]"
                ]
            }
        },
        "ans_pos": {
            "name": "ans_pos",
            "location": 128,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "pos": [
                    "float",
                    "TextIO",
                    "Optional[int]",
                    "bool",
                    "Optional[str]",
                    "raiden.utils.Callable",
                    "List[str]"
                ],
                "new_ans": [
                    "float",
                    "TextIO",
                    "Optional[int]",
                    "bool",
                    "Optional[str]",
                    "raiden.utils.Callable",
                    "List[str]"
                ],
                "end": [
                    "float",
                    "TextIO",
                    "Optional[int]",
                    "bool",
                    "Optional[str]",
                    "raiden.utils.Callable",
                    "List[str]"
                ],
                "add_dt": [
                    "float",
                    "TextIO",
                    "Optional[int]",
                    "bool",
                    "Optional[str]",
                    "raiden.utils.Callable",
                    "List[str]"
                ]
            }
        },
        "ans_catch_all": {
            "name": "ans_catch_all",
            "location": 142,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "new_ans": [
                    "Callable",
                    "list",
                    "int"
                ]
            }
        },
        "ans_entity_full.func": {
            "name": "func",
            "location": 106,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_abbrev.func": {
            "name": "func",
            "location": 113,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_match_wh.func": {
            "name": "func",
            "location": 122,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": []
            }
        },
        "ans_pos.func": {
            "name": "func",
            "location": 130,
            "return": [],
            "arguments": {
                "a": [],
                "tokens": [],
                "q": [],
                "determiner": []
            }
        },
        "ans_catch_all.func": {
            "name": "func",
            "location": 143,
            "return": [
                "int",
                "Iterable[str]",
                "Callable",
                "Sequence[str]"
            ],
            "arguments": {
                "a": [
                    "List[str]",
                    "str",
                    "int",
                    "Optional[Container[str]]",
                    "Iterable[Tuple[str, str]]",
                    "list",
                    "Optional[List[str]]"
                ],
                "tokens": [
                    "List[str]",
                    "str",
                    "int",
                    "Optional[Container[str]]",
                    "Iterable[Tuple[str, str]]",
                    "list",
                    "Optional[List[str]]"
                ],
                "q": [
                    "List[str]",
                    "str",
                    "int",
                    "Optional[Container[str]]",
                    "Iterable[Tuple[str, str]]",
                    "list",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/conversion_rules.py": {
        "_check_match": {
            "name": "_check_match",
            "location": 25,
            "return": [
                "bool"
            ],
            "arguments": {
                "node": [
                    "Optional[Callable]",
                    "int",
                    "bool",
                    "type"
                ],
                "pattern_tok": [
                    "Dict[str, int]"
                ]
            }
        },
        "_recursive_match_pattern": {
            "name": "_recursive_match_pattern",
            "location": 41,
            "return": [
                "bool"
            ],
            "arguments": {
                "pattern_toks": [
                    "int",
                    "str"
                ],
                "stack": [
                    "List[Tuple[int, int]]",
                    "Tuple[int, int]",
                    "bytes",
                    "Union[int, str]",
                    "Optional[List[str]]",
                    "Dict[str, Dict[str, Any]]",
                    "int",
                    "Sequence[str]"
                ],
                "matches": [
                    "dict",
                    "str",
                    "bool",
                    "List[T]",
                    "Set[str]"
                ]
            }
        },
        "match_pattern": {
            "name": "match_pattern",
            "location": 65,
            "return": [
                "type",
                "List[str]",
                "Optional[int]"
            ],
            "arguments": {
                "pattern": [
                    "dict",
                    "Pattern[str]",
                    "str",
                    "Dict[str, List[str]]"
                ],
                "const_parse": []
            }
        },
        "run_postprocessing": {
            "name": "run_postprocessing",
            "location": 78,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "s": [
                    "bool",
                    "float",
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "rules": [
                    "bool",
                    "str",
                    "float",
                    "Tuple[str]",
                    "Tuple[int]"
                ],
                "all_args": [
                    "Callable",
                    "bool",
                    "type"
                ]
            }
        },
        "convert_whp": {
            "name": "convert_whp",
            "location": 97,
            "return": [
                "Optional[int]",
                "Optional[bool]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "node": [
                    "str"
                ],
                "q": [
                    "str",
                    "List[str]"
                ],
                "a": [
                    "int",
                    "str",
                    "list",
                    "float",
                    "List[str]"
                ],
                "tokens": [
                    "str",
                    "Optional[Union[int, float]]"
                ],
                "quiet": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "fix_style": {
            "name": "fix_style",
            "location": 111,
            "return": [
                "str",
                "float"
            ],
            "arguments": {
                "s": [
                    "str"
                ]
            }
        },
        "ConversionRule.convert": {
            "name": "convert",
            "location": 120,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "q": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "a": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "tokens": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "const_parse": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "run_fix_style": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ]
            }
        },
        "ConstituencyRule.__init__": {
            "name": "__init__",
            "location": 125,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "in_pattern": [
                    "str",
                    "bool",
                    "float"
                ],
                "out_pattern": [
                    "Optional[dict]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "postproc": [
                    "Optional[dict]",
                    "int",
                    "List['cirq.Circuit']"
                ]
            }
        },
        "ConstituencyRule.convert": {
            "name": "convert",
            "location": 135,
            "return": [
                "bool",
                "int",
                "Optional[str]",
                "Optional[List[str]]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "List[List[int]]",
                    "str",
                    "bool"
                ],
                "a": [
                    "int",
                    "bool"
                ],
                "tokens": [
                    "int",
                    "List[List[int]]",
                    "str",
                    "bool"
                ],
                "const_parse": [
                    "str",
                    "List[str]",
                    "Optional[Sequence[Any]]",
                    "dict",
                    "Tuple[Tuple[int, int]]"
                ],
                "run_fix_style": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ]
            }
        },
        "ConstituencyRule.gen_output": {
            "name": "gen_output",
            "location": 175,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "fmt_args": [
                    "str",
                    "int",
                    "Union[Type, Tuple[Type, ...]]",
                    "bool"
                ]
            }
        },
        "ReplaceRule.__init__": {
            "name": "__init__",
            "location": 181,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "target": [
                    "int",
                    "bool",
                    "str",
                    "List[str]",
                    "Optional[float]"
                ],
                "replacement": [
                    "int",
                    "Union[str, float]",
                    "str"
                ],
                "start": [
                    "int",
                    "Union[str, float]",
                    "str"
                ]
            }
        },
        "ReplaceRule.convert": {
            "name": "convert",
            "location": 187,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "bool",
                    "str",
                    "List[str]",
                    "Tuple[str]"
                ],
                "a": [
                    "str",
                    "bytes",
                    "int",
                    "List[str]",
                    "Optional[str]"
                ],
                "tokens": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "const_parse": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "run_fix_style": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ]
            }
        },
        "FindWHPRule._recursive_convert": {
            "name": "_recursive_convert",
            "location": 205,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "str",
                    "int"
                ],
                "q": [
                    "int",
                    "str"
                ],
                "a": [
                    "int",
                    "str"
                ],
                "tokens": [
                    "int",
                    "str"
                ],
                "found_whp": [
                    "str",
                    "Optional[int]",
                    "bytes",
                    "int",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "FindWHPRule.convert": {
            "name": "convert",
            "location": 224,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "Optional[Union[Any, Any]]",
                    "Optional[Any]",
                    "bool"
                ],
                "a": [
                    "int",
                    "Optional[Union[Any, Any]]",
                    "Optional[Any]",
                    "bool"
                ],
                "tokens": [
                    "int",
                    "Optional[Union[Any, Any]]",
                    "Optional[Any]",
                    "bool"
                ],
                "const_parse": [
                    "int",
                    "Optional[Union[Any, Any]]",
                    "Optional[Any]",
                    "bool"
                ],
                "run_fix_style": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ]
            }
        },
        "AnswerRule.convert": {
            "name": "convert",
            "location": 235,
            "return": [
                "Tuple[int, int]",
                "float"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "a": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "tokens": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "const_parse": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ],
                "run_fix_style": [
                    "bool",
                    "dict",
                    "str",
                    "list"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/addsent/rules/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/generators/swag/activitynet_captions_reader.py": {
        "ActivityNetCaptionsDatasetReader.__init__": {
            "name": "__init__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool",
                    "int"
                ],
                "tokenizer": [
                    "List[Tuple[int, int]]",
                    "Tuple[int, int]",
                    "List[int]",
                    "str",
                    "Optional[List[str]]"
                ],
                "token_indexers": [
                    "int",
                    "bool"
                ]
            }
        },
        "ActivityNetCaptionsDatasetReader._read": {
            "name": "_read",
            "location": 64,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "ActivityNetCaptionsDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 75,
            "return": [
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "video_id": [
                    "str",
                    "Optional[str]",
                    "int",
                    "dict"
                ],
                "first_sentence": [
                    "str",
                    "int",
                    "List[str]"
                ],
                "second_sentence": [
                    "str",
                    "int",
                    "List[str]"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/openai_transformer_model.py": {
        "OpenAITransformerLanguageModel.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "bool",
                    "int"
                ],
                "openai_token_embedder": [
                    "Optional[Mapping[str, Any]]",
                    "List[dict]",
                    "Sequence[str]",
                    "Sequence[Sequence[str]]",
                    "Sequence[Tuple[str, int]]",
                    "Callable[[], int]",
                    "str",
                    "bool"
                ],
                "remove_bos_eos": [
                    "List[Callable]",
                    "str",
                    "List[Exception]",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "OpenAITransformerLanguageModel._get_target_token_embedding": {
            "name": "_get_target_token_embedding",
            "location": 38,
            "return": [
                "dict",
                "bool",
                "int",
                "float",
                "List[List[str]]"
            ],
            "arguments": {
                "self": [],
                "token_embeddings": [
                    "torch.Tensor",
                    "int",
                    "torch.nn.utils.rnn.PackedSequence",
                    "str"
                ],
                "mask": [
                    "torch.Tensor",
                    "bytes",
                    "int",
                    "core.models.GroupingKey",
                    "Hashable"
                ],
                "direction": [
                    "int",
                    "str",
                    "List[int]"
                ]
            }
        },
        "OpenAITransformerLanguageModel._compute_loss": {
            "name": "_compute_loss",
            "location": 51,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "lm_embeddings": [
                    "torch.Tensor",
                    "Sequence[str]",
                    "bool"
                ],
                "token_embeddings": [
                    "Optional[dict]"
                ],
                "forward_targets": [
                    "torch.Tensor",
                    "Sequence[str]",
                    "bool"
                ],
                "backward_targets": [
                    "torch.Tensor",
                    "Sequence[str]",
                    "bool"
                ]
            }
        },
        "OpenAITransformerLanguageModel.forward": {
            "name": "forward",
            "location": 89,
            "return": [
                "bool",
                "Dict[str, Any]",
                "List[float]"
            ],
            "arguments": {
                "self": [],
                "source": [
                    "str",
                    "Optional[Dict[str, bool]]",
                    "int"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/simple_bilm.py": {
        "_de_duplicate_generations": {
            "name": "_de_duplicate_generations",
            "location": 23,
            "return": [
                "int",
                "Set[str]",
                "List[float]",
                "Tuple[int]"
            ],
            "arguments": {
                "generations": [
                    "bool",
                    "numpy.ndarray",
                    "Callable",
                    "Optional[Callable]",
                    "allennlp.common.util.JsonDict"
                ]
            }
        },
        "StackedLstm.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "float",
                    "Union[Tuple[int, int], int]",
                    "str"
                ],
                "hidden_size": [
                    "int",
                    "float",
                    "Union[Tuple[int, int], int]",
                    "torch.BoolTensor",
                    "str",
                    "torch.Tensor"
                ],
                "num_layers": [
                    "int",
                    "Optional[int]",
                    "str"
                ],
                "recurrent_dropout_probability": [
                    "int",
                    "bool",
                    "float"
                ],
                "use_highway": [
                    "int",
                    "bool",
                    "float"
                ],
                "use_input_projection_bias": [
                    "int",
                    "bool",
                    "float"
                ],
                "go_forward": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "StackedLstm.forward": {
            "name": "forward",
            "location": 97,
            "return": [
                "dict",
                "Awaitable",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "ebl.transliteration.domain.tokens.Token",
                    "Optional[Any]",
                    "str"
                ],
                "initial_state": [
                    "torch.Tensor",
                    "allennlp.nn.decoding.decoder_state.DecoderState"
                ]
            }
        },
        "SimpleBiLM.__init__": {
            "name": "__init__",
            "location": 139,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "Optional[lexer.Token]",
                    "allennlp.data.Vocabulary",
                    "allennlp.modules.Seq2SeqEncoder",
                    "Optional[Pattern]",
                    "str"
                ],
                "recurrent_dropout_probability": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Optional[Sequence[float]]"
                ],
                "embedding_dropout_probability": [
                    "float",
                    "static_frame.core.util.UFunc",
                    "bool",
                    "Tuple[numpy.dtype]",
                    "int",
                    "Iterator[numpy.ndarray]"
                ],
                "input_size": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Optional[Sequence[float]]"
                ],
                "hidden_size": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Optional[Sequence[float]]"
                ]
            }
        },
        "SimpleBiLM.embed_words": {
            "name": "embed_words",
            "location": 174,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "SimpleBiLM.timestep_to_ids": {
            "name": "timestep_to_ids",
            "location": 190,
            "return": [
                "Optional[numpy.ndarray]",
                "Dict[str, Any]",
                "str",
                "Optional[bool]",
                "int",
                "Optional[List[Any]]",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "timestep_tokenized": [
                    "numpy.ndarray",
                    "dict",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "SimpleBiLM.batch_to_ids": {
            "name": "batch_to_ids",
            "location": 194,
            "return": [
                "bytes",
                "int",
                "IO",
                "List[str]",
                "cmk.utils.type_defs.HostAddress",
                "str"
            ],
            "arguments": {
                "self": [],
                "stories_tokenized": [
                    "int",
                    "List[str]",
                    "bytes",
                    "List[int]",
                    "str",
                    "Exception"
                ]
            }
        },
        "SimpleBiLM.conditional_generation": {
            "name": "conditional_generation",
            "location": 209,
            "return": [
                "trezor.utils.Writer"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "str",
                    "int",
                    "bytes",
                    "float",
                    "bool"
                ],
                "gt_completion": [
                    "int",
                    "numpy.ndarray",
                    "Optional[Union[int, slice]]",
                    "Optional[numpy.ndarray]",
                    "Dict[str, str]"
                ],
                "batch_size": [
                    "numpy.ndarray",
                    "int",
                    "bool",
                    "str",
                    "Optional[int]"
                ],
                "max_gen_length": [
                    "int",
                    "numpy.ndarray",
                    "Optional[Union[int, slice]]",
                    "Optional[numpy.ndarray]",
                    "Dict[str, str]"
                ],
                "same_length_as_gt": [
                    "bool",
                    "int",
                    "list",
                    "List[List[int]]",
                    "dict",
                    "List[List[Any]]"
                ],
                "first_is_gold": [
                    "bool",
                    "int",
                    "list",
                    "List[List[int]]",
                    "dict",
                    "List[List[Any]]"
                ]
            }
        },
        "SimpleBiLM._chunked_logsoftmaxes": {
            "name": "_chunked_logsoftmaxes",
            "location": 280,
            "return": [
                "bool",
                "utils.Node",
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "activation": [
                    "int",
                    "list"
                ],
                "word_targets": [
                    "int",
                    "float"
                ],
                "chunk_size": [
                    "int",
                    "Tuple[int, int]",
                    "list",
                    "float"
                ]
            }
        },
        "SimpleBiLM.forward": {
            "name": "forward",
            "location": 302,
            "return": [
                "int",
                "Dict[str, Any]",
                "str",
                "List[int]",
                "Union[Dict, List]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "List[Tuple[int, int]]",
                    "float"
                ],
                "use_forward": [
                    "bool",
                    "int"
                ],
                "use_reverse": [
                    "bool",
                    "int"
                ],
                "compute_logprobs": [
                    "bool",
                    "int"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/swag_generator.py": {
        "SwagGenerator.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [],
            "arguments": {
                "self": [],
                "default_seeds": [],
                "quiet": []
            }
        },
        "SwagGenerator._find_VP": {
            "name": "_find_VP",
            "location": 77,
            "return": [],
            "arguments": {
                "self": [],
                "tree": []
            }
        },
        "SwagGenerator._split_on_final_vp": {
            "name": "_split_on_final_vp",
            "location": 112,
            "return": [],
            "arguments": {
                "self": [],
                "sentence": []
            }
        },
        "SwagGenerator.generate_from_seed": {
            "name": "generate_from_seed",
            "location": 125,
            "return": [],
            "arguments": {
                "self": [],
                "seed": []
            }
        },
        "SwagGenerator._find_VP._recurse_on_children": {
            "name": "_recurse_on_children",
            "location": 81,
            "return": [],
            "arguments": {}
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/utils.py": {
        "optimistic_restore": {
            "name": "optimistic_restore",
            "location": 6,
            "return": [],
            "arguments": {
                "network": [],
                "state_dict": []
            }
        },
        "pairwise": {
            "name": "pairwise",
            "location": 27,
            "return": [],
            "arguments": {
                "iterable": []
            }
        },
        "n2w_1k": {
            "name": "n2w_1k",
            "location": 33,
            "return": [],
            "arguments": {
                "num": [],
                "use_ordinal": []
            }
        },
        "postprocess": {
            "name": "postprocess",
            "location": 38,
            "return": [],
            "arguments": {
                "sentence": []
            }
        },
        "remove_allcaps": {
            "name": "remove_allcaps",
            "location": 69,
            "return": [],
            "arguments": {
                "sent": []
            }
        },
        "remove_allcaps._sanitize": {
            "name": "_sanitize",
            "location": 76,
            "return": [],
            "arguments": {
                "word": [],
                "is_first": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/generators/swag/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/pruners/pruner.py": {
        "Pruner.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/pruners/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/tests/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/tests/dataset_readers/activitynet_captions_test.py": {
        "TestActivityNetCaptionsReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "Callable"
                ]
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/tests/dataset_readers/__init__.py": {},
    "adversarialnlp-master/adversarialnlp/tests/generators/addsent_generator_test.py": {
        "TestSwagGenerator.test_yield_one_epoch_generation_over_the_data_once": {
            "name": "test_yield_one_epoch_generation_over_the_data_once",
            "location": 55,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/tests/generators/swag_generator_test.py": {
        "GeneratorTest.setUp": {
            "name": "setUp",
            "location": 19,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneratorTest.create_instance": {
            "name": "create_instance",
            "location": 44,
            "return": [
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "first_sentence": [
                    "bool",
                    "int"
                ],
                "second_sentence": [
                    "bool",
                    "int"
                ]
            }
        },
        "GeneratorTest.assert_instances_are_correct": {
            "name": "assert_instances_are_correct",
            "location": 51,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "candidate_instances": [
                    "Tuple['cirq.Qid']"
                ]
            }
        },
        "TestSwagGenerator.test_yield_one_epoch_generation_over_the_data_once": {
            "name": "test_yield_one_epoch_generation_over_the_data_once",
            "location": 63,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneratorTest.setUp.LazyIterable.__iter__": {
            "name": "__iter__",
            "location": 38,
            "return": [
                "tuple",
                "float",
                "Optional[int]",
                "Optional[Iterable[str]]",
                "List[str]",
                "Tuple[str]",
                "Union[List[float], List[int]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "adversarialnlp-master/adversarialnlp/tests/generators/__init__.py": {},
    "adversarialnlp-master/docs/conf.py": {},
    "adversarialnlp-master/tutorials/usage.py": {}
}
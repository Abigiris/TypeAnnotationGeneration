{
    "cnt.rulebase-master/setup.py": {
        "load_requirements": {
            "name": "load_requirements",
            "location": 9,
            "return": [
                "bool",
                "list",
                "List[str]",
                "List[Tuple[str, Any]]",
                "str"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/chinese_chars.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/cjk_compatibility_ideographs.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/delimiters.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/digits.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/english_chars.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/utils.py": {
        "sorted_chain": {
            "name": "sorted_chain",
            "location": 7,
            "return": [
                "List[int]",
                "int",
                "float"
            ],
            "arguments": {}
        },
        "normalize_cjk_fullwidth_ascii": {
            "name": "normalize_cjk_fullwidth_ascii",
            "location": 12,
            "return": [
                "str",
                "bytes",
                "bool"
            ],
            "arguments": {
                "seq": [
                    "str",
                    "int",
                    "float",
                    "List[int]"
                ]
            }
        },
        "normalize_cjk_compatibility_ideographs": {
            "name": "normalize_cjk_compatibility_ideographs",
            "location": 27,
            "return": [
                "Optional[bool]",
                "Optional[int]",
                "Callable",
                "dict"
            ],
            "arguments": {
                "seq": [
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "int",
                    "Dict[str, Dict[str, str]]"
                ]
            }
        },
        "normalize_cjk_fullwidth_ascii.convert": {
            "name": "convert",
            "location": 18,
            "return": [
                "str",
                "Optional[float]",
                "int"
            ],
            "arguments": {
                "char": [
                    "str",
                    "List[List[Any]]"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/const/whitespaces.py": {},
    "cnt.rulebase-master/cnt/rulebase/const/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/rules/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/basic_operation.py": {
        "_generate_interval_labeler_class": {
            "name": "_generate_interval_labeler_class",
            "location": 61,
            "return": [
                "int",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "IntervalBasedOperationLabelProcessor.result": {
            "name": "result",
            "location": 11,
            "return": [
                "int",
                "T",
                "float",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedOperationOutputGenerator.continuous_intervals": {
            "name": "continuous_intervals",
            "location": 34,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicIntervalBasedOperation.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "intervals": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "BasicIntervalBasedOperation.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicIntervalBasedOperation._generate_workflow": {
            "name": "_generate_workflow",
            "location": 89,
            "return": [
                "Dict[str, Any]",
                "str",
                "bool",
                "Tuple[int, int, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedOperation.__init__": {
            "name": "__init__",
            "location": 99,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "intervals_collection": [
                    "int",
                    "Dict[str, Any]",
                    "Union[str, int]",
                    "bool"
                ]
            }
        },
        "IntervalsCollectionBasedOperation.initialize_label_processor_class": {
            "name": "initialize_label_processor_class",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedOperation.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedOperation._generate_workflow": {
            "name": "_generate_workflow",
            "location": 128,
            "return": [
                "Dict[str, Any]",
                "str",
                "bool",
                "Tuple[int, int, str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/builtin_application.py": {
        "BuiltInCollector.generate_collector_lazy": {
            "name": "generate_collector_lazy",
            "location": 16,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ],
                "intervals_collection": [
                    "Type",
                    "float",
                    "type"
                ]
            }
        },
        "BuiltInCollector.generate_collector": {
            "name": "generate_collector",
            "location": 25,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ],
                "intervals_collection": [
                    "Type",
                    "float",
                    "type"
                ]
            }
        },
        "BuiltInCollector.setup_collector": {
            "name": "setup_collector",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]",
                    "bool"
                ],
                "name": [
                    "str"
                ],
                "intervals_collection": [
                    "str",
                    "Callable[[Any], bool]",
                    "Dict[str, str]"
                ]
            }
        },
        "BuiltInReplacer.generate_param": {
            "name": "generate_param",
            "location": 67,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "type",
                    "str",
                    "Type[T]"
                ],
                "repl_with_intervals_collection": [
                    "str",
                    "dict",
                    "Iterable[str]"
                ]
            }
        },
        "BuiltInReplacer.generate_replacer_lazy": {
            "name": "generate_replacer_lazy",
            "location": 94,
            "return": [
                "Callable",
                "list",
                "str",
                "float"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Iterable[Any]",
                    "Callable",
                    "Dict[str, Any]"
                ],
                "repl_with_intervals_collection": [
                    "str",
                    "Iterable[Any]",
                    "Callable",
                    "Dict[str, Any]"
                ]
            }
        },
        "BuiltInReplacer.generate_replacer": {
            "name": "generate_replacer",
            "location": 104,
            "return": [
                "Callable",
                "list",
                "str",
                "float"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Iterable[Any]",
                    "Callable",
                    "Dict[str, Any]"
                ],
                "repl_with_intervals_collection": [
                    "str",
                    "Iterable[Any]",
                    "Callable",
                    "Dict[str, Any]"
                ]
            }
        },
        "BuiltInReplacer.generate_replacer_to_string": {
            "name": "generate_replacer_to_string",
            "location": 114,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "Type[T]",
                    "str",
                    "Callable[..., T]",
                    "Type[object]",
                    "Callable",
                    "bool",
                    "List[Union[str, \"SqlFile\"]]",
                    "Callable[..., str]"
                ],
                "repl_with_intervals_collection": [
                    "Type[T]",
                    "str",
                    "Callable[..., T]",
                    "Type[object]",
                    "Callable",
                    "bool",
                    "List[Union[str, \"SqlFile\"]]",
                    "Callable[..., str]"
                ]
            }
        },
        "BuiltInReplacer.setup_replacer": {
            "name": "setup_replacer",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable[[Any], bool]",
                    "bool"
                ],
                "name": [
                    "str"
                ],
                "repl": [
                    "str",
                    "Callable[[Any], bool]",
                    "bool"
                ],
                "intervals_collection": [
                    "str",
                    "Callable[[Any], bool]",
                    "bool"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/interval_based_collector.py": {
        "_IntervalBasedCollectorOutputGenerator._result": {
            "name": "_result",
            "location": 16,
            "return": [
                "cnt.rulebase.workflow.SegmentGeneratorType"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorOutputGeneratorLazy.result": {
            "name": "result",
            "location": 25,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorOutputGenerator.result": {
            "name": "result",
            "location": 31,
            "return": [
                "str",
                "List[str]",
                "List[Dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorLazy.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollectorLazy.result": {
            "name": "result",
            "location": 40,
            "return": [
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "int",
                    "Optional[List[str]]"
                ]
            }
        },
        "IntervalBasedCollector.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalBasedCollector.result": {
            "name": "result",
            "location": 49,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/interval_based_replacer.py": {
        "IntervalsCollectionBasedReplacerConfig.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "labeler2repl": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "IntervalsCollectionBasedReplacerLabelProcessor.result": {
            "name": "result",
            "location": 29,
            "return": [
                "int",
                "T",
                "float",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_IntervalsCollectionBasedReplacerOutputGenerator._result": {
            "name": "_result",
            "location": 48,
            "return": [
                "ResultLazyType"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerOutputGeneratorLazy.result": {
            "name": "result",
            "location": 81,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerOutputGenerator.result": {
            "name": "result",
            "location": 88,
            "return": [
                "str",
                "List[str]",
                "List[Dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerOperation.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "replacer_intervals": [
                    "Dict[str, Any]",
                    "dict",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "IntervalsCollectionBasedReplacerOperation.initialize_label_processor_class": {
            "name": "initialize_label_processor_class",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerLazy.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerLazy.result": {
            "name": "result",
            "location": 120,
            "return": [
                "str",
                "Type[Any]",
                "ClassVar"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool"
                ]
            }
        },
        "IntervalsCollectionBasedReplacer.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacer.result": {
            "name": "result",
            "location": 129,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        },
        "IntervalsCollectionBasedReplacerToString.initialize_output_generator_class": {
            "name": "initialize_output_generator_class",
            "location": 135,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalsCollectionBasedReplacerToString.result": {
            "name": "result",
            "location": 138,
            "return": [
                "str",
                "int",
                "List[str]",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/interval_based_operations/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/rules/sentence_segmentation/const.py": {
        "_flatten_nested": {
            "name": "_flatten_nested",
            "location": 9,
            "return": [],
            "arguments": {
                "seq": [],
                "ret": []
            }
        },
        "_append_code_points_to_text": {
            "name": "_append_code_points_to_text",
            "location": 20,
            "return": [],
            "arguments": {
                "text": []
            }
        },
        "_append_code_points_to_seq": {
            "name": "_append_code_points_to_seq",
            "location": 24,
            "return": [],
            "arguments": {
                "seq": []
            }
        },
        "_append_single_quotation": {
            "name": "_append_single_quotation",
            "location": 30,
            "return": [],
            "arguments": {
                "seq": []
            }
        },
        "_append_double_quotation": {
            "name": "_append_double_quotation",
            "location": 34,
            "return": [],
            "arguments": {
                "seq": []
            }
        },
        "_generate_sentence_ends": {
            "name": "_generate_sentence_ends",
            "location": 38,
            "return": [],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/sentence_segmentation/sentence_segmenter.py": {
        "_generate_sentseg_workflow": {
            "name": "_generate_sentseg_workflow",
            "location": 193,
            "return": [
                "Dict[str, Any]",
                "str",
                "bool",
                "Tuple[int, int, str]"
            ],
            "arguments": {
                "lazy": [
                    "bool",
                    "float",
                    "List[int]"
                ]
            }
        },
        "_sentseg": {
            "name": "_sentseg",
            "location": 213,
            "return": [
                "Type[Any]"
            ],
            "arguments": {
                "sentseg_workflow": [
                    "str",
                    "cnrulebase.workflow.BasicWorkflow",
                    "bool",
                    "Optional[List[str]]",
                    "type"
                ],
                "text": [
                    "str",
                    "cnrulebase.workflow.BasicWorkflow",
                    "bool",
                    "Optional[List[str]]",
                    "type"
                ],
                "enable_strict_sentence_charset": [
                    "str",
                    "int"
                ],
                "enable_comma_ending": [
                    "str",
                    "int"
                ],
                "extend_ending_with_delimiters": [
                    "str",
                    "int"
                ],
                "dynamic_endings": [
                    "str",
                    "int"
                ]
            }
        },
        "sentseg": {
            "name": "sentseg",
            "location": 231,
            "return": [
                "dict"
            ],
            "arguments": {
                "text": [
                    "bool",
                    "Optional[List[str]]",
                    "str",
                    "Type"
                ],
                "enable_strict_sentence_charset": [
                    "bool",
                    "Optional[List[str]]",
                    "str",
                    "Type"
                ],
                "enable_comma_ending": [
                    "bool",
                    "Optional[List[str]]",
                    "str",
                    "Type"
                ],
                "extend_ending_with_delimiters": [
                    "bool",
                    "Optional[List[str]]",
                    "str",
                    "Type"
                ],
                "dynamic_endings": [
                    "bool",
                    "Optional[List[str]]",
                    "str",
                    "Type"
                ]
            }
        },
        "sentseg_lazy": {
            "name": "sentseg_lazy",
            "location": 250,
            "return": [
                "tuple",
                "Type[Any]"
            ],
            "arguments": {
                "text": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "int"
                ],
                "enable_strict_sentence_charset": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "int"
                ],
                "enable_comma_ending": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "int"
                ],
                "extend_ending_with_delimiters": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "int"
                ],
                "dynamic_endings": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "int"
                ]
            }
        },
        "SentenceSegementationConfig.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "enable_strict_sentence_charset": [
                    "int",
                    "bool",
                    "float"
                ],
                "enable_comma_ending": [
                    "int",
                    "bool",
                    "float"
                ],
                "extend_ending_with_delimiters": [
                    "int",
                    "bool",
                    "float"
                ],
                "dynamic_endings": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "DynamicSentenceEndingLabeler.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ],
                "config": [
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        },
        "DynamicSentenceEndingLabeler.intervals_generator": {
            "name": "intervals_generator",
            "location": 48,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CommaLabeler.label": {
            "name": "label",
            "location": 69,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "str"
                ]
            }
        },
        "SentenceSegementationLabelProcessor._labels_indicate_sentence_ending": {
            "name": "_labels_indicate_sentence_ending",
            "location": 102,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "str",
                    "float"
                ]
            }
        },
        "SentenceSegementationLabelProcessor.result": {
            "name": "result",
            "location": 108,
            "return": [
                "int",
                "T",
                "float",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_SentenceSegementationOutputGeneratorLazy._result": {
            "name": "_result",
            "location": 176,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceSegementationOutputGeneratorLazy.result": {
            "name": "result",
            "location": 183,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SentenceSegementationOutputGenerator.result": {
            "name": "result",
            "location": 189,
            "return": [
                "str",
                "List[str]",
                "List[Dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DynamicSentenceEndingLabeler.intervals_generator.mocker_generator": {
            "name": "mocker_generator",
            "location": 50,
            "return": [
                "cnt.rulebase.workflow.IntervalGeneratorType"
            ],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/cnt/rulebase/rules/sentence_segmentation/__init__.py": {},
    "cnt.rulebase-master/cnt/rulebase/workflow/basic_workflow.py": {
        "BasicSequentialLabeler.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "str",
                    "list",
                    "dict"
                ],
                "config": [
                    "dict",
                    "int"
                ]
            }
        },
        "BasicSequentialLabeler.label": {
            "name": "label",
            "location": 24,
            "return": [
                "builtins.bool"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "str",
                    "bool",
                    "Dict[str, Any]",
                    "Sequence[str]"
                ]
            }
        },
        "BasicLabelProcessor.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "list"
                ],
                "index_labels_generator": [
                    "str",
                    "Dict[str, Any]",
                    "Callable[[Dict], None]",
                    "float"
                ],
                "config": [
                    "list",
                    "Optional[str]",
                    "Dict[str, str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "BasicLabelProcessor.result": {
            "name": "result",
            "location": 54,
            "return": [
                "typing.Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicOutputGenerator.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "int",
                    "bool",
                    "str",
                    "Tuple[str, str, str]",
                    "Optional[str]"
                ],
                "label_processor_result": [
                    "bool",
                    "int"
                ],
                "config": [
                    "bool",
                    "str",
                    "list",
                    "Optional[str]",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "BasicOutputGenerator.result": {
            "name": "result",
            "location": 76,
            "return": [
                "typing.Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicWorkflow.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "sequential_labeler_classes": [
                    "Tuple[Hashable]",
                    "dict",
                    "str",
                    "int",
                    "Callable[[], bool]",
                    "bool"
                ],
                "label_processor_class": [
                    "bool",
                    "int"
                ],
                "output_generator_class": [
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "int"
                ]
            }
        },
        "BasicWorkflow.result": {
            "name": "result",
            "location": 103,
            "return": [
                "str",
                "Dict[str, Any]",
                "Awaitable"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "Dict[str, Any]"
                ],
                "config": [
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/workflow/exact_match_labeler.py": {
        "_ac_automation_match": {
            "name": "_ac_automation_match",
            "location": 9,
            "return": [
                "cnt.rulebase.workflow.type_annotations.IntervalGeneratorType"
            ],
            "arguments": {
                "text": [
                    "str",
                    "Tuple[int, int]"
                ],
                "ac_automation": [
                    "str",
                    "Tuple[int, int]"
                ]
            }
        },
        "ExactMatchLabeler.build_ac_automation_from_strings": {
            "name": "build_ac_automation_from_strings",
            "location": 42,
            "return": [
                "str",
                "Optional[str]",
                "Optional[Dict]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bytes",
                    "int"
                ],
                "keys": [
                    "List[str]",
                    "str"
                ]
            }
        },
        "ExactMatchLabeler.build_and_bind_ac_automation_from_strings": {
            "name": "build_and_bind_ac_automation_from_strings",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "List[str]",
                    "str",
                    "Set[str]"
                ],
                "keys": [
                    "List[str]",
                    "str",
                    "Set[str]"
                ]
            }
        },
        "ExactMatchLabeler.intervals_generator": {
            "name": "intervals_generator",
            "location": 53,
            "return": [
                "str",
                "dict",
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/workflow/interval_labeler.py": {
        "_next_interval": {
            "name": "_next_interval",
            "location": 10,
            "return": [
                "str",
                "Optional[str]",
                "Optional[List[Any]]",
                "list",
                "Optional[BaseException]"
            ],
            "arguments": {
                "intervals": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "build_re_pattern_from_intervals": {
            "name": "build_re_pattern_from_intervals",
            "location": 17,
            "return": [
                "Dict[str, List[str]]",
                "dict",
                "bool",
                "str"
            ],
            "arguments": {
                "intervals": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "IntervalLabeler.initialize_by_regular_expression": {
            "name": "initialize_by_regular_expression",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Exception"
                ],
                "pattern": [
                    "str",
                    "Exception"
                ]
            }
        },
        "IntervalLabeler.initialize_by_intervals": {
            "name": "initialize_by_intervals",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "List[str]",
                    "T",
                    "\"CategoricalDtype\""
                ],
                "intervals": [
                    "str",
                    "List[str]",
                    "T",
                    "\"CategoricalDtype\""
                ]
            }
        },
        "IntervalLabeler.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ],
                "config": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ]
            }
        },
        "IntervalLabeler.intervals_generator": {
            "name": "intervals_generator",
            "location": 59,
            "return": [
                "bool",
                "list",
                "str",
                "List[str]",
                "Optional[dict]",
                "Sequence[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntervalLabeler.label": {
            "name": "label",
            "location": 64,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        }
    },
    "cnt.rulebase-master/cnt/rulebase/workflow/type_annotations.py": {},
    "cnt.rulebase-master/cnt/rulebase/workflow/__init__.py": {},
    "cnt.rulebase-master/docs/conf.py": {},
    "cnt.rulebase-master/tasks/tasks.py": {
        "variant_mapping": {
            "name": "variant_mapping",
            "location": 4,
            "return": [
                ""
            ],
            "arguments": {
                "c": [
                    "str",
                    "bool",
                    "List[str]"
                ],
                "unihan_variant_path": [
                    "str"
                ],
                "output": [
                    "str",
                    "Optional[str]",
                    "bool"
                ]
            }
        }
    },
    "cnt.rulebase-master/tests/test_const_utils.py": {
        "test_normalize_cjk_fullwidth_ascii": {
            "name": "test_normalize_cjk_fullwidth_ascii",
            "location": 4,
            "return": [],
            "arguments": {}
        },
        "test_normalize_cjk_compatibility_ideographs": {
            "name": "test_normalize_cjk_compatibility_ideographs",
            "location": 11,
            "return": [],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/tests/test_interval_based_collector.py": {
        "test_interval_based_collector": {
            "name": "test_interval_based_collector",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_chinese_sentence_chars_collector": {
            "name": "test_chinese_sentence_chars_collector",
            "location": 31,
            "return": [],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/tests/test_interval_based_replacer.py": {
        "test_replacer": {
            "name": "test_replacer",
            "location": 9,
            "return": [],
            "arguments": {}
        },
        "test_replacer_intervals": {
            "name": "test_replacer_intervals",
            "location": 26,
            "return": [],
            "arguments": {}
        },
        "test_built_in_replacer": {
            "name": "test_built_in_replacer",
            "location": 52,
            "return": [],
            "arguments": {}
        }
    },
    "cnt.rulebase-master/tests/test_sentseg.py": {
        "test_sentence_ending_labler": {
            "name": "test_sentence_ending_labler",
            "location": 12,
            "return": [],
            "arguments": {}
        },
        "test_whitespace_labeler": {
            "name": "test_whitespace_labeler",
            "location": 26,
            "return": [],
            "arguments": {}
        },
        "test_sentence_valid_character_labeler": {
            "name": "test_sentence_valid_character_labeler",
            "location": 39,
            "return": [],
            "arguments": {}
        },
        "test_sentseg": {
            "name": "test_sentseg",
            "location": 62,
            "return": [],
            "arguments": {}
        },
        "test_sentseg_lazy": {
            "name": "test_sentseg_lazy",
            "location": 97,
            "return": [],
            "arguments": {}
        }
    }
}
{
    "cracking-the-coding-interview-master/main.py": {
        "main": {
            "name": "main",
            "location": 4,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch01/hash_map.py": {
        "HashMap.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "HashMap.get": {
            "name": "get",
            "location": 16,
            "return": [
                "bool",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "Optional[str]",
                "Optional[Type]",
                "Optional[List[Any]]"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ]
            }
        },
        "HashMap.put": {
            "name": "put",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "value": [
                    "str",
                    "List[str]",
                    "dict"
                ]
            }
        },
        "HashMap._rebalance": {
            "name": "_rebalance",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cracking-the-coding-interview-master/ch01/matrix.py": {
        "rotate_matrix": {
            "name": "rotate_matrix",
            "location": 8,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "matrix": [
                    "int",
                    "Sequence[T]",
                    "List[Dict[str, Any]]",
                    "List[str]",
                    "List[int]",
                    "list"
                ]
            }
        },
        "zero_matrix": {
            "name": "zero_matrix",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "matrix": [
                    "List[List[T]]",
                    "int",
                    "bytes"
                ]
            }
        }
    },
    "cracking-the-coding-interview-master/ch01/string.py": {
        "all_unique_chars": {
            "name": "all_unique_chars",
            "location": 6,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "is_permutation": {
            "name": "is_permutation",
            "location": 12,
            "return": [],
            "arguments": {
                "s1": [],
                "s2": []
            }
        },
        "url_encode_spaces": {
            "name": "url_encode_spaces",
            "location": 20,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "is_palindrome_permutation": {
            "name": "is_palindrome_permutation",
            "location": 28,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "within_one_edit": {
            "name": "within_one_edit",
            "location": 39,
            "return": [],
            "arguments": {
                "s1": [],
                "s2": []
            }
        },
        "_at_most_one_replaced_char": {
            "name": "_at_most_one_replaced_char",
            "location": 52,
            "return": [],
            "arguments": {
                "s1": [],
                "s2": []
            }
        },
        "_left_str_has_one_removed_char": {
            "name": "_left_str_has_one_removed_char",
            "location": 66,
            "return": [],
            "arguments": {
                "s1": [],
                "s2": []
            }
        },
        "is_rotation": {
            "name": "is_rotation",
            "location": 117,
            "return": [],
            "arguments": {
                "s1": [],
                "s2": []
            }
        },
        "CompressedString.__init__": {
            "name": "__init__",
            "location": 91,
            "return": [],
            "arguments": {
                "self": [],
                "s": []
            }
        },
        "CompressedString.__str__": {
            "name": "__str__",
            "location": 108,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "cracking-the-coding-interview-master/ch01/test_hash_map.py": {
        "test_get": {
            "name": "test_get",
            "location": 4,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_get_missing_key": {
            "name": "test_get_missing_key",
            "location": 15,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_empty_hash_map": {
            "name": "test_empty_hash_map",
            "location": 22,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_put": {
            "name": "test_put",
            "location": 27,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch01/test_matrix.py": {
        "test_rotate_matrix": {
            "name": "test_rotate_matrix",
            "location": 4,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_rotate_matrix_edge_cases": {
            "name": "test_rotate_matrix_edge_cases",
            "location": 36,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_zero_matrix": {
            "name": "test_zero_matrix",
            "location": 42,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_zero_matrix_edge_cases": {
            "name": "test_zero_matrix_edge_cases",
            "location": 57,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch01/test_string.py": {
        "test_all_unique_chars": {
            "name": "test_all_unique_chars",
            "location": 4,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_permutation": {
            "name": "test_is_permutation",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_url_encode_spaces": {
            "name": "test_url_encode_spaces",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_palindrome_permutation": {
            "name": "test_is_palindrome_permutation",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_within_one_edit": {
            "name": "test_within_one_edit",
            "location": 38,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_compressed_string": {
            "name": "test_compressed_string",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_rotation": {
            "name": "test_is_rotation",
            "location": 60,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch01/__init__.py": {},
    "cracking-the-coding-interview-master/ch02/linked_list.py": {
        "LinkedListIterator.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Optional[ch02.node.Node[T]]",
                    "docutils.nodes.Node",
                    "float"
                ]
            }
        },
        "LinkedListIterator.__iter__": {
            "name": "__iter__",
            "location": 12,
            "return": [
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedListIterator.__next__": {
            "name": "__next__",
            "location": 15,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.for_each": {
            "name": "for_each",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "func": [
                    "Callable[[T], None]",
                    "dict",
                    "Iterable[Any]",
                    "Dict[str, str]"
                ]
            }
        },
        "LinkedList.is_empty": {
            "name": "is_empty",
            "location": 39,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.head": {
            "name": "head",
            "location": 42,
            "return": [
                "Optional[str]",
                "str",
                "bool",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.tail": {
            "name": "tail",
            "location": 45,
            "return": [
                "Optional[str]",
                "str",
                "Optional[List[Any]]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.prepend": {
            "name": "prepend",
            "location": 53,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T",
                    "dict",
                    "List[T]",
                    "list"
                ]
            }
        },
        "LinkedList.append": {
            "name": "append",
            "location": 63,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "bool",
                    "Dict[str, Any]",
                    "Union[int, slice]"
                ]
            }
        },
        "LinkedList.delete": {
            "name": "delete",
            "location": 72,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "LinkedList._get_node": {
            "name": "_get_node",
            "location": 91,
            "return": [
                "Optional[str]",
                "dict",
                "Optional[List[str]]",
                "bool",
                "Callable[[], None]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "dict",
                    "Iterable",
                    "str"
                ]
            }
        },
        "LinkedList.get": {
            "name": "get",
            "location": 101,
            "return": [
                "Optional[str]",
                "int",
                "Optional[List[str]]",
                "str",
                "Optional[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "str",
                    "Tuple[int]",
                    "Callable"
                ]
            }
        },
        "LinkedList.distinct": {
            "name": "distinct",
            "location": 106,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.get_kth_to_last": {
            "name": "get_kth_to_last",
            "location": 116,
            "return": [
                "bool",
                "Dict[str, Any]",
                "Optional[Union[Any, str]]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "int",
                    "bool",
                    "str",
                    "Set[str]"
                ]
            }
        },
        "LinkedList.partition": {
            "name": "partition",
            "location": 123,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "T",
                    "str",
                    "dict",
                    "bytes",
                    "int"
                ]
            }
        },
        "LinkedList.is_palindrome": {
            "name": "is_palindrome",
            "location": 139,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.intersects_with": {
            "name": "intersects_with",
            "location": 150,
            "return": [
                "str",
                "Dict[str, Any]",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Set[VT]",
                    "Iterable[T]",
                    "T"
                ]
            }
        },
        "LinkedList.has_loop": {
            "name": "has_loop",
            "location": 167,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.__str__": {
            "name": "__str__",
            "location": 178,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.__len__": {
            "name": "__len__",
            "location": 181,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinkedList.__eq__": {
            "name": "__eq__",
            "location": 187,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[Dict[str, Any]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "LinkedList.__iter__": {
            "name": "__iter__",
            "location": 190,
            "return": [
                "str",
                "Callable[[str], T]",
                "list"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cracking-the-coding-interview-master/ch02/node.py": {
        "Node.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "T"
                ]
            }
        },
        "Node.value": {
            "name": "value",
            "location": 11,
            "return": [
                "str",
                "int",
                "Type[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Node.next": {
            "name": "next",
            "location": 14,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Node.set_next": {
            "name": "set_next",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "next_node": [
                    "List[Dict[str, Any]]",
                    "List[int]",
                    "Callable[[T], T]",
                    "dict",
                    "List[T]",
                    "list"
                ]
            }
        }
    },
    "cracking-the-coding-interview-master/ch02/test_linked_list.py": {
        "test_iter": {
            "name": "test_iter",
            "location": 5,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_list": {
            "name": "test_to_list",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_str": {
            "name": "test_to_str",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_len": {
            "name": "test_len",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_eq": {
            "name": "test_eq",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_head": {
            "name": "test_head",
            "location": 40,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_tail": {
            "name": "test_tail",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_empty": {
            "name": "test_is_empty",
            "location": 52,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_append": {
            "name": "test_append",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_prepend": {
            "name": "test_prepend",
            "location": 67,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_get": {
            "name": "test_get",
            "location": 76,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_get_kth_to_last": {
            "name": "test_get_kth_to_last",
            "location": 89,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_delete": {
            "name": "test_delete",
            "location": 102,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_delete_out_of_bounds": {
            "name": "test_delete_out_of_bounds",
            "location": 118,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_distinct": {
            "name": "test_distinct",
            "location": 131,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_partition": {
            "name": "test_partition",
            "location": 140,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_palindrome": {
            "name": "test_is_palindrome",
            "location": 150,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_intersects_with": {
            "name": "test_intersects_with",
            "location": 160,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_has_loop": {
            "name": "test_has_loop",
            "location": 169,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch02/__init__.py": {},
    "cracking-the-coding-interview-master/ch03/queue.py": {
        "QueueIterator.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Optional[ch02.node.Node[T]]",
                    "docutils.nodes.Node",
                    "float"
                ]
            }
        },
        "QueueIterator.__iter__": {
            "name": "__iter__",
            "location": 11,
            "return": [
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "QueueIterator.__next__": {
            "name": "__next__",
            "location": 14,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.add": {
            "name": "add",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "Iterable[T]",
                    "T",
                    "list",
                    "str"
                ]
            }
        },
        "Queue.remove": {
            "name": "remove",
            "location": 48,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.peek": {
            "name": "peek",
            "location": 57,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.is_empty": {
            "name": "is_empty",
            "location": 63,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__str__": {
            "name": "__str__",
            "location": 66,
            "return": [
                "str",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__len__": {
            "name": "__len__",
            "location": 69,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__eq__": {
            "name": "__eq__",
            "location": 75,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "dict",
                    "Optional[Iterable[T]]"
                ]
            }
        },
        "Queue.__iter__": {
            "name": "__iter__",
            "location": 78,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cracking-the-coding-interview-master/ch03/set_of_stacks.py": {
        "SetOfStacksIterator.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "stacks": [
                    "int",
                    "Iterable[str]",
                    "str"
                ]
            }
        },
        "SetOfStacksIterator.__iter__": {
            "name": "__iter__",
            "location": 12,
            "return": [
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacksIterator.__next__": {
            "name": "__next__",
            "location": 15,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacks.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_stack_size": [
                    "int",
                    "str",
                    "Union[None, int]"
                ],
                "items": [
                    "bool",
                    "Optional[bool]",
                    "Optional[int]",
                    "int"
                ]
            }
        },
        "SetOfStacks.pop": {
            "name": "pop",
            "location": 40,
            "return": [
                "Dict[str, Any]",
                "Dict[str, Dict[str, int]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacks.peek": {
            "name": "peek",
            "location": 51,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacks.push": {
            "name": "push",
            "location": 57,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "List[Dict[str, Any]]",
                    "Iterable[str]",
                    "List[str]"
                ]
            }
        },
        "SetOfStacks.is_empty": {
            "name": "is_empty",
            "location": 65,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacks.__str__": {
            "name": "__str__",
            "location": 68,
            "return": [
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacks.__len__": {
            "name": "__len__",
            "location": 72,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "SetOfStacks.__eq__": {
            "name": "__eq__",
            "location": 78,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[int]",
                    "Optional[\"Cell\"]",
                    "Optional[List[str]]"
                ]
            }
        },
        "SetOfStacks.__iter__": {
            "name": "__iter__",
            "location": 86,
            "return": [
                "str",
                "AbstractSet[Any]",
                "Optional[type]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cracking-the-coding-interview-master/ch03/stack.py": {
        "StackIterator.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Optional[ch02.node.Node[T]]",
                    "docutils.nodes.Node",
                    "float"
                ]
            }
        },
        "StackIterator.__iter__": {
            "name": "__iter__",
            "location": 13,
            "return": [
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "StackIterator.__next__": {
            "name": "__next__",
            "location": 16,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.pop": {
            "name": "pop",
            "location": 36,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.peek": {
            "name": "peek",
            "location": 44,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.push": {
            "name": "push",
            "location": 50,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T",
                    "str",
                    "Iterable[T]"
                ]
            }
        },
        "Stack.is_empty": {
            "name": "is_empty",
            "location": 56,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.sorted": {
            "name": "sorted",
            "location": 59,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__str__": {
            "name": "__str__",
            "location": 74,
            "return": [
                "str",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__len__": {
            "name": "__len__",
            "location": 77,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__eq__": {
            "name": "__eq__",
            "location": 83,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "dict",
                    "Optional[Iterable[T]]"
                ]
            }
        },
        "Stack.__iter__": {
            "name": "__iter__",
            "location": 86,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "cracking-the-coding-interview-master/ch03/test_queue.py": {
        "test_iter": {
            "name": "test_iter",
            "location": 5,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_list": {
            "name": "test_to_list",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_str": {
            "name": "test_to_str",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_len": {
            "name": "test_len",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_eq": {
            "name": "test_eq",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_empty": {
            "name": "test_is_empty",
            "location": 40,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_add": {
            "name": "test_add",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_remove": {
            "name": "test_remove",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_peek": {
            "name": "test_peek",
            "location": 70,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch03/test_set_of_stacks.py": {
        "test_iter": {
            "name": "test_iter",
            "location": 5,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_list": {
            "name": "test_to_list",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_str": {
            "name": "test_to_str",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_len": {
            "name": "test_len",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_eq": {
            "name": "test_eq",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_empty": {
            "name": "test_is_empty",
            "location": 41,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_push": {
            "name": "test_push",
            "location": 47,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_pop": {
            "name": "test_pop",
            "location": 55,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_peek": {
            "name": "test_peek",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch03/test_stack.py": {
        "test_iter": {
            "name": "test_iter",
            "location": 5,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_list": {
            "name": "test_to_list",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_to_str": {
            "name": "test_to_str",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_len": {
            "name": "test_len",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_eq": {
            "name": "test_eq",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_is_empty": {
            "name": "test_is_empty",
            "location": 40,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_push": {
            "name": "test_push",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_pop": {
            "name": "test_pop",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_peek": {
            "name": "test_peek",
            "location": 70,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_sorted": {
            "name": "test_sorted",
            "location": 81,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_sorted_does_not_mutate": {
            "name": "test_sorted_does_not_mutate",
            "location": 90,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "cracking-the-coding-interview-master/ch03/__init__.py": {},
    "cracking-the-coding-interview-master/util/comparable.py": {
        "Comparable.__eq__": {
            "name": "__eq__",
            "location": 10,
            "return": [
                "builtins.bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "SupportsFloat",
                    "List[str]",
                    "Union[int, float]",
                    "AbstractSet[T]"
                ]
            }
        },
        "Comparable.__lt__": {
            "name": "__lt__",
            "location": 14,
            "return": [
                "builtins.bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "SupportsFloat",
                    "List[str]",
                    "Union[int, float]",
                    "AbstractSet[T]"
                ]
            }
        },
        "Comparable.__gt__": {
            "name": "__gt__",
            "location": 17,
            "return": [
                "bool",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "T",
                    "Tuple[int, int]"
                ]
            }
        },
        "Comparable.__le__": {
            "name": "__le__",
            "location": 20,
            "return": [
                "bool",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "T",
                    "Tuple[int, int]"
                ]
            }
        },
        "Comparable.__ge__": {
            "name": "__ge__",
            "location": 23,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "List[str]",
                    "float",
                    "str",
                    "int"
                ]
            }
        }
    },
    "cracking-the-coding-interview-master/util/__init__.py": {}
}
{
    "fables-master/example.py": {},
    "fables-master/noxfile.py": {
        "blacken": {
            "name": "blacken",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {
                "session": [
                    "nox.sessions.Session"
                ]
            }
        },
        "lint": {
            "name": "lint",
            "location": 14,
            "return": [
                ""
            ],
            "arguments": {
                "session": []
            }
        },
        "type_check": {
            "name": "type_check",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {
                "session": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ]
            }
        },
        "test": {
            "name": "test",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "session": [
                    "nox.sessions.Session"
                ],
                "pandas": [
                    "str"
                ]
            }
        }
    },
    "fables-master/setup.py": {},
    "fables-master/fables/api.py": {
        "_check_file_size": {
            "name": "_check_file_size",
            "location": 16,
            "return": [
                "bool",
                "str",
                "Optional[List[str]]",
                "dict",
                "int"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Union[str, bytes]",
                    "bytes",
                    "AnyStr"
                ]
            }
        },
        "_check_stream_size": {
            "name": "_check_stream_size",
            "location": 21,
            "return": [
                "str",
                "Mapping[str, Any]",
                "Optional[bool]"
            ],
            "arguments": {
                "stream": [
                    "Optional[Union[float, str]]",
                    "str",
                    "io.BytesIO",
                    "IO[bytes]"
                ]
            }
        },
        "_parse_user_input": {
            "name": "_parse_user_input",
            "location": 28,
            "return": [
                "str",
                "Dict[str, Any]",
                "Callable",
                "dict"
            ],
            "arguments": {
                "io": [
                    "str",
                    "Union[str, IO[bytes], None]",
                    "Optional[str]",
                    "bool"
                ],
                "calling_func_name": [
                    "str"
                ],
                "password": [
                    "Optional[str]",
                    "str",
                    "Optional[Dict[str, str]]",
                    "bool"
                ],
                "passwords": [
                    "Optional[str]",
                    "Optional[int]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[Sequence[str]]",
                    "Optional[Dict[str, str]]"
                ],
                "stream_file_name": [
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "detect": {
            "name": "detect",
            "location": 79,
            "return": [
                "int",
                "Optional[Dict[str, str]]",
                "bool"
            ],
            "arguments": {
                "io": [
                    "str",
                    "Optional[str]",
                    "TextIO",
                    "Exception"
                ]
            }
        },
        "parse": {
            "name": "parse",
            "location": 99,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "io": [
                    "str",
                    "Optional[TextIO]",
                    "Optional[io.BytesIO]"
                ]
            }
        }
    },
    "fables-master/fables/constants.py": {},
    "fables-master/fables/errors.py": {
        "InsufficientEncodingDetectorConfidenceError.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "confidence_threshold": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "fables-master/fables/parse.py": {
        "sniff_delimiter": {
            "name": "sniff_delimiter",
            "location": 36,
            "return": [
                "str"
            ],
            "arguments": {
                "bytesio": [
                    "str",
                    "bytes",
                    "Union[str, bytes]"
                ],
                "encoding": [
                    "str",
                    "Optional[str]",
                    "bytes",
                    "int"
                ]
            }
        },
        "detect_encoding": {
            "name": "detect_encoding",
            "location": 45,
            "return": [
                "str"
            ],
            "arguments": {
                "bytesio": [
                    "str",
                    "Optional[int]",
                    "Callable"
                ]
            }
        },
        "_extract_data_frame_from_csv": {
            "name": "_extract_data_frame_from_csv",
            "location": 56,
            "return": [
                "str",
                "bool",
                "dict"
            ],
            "arguments": {
                "bytesio": [
                    "str",
                    "bytes",
                    "int",
                    "bool"
                ],
                "pandas_kwargs": [
                    "bytes"
                ]
            }
        },
        "remove_data_before_header": {
            "name": "remove_data_before_header",
            "location": 73,
            "return": [
                "str",
                "bool",
                "int",
                "dict"
            ],
            "arguments": {
                "df": [
                    "list",
                    "List[str]",
                    "List[List[Any]]",
                    "List[Callable]",
                    "str",
                    "bytes"
                ],
                "force_numeric": [
                    "bool",
                    "T",
                    "list",
                    "dict",
                    "List[dict]"
                ]
            }
        },
        "post_process_dataframe": {
            "name": "post_process_dataframe",
            "location": 114,
            "return": [
                "Optional[Type]",
                "dict"
            ],
            "arguments": {
                "df": [
                    "List[str]",
                    "bool"
                ],
                "force_numeric": [
                    "bool",
                    "int",
                    "bytes",
                    "Optional[int]"
                ]
            }
        },
        "parse_csv": {
            "name": "parse_csv",
            "location": 134,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "bytesio": [
                    "pandas.DataFrame",
                    "bool",
                    "Dict[str, str]",
                    "str"
                ]
            }
        },
        "parse_excel_sheet": {
            "name": "parse_excel_sheet",
            "location": 153,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "excel_file": [
                    "str",
                    "Dict[str, Any]",
                    "list"
                ],
                "sheet": [
                    "str",
                    "Dict[str, Any]",
                    "list"
                ]
            }
        },
        "ParseVisitor.__init__": {
            "name": "__init__",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ParseVisitor.visit": {
            "name": "visit",
            "location": 172,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": []
            }
        },
        "ParseVisitor.visit_Csv": {
            "name": "visit_Csv",
            "location": 177,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": []
            }
        },
        "ParseVisitor._visit_excel": {
            "name": "_visit_excel",
            "location": 196,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": []
            }
        },
        "ParseVisitor.visit_Xls": {
            "name": "visit_Xls",
            "location": 235,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Sequence[Any]"
                ]
            }
        },
        "ParseVisitor.visit_Xlsx": {
            "name": "visit_Xlsx",
            "location": 238,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Sequence[Any]"
                ]
            }
        },
        "ParseVisitor.visit_Xlsb": {
            "name": "visit_Xlsb",
            "location": 241,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Sequence[Any]"
                ]
            }
        },
        "ParseVisitor.visit_Zip": {
            "name": "visit_Zip",
            "location": 244,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Sequence[Any]"
                ]
            }
        },
        "ParseVisitor.visit_Directory": {
            "name": "visit_Directory",
            "location": 248,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Sequence[Any]"
                ]
            }
        },
        "ParseVisitor.visit_Skip": {
            "name": "visit_Skip",
            "location": 252,
            "return": [
                "typing.Iterable[fables.results.ParseResult]"
            ],
            "arguments": {
                "self": [],
                "_node": []
            }
        }
    },
    "fables-master/fables/results.py": {},
    "fables-master/fables/table.py": {
        "Table.__str__": {
            "name": "__str__",
            "location": 18,
            "return": [
                "str",
                "bool",
                "Optional[Dict[str, Any]]",
                "List[str]",
                "Optional[str]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "fables-master/fables/tree.py": {
        "mimetype_from_stream": {
            "name": "mimetype_from_stream",
            "location": 350,
            "return": [
                "Optional[int]",
                "Optional[bool]",
                "Optional[str]",
                "Optional[float]",
                "str"
            ],
            "arguments": {
                "stream": [
                    "Optional[bytes]",
                    "Optional[IO[str]]",
                    "bytes",
                    "str",
                    "Callable[[], bytes]",
                    "Optional[IO[bytes]]",
                    "dict"
                ]
            }
        },
        "extension_from_name": {
            "name": "extension_from_name",
            "location": 361,
            "return": [
                "bool",
                "str",
                "Tuple[str, Optional[str]]",
                "dict",
                "Type"
            ],
            "arguments": {
                "name": [
                    "str"
                ]
            }
        },
        "mimetype_and_extension": {
            "name": "mimetype_and_extension",
            "location": 369,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "node_from_file": {
            "name": "node_from_file",
            "location": 386,
            "return": [
                "str",
                "List[str]",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "StreamManager.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Dict[str, Any]",
                    "List[str]",
                    "dict"
                ],
                "stream": [
                    "Optional[str]",
                    "str",
                    "Union[str, bytes, None]"
                ]
            }
        },
        "StreamManager.__enter__": {
            "name": "__enter__",
            "location": 51,
            "return": [
                "float",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "StreamManager.__exit__": {
            "name": "__exit__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.empty": {
            "name": "empty",
            "location": 91,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.stream": {
            "name": "stream",
            "location": 95,
            "return": [
                "bool",
                "str",
                "Tuple[str, List[str], List[float], List[str], List[float], List[float], List[Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.children": {
            "name": "children",
            "location": 103,
            "return": [
                "typing.Iterator[\"FileNode\"]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.encrypted": {
            "name": "encrypted",
            "location": 107,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.add_password": {
            "name": "add_password",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "List[str]"
                ],
                "password": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "FileNode.password": {
            "name": "password",
            "location": 114,
            "return": [
                "Optional[str]",
                "Optional[List[Any]]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "bool",
                "Optional[List[str]]",
                "Optional[Union[str, Any]]",
                "Optional[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FileNode.__str__": {
            "name": "__str__",
            "location": 140,
            "return": [
                "Optional[str]",
                "str",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "MimeTypeFileNode.is_my_mimetype_or_extension": {
            "name": "is_my_mimetype_or_extension",
            "location": 150,
            "return": [
                "bool"
            ],
            "arguments": {
                "cls": [
                    "Tuple[object]"
                ],
                "mimetype": [
                    "type",
                    "Optional[type]"
                ],
                "extension": [
                    "str"
                ]
            }
        },
        "Zip._bytes_password": {
            "name": "_bytes_password",
            "location": 174,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Zip._encrypted_from_bit_signature": {
            "name": "_encrypted_from_bit_signature",
            "location": 181,
            "return": [
                "bool"
            ],
            "arguments": {
                "zf": [
                    "zipfile.ZipFile",
                    "bool",
                    "str"
                ]
            }
        },
        "Zip._password_decrypts": {
            "name": "_password_decrypts",
            "location": 190,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Zip.encrypted": {
            "name": "encrypted",
            "location": 211,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Zip.children": {
            "name": "children",
            "location": 219,
            "return": [
                "typing.Iterator[FileNode]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ExcelEncryptionMixin.__init__": {
            "name": "__init__",
            "location": 259,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ExcelEncryptionMixin.decrypt": {
            "name": "decrypt",
            "location": 265,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "encrypted_stream": [
                    "str"
                ],
                "password": [
                    "str"
                ]
            }
        },
        "ExcelEncryptionMixin.encrypted": {
            "name": "encrypted",
            "location": 286,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ExcelEncryptionMixin.stream": {
            "name": "stream",
            "location": 299,
            "return": [
                "bool",
                "bytes",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Directory.children": {
            "name": "children",
            "location": 339,
            "return": [
                "typing.Iterator[FileNode]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "fables-master/fables/__init__.py": {},
    "fables-master/mypy_stubs/magic.py": {
        "from_buffer": {
            "name": "from_buffer",
            "location": 3,
            "return": [],
            "arguments": {
                "buffer": [],
                "mime": []
            }
        }
    },
    "fables-master/mypy_stubs/msoffcrypto/__init__.py": {},
    "fables-master/mypy_stubs/msoffcrypto/__main__.py": {
        "is_encrypted": {
            "name": "is_encrypted",
            "location": 3,
            "return": [],
            "arguments": {
                "file": []
            }
        }
    },
    "fables-master/tests/context.py": {},
    "fables-master/tests/__init__.py": {},
    "fables-master/tests/integration/constants.py": {},
    "fables-master/tests/integration/test_it_decrypts_files.py": {
        "test_it_unlocks_files_when_the_password_is_correct": {
            "name": "test_it_unlocks_files_when_the_password_is_correct",
            "location": 23,
            "return": [
                ""
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "password": [
                    "str",
                    "Optional[str]",
                    "Dict[str, Any]"
                ],
                "expected_to_be_encrypted": [
                    "str",
                    "Iterator[str]",
                    "Optional[List[str]]",
                    "Optional[Dict[str, int]]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "test_it_raises_an_exception_when_decrypting_a_corrupt_file": {
            "name": "test_it_raises_an_exception_when_decrypting_a_corrupt_file",
            "location": 41,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fables-master/tests/integration/test_it_detects_files.py": {
        "test_it_detects_file_metadata": {
            "name": "test_it_detects_file_metadata",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {
                "name": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "node_type": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Optional[Dict[str, Any]]",
                    "Hashable"
                ],
                "mimetype": [
                    "int",
                    "Optional[bool]",
                    "Optional[recidiviz.common.constants.state.state_supervision_period.StateSupervisionLevel]",
                    "Iterable[str]",
                    "Optional[str]",
                    "str",
                    "float",
                    "Sequence"
                ],
                "extension": [
                    "int",
                    "Optional[bool]",
                    "Optional[recidiviz.common.constants.state.state_supervision_period.StateSupervisionLevel]",
                    "Iterable[str]",
                    "Optional[str]",
                    "str",
                    "float",
                    "Sequence"
                ],
                "num_children": [
                    "Sequence[str]",
                    "int",
                    "str",
                    "Optional[List[str]]"
                ]
            }
        },
        "test_it_detects_when_a_file_is_encrypted": {
            "name": "test_it_detects_when_a_file_is_encrypted",
            "location": 56,
            "return": [
                ""
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "expected_to_be_encrypted": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int",
                    "Dict[str, int]",
                    "Tuple[int, int]"
                ]
            }
        },
        "test_it_raises_a_value_error_for_a_file_name_that_does_not_exist_on_disk": {
            "name": "test_it_raises_a_value_error_for_a_file_name_that_does_not_exist_on_disk",
            "location": 62,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_raises_a_type_error_for_stream_not_read_in_bytes_mode": {
            "name": "test_it_raises_a_type_error_for_stream_not_read_in_bytes_mode",
            "location": 72,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_detects_when_a_file_is_empty": {
            "name": "test_it_detects_when_a_file_is_empty",
            "location": 84,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fables-master/tests/integration/test_it_extracts_files.py": {
        "test_zip_children_nodes_have_file_name_for_named_stream": {
            "name": "test_zip_children_nodes_have_file_name_for_named_stream",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_zip_children_nodes_have_file_name_for_nameless_stream": {
            "name": "test_zip_children_nodes_have_file_name_for_nameless_stream",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fables-master/tests/integration/test_it_parses_files.py": {
        "_it_parses_a_csv": {
            "name": "_it_parses_a_csv",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {
                "csv_name": [
                    "str",
                    "int",
                    "bool"
                ],
                "expected_df": [
                    "float",
                    "bool",
                    "str",
                    "numpy.ndarray",
                    "List[List[float]]",
                    "Optional[str]",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_it_parses_a_csv": {
            "name": "test_it_parses_a_csv",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_csv_with_only_a_header": {
            "name": "test_it_parses_a_csv_with_only_a_header",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_stream_parse_is_the_same_as_disk_parse": {
            "name": "test_stream_parse_is_the_same_as_disk_parse",
            "location": 60,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "_it_parses_an_excel_file_with_one_sheet": {
            "name": "_it_parses_an_excel_file_with_one_sheet",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {
                "excel_name": [
                    "str",
                    "Optional[str]"
                ],
                "expected_df": [
                    "float",
                    "List[float]",
                    "str",
                    "int"
                ],
                "passwords": [
                    "str"
                ]
            }
        },
        "test_it_parses_a_xlsx_with_one_sheet": {
            "name": "test_it_parses_a_xlsx_with_one_sheet",
            "location": 102,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsb_with_one_sheet": {
            "name": "test_it_parses_a_xlsb_with_one_sheet",
            "location": 107,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsb_with_only_a_header": {
            "name": "test_it_parses_a_xlsb_with_only_a_header",
            "location": 112,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsb_with_many_sheets": {
            "name": "test_it_parses_a_xlsb_with_many_sheets",
            "location": 118,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsx_with_many_sheets": {
            "name": "test_it_parses_a_xlsx_with_many_sheets",
            "location": 145,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsx_with_only_a_header": {
            "name": "test_it_parses_a_xlsx_with_only_a_header",
            "location": 172,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsx_with_only_one_cell_filled": {
            "name": "test_it_parses_a_xlsx_with_only_one_cell_filled",
            "location": 194,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xls_with_one_sheet": {
            "name": "test_it_parses_a_xls_with_one_sheet",
            "location": 216,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xls_with_many_sheets": {
            "name": "test_it_parses_a_xls_with_many_sheets",
            "location": 221,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "_validate_basic_csv_and_basic_xlsx_together": {
            "name": "_validate_basic_csv_and_basic_xlsx_together",
            "location": 248,
            "return": [
                ""
            ],
            "arguments": {
                "parse_results": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ],
                "child_names": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "test_it_parses_all_files_in_a_directory": {
            "name": "test_it_parses_all_files_in_a_directory",
            "location": 276,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "_it_parses_flat_files_in_a_basic_zip": {
            "name": "_it_parses_flat_files_in_a_basic_zip",
            "location": 291,
            "return": [
                ""
            ],
            "arguments": {
                "zip_file": [
                    "str"
                ],
                "zip_path": [
                    "str"
                ]
            }
        },
        "test_it_parses_flat_files_in_a_basic_zip": {
            "name": "test_it_parses_flat_files_in_a_basic_zip",
            "location": 302,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "_validate_side_xls_file": {
            "name": "_validate_side_xls_file",
            "location": 313,
            "return": [
                ""
            ],
            "arguments": {
                "xls_result": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "expected_name": [
                    "str"
                ]
            }
        },
        "test_it_parses_files_in_a_directory_inside_a_zip": {
            "name": "test_it_parses_files_in_a_directory_inside_a_zip",
            "location": 326,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_files_in_a_zip_in_a_zip": {
            "name": "test_it_parses_files_in_a_zip_in_a_zip",
            "location": 356,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_files_in_an_encrypted_zip_with_password": {
            "name": "test_it_parses_files_in_an_encrypted_zip_with_password",
            "location": 388,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_files_in_an_encrypted_xlsx": {
            "name": "test_it_parses_files_in_an_encrypted_xlsx",
            "location": 404,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_files_in_an_encrypted_xls": {
            "name": "test_it_parses_files_in_an_encrypted_xls",
            "location": 411,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_nested_encrypted_files": {
            "name": "test_it_parses_nested_encrypted_files",
            "location": 418,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_finds_no_tables_in_an_invalid_csv_plain_text_file": {
            "name": "test_it_finds_no_tables_in_an_invalid_csv_plain_text_file",
            "location": 455,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_finds_tables_in_a_valid_csv_plain_text_file": {
            "name": "test_it_finds_tables_in_a_valid_csv_plain_text_file",
            "location": 474,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_finds_no_tables_in_a_png_file": {
            "name": "test_it_finds_no_tables_in_a_png_file",
            "location": 493,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_raises_a_value_error_for_a_file_name_that_does_not_exist_on_disk": {
            "name": "test_it_raises_a_value_error_for_a_file_name_that_does_not_exist_on_disk",
            "location": 499,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_raises_a_type_error_for_stream_not_read_in_bytes_mode": {
            "name": "test_it_raises_a_type_error_for_stream_not_read_in_bytes_mode",
            "location": 508,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_creates_a_parse_error_for_malformed_csv": {
            "name": "test_it_creates_a_parse_error_for_malformed_csv",
            "location": 520,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_creates_a_parse_error_for_corrupt_file": {
            "name": "test_it_creates_a_parse_error_for_corrupt_file",
            "location": 539,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_removes_columns_that_have_no_headers_and_have_only_null_data_before_parsing": {
            "name": "test_it_removes_columns_that_have_no_headers_and_have_only_null_data_before_parsing",
            "location": 569,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ]
            }
        },
        "test_it_parses_a_xls_with_no_extension": {
            "name": "test_it_parses_a_xls_with_no_extension",
            "location": 593,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_xlsx_with_no_extension": {
            "name": "test_it_parses_a_xlsx_with_no_extension",
            "location": 598,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_files_in_a_zip_with_no_extension": {
            "name": "test_it_parses_files_in_a_zip_with_no_extension",
            "location": 603,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_csv_with_missing_opening_rows": {
            "name": "test_it_parses_a_csv_with_missing_opening_rows",
            "location": 609,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_semicolon_seperated_csv": {
            "name": "test_it_parses_a_semicolon_seperated_csv",
            "location": 622,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_a_tab_seperated_csv": {
            "name": "test_it_parses_a_tab_seperated_csv",
            "location": 633,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_parses_files_with_null_opening_rows": {
            "name": "test_it_parses_files_with_null_opening_rows",
            "location": 651,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "test_callable": [
                    "str",
                    "List[str]"
                ],
                "expected_df": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "test_it_parses_files_with_null_leading_and_trailing_cols": {
            "name": "test_it_parses_files_with_null_leading_and_trailing_cols",
            "location": 684,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "test_callable": [
                    "str",
                    "Sequence[str]",
                    "Optional[str]"
                ],
                "expected_df": [
                    "str",
                    "Sequence[str]",
                    "Optional[str]"
                ]
            }
        },
        "test_it_parses_files_with_null_middle_cols": {
            "name": "test_it_parses_files_with_null_middle_cols",
            "location": 721,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "test_callable": [
                    "str",
                    "Sequence[str]",
                    "Optional[str]"
                ],
                "expected_df": [
                    "str",
                    "Sequence[str]",
                    "Optional[str]"
                ]
            }
        },
        "test_it_parses_files_with_null_middle_rows": {
            "name": "test_it_parses_files_with_null_middle_rows",
            "location": 738,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "test_callable": [
                    "str",
                    "List[str]"
                ],
                "expected_df": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "test_it_parses_files_with_noisy_opening_rows": {
            "name": "test_it_parses_files_with_noisy_opening_rows",
            "location": 756,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "test_callable": [
                    "str",
                    "List[str]"
                ],
                "expected_df": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "test_it_parses_csv_files_with_a_lot_of_json": {
            "name": "test_it_parses_csv_files_with_a_lot_of_json",
            "location": 775,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str",
                    "Optional[str]"
                ],
                "test_callable": [
                    "str",
                    "Sequence[str]"
                ],
                "expected_df": [
                    "str",
                    "Sequence[str]"
                ]
            }
        },
        "test_it_parses_files_using_pandas_kwargs": {
            "name": "test_it_parses_files_using_pandas_kwargs",
            "location": 789,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "pandas_kwargs": [
                    "str",
                    "List[Tuple[str, Any]]"
                ]
            }
        },
        "test_force_numeric": {
            "name": "test_force_numeric",
            "location": 865,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str",
                    "Union[None, str, List[str]]",
                    "Optional[str]",
                    "Tuple[str, int]"
                ],
                "force_numeric": [
                    "str",
                    "int"
                ],
                "pandas_kwargs": [
                    "str",
                    "int"
                ],
                "expected_df": [
                    "float",
                    "Optional[Dict[int, int]]"
                ]
            }
        }
    },
    "fables-master/tests/integration/__init__.py": {},
    "fables-master/tests/unit/test_api.py": {
        "test_check_file_size_detects_when_file_is_too_large": {
            "name": "test_check_file_size_detects_when_file_is_too_large",
            "location": 18,
            "return": [
                ""
            ],
            "arguments": {
                "name": [
                    "str",
                    "int"
                ],
                "size": [
                    "str",
                    "int",
                    "MutableMapping"
                ],
                "expected_to_be_too_big": [
                    "str",
                    "Tuple[int, int, int, int]",
                    "int"
                ],
                "monkeypatch": [
                    "str",
                    "int"
                ]
            }
        },
        "test_detect_raises_a_value_error_when_file_is_too_large": {
            "name": "test_detect_raises_a_value_error_when_file_is_too_large",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {
                "monkeypatch": []
            }
        },
        "test_detect_detects_when_stream_is_too_large": {
            "name": "test_detect_detects_when_stream_is_too_large",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {
                "size": [
                    "Callable",
                    "bool",
                    "tests.testmodels.Signals",
                    "list",
                    "str"
                ],
                "expected_to_be_too_big": [
                    "Set[Hashable]",
                    "Hashable",
                    "list"
                ],
                "monkeypatch": [
                    "str",
                    "bytes"
                ]
            }
        },
        "test_detect_raises_a_value_error_when_stream_is_too_large": {
            "name": "test_detect_raises_a_value_error_when_stream_is_too_large",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {
                "monkeypatch": [
                    "tests.test_util.aiohttp.AiohttpClientMocker"
                ]
            }
        },
        "_it_raises_a_value_error_when_passwords_is_not_a_dict": {
            "name": "_it_raises_a_value_error_when_passwords_is_not_a_dict",
            "location": 88,
            "return": [
                ""
            ],
            "arguments": {
                "callable": [
                    "io.BytesIO",
                    "int",
                    "IO[bytes]",
                    "TextIO"
                ]
            }
        },
        "test_detect_raises_a_value_error_when_passwords_is_not_a_dict": {
            "name": "test_detect_raises_a_value_error_when_passwords_is_not_a_dict",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_parse_raises_a_value_error_when_passwords_is_not_a_dict": {
            "name": "test_parse_raises_a_value_error_when_passwords_is_not_a_dict",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "_it_raises_a_value_error_when_password_is_not_a_str": {
            "name": "_it_raises_a_value_error_when_password_is_not_a_str",
            "location": 104,
            "return": [
                ""
            ],
            "arguments": {
                "callable": [
                    "io.BytesIO",
                    "int",
                    "IO[bytes]",
                    "TextIO"
                ]
            }
        },
        "test_detect_raises_a_value_error_when_password_is_not_a_str": {
            "name": "test_detect_raises_a_value_error_when_password_is_not_a_str",
            "location": 112,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_parse_raises_a_value_error_when_password_is_not_a_str": {
            "name": "test_parse_raises_a_value_error_when_password_is_not_a_str",
            "location": 116,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_parse_raises_value_error_when_no_io_or_tree_is_given": {
            "name": "test_parse_raises_value_error_when_no_io_or_tree_is_given",
            "location": 120,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_detect_accepts_a_stream_file_name": {
            "name": "test_detect_accepts_a_stream_file_name",
            "location": 130,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_parse_accepts_a_stream_file_name": {
            "name": "test_parse_accepts_a_stream_file_name",
            "location": 137,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_node_stream_property_returns_at_byte_0_after_detect": {
            "name": "test_node_stream_property_returns_at_byte_0_after_detect",
            "location": 146,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_node_stream_property_returns_at_byte_0_after_parse": {
            "name": "test_node_stream_property_returns_at_byte_0_after_parse",
            "location": 154,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "MockOSStatResult.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "size": [
                    "int",
                    "str",
                    "bytes"
                ]
            }
        },
        "test_check_file_size_detects_when_file_is_too_large.mock_stat": {
            "name": "mock_stat",
            "location": 21,
            "return": [],
            "arguments": {
                "name": []
            }
        },
        "test_detect_raises_a_value_error_when_file_is_too_large.mock_exists": {
            "name": "mock_exists",
            "location": 35,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "test_detect_raises_a_value_error_when_file_is_too_large.mock_stat": {
            "name": "mock_stat",
            "location": 42,
            "return": [
                "str",
                "tests.test_util.aiohttp.AiohttpClientMocker",
                "Optional[str]",
                "io.BytesIO"
            ],
            "arguments": {
                "name": [
                    "str"
                ]
            }
        },
        "test_detect_detects_when_stream_is_too_large.mock_tell": {
            "name": "mock_tell",
            "location": 61,
            "return": [],
            "arguments": {}
        },
        "test_detect_raises_a_value_error_when_stream_is_too_large.mock_tell": {
            "name": "mock_tell",
            "location": 74,
            "return": [
                "str",
                "bool",
                "Set[str]"
            ],
            "arguments": {}
        }
    },
    "fables-master/tests/unit/test_table.py": {
        "test_table_str": {
            "name": "test_table_str",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fables-master/tests/unit/test_tree.py": {
        "test_extension_from_name": {
            "name": "test_extension_from_name",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "expected_extension": [
                    "str"
                ]
            }
        },
        "test_stream_manager_raises_runtime_error_for_only_none_args": {
            "name": "test_stream_manager_raises_runtime_error_for_only_none_args",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_it_assigns_the_right_password": {
            "name": "test_it_assigns_the_right_password",
            "location": 91,
            "return": [
                ""
            ],
            "arguments": {
                "name": [
                    "str",
                    "Optional[str]"
                ],
                "passwords": [
                    "str",
                    "Optional[str]"
                ],
                "expected_password": [
                    "str",
                    "bool",
                    "int",
                    "bytes"
                ]
            }
        },
        "test_add_password_to_node": {
            "name": "test_add_password_to_node",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_node_str": {
            "name": "test_node_str",
            "location": 102,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_mimetype_from_stream_for_empty_stream": {
            "name": "test_mimetype_from_stream_for_empty_stream",
            "location": 110,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fables-master/tests/unit/__init__.py": {}
}
{
    "fklearn-master/setup.py": {
        "requirements_from_pip": {
            "name": "requirements_from_pip",
            "location": 11,
            "return": [
                "int",
                "str",
                "list",
                "List[str]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        }
    },
    "fklearn-master/docs/source/conf.py": {},
    "fklearn-master/src/fklearn/common_docstrings.py": {
        "learner_pred_fn_docstring": {
            "name": "learner_pred_fn_docstring",
            "location": 2,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "f_name": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "shap": [
                    "str",
                    "dict",
                    "type",
                    "Tuple[str, int]",
                    "Dict[str, Any]"
                ]
            }
        },
        "learner_return_docstring": {
            "name": "learner_return_docstring",
            "location": 31,
            "return": [
                "int",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "model_name": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/version.py": {
        "version": {
            "name": "version",
            "location": 4,
            "return": [
                "str",
                "Optional[str]",
                "Iterable[str]",
                "bytes"
            ],
            "arguments": {}
        }
    },
    "fklearn-master/src/fklearn/__init__.py": {},
    "fklearn-master/src/fklearn/causal/debias.py": {
        "debias_with_regression_formula": {
            "name": "debias_with_regression_formula",
            "location": 15,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "List[Tuple[int, int]]"
                ],
                "treatment_column": [
                    "float",
                    "bool",
                    "str",
                    "int"
                ],
                "outcome_column": [
                    "float",
                    "bool",
                    "str",
                    "int"
                ],
                "confounder_formula": [
                    "float",
                    "bool",
                    "str",
                    "int"
                ],
                "suffix": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "List[Tuple[int, int]]"
                ],
                "denoise": [
                    "float",
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "debias_with_regression": {
            "name": "debias_with_regression",
            "location": 69,
            "return": [
                "int",
                "float"
            ],
            "arguments": {
                "df": [
                    "int",
                    "bool",
                    "Union[\"SAONegotiator\", Collection[\"SAONegotiator\"]]",
                    "List[int]",
                    "Optional[float]"
                ],
                "treatment_column": [
                    "pandas.DataFrame",
                    "int",
                    "numpy.ndarray",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "outcome_column": [
                    "pandas.DataFrame",
                    "int",
                    "numpy.ndarray",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "confounder_columns": [
                    "int",
                    "bool",
                    "Union[\"SAONegotiator\", Collection[\"SAONegotiator\"]]",
                    "List[int]",
                    "Optional[float]"
                ],
                "suffix": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "List[int]",
                    "List[Tuple[int, int]]",
                    "Dict[str, Dict[str, str]]"
                ],
                "denoise": [
                    "pandas.DataFrame",
                    "int",
                    "numpy.ndarray",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        },
        "debias_with_fixed_effects": {
            "name": "debias_with_fixed_effects",
            "location": 124,
            "return": [
                "int",
                "numpy.ndarray",
                "Optional[int]",
                "List[int]",
                "float"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "int",
                    "Tuple[float, float]",
                    "Callable[[str, str], float]",
                    "set"
                ],
                "treatment_column": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "outcome_column": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "confounder_columns": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "suffix": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "denoise": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "debias_with_double_ml": {
            "name": "debias_with_double_ml",
            "location": 175,
            "return": [
                "str",
                "bool",
                "Optional[int]",
                "Optional[bool]"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "Callable[[str, str], float]",
                    "Optional[int]"
                ],
                "treatment_column": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "outcome_column": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "confounder_columns": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "ml_regressor": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "extra_params": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "cv": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "suffix": [
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "Callable[[str, str], float]",
                    "Optional[int]"
                ],
                "denoise": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "seed": [
                    "int",
                    "float",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "debias_with_regression_formula.get_resid": {
            "name": "get_resid",
            "location": 61,
            "return": [
                "int",
                "str",
                "bool",
                "Sequence[int]",
                "bytes"
            ],
            "arguments": {
                "col_to_debias": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "debias_with_fixed_effects.debias_column": {
            "name": "debias_column",
            "location": 167,
            "return": [
                "numpy.ndarray",
                "bool",
                "float",
                "\"Cash\""
            ],
            "arguments": {
                "c": [
                    "Iterable['cirq.Qid']",
                    "List['cirq.Qid']",
                    "numpy.ndarray"
                ]
            }
        },
        "debias_with_double_ml.get_cv_resid": {
            "name": "get_cv_resid",
            "location": 241,
            "return": [
                "dict",
                "str",
                "List[Dict[str, Any]]",
                "int"
            ],
            "arguments": {
                "col_to_debias": [
                    "float",
                    "str",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/causal/effects.py": {
        "_apply_effect": {
            "name": "_apply_effect",
            "location": 9,
            "return": [
                "int",
                "Optional[int]",
                "str",
                "List[int]"
            ],
            "arguments": {
                "evaluator": [
                    "bool",
                    "str",
                    "Optional[float]"
                ],
                "df": [
                    "bool",
                    "str",
                    "Optional[float]"
                ],
                "treatment_column": [
                    "bool",
                    "str",
                    "Optional[float]"
                ],
                "outcome_column": [
                    "bool",
                    "str",
                    "Optional[float]"
                ]
            }
        },
        "linear_effect": {
            "name": "linear_effect",
            "location": 17,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "treatment_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "outcome_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        },
        "spearman_effect": {
            "name": "spearman_effect",
            "location": 42,
            "return": [
                "bytearray",
                "List[int]",
                "float",
                "str"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "treatment_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "outcome_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        },
        "pearson_effect": {
            "name": "pearson_effect",
            "location": 68,
            "return": [
                "bytearray",
                "List[int]",
                "float",
                "str"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "treatment_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "outcome_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        },
        "exponential_coefficient_effect": {
            "name": "exponential_coefficient_effect",
            "location": 93,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "treatment_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "outcome_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        },
        "logistic_coefficient_effect": {
            "name": "logistic_coefficient_effect",
            "location": 120,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "treatment_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "outcome_column": [
                    "pandas.DataFrame",
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/causal/__init__.py": {},
    "fklearn-master/src/fklearn/causal/cate_learning/double_machine_learning.py": {
        "_cv_estimate": {
            "name": "_cv_estimate",
            "location": 18,
            "return": [
                "str",
                "float",
                "bytearray"
            ],
            "arguments": {
                "model": [
                    "str",
                    "bool"
                ],
                "train_data": [
                    "Tuple[str, Any]",
                    "dict"
                ],
                "features": [
                    "raiden.utils.BlockNumber",
                    "str",
                    "Tuple[str]",
                    "int"
                ],
                "y": [
                    "str",
                    "bool"
                ],
                "n_splits": [
                    "bool",
                    "int",
                    "Union[Callable, str]",
                    "slice",
                    "bytes"
                ]
            }
        },
        "non_parametric_double_ml_learner": {
            "name": "non_parametric_double_ml_learner",
            "location": 38,
            "return": [
                "str",
                "bool",
                "List[dict]",
                "dict",
                "float"
            ],
            "arguments": {
                "df": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "feature_columns": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "treatment_column": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "outcome_column": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "debias_model": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "debias_feature_columns": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "denoise_model": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "denoise_feature_columns": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "final_model": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "final_model_feature_columns": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "prediction_column": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "cv_splits": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "encode_extra_cols": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Optional[float]"
                ]
            }
        },
        "non_parametric_double_ml_learner.p": {
            "name": "p",
            "location": 140,
            "return": [
                "int",
                "Sequence['cirq.Qid']",
                "Callable"
            ],
            "arguments": {
                "new_df": [
                    "pandas.DataFrame",
                    "float"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/causal/cate_learning/__init__.py": {},
    "fklearn-master/src/fklearn/causal/validation/auc.py": {
        "area_under_the_cumulative_effect_curve": {
            "name": "area_under_the_cumulative_effect_curve",
            "location": 10,
            "return": [
                "Callable",
                "Dict[str, Any]"
            ],
            "arguments": {
                "df": [
                    "int",
                    "float",
                    "Optional[float]"
                ],
                "treatment": [
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ],
                "outcome": [
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ],
                "prediction": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "min_rows": [
                    "int",
                    "str"
                ],
                "steps": [
                    "int",
                    "list"
                ],
                "effect_fn": [
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ]
            }
        },
        "area_under_the_cumulative_gain_curve": {
            "name": "area_under_the_cumulative_gain_curve",
            "location": 64,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "df": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "treatment": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "outcome": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "prediction": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "min_rows": [
                    "int",
                    "str"
                ],
                "steps": [
                    "int",
                    "list"
                ],
                "effect_fn": [
                    "Optional[float]",
                    "float",
                    "int"
                ]
            }
        },
        "area_under_the_relative_cumulative_gain_curve": {
            "name": "area_under_the_relative_cumulative_gain_curve",
            "location": 117,
            "return": [
                "int",
                "str",
                "Tuple[Any, Any, Any]"
            ],
            "arguments": {
                "df": [
                    "int",
                    "float",
                    "Optional[float]"
                ],
                "treatment": [
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ],
                "outcome": [
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ],
                "prediction": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "min_rows": [
                    "int",
                    "str"
                ],
                "steps": [
                    "int",
                    "list"
                ],
                "effect_fn": [
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/causal/validation/cate.py": {
        "_validate_test_and_control_groups": {
            "name": "_validate_test_and_control_groups",
            "location": 8,
            "return": [
                "str",
                "pandas.DataFrame",
                "Optional[int]"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "dict",
                    "list"
                ],
                "group_column": [
                    "str",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "dict",
                    "list"
                ],
                "control_group_name": [
                    "str",
                    "float"
                ]
            }
        },
        "cate_mean_by_bin": {
            "name": "cate_mean_by_bin",
            "location": 48,
            "return": [
                "int"
            ],
            "arguments": {
                "test_data": [
                    "bool",
                    "str"
                ],
                "group_column": [
                    "bool",
                    "str"
                ],
                "control_group_name": [
                    "bool",
                    "str"
                ],
                "bin_column": [
                    "str",
                    "bool",
                    "int"
                ],
                "n_bins": [
                    "str",
                    "bool",
                    "int"
                ],
                "allow_dropped_bins": [
                    "Dict[str, Tuple[str, int, int]]",
                    "float",
                    "Dict[str, Tuple[str, str, Any]]",
                    "int",
                    "bool",
                    "dict"
                ],
                "prediction_column": [],
                "target_column": []
            }
        },
        "cate_mean_by_bin_meta_evaluator": {
            "name": "cate_mean_by_bin_meta_evaluator",
            "location": 120,
            "return": [
                "str",
                "dict",
                "bytes",
                "float",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "int",
                    "str",
                    "float"
                ],
                "group_column": [
                    "int",
                    "str",
                    "float"
                ],
                "control_group_name": [
                    "int",
                    "str",
                    "float"
                ],
                "bin_column": [
                    "int",
                    "str",
                    "float"
                ],
                "n_bins": [
                    "int",
                    "str",
                    "float"
                ],
                "allow_dropped_bins": [
                    "int",
                    "str",
                    "float"
                ],
                "inner_evaluator": [
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "eval_name": [
                    "Optional[str]",
                    "int",
                    "Optional[int]",
                    "bool",
                    "Optional[Mapping[str, str]]",
                    "Optional[bool]"
                ],
                "prediction_column": [
                    "int",
                    "str",
                    "float"
                ],
                "target_column": [
                    "int",
                    "str",
                    "float"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/causal/validation/curves.py": {
        "effect_by_segment": {
            "name": "effect_by_segment",
            "location": 12,
            "return": [
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Callable",
                    "str"
                ],
                "treatment": [
                    "int",
                    "Callable",
                    "str"
                ],
                "outcome": [
                    "int",
                    "Callable",
                    "str"
                ],
                "prediction": [
                    "int",
                    "Callable",
                    "str"
                ],
                "segments": [
                    "int",
                    "Callable",
                    "str"
                ],
                "effect_fn": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "cumulative_effect_curve": {
            "name": "cumulative_effect_curve",
            "location": 56,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "Optional[float]",
                    "bool",
                    "int"
                ],
                "treatment": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "pandas.DataFrame"
                ],
                "outcome": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "pandas.DataFrame"
                ],
                "prediction": [
                    "int",
                    "bool"
                ],
                "min_rows": [
                    "int",
                    "list",
                    "str"
                ],
                "steps": [
                    "int",
                    "list",
                    "str"
                ],
                "effect_fn": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "pandas.DataFrame"
                ]
            }
        },
        "cumulative_gain_curve": {
            "name": "cumulative_gain_curve",
            "location": 104,
            "return": [
                "int",
                "numpy.ndarray",
                "float"
            ],
            "arguments": {
                "df": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "treatment": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "outcome": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "prediction": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "min_rows": [
                    "int",
                    "numpy.ndarray",
                    "list"
                ],
                "steps": [
                    "int",
                    "numpy.ndarray",
                    "list"
                ],
                "effect_fn": [
                    "Optional[float]",
                    "float",
                    "int"
                ]
            }
        },
        "relative_cumulative_gain_curve": {
            "name": "relative_cumulative_gain_curve",
            "location": 156,
            "return": [
                "float",
                "int",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Optional[float]"
                ],
                "treatment": [
                    "numpy.ndarray",
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ],
                "outcome": [
                    "numpy.ndarray",
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ],
                "prediction": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "min_rows": [
                    "int",
                    "numpy.ndarray",
                    "list"
                ],
                "steps": [
                    "int",
                    "numpy.ndarray",
                    "list"
                ],
                "effect_fn": [
                    "numpy.ndarray",
                    "float",
                    "tuple",
                    "Dict[str, Any]",
                    "List[str]",
                    "int"
                ]
            }
        },
        "effect_curves": {
            "name": "effect_curves",
            "location": 210,
            "return": [
                "str",
                "bytearray",
                "bytes",
                "int"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "treatment": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "outcome": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "prediction": [
                    "Optional[float]",
                    "float",
                    "int"
                ],
                "min_rows": [
                    "Optional[Union[int, Any]]",
                    "int",
                    "List[int]"
                ],
                "steps": [
                    "Optional[Union[int, Any]]",
                    "int",
                    "List[int]"
                ],
                "effect_fn": [
                    "Optional[float]",
                    "float",
                    "int"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/causal/validation/__init__.py": {},
    "fklearn-master/src/fklearn/data/datasets.py": {
        "make_tutorial_data": {
            "name": "make_tutorial_data",
            "location": 8,
            "return": [
                "str",
                "int",
                "bytes",
                "Generator"
            ],
            "arguments": {
                "n": [
                    "int",
                    "List[List[int]]"
                ]
            }
        },
        "make_confounded_data": {
            "name": "make_confounded_data",
            "location": 46,
            "return": [
                "str",
                "int",
                "bytes",
                "Generator"
            ],
            "arguments": {
                "n": [
                    "int",
                    "Sequence[Any]",
                    "Union[float, int]"
                ]
            }
        },
        "make_confounded_data.get_severity": {
            "name": "get_severity",
            "location": 70,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int"
                ]
            }
        },
        "make_confounded_data.get_treatment": {
            "name": "get_treatment",
            "location": 74,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int"
                ]
            }
        },
        "make_confounded_data.get_recovery": {
            "name": "get_recovery",
            "location": 79,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "list",
                    "List[int]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/data/__init__.py": {},
    "fklearn-master/src/fklearn/metrics/pd_extractors.py": {
        "evaluator_extractor": {
            "name": "evaluator_extractor",
            "location": 11,
            "return": [
                "str",
                "Optional[str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "result": [
                    "str",
                    "Optional[str]",
                    "Optional[object]",
                    "Dict[str, Any]"
                ],
                "evaluator_name": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "combined_evaluator_extractor": {
            "name": "combined_evaluator_extractor",
            "location": 17,
            "return": [
                "str",
                "tuple",
                "int",
                "Tuple[float]"
            ],
            "arguments": {
                "result": [
                    "List[str]",
                    "list",
                    "List[Union[int, Any]]",
                    "List[int]",
                    "int",
                    "str",
                    "bool"
                ],
                "base_extractors": [
                    "List[str]",
                    "list",
                    "List[Union[int, Any]]",
                    "List[int]",
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "split_evaluator_extractor_iteration": {
            "name": "split_evaluator_extractor_iteration",
            "location": 22,
            "return": [
                "str",
                "Dict[str, str]",
                "Optional[str]",
                "Dict[int, Set[str]]",
                "Union[str, int]"
            ],
            "arguments": {
                "split_value": [
                    "str",
                    "dict"
                ],
                "result": [
                    "Dict[str, str]",
                    "bool",
                    "str",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "List[Dict[str, Any]]"
                ],
                "split_col": [
                    "str",
                    "Optional[str]",
                    "Sequence[str]",
                    "List[str]"
                ],
                "base_extractor": [
                    "Dict[str, str]",
                    "bool",
                    "str",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "List[Dict[str, Any]]"
                ],
                "eval_name": [
                    "Optional[str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[List[str]]",
                    "Dict[Optional[str], str]",
                    "str"
                ]
            }
        },
        "split_evaluator_extractor": {
            "name": "split_evaluator_extractor",
            "location": 33,
            "return": [
                "str",
                "dict",
                "bool"
            ],
            "arguments": {
                "result": [
                    "bool",
                    "str",
                    "Optional[int]"
                ],
                "split_col": [
                    "bool",
                    "str",
                    "Optional[int]"
                ],
                "split_values": [
                    "bool",
                    "str",
                    "Optional[int]"
                ],
                "base_extractor": [
                    "bool",
                    "str",
                    "Optional[int]"
                ],
                "eval_name": [
                    "bool",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "temporal_split_evaluator_extractor": {
            "name": "temporal_split_evaluator_extractor",
            "location": 41,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "result": [
                    "str",
                    "dict",
                    "int",
                    "Dict[str, str]",
                    "Optional[str]"
                ],
                "time_col": [
                    "str",
                    "Optional[str]",
                    "bytes"
                ],
                "base_extractor": [
                    "str",
                    "int",
                    "Optional[str]",
                    "List[str]",
                    "Optional[Mapping[str, Any]]",
                    "List[int]",
                    "Any"
                ],
                "time_format": [
                    "str",
                    "Optional[str]"
                ],
                "eval_name": [
                    "str",
                    "bool",
                    "Dict[str, str]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "learning_curve_evaluator_extractor": {
            "name": "learning_curve_evaluator_extractor",
            "location": 61,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "result": [
                    "str",
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "bool",
                    "bytes"
                ],
                "base_extractor": [
                    "str",
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "bool",
                    "bytes"
                ]
            }
        },
        "reverse_learning_curve_evaluator_extractor": {
            "name": "reverse_learning_curve_evaluator_extractor",
            "location": 66,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "result": [
                    "Callable[..., Awaitable[None]]",
                    "pandas.DataFrame"
                ],
                "base_extractor": [
                    "Callable[..., Awaitable[None]]",
                    "pandas.DataFrame"
                ]
            }
        },
        "stability_curve_evaluator_extractor": {
            "name": "stability_curve_evaluator_extractor",
            "location": 71,
            "return": [
                "str",
                "bytearray",
                "bytes",
                "slice"
            ],
            "arguments": {
                "result": [
                    "str",
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "bool",
                    "bytes"
                ],
                "base_extractor": [
                    "str",
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "bool",
                    "bytes"
                ]
            }
        },
        "repeat_split_log": {
            "name": "repeat_split_log",
            "location": 76,
            "return": [
                "str",
                "List[Dict]",
                "list",
                "tuple",
                "Optional[List[str]]",
                "List[str]"
            ],
            "arguments": {
                "split_log": [
                    "Optional[int]",
                    "list",
                    "IO",
                    "List[Tuple[bool, str]]"
                ],
                "results_len": [
                    "bytes",
                    "str",
                    "List[int]",
                    "dict",
                    "List[str]",
                    "list"
                ]
            }
        },
        "extract_base_iteration": {
            "name": "extract_base_iteration",
            "location": 86,
            "return": [
                "bool"
            ],
            "arguments": {
                "result": [
                    "dict",
                    "List[List]",
                    "type",
                    "Mapping[Any, Any]",
                    "Dict[str, Any]"
                ],
                "extractor": [
                    "List[str]",
                    "List[Type]",
                    "list",
                    "bool",
                    "int"
                ]
            }
        },
        "extract": {
            "name": "extract",
            "location": 99,
            "return": [
                "List[float]",
                "int",
                "Mapping[str, Any]",
                "List[int]",
                "bool",
                "Sequence['cirq.Qid']",
                "Sequence[str]",
                "str"
            ],
            "arguments": {
                "validator_results": [
                    "int",
                    "str",
                    "List[Tuple[float, Any]]"
                ],
                "extractor": [
                    "int",
                    "str",
                    "List[Tuple[float, Any]]"
                ]
            }
        },
        "extract_lc": {
            "name": "extract_lc",
            "location": 104,
            "return": [
                "int",
                "str",
                "List[str]",
                "List[dict]",
                "bool"
            ],
            "arguments": {
                "validator_results": [
                    "dict",
                    "Awaitable[T]",
                    "List[int]"
                ],
                "extractor": [
                    "dict",
                    "Awaitable[T]",
                    "List[int]"
                ]
            }
        },
        "extract_reverse_lc": {
            "name": "extract_reverse_lc",
            "location": 109,
            "return": [
                "int",
                "str",
                "List[str]",
                "List[dict]",
                "bool"
            ],
            "arguments": {
                "validator_results": [
                    "List[int]",
                    "numpy.ndarray",
                    "Optional[int]",
                    "dict",
                    "bool"
                ],
                "extractor": [
                    "List[int]",
                    "numpy.ndarray",
                    "Optional[int]",
                    "dict",
                    "bool"
                ]
            }
        },
        "extract_sc": {
            "name": "extract_sc",
            "location": 114,
            "return": [
                "int",
                "str",
                "List[str]",
                "List[dict]",
                "bool"
            ],
            "arguments": {
                "validator_results": [
                    "dict",
                    "Awaitable[T]",
                    "List[int]"
                ],
                "extractor": [
                    "dict",
                    "Awaitable[T]",
                    "List[int]"
                ]
            }
        },
        "extract_param_tuning_iteration": {
            "name": "extract_param_tuning_iteration",
            "location": 119,
            "return": [
                "Optional[T]",
                "Callable",
                "set"
            ],
            "arguments": {
                "iteration": [
                    "Optional[str]",
                    "bool",
                    "Optional[int]",
                    "bytes",
                    "str"
                ],
                "tuning_log": [
                    "Optional[str]",
                    "bool",
                    "Optional[int]",
                    "bytes",
                    "str"
                ],
                "base_extractor": [
                    "numpy.ndarray",
                    "str",
                    "List[str]",
                    "int",
                    "bool"
                ],
                "model_learner_name": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "int"
                ]
            }
        },
        "extract_tuning": {
            "name": "extract_tuning",
            "location": 125,
            "return": [
                "str",
                "bytes",
                "int"
            ],
            "arguments": {
                "tuning_log": [
                    "str",
                    "pandas.DataFrame"
                ],
                "base_extractor": [
                    "str"
                ],
                "model_learner_name": [
                    "str"
                ]
            }
        },
        "permutation_extractor": {
            "name": "permutation_extractor",
            "location": 132,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "results": [
                    "Mapping[str, Any]",
                    "str",
                    "Dict[str, Any]",
                    "Type[object]",
                    "Mapping[str, str]",
                    "dict"
                ],
                "base_extractor": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/metrics/__init__.py": {},
    "fklearn-master/src/fklearn/preprocessing/rebalancing.py": {
        "rebalance_by_categorical": {
            "name": "rebalance_by_categorical",
            "location": 6,
            "return": [
                "bytearray",
                "List[int]",
                "float",
                "str"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "Optional[Any]",
                    "Generator",
                    "Optional[bool]",
                    "float",
                    "bool"
                ],
                "categ_column": [
                    "int",
                    "Optional[Any]",
                    "Generator",
                    "Optional[bool]",
                    "float",
                    "bool"
                ],
                "max_lines_by_categ": [
                    "int",
                    "bool",
                    "List[str]",
                    "float"
                ],
                "seed": [
                    "int",
                    "bool"
                ]
            }
        },
        "rebalance_by_continuous": {
            "name": "rebalance_by_continuous",
            "location": 41,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "str",
                    "pandas.DataFrame"
                ],
                "continuous_column": [
                    "int",
                    "str",
                    "pandas.DataFrame"
                ],
                "buckets": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Union[float, str]",
                    "bool"
                ],
                "max_lines_by_categ": [
                    "int",
                    "str",
                    "pandas.DataFrame"
                ],
                "by_quantile": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Union[float, str]",
                    "bool"
                ],
                "seed": [
                    "int",
                    "str",
                    "pandas.DataFrame"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/preprocessing/schema.py": {
        "feature_duplicator": {
            "name": "feature_duplicator",
            "location": 11,
            "return": [
                "Callable",
                "str",
                "Tuple[Any, Any, Any]",
                "list"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "int",
                    "dict",
                    "Tuple[str]"
                ],
                "columns_to_duplicate": [
                    "str",
                    "bool",
                    "list",
                    "tuple",
                    "Callable"
                ],
                "columns_mapping": [
                    "str",
                    "bool",
                    "list",
                    "tuple",
                    "Callable"
                ],
                "prefix": [
                    "str",
                    "bool",
                    "list",
                    "tuple",
                    "Callable"
                ],
                "suffix": [
                    "str",
                    "bool",
                    "list",
                    "tuple",
                    "Callable"
                ]
            }
        },
        "column_duplicatable": {
            "name": "column_duplicatable",
            "location": 83,
            "return": [
                "int",
                "deque",
                "bool"
            ],
            "arguments": {
                "columns_to_bind": [
                    "int",
                    "bool",
                    "str",
                    "List[int]",
                    "Mapping[str, str]"
                ]
            }
        },
        "feature_duplicator.p": {
            "name": "p",
            "location": 64,
            "return": [
                "int",
                "Callable",
                "Sequence['cirq.Qid']"
            ],
            "arguments": {
                "new_df": [
                    "str"
                ]
            }
        },
        "column_duplicatable._decorator": {
            "name": "_decorator",
            "location": 96,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "child": [
                    "str",
                    "IO",
                    "float",
                    "bytes"
                ]
            }
        },
        "column_duplicatable._decorator._init": {
            "name": "_init",
            "location": 99,
            "return": [
                "int",
                "bool",
                "apistar.types.RouteConfig",
                "float"
            ],
            "arguments": {}
        }
    },
    "fklearn-master/src/fklearn/preprocessing/splitting.py": {
        "time_split_dataset": {
            "name": "time_split_dataset",
            "location": 13,
            "return": [
                "bool",
                "OrderedDict",
                "Dict[int, dict]",
                "dict",
                "Optional[List[str]]"
            ],
            "arguments": {
                "dataset": [
                    "Optional[str]",
                    "str"
                ],
                "train_start_date": [
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "train_end_date": [
                    "fklearn.types.DateType"
                ],
                "holdout_end_date": [
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "time_column": [
                    "Optional[str]",
                    "str"
                ],
                "holdout_start_date": [
                    "fklearn.types.DateType"
                ]
            }
        },
        "space_time_split_dataset": {
            "name": "space_time_split_dataset",
            "location": 72,
            "return": [
                "str",
                "int",
                "List[str]",
                "Set[str]",
                "bool",
                "pandas.DataFrame",
                "set"
            ],
            "arguments": {
                "dataset": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame"
                ],
                "train_start_date": [
                    "fklearn.types.DateType",
                    "Sequence[str]",
                    "pandas.DataFrame"
                ],
                "train_end_date": [
                    "fklearn.types.DateType"
                ],
                "holdout_end_date": [
                    "fklearn.types.DateType",
                    "Sequence[str]",
                    "pandas.DataFrame"
                ],
                "split_seed": [
                    "int",
                    "bool",
                    "List[str]",
                    "pandas.DataFrame",
                    "str"
                ],
                "space_holdout_percentage": [
                    "Tuple[int, int]",
                    "numpy.ndarray",
                    "int",
                    "str",
                    "List[str]"
                ],
                "space_column": [
                    "float",
                    "str",
                    "int",
                    "Iterable[int]"
                ],
                "time_column": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame"
                ],
                "holdout_space": [
                    "numpy.ndarray",
                    "float",
                    "Optional[str]",
                    "Optional[bytes]",
                    "int"
                ],
                "holdout_start_date": [
                    "fklearn.types.DateType"
                ]
            }
        },
        "stratified_split_dataset": {
            "name": "stratified_split_dataset",
            "location": 179,
            "return": [
                "BaseException",
                "Tuple[int, int]"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "bytes",
                    "List[Tuple[int, int]]",
                    "Tuple[int, int]"
                ],
                "target_column": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Dict[str, int]"
                ],
                "test_size": [
                    "int",
                    "Optional[Sequence[str]]",
                    "bool"
                ],
                "random_state": [
                    "int",
                    "Optional[Sequence[str]]",
                    "bool"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/preprocessing/__init__.py": {},
    "fklearn-master/src/fklearn/training/calibration.py": {
        "isotonic_calibration_learner": {
            "name": "isotonic_calibration_learner",
            "location": 14,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "pandas.DataFrame"
                ],
                "target_column": [
                    "str",
                    "pandas.DataFrame"
                ],
                "prediction_column": [
                    "str",
                    "pandas.DataFrame"
                ],
                "output_column": [
                    "str",
                    "pandas.DataFrame"
                ],
                "y_min": [
                    "float",
                    "bool",
                    "str"
                ],
                "y_max": [
                    "float",
                    "bool",
                    "str"
                ]
            }
        },
        "find_thresholds_with_same_risk": {
            "name": "find_thresholds_with_same_risk",
            "location": 75,
            "return": [
                "str",
                "utils.Node",
                "List[int]",
                "int"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "Optional[dict]",
                    "str",
                    "List['cirq.Circuit']",
                    "pandas.DataFrame",
                    "float",
                    "int",
                    "Optional[str]"
                ],
                "sensitive_factor": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "unfair_band_column": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "model_prediction_output": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "output_column_name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "isotonic_calibration_learner.p": {
            "name": "p",
            "location": 53,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "find_thresholds_with_same_risk._find_thresholds_with_same_risk": {
            "name": "_find_thresholds_with_same_risk",
            "location": 110,
            "return": [
                "int",
                "set",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "List['cirq.Qid']",
                    "str"
                ],
                "metric_by_band": [
                    "int",
                    "set",
                    "str"
                ]
            }
        },
        "find_thresholds_with_same_risk.p": {
            "name": "p",
            "location": 141,
            "return": [
                "str",
                "Callable[[str], str]",
                "bool"
            ],
            "arguments": {
                "new_df": [
                    "str",
                    "sklearn.base.BaseEstimator"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/classification.py": {
        "logistic_classification_learner": {
            "name": "logistic_classification_learner",
            "location": 17,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "int"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "int"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "int"
                ],
                "params": [
                    "str",
                    "bool",
                    "fklearn.types.LogType",
                    "float"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "int"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "fklearn.types.LogType",
                    "float"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "fklearn.types.LogType",
                    "float"
                ]
            }
        },
        "xgb_classification_learner": {
            "name": "xgb_classification_learner",
            "location": 100,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "learning_rate": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "num_estimators": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "extra_params": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ]
            }
        },
        "_get_catboost_shap_values": {
            "name": "_get_catboost_shap_values",
            "location": 234,
            "return": [
                "bool",
                "dict",
                "Dict[str, str]",
                "Optional[str]"
            ],
            "arguments": {
                "df": [
                    "Dict[str, Any]",
                    "Iterable",
                    "str",
                    "list",
                    "pandas.DataFrame",
                    "int"
                ],
                "cbr": [
                    "Dict[str, Any]",
                    "hackathon.utils.utils.DataMessage",
                    "cmk.utils.type_defs.EventRule",
                    "bool"
                ],
                "features": [
                    "Dict[str, Any]",
                    "Iterable",
                    "str",
                    "list",
                    "pandas.DataFrame",
                    "int"
                ],
                "target": [
                    "Dict[str, Any]",
                    "Iterable",
                    "str",
                    "list",
                    "pandas.DataFrame",
                    "int"
                ],
                "weights": [
                    "Dict[str, Any]",
                    "Iterable",
                    "str",
                    "list",
                    "pandas.DataFrame",
                    "int"
                ],
                "cat_features": [
                    "Dict[str, Any]",
                    "Iterable",
                    "str",
                    "list",
                    "pandas.DataFrame",
                    "int"
                ]
            }
        },
        "catboost_classification_learner": {
            "name": "catboost_classification_learner",
            "location": 275,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "features": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "target": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "learning_rate": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "num_estimators": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "extra_params": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "prediction_column": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ]
            }
        },
        "nlp_logistic_classification_learner": {
            "name": "nlp_logistic_classification_learner",
            "location": 410,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "pandas.DataFrame",
                    "List[str]",
                    "Optional[\"Address\"]",
                    "bool"
                ],
                "text_feature_cols": [
                    "str",
                    "pandas.DataFrame",
                    "List[str]",
                    "Optional[\"Address\"]",
                    "bool"
                ],
                "target": [
                    "str",
                    "pandas.DataFrame",
                    "List[str]",
                    "Optional[\"Address\"]",
                    "bool"
                ],
                "vectorizer_params": [
                    "fklearn.types.LogType",
                    "bool",
                    "int",
                    "str"
                ],
                "logistic_params": [
                    "fklearn.types.LogType",
                    "bool",
                    "int",
                    "str"
                ],
                "prediction_column": [
                    "str",
                    "pandas.DataFrame",
                    "List[str]",
                    "Optional[\"Address\"]",
                    "bool"
                ]
            }
        },
        "lgbm_classification_learner": {
            "name": "lgbm_classification_learner",
            "location": 499,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "learning_rate": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "num_estimators": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "extra_params": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ]
            }
        },
        "logistic_classification_learner.p": {
            "name": "p",
            "location": 69,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "xgb_classification_learner.p": {
            "name": "p",
            "location": 176,
            "return": [],
            "arguments": {
                "new_df": [],
                "apply_shap": []
            }
        },
        "catboost_classification_learner.p": {
            "name": "p",
            "location": 354,
            "return": [],
            "arguments": {
                "new_df": [],
                "apply_shap": []
            }
        },
        "nlp_logistic_classification_learner.p": {
            "name": "p",
            "location": 463,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "lgbm_classification_learner.p": {
            "name": "p",
            "location": 577,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "new_df": [
                    "pandas.DataFrame",
                    "ark.types.PrimalItem",
                    "numpy.ndarray",
                    "Type[Any]",
                    "dict",
                    "\"Machine\""
                ],
                "apply_shap": [
                    "bool",
                    "List[Dict[str, Any]]",
                    "float"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/ensemble.py": {
        "xgb_octopus_classification_learner": {
            "name": "xgb_octopus_classification_learner",
            "location": 16,
            "return": [
                "str",
                "int",
                "Tuple[float, float]",
                "List[Tuple[int, int]]"
            ],
            "arguments": {
                "train_set": [
                    "pandas.DataFrame",
                    "str",
                    "int",
                    "bool"
                ],
                "learning_rate_by_bin": [
                    "str",
                    "int",
                    "list",
                    "Dict[T, int]",
                    "bool",
                    "Tuple[int, int, int, int]"
                ],
                "num_estimators_by_bin": [
                    "str",
                    "int",
                    "list",
                    "Dict[T, int]",
                    "bool",
                    "Tuple[int, int, int, int]"
                ],
                "extra_params_by_bin": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "bytearray"
                ],
                "features_by_bin": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "bytearray"
                ],
                "train_split_col": [
                    "str",
                    "int",
                    "list",
                    "Dict[T, int]",
                    "bool",
                    "Tuple[int, int, int, int]"
                ],
                "train_split_bins": [
                    "str",
                    "int",
                    "list",
                    "Dict[T, int]",
                    "bool",
                    "Tuple[int, int, int, int]"
                ],
                "nthread": [
                    "str",
                    "int",
                    "list",
                    "Dict[T, int]",
                    "bool",
                    "Tuple[int, int, int, int]"
                ],
                "target_column": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "bytearray"
                ],
                "prediction_column": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "bytearray"
                ]
            }
        },
        "xgb_octopus_classification_learner.p": {
            "name": "p",
            "location": 136,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "str"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/imputation.py": {
        "imputer": {
            "name": "imputer",
            "location": 14,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "Hashable",
                    "int",
                    "Optional[int]"
                ],
                "columns_to_impute": [
                    "bool",
                    "Hashable",
                    "int",
                    "Optional[int]"
                ],
                "impute_strategy": [
                    "bool",
                    "Hashable",
                    "int",
                    "Optional[int]"
                ],
                "placeholder_value": [
                    "bool",
                    "Hashable",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "placeholder_imputer": {
            "name": "placeholder_imputer",
            "location": 88,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "raiden.utils.Balance",
                    "augury.types.DataFrameCalculator",
                    "Callable[[pandas.DataFrame], pandas.DataFrame]",
                    "\"Env\"",
                    "int",
                    "\"State\""
                ],
                "columns_to_impute": [
                    "dict",
                    "Tuple['cirq.Qid']",
                    "Tuple[str, list]",
                    "Tuple[str, Dict[str, Any]]"
                ],
                "placeholder_value": [
                    "dict",
                    "Tuple['cirq.Qid']",
                    "Tuple[str, list]",
                    "Tuple[str, Dict[str, Any]]"
                ]
            }
        },
        "imputer.p": {
            "name": "p",
            "location": 59,
            "return": [],
            "arguments": {
                "new_data_set": []
            }
        },
        "placeholder_imputer.p": {
            "name": "p",
            "location": 108,
            "return": [
                "str"
            ],
            "arguments": {
                "new_data_set": [
                    "bool",
                    "pandas.DataFrame"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/pipeline.py": {
        "build_pipeline": {
            "name": "build_pipeline",
            "location": 11,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "build_pipeline._has_one_unfilled_arg": {
            "name": "_has_one_unfilled_arg",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "learner": [
                    "str",
                    "int"
                ]
            }
        },
        "build_pipeline._no_variable_args": {
            "name": "_no_variable_args",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "learner": [
                    "fklearn.types.LearnerFnType",
                    "Union[str, List[str]]",
                    "str",
                    "types.Message",
                    "Container[\"Taxon\"]"
                ],
                "predict_fn": [
                    "mypy.types.Instance",
                    "Type",
                    "bool"
                ]
            }
        },
        "build_pipeline.pipeline": {
            "name": "pipeline",
            "location": 66,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {
                "data": [
                    "int",
                    "bytes",
                    "bool",
                    "dict"
                ]
            }
        },
        "build_pipeline.pipeline.predict_fn": {
            "name": "predict_fn",
            "location": 93,
            "return": [
                "Callable",
                "Dict[str, int]"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "str",
                    "bytes"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/regression.py": {
        "linear_regression_learner": {
            "name": "linear_regression_learner",
            "location": 17,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]"
                ],
                "params": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "fklearn.types.LogType",
                    "float"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "fklearn.types.LogType",
                    "float"
                ]
            }
        },
        "xgb_regression_learner": {
            "name": "xgb_regression_learner",
            "location": 92,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "learning_rate": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "num_estimators": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "extra_params": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ]
            }
        },
        "catboost_regressor_learner": {
            "name": "catboost_regressor_learner",
            "location": 204,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "features": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "target": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "learning_rate": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "num_estimators": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "extra_params": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "prediction_column": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "List[str]"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ]
            }
        },
        "gp_regression_learner": {
            "name": "gp_regression_learner",
            "location": 309,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Union[str, float]",
                    "List[str]"
                ],
                "features": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Union[str, float]",
                    "List[str]"
                ],
                "target": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Union[str, float]",
                    "List[str]"
                ],
                "kernel": [
                    "bool",
                    "Dict[str, Any]",
                    "float",
                    "int",
                    "raiden.utils.Callable"
                ],
                "alpha": [
                    "bool",
                    "Dict[str, Any]",
                    "float",
                    "int",
                    "raiden.utils.Callable"
                ],
                "extra_variance": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Union[str, float]",
                    "List[str]"
                ],
                "return_std": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Union[str, float]",
                    "List[str]"
                ],
                "extra_params": [
                    "bool",
                    "Dict[str, Any]",
                    "float",
                    "int",
                    "raiden.utils.Callable"
                ],
                "prediction_column": [
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Union[str, float]",
                    "List[str]"
                ],
                "encode_extra_cols": [
                    "bool",
                    "Dict[str, Any]",
                    "float",
                    "int",
                    "raiden.utils.Callable"
                ]
            }
        },
        "lgbm_regression_learner": {
            "name": "lgbm_regression_learner",
            "location": 409,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "learning_rate": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "num_estimators": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "extra_params": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "int",
                    "pandas.DataFrame"
                ],
                "weight_column": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ],
                "encode_extra_cols": [
                    "str",
                    "bool",
                    "float",
                    "fklearn.types.LogType"
                ]
            }
        },
        "custom_supervised_model_learner": {
            "name": "custom_supervised_model_learner",
            "location": 523,
            "return": [
                "str",
                "List[dict]",
                "torch.nn.utils.rnn.PackedSequence",
                "bytes",
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "Tuple[str]",
                    "Optional[str]"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "int",
                    "bool"
                ],
                "target": [
                    "str",
                    "List[str]",
                    "int",
                    "bool"
                ],
                "model": [
                    "str",
                    "float",
                    "int",
                    "Optional[str]",
                    "bool"
                ],
                "supervised_type": [
                    "str",
                    "List[str]",
                    "int",
                    "bool"
                ],
                "log": [
                    "Dict[str, Dict]",
                    "bool",
                    "opentrons.types.Location",
                    "opentrons.protocols.types.APIVersion",
                    "str"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "int",
                    "bool"
                ]
            }
        },
        "linear_regression_learner.p": {
            "name": "p",
            "location": 68,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "xgb_regression_learner.p": {
            "name": "p",
            "location": 166,
            "return": [],
            "arguments": {
                "new_df": [],
                "apply_shap": []
            }
        },
        "catboost_regressor_learner.p": {
            "name": "p",
            "location": 271,
            "return": [],
            "arguments": {
                "new_df": [],
                "apply_shap": []
            }
        },
        "gp_regression_learner.p": {
            "name": "p",
            "location": 380,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "lgbm_regression_learner.p": {
            "name": "p",
            "location": 486,
            "return": [],
            "arguments": {
                "new_df": [],
                "apply_shap": []
            }
        },
        "custom_supervised_model_learner.p": {
            "name": "p",
            "location": 582,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "new_df": [
                    "int",
                    "Set[int]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/transformation.py": {
        "selector": {
            "name": "selector",
            "location": 17,
            "return": [
                "str",
                "trezor.utils.Writer",
                "Dict[str, Any]"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "numpy.ndarray",
                    "Optional[List[Any]]",
                    "bytes"
                ],
                "training_columns": [
                    "List[str]",
                    "int",
                    "Union[str, List[str], None]",
                    "Union[List[str], str]"
                ],
                "predict_columns": [
                    "List[str]",
                    "int",
                    "Union[str, List[str], None]",
                    "Union[List[str], str]"
                ]
            }
        },
        "capper": {
            "name": "capper",
            "location": 58,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "columns_to_cap": [
                    "Dict[str, float]",
                    "List[str]",
                    "str",
                    "Iterable[str]",
                    "bool",
                    "List[\"DictDataLoader\"]"
                ],
                "precomputed_caps": [
                    "Dict[str, float]",
                    "List[str]",
                    "str",
                    "Iterable[str]",
                    "bool",
                    "List[\"DictDataLoader\"]"
                ]
            }
        },
        "floorer": {
            "name": "floorer",
            "location": 105,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "columns_to_floor": [
                    "Dict[str, float]",
                    "List[str]",
                    "str",
                    "Iterable[str]",
                    "bool",
                    "List[\"DictDataLoader\"]"
                ],
                "precomputed_floors": [
                    "Dict[str, float]",
                    "List[str]",
                    "str",
                    "Iterable[str]",
                    "bool",
                    "List[\"DictDataLoader\"]"
                ]
            }
        },
        "ecdfer": {
            "name": "ecdfer",
            "location": 152,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "Tuple[float, float, float, float]",
                    "int"
                ],
                "ascending": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "List[Tuple[numpy.ndarray, numpy.ndarray, float, numpy.ndarray, bool]]"
                ],
                "prediction_column": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "List[Tuple[numpy.ndarray, numpy.ndarray, float, numpy.ndarray, bool]]"
                ],
                "ecdf_column": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "List[Tuple[numpy.ndarray, numpy.ndarray, float, numpy.ndarray, bool]]"
                ],
                "max_range": [
                    "int",
                    "str",
                    "bool",
                    "Callable"
                ]
            }
        },
        "discrete_ecdfer": {
            "name": "discrete_ecdfer",
            "location": 211,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "bool",
                    "str"
                ],
                "ascending": [
                    "str",
                    "int",
                    "bool",
                    "Callable"
                ],
                "prediction_column": [
                    "str",
                    "int",
                    "bool",
                    "Callable"
                ],
                "ecdf_column": [
                    "str",
                    "int",
                    "bool",
                    "Callable"
                ],
                "max_range": [
                    "str",
                    "int",
                    "bool",
                    "Callable"
                ],
                "round_method": [
                    "str",
                    "int",
                    "bool",
                    "Callable"
                ]
            }
        },
        "prediction_ranger": {
            "name": "prediction_ranger",
            "location": 292,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "Iterator[numpy.ndarray]",
                    "bool",
                    "int",
                    "str"
                ],
                "prediction_min": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "prediction_max": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "apply_replacements": {
            "name": "apply_replacements",
            "location": 332,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [],
                "columns": [
                    "int",
                    "float",
                    "List[str]"
                ],
                "vec": [],
                "replace_unseen": []
            }
        },
        "value_mapper": {
            "name": "value_mapper",
            "location": 367,
            "return": [
                "int",
                "tuple",
                "List[int]",
                "float",
                "raiden.utils.BlockHash",
                "str",
                "bool"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "Dict[str, Dict]",
                    "Optional[float]",
                    "mode.utils.types.trees.NodeT",
                    "Dict[str, Any]",
                    "bool"
                ],
                "value_maps": [
                    "pandas.DataFrame",
                    "Dict[str, Dict]",
                    "Optional[float]",
                    "mode.utils.types.trees.NodeT",
                    "Dict[str, Any]",
                    "bool"
                ],
                "ignore_unseen": [
                    "bool",
                    "int",
                    "float",
                    "Callable",
                    "Optional[str]",
                    "set"
                ],
                "replace_unseen_to": [
                    "bool",
                    "int",
                    "float",
                    "Callable",
                    "Optional[str]",
                    "set"
                ]
            }
        },
        "truncate_categorical": {
            "name": "truncate_categorical",
            "location": 411,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "float"
                ],
                "columns_to_truncate": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool"
                ],
                "percentile": [
                    "bool",
                    "Union[str, float]",
                    "float"
                ],
                "replacement": [
                    "bool",
                    "Union[str, float]",
                    "float"
                ],
                "replace_unseen": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool"
                ],
                "store_mapping": [
                    "bool",
                    "Union[str, float]",
                    "float"
                ]
            }
        },
        "rank_categorical": {
            "name": "rank_categorical",
            "location": 476,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "Optional[str]",
                    "Optional[bool]",
                    "numpy.ndarray",
                    "float"
                ],
                "columns_to_rank": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool"
                ],
                "replace_unseen": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool"
                ],
                "store_mapping": [
                    "bool"
                ]
            }
        },
        "count_categorizer": {
            "name": "count_categorizer",
            "location": 534,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "Optional[str]",
                    "Optional[bool]",
                    "numpy.ndarray",
                    "float"
                ],
                "columns_to_categorize": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool"
                ],
                "replace_unseen": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool"
                ],
                "store_mapping": [
                    "bool"
                ]
            }
        },
        "label_categorizer": {
            "name": "label_categorizer",
            "location": 587,
            "return": [
                "str",
                "Callable",
                "utils.Node",
                "float"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "raiden.utils.Callable",
                    "Exception",
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "columns_to_categorize": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool",
                    "str",
                    "Iterable[str]"
                ],
                "replace_unseen": [
                    "List[str]",
                    "Union[str, float]",
                    "int",
                    "bool",
                    "str",
                    "Iterable[str]"
                ],
                "store_mapping": [
                    "bool"
                ]
            }
        },
        "quantile_biner": {
            "name": "quantile_biner",
            "location": 643,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "columns_to_bin": [
                    "List[str]",
                    "int",
                    "Dict[str, float]",
                    "bool"
                ],
                "q": [
                    "List[str]",
                    "int",
                    "Dict[str, float]",
                    "bool"
                ],
                "right": [
                    "bool",
                    "types.Ty",
                    "types.ExistentialTyVar",
                    "bytes",
                    "List[str]"
                ]
            }
        },
        "onehot_categorizer": {
            "name": "onehot_categorizer",
            "location": 700,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "List[float]",
                    "Optional[List[Any]]",
                    "List[numpy.ndarray]",
                    "float",
                    "Optional[str]",
                    "int"
                ],
                "columns_to_categorize": [
                    "bool",
                    "List[str]",
                    "int",
                    "Optional[List[str]]",
                    "float",
                    "Optional[List[Any]]",
                    "str"
                ],
                "hardcode_nans": [
                    "bool",
                    "List[str]",
                    "int",
                    "Optional[List[str]]",
                    "float",
                    "Optional[List[Any]]",
                    "str"
                ],
                "drop_first_column": [
                    "bool",
                    "List[str]",
                    "int",
                    "Optional[List[str]]",
                    "float",
                    "Optional[List[Any]]",
                    "str"
                ],
                "store_mapping": [
                    "bool",
                    "Union[str, float]",
                    "float"
                ]
            }
        },
        "target_categorizer": {
            "name": "target_categorizer",
            "location": 770,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "float",
                    "List[int]",
                    "bool",
                    "Callable[[str], bool]",
                    "numpy.array"
                ],
                "columns_to_categorize": [
                    "bool",
                    "List[str]",
                    "str",
                    "float"
                ],
                "target_column": [
                    "bool",
                    "List[str]",
                    "str",
                    "float"
                ],
                "smoothing": [
                    "bool",
                    "List[str]",
                    "str",
                    "float"
                ],
                "ignore_unseen": [
                    "bool",
                    "List[str]",
                    "str",
                    "float"
                ],
                "store_mapping": [
                    "bool",
                    "Union[str, float]",
                    "float"
                ]
            }
        },
        "standard_scaler": {
            "name": "standard_scaler",
            "location": 847,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "columns_to_scale": [
                    "List[str]",
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "custom_transformer": {
            "name": "custom_transformer",
            "location": 892,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int"
                ],
                "columns_to_transform": [
                    "List[str]",
                    "Callable[[pandas.DataFrame], pandas.DataFrame]",
                    "bool"
                ],
                "transformation_function": [
                    "List[str]",
                    "Callable[[pandas.DataFrame], pandas.DataFrame]",
                    "bool"
                ],
                "is_vectorized": [
                    "bool",
                    "str",
                    "Optional[bool]"
                ]
            }
        },
        "null_injector": {
            "name": "null_injector",
            "location": 940,
            "return": [
                "bool",
                "int",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "pandas.DataFrame",
                    "bool",
                    "List[str]",
                    "Sequence[Sequence[int]]",
                    "Iterable[Any]"
                ],
                "proportion": [
                    "Optional[List[str]]",
                    "float",
                    "Optional[List[Any]]",
                    "List[str]",
                    "bool",
                    "int",
                    "str"
                ],
                "columns_to_inject": [
                    "Optional[List[str]]",
                    "float",
                    "Optional[List[Any]]",
                    "List[str]",
                    "bool",
                    "int",
                    "str"
                ],
                "groups": [
                    "Optional[List[str]]",
                    "float",
                    "Optional[List[Any]]",
                    "List[str]",
                    "bool",
                    "int",
                    "str"
                ],
                "seed": [
                    "int",
                    "pandas.DataFrame",
                    "bool",
                    "List[str]",
                    "Sequence[Sequence[int]]",
                    "Iterable[Any]"
                ]
            }
        },
        "missing_warner": {
            "name": "missing_warner",
            "location": 1001,
            "return": [
                "str",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "bool",
                    "float",
                    "int",
                    "str"
                ],
                "cols_list": [
                    "List[str]",
                    "str",
                    "Optional[List[str]]",
                    "Dict[str, List[str]]",
                    "Optional[Sequence[str]]",
                    "Union[str, list]"
                ],
                "new_column_name": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "float",
                    "mode.utils.times.Seconds"
                ],
                "detailed_warning": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "float",
                    "mode.utils.times.Seconds"
                ],
                "detailed_column_name": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "float",
                    "mode.utils.times.Seconds"
                ]
            }
        },
        "selector.p": {
            "name": "p",
            "location": 39,
            "return": [],
            "arguments": {
                "new_data_set": []
            }
        },
        "capper.p": {
            "name": "p",
            "location": 85,
            "return": [],
            "arguments": {
                "new_data_set": []
            }
        },
        "floorer.p": {
            "name": "p",
            "location": 133,
            "return": [],
            "arguments": {
                "new_data_set": []
            }
        },
        "ecdfer.p": {
            "name": "p",
            "location": 192,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "discrete_ecdfer.p": {
            "name": "p",
            "location": 277,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "prediction_ranger.p": {
            "name": "p",
            "location": 314,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "value_mapper.new_col_value_map": {
            "name": "new_col_value_map",
            "location": 393,
            "return": [
                "dict",
                "int",
                "cmk.utils.type_defs.CheckVariables",
                "Dict[str, List[Callable]]",
                "list",
                "Dict[str, str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "old_col_value_map": [
                    "str",
                    "Optional[Callable]",
                    "list",
                    "Dict[str, Set[str]]"
                ],
                "new_keys": [
                    "list",
                    "str",
                    "dict",
                    "Sequence[str]",
                    "Dict[str, List[str]]",
                    "List[numpy.ndarray]",
                    "int",
                    "Optional[List[str]]",
                    "rouver.types.StartResponse"
                ]
            }
        },
        "value_mapper.p": {
            "name": "p",
            "location": 402,
            "return": [],
            "arguments": {
                "df": []
            }
        },
        "truncate_categorical.p": {
            "name": "p",
            "location": 454,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "rank_categorical.p": {
            "name": "p",
            "location": 512,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "count_categorizer.p": {
            "name": "p",
            "location": 565,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "label_categorizer.categ_dict": {
            "name": "categ_dict",
            "location": 615,
            "return": [
                "dict",
                "Optional[Dict[str, str]]",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "series": [
                    "str",
                    "bool",
                    "List[Dict]",
                    "Mapping[str, Any]",
                    "Dict[int, Dict[str, Any]]",
                    "dict"
                ]
            }
        },
        "label_categorizer.p": {
            "name": "p",
            "location": 621,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "quantile_biner.p": {
            "name": "p",
            "location": 680,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "onehot_categorizer.p": {
            "name": "p",
            "location": 738,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "target_categorizer.categ_target_dict": {
            "name": "categ_target_dict",
            "location": 811,
            "return": [
                "bool",
                "Dict[str, List[str]]",
                "List[str]",
                "Dict[str, Any]",
                "Dict[str, str]"
            ],
            "arguments": {
                "column": [
                    "str",
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        },
        "target_categorizer.p": {
            "name": "p",
            "location": 823,
            "return": [],
            "arguments": {
                "new_df": []
            }
        },
        "standard_scaler.p": {
            "name": "p",
            "location": 872,
            "return": [],
            "arguments": {
                "new_data_set": []
            }
        },
        "custom_transformer.p": {
            "name": "p",
            "location": 919,
            "return": [],
            "arguments": {
                "df": []
            }
        },
        "null_injector.p": {
            "name": "p",
            "location": 982,
            "return": [],
            "arguments": {
                "new_data_set": []
            }
        },
        "missing_warner.p": {
            "name": "p",
            "location": 1029,
            "return": [
                "Sequence['cirq.Qid']",
                "str"
            ],
            "arguments": {
                "dataset": [
                    "pandas.DataFrame",
                    "int",
                    "bool",
                    "cmk.utils.type_defs.HostName",
                    "tuple"
                ]
            }
        },
        "missing_warner.p.detailed_assignment": {
            "name": "detailed_assignment",
            "location": 1030,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "list",
                    "numpy.ndarray",
                    "pandas.DataFrame",
                    "bool",
                    "List[str]"
                ],
                "cols_to_check": [
                    "List[str]",
                    "int",
                    "Mapping[str, Any]",
                    "numpy.ndarray",
                    "List[int]",
                    "Tuple[int]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/unsupervised.py": {
        "isolation_forest_learner": {
            "name": "isolation_forest_learner",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]",
                    "int",
                    "bool"
                ],
                "features": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]",
                    "int",
                    "bool"
                ],
                "params": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]",
                    "int",
                    "bool"
                ],
                "prediction_column": [
                    "str",
                    "List[str]",
                    "pandas.DataFrame",
                    "Dict[str, Any]",
                    "int",
                    "bool"
                ],
                "encode_extra_cols": [
                    "bool",
                    "int",
                    "list"
                ]
            }
        },
        "isolation_forest_learner.p": {
            "name": "p",
            "location": 54,
            "return": [
                "str",
                "dict",
                "Dict[str, Any]",
                "Set[str]",
                "Iterable[Any]",
                "list"
            ],
            "arguments": {
                "new_df": [
                    "pandas.DataFrame",
                    "int",
                    "Iterable[Any]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/utils.py": {
        "log_learner_time": {
            "name": "log_learner_time",
            "location": 14,
            "return": [
                "str",
                "bool",
                "float",
                "int",
                "List[float]",
                "List[Tuple[Any, str, int]]"
            ],
            "arguments": {
                "learner": [
                    "str",
                    "fklearn.types.UncurriedLearnerFnType",
                    "utils.types.Vec3D",
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ],
                "learner_name": [
                    "str",
                    "fklearn.types.UncurriedLearnerFnType",
                    "utils.types.Vec3D",
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "print_learner_run": {
            "name": "print_learner_run",
            "location": 25,
            "return": [
                "int",
                "str",
                "List[int]",
                "Tuple[int]",
                "float"
            ],
            "arguments": {
                "learner": [
                    "str",
                    "fklearn.types.UncurriedLearnerFnType",
                    "bool",
                    "pandas.DataFrame",
                    "List[Union[int, Any]]",
                    "Optional[str]"
                ],
                "learner_name": [
                    "str",
                    "fklearn.types.UncurriedLearnerFnType",
                    "bool",
                    "pandas.DataFrame",
                    "List[Union[int, Any]]",
                    "Optional[str]"
                ]
            }
        },
        "expand_features_encoded": {
            "name": "expand_features_encoded",
            "location": 34,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Callable",
                    "str"
                ],
                "features": [
                    "List[str]",
                    "bool",
                    "bytes"
                ]
            }
        },
        "log_learner_time.timed_learner": {
            "name": "timed_learner",
            "location": 16,
            "return": [
                "bool",
                "str",
                "int",
                "float"
            ],
            "arguments": {}
        },
        "print_learner_run.printed_learner": {
            "name": "printed_learner",
            "location": 27,
            "return": [
                "mypy.types.Type",
                "types.Resolver",
                "bool"
            ],
            "arguments": {}
        },
        "expand_features_encoded.fklearn_features": {
            "name": "fklearn_features",
            "location": 61,
            "return": [
                "str",
                "List[str]",
                "List[Dict]",
                "list",
                "Union[List, Tuple]"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "str",
                    "int"
                ]
            }
        },
        "expand_features_encoded.feature_prefix": {
            "name": "feature_prefix",
            "location": 64,
            "return": [
                "List[int]",
                "List[List[int]]",
                "int",
                "bool"
            ],
            "arguments": {
                "feature": [
                    "str",
                    "bytes"
                ]
            }
        },
        "expand_features_encoded.filter_non_listed_features": {
            "name": "filter_non_listed_features",
            "location": 67,
            "return": [
                "List[str]",
                "str",
                "List[T]",
                "List[Dict]",
                "list"
            ],
            "arguments": {
                "fklearn_features": [
                    "List[str]",
                    "str",
                    "int"
                ],
                "features": [
                    "Iterator[travelfootprininsta.types.FeedItem]",
                    "ark.types.DinoCharacterStatusComponent",
                    "float"
                ]
            }
        },
        "expand_features_encoded.remove_original_pre_encoded_features": {
            "name": "remove_original_pre_encoded_features",
            "location": 71,
            "return": [
                "str",
                "List[Dict]",
                "List[str]",
                "list",
                "tuple",
                "Optional[List[str]]",
                "List[int]"
            ],
            "arguments": {
                "features": [
                    "List[str]",
                    "str",
                    "bool",
                    "Iterable[Sequence[str]]"
                ],
                "encoded_features": [
                    "List[str]",
                    "str",
                    "List[Tuple[str, int]]",
                    "int",
                    "Optional[str]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/training/__init__.py": {},
    "fklearn-master/src/fklearn/tuning/model_agnostic_fc.py": {
        "correlation_feature_selection": {
            "name": "correlation_feature_selection",
            "location": 11,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "train_set": [
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ],
                "features": [
                    "list",
                    "float",
                    "Iterable[T]",
                    "tuple",
                    "str"
                ],
                "threshold": [
                    "str",
                    "float",
                    "dict"
                ]
            }
        },
        "variance_feature_selection": {
            "name": "variance_feature_selection",
            "location": 52,
            "return": [
                "str",
                "int",
                "nucypher.types.NuNits",
                "web3.types.Wei"
            ],
            "arguments": {
                "train_set": [
                    "str",
                    "OrderedDict"
                ],
                "features": [
                    "List[list]",
                    "list",
                    "Callable",
                    "Optional[str]",
                    "str",
                    "List[int]",
                    "List[str]"
                ],
                "threshold": [
                    "str",
                    "Callable",
                    "int",
                    "dict",
                    "Type[T]",
                    "Optional[str]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/tuning/parameter_tuners.py": {
        "random_search_tuner": {
            "name": "random_search_tuner",
            "location": 16,
            "return": [
                "bool",
                "List[str]",
                "str"
            ],
            "arguments": {
                "space": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "train_set": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "param_train_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "split_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "eval_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "iterations": [
                    "int",
                    "Union[None, int]"
                ],
                "random_seed": [
                    "int",
                    "bool",
                    "str",
                    "float"
                ],
                "save_intermediary_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "n_jobs": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ]
            }
        },
        "grid_search_cv": {
            "name": "grid_search_cv",
            "location": 107,
            "return": [
                "int",
                "tuple",
                "List[Dict[str, str]]",
                "Sequence[object]",
                "Iterable",
                "bool"
            ],
            "arguments": {
                "space": [
                    "fklearn.types.LogType",
                    "bytes",
                    "Dict[str, Any]",
                    "int",
                    "Optional[Mapping[str, Any]]",
                    "Callable[[dict], None]",
                    "str",
                    "Union[int, float]",
                    "Dict[Hashable, int]"
                ],
                "train_set": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "param_train_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "split_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "eval_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "save_intermediary_fn": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ],
                "load_intermediary_fn": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]"
                ],
                "warm_start_file": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]"
                ],
                "n_jobs": [
                    "pandas.DataFrame",
                    "int",
                    "fklearn.types.LogType",
                    "bool"
                ]
            }
        },
        "random_search_tuner.tune_iteration": {
            "name": "tune_iteration",
            "location": 91,
            "return": [],
            "arguments": {}
        },
        "grid_search_cv.tune_iteration": {
            "name": "tune_iteration",
            "location": 188,
            "return": [
                "List[Dict[str, Any]]",
                "BaseException",
                "str"
            ],
            "arguments": {
                "iter_space": [
                    "dict",
                    "Type[\"SerializationDialect\"]",
                    "bool"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/tuning/samplers.py": {
        "remove_by_feature_importance": {
            "name": "remove_by_feature_importance",
            "location": 16,
            "return": [
                "Iterable[str]",
                "bool",
                "float"
            ],
            "arguments": {
                "log": [
                    "int",
                    "fklearn.types.LogType",
                    "Callable",
                    "bool",
                    "numpy.ndarray",
                    "list"
                ],
                "num_removed_by_step": [
                    "int",
                    "fklearn.types.LogType",
                    "Callable",
                    "bool",
                    "numpy.ndarray",
                    "list"
                ]
            }
        },
        "remove_features_subsets": {
            "name": "remove_features_subsets",
            "location": 39,
            "return": [
                "List[Dict]",
                "List[str]",
                "List[int]",
                "str",
                "List[List[Any]]"
            ],
            "arguments": {
                "log_list": [
                    "str",
                    "bool",
                    "dict",
                    "List[Tuple[str, str]]",
                    "List[str]",
                    "Tuple[str, int]"
                ],
                "extractor": [
                    "str",
                    "bool",
                    "dict",
                    "List[Tuple[str, str]]",
                    "List[str]",
                    "Tuple[str, int]"
                ],
                "metric_name": [
                    "str",
                    "bool",
                    "dict",
                    "List[Tuple[str, str]]",
                    "List[str]",
                    "Tuple[str, int]"
                ],
                "num_removed_by_step": [
                    "int",
                    "Sequence[int]",
                    "Dict[int, str]",
                    "torch.utils.data.Dataset"
                ]
            }
        },
        "remove_by_feature_shuffling": {
            "name": "remove_by_feature_shuffling",
            "location": 75,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "log": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "fklearn.types.LogType",
                    "str",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.Address"
                ],
                "predict_fn": [
                    "str",
                    "fklearn.types.ExtractorFnType",
                    "fklearn.types.EvalFnType",
                    "bool",
                    "Optional[str]"
                ],
                "eval_fn": [
                    "str",
                    "fklearn.types.ExtractorFnType",
                    "fklearn.types.EvalFnType",
                    "bool",
                    "Optional[str]"
                ],
                "eval_data": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "fklearn.types.LogType",
                    "str",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.Address"
                ],
                "extractor": [
                    "str",
                    "fklearn.types.ExtractorFnType",
                    "fklearn.types.EvalFnType",
                    "bool",
                    "Optional[str]"
                ],
                "metric_name": [
                    "str",
                    "fklearn.types.ExtractorFnType",
                    "fklearn.types.EvalFnType",
                    "bool",
                    "Optional[str]"
                ],
                "max_removed_by_step": [
                    "int",
                    "float",
                    "Optional[Union[Any, Any]]",
                    "Optional[int]",
                    "bool"
                ],
                "threshold": [
                    "int",
                    "float",
                    "Optional[Union[Any, Any]]",
                    "Optional[int]",
                    "bool"
                ],
                "speed_up_by_importance": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "fklearn.types.LogType",
                    "str",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.Address"
                ],
                "parallel": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "fklearn.types.LogType",
                    "str",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.Address"
                ],
                "nthread": [
                    "int",
                    "bool",
                    "Optional[float]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "Dict[int, str]"
                ],
                "seed": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "fklearn.types.LogType",
                    "str",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.Address"
                ]
            }
        },
        "remove_by_feature_shuffling.shuffle": {
            "name": "shuffle",
            "location": 149,
            "return": [
                "str",
                "int",
                "bool",
                "List[Dict[str, Any]]",
                "Dict[str, Any]",
                "bytes"
            ],
            "arguments": {
                "feature": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/tuning/selectors.py": {
        "feature_importance_backward_selection": {
            "name": "feature_importance_backward_selection",
            "location": 17,
            "return": [
                "Dict[str, Any]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "train_data": [
                    "int",
                    "bool",
                    "float",
                    "dict"
                ],
                "param_train_fn": [
                    "int",
                    "bool",
                    "float",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "List[int]"
                ],
                "features": [
                    "int",
                    "List[int]",
                    "float"
                ],
                "split_fn": [
                    "int",
                    "bool",
                    "float",
                    "dict"
                ],
                "eval_fn": [
                    "int",
                    "bool",
                    "float",
                    "dict"
                ],
                "extractor": [
                    "int",
                    "pandas.DataFrame",
                    "str"
                ],
                "metric_name": [
                    "int",
                    "pandas.DataFrame",
                    "str"
                ],
                "num_removed_by_step": [
                    "int",
                    "float",
                    "str"
                ],
                "threshold": [
                    "int",
                    "pandas.DataFrame",
                    "str"
                ],
                "early_stop": [
                    "int",
                    "pandas.DataFrame",
                    "str"
                ],
                "iter_limit": [
                    "int",
                    "pandas.DataFrame",
                    "str"
                ],
                "min_remaining_features": [
                    "int",
                    "pandas.DataFrame",
                    "str"
                ],
                "save_intermediary_fn": [
                    "Optional[int]",
                    "float",
                    "Union[None, int]",
                    "bool",
                    "Optional[str]",
                    "Optional[float]"
                ],
                "n_jobs": [
                    "int",
                    "bool",
                    "float",
                    "dict"
                ]
            }
        },
        "poor_man_boruta_selection": {
            "name": "poor_man_boruta_selection",
            "location": 124,
            "return": [
                "Dict[str, Any]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "train_data": [
                    "List[str]",
                    "pandas.DataFrame",
                    "Tuple[Union[int, slice], Union[int, slice]]",
                    "bytes"
                ],
                "test_data": [
                    "bool",
                    "int"
                ],
                "param_train_fn": [
                    "List[str]",
                    "List[int]"
                ],
                "features": [
                    "List[str]",
                    "pandas.DataFrame",
                    "List[int]",
                    "int"
                ],
                "eval_fn": [
                    "bool",
                    "int"
                ],
                "extractor": [
                    "bool",
                    "int"
                ],
                "metric_name": [
                    "bool",
                    "int"
                ],
                "max_removed_by_step": [
                    "bool",
                    "int"
                ],
                "threshold": [
                    "bool",
                    "int"
                ],
                "early_stop": [
                    "bool",
                    "int",
                    "pandas.DataFrame"
                ],
                "iter_limit": [
                    "bool",
                    "int",
                    "pandas.DataFrame"
                ],
                "min_remaining_features": [
                    "bool",
                    "int",
                    "pandas.DataFrame"
                ],
                "save_intermediary_fn": [
                    "Sequence[str]",
                    "Optional[AnyStr]"
                ],
                "speed_up_by_importance": [
                    "bool",
                    "int"
                ],
                "parallel": [
                    "bool",
                    "int"
                ],
                "nthread": [
                    "bool",
                    "int"
                ],
                "seed": [
                    "bool",
                    "int"
                ]
            }
        },
        "backward_subset_feature_selection": {
            "name": "backward_subset_feature_selection",
            "location": 284,
            "return": [
                "Dict[str, Any]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "train_data": [
                    "str",
                    "bytes",
                    "float",
                    "bool"
                ],
                "param_train_fn": [
                    "bool",
                    "Dict[str, Any]",
                    "int",
                    "float"
                ],
                "features_sets": [
                    "list",
                    "\"ImageStack\"",
                    "int",
                    "bool",
                    "Iterator[Tuple[Any]]",
                    "Mapping[Any, Any]",
                    "List[Tuple[str, str]]"
                ],
                "split_fn": [
                    "str",
                    "bytes",
                    "float",
                    "bool"
                ],
                "eval_fn": [
                    "str",
                    "bytes",
                    "float",
                    "bool"
                ],
                "extractor": [
                    "bool",
                    "opentrons.protocols.execution.types.LoadedLabware",
                    "Optional[Set[str]]",
                    "Optional[List[str]]"
                ],
                "metric_name": [
                    "bool",
                    "opentrons.protocols.execution.types.LoadedLabware",
                    "Optional[Set[str]]",
                    "Optional[List[str]]"
                ],
                "threshold": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "num_removed_by_step": [
                    "bool",
                    "opentrons.protocols.execution.types.LoadedLabware",
                    "Optional[Set[str]]",
                    "Optional[List[str]]"
                ],
                "early_stop": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "iter_limit": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "min_remaining_features": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "save_intermediary_fn": [
                    "List[List[Callable]]",
                    "bool",
                    "Union[int, str, None]",
                    "Optional[float]",
                    "Optional[str]"
                ],
                "n_jobs": [
                    "str",
                    "bytes",
                    "float",
                    "bool"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/tuning/stoppers.py": {
        "aggregate_stop_funcs": {
            "name": "aggregate_stop_funcs",
            "location": 12,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "stop_by_iter_num": {
            "name": "stop_by_iter_num",
            "location": 34,
            "return": [
                "int",
                "List[T]",
                "str"
            ],
            "arguments": {
                "logs": [
                    "fklearn.types.ListLogListType",
                    "int",
                    "str"
                ],
                "iter_limit": [
                    "fklearn.types.ListLogListType",
                    "int",
                    "str"
                ]
            }
        },
        "stop_by_no_improvement": {
            "name": "stop_by_no_improvement",
            "location": 57,
            "return": [
                "bool"
            ],
            "arguments": {
                "logs": [
                    "str",
                    "dict",
                    "bool",
                    "set",
                    "Callable[..., T]"
                ],
                "extractor": [
                    "str",
                    "bool"
                ],
                "metric_name": [
                    "str",
                    "bool"
                ],
                "early_stop": [
                    "str",
                    "dict",
                    "bool",
                    "set",
                    "Callable[..., T]"
                ],
                "threshold": [
                    "float",
                    "str",
                    "bool",
                    "Callable",
                    "Optional[str]"
                ]
            }
        },
        "stop_by_no_improvement_parallel": {
            "name": "stop_by_no_improvement_parallel",
            "location": 101,
            "return": [
                "bool"
            ],
            "arguments": {
                "logs": [
                    "Exception",
                    "str",
                    "BaseException"
                ],
                "extractor": [
                    "str",
                    "List[Dict[str, Any]]",
                    "Dict[str, object]",
                    "Dict[str, Dict[str, str]]"
                ],
                "metric_name": [
                    "str",
                    "List[Dict[str, Any]]",
                    "Dict[str, object]",
                    "Dict[str, Dict[str, str]]"
                ],
                "early_stop": [
                    "bool",
                    "str",
                    "dict",
                    "Iterable[T]",
                    "int"
                ],
                "threshold": [
                    "float",
                    "str",
                    "bool",
                    "Callable",
                    "Optional[str]"
                ]
            }
        },
        "stop_by_num_features": {
            "name": "stop_by_num_features",
            "location": 146,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "logs": [
                    "int",
                    "fklearn.types.ListLogListType",
                    "str",
                    "Dict[str, Any]",
                    "raiden.utils.ChainID",
                    "raiden.utils.Iterator[raiden.utils.Port]"
                ],
                "min_num_features": [
                    "int",
                    "fklearn.types.ListLogListType",
                    "str",
                    "Dict[str, Any]",
                    "raiden.utils.ChainID",
                    "raiden.utils.Iterator[raiden.utils.Port]"
                ]
            }
        },
        "stop_by_num_features_parallel": {
            "name": "stop_by_num_features_parallel",
            "location": 169,
            "return": [
                "Callable[[T], List[T]]",
                "str",
                "bool"
            ],
            "arguments": {
                "logs": [
                    "Optional[str]",
                    "Callable",
                    "str"
                ],
                "extractor": [
                    "Optional[str]",
                    "Callable",
                    "str"
                ],
                "metric_name": [
                    "Optional[str]",
                    "Callable",
                    "str"
                ],
                "min_num_features": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "aggregate_stop_funcs.p": {
            "name": "p",
            "location": 27,
            "return": [
                "bool",
                "Optional[bool]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "logs": [
                    "fklearn.types.ListLogListType",
                    "Any",
                    "bool",
                    "int",
                    "dict"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/tuning/utils.py": {
        "get_avg_metric_from_extractor": {
            "name": "get_avg_metric_from_extractor",
            "location": 10,
            "return": [
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "logs": [
                    "float",
                    "int"
                ],
                "extractor": [
                    "float",
                    "int"
                ],
                "metric_name": [
                    "str",
                    "Optional[str]",
                    "type",
                    "List[int]"
                ]
            }
        },
        "get_best_performing_log": {
            "name": "get_best_performing_log",
            "location": 15,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "log_list": [
                    "str",
                    "Optional[str]",
                    "T",
                    "Callable[[str], str]"
                ],
                "extractor": [
                    "str",
                    "Optional[str]"
                ],
                "metric_name": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "get_used_features": {
            "name": "get_used_features",
            "location": 20,
            "return": [
                "str",
                "Optional[Mapping[str, Any]]",
                "dict"
            ],
            "arguments": {
                "log": [
                    "dict",
                    "str",
                    "Dict[str, Dict[str, str]]"
                ]
            }
        },
        "order_feature_importance_avg_from_logs": {
            "name": "order_feature_importance_avg_from_logs",
            "location": 24,
            "return": [
                "bool"
            ],
            "arguments": {
                "log": [
                    "dict",
                    "int",
                    "Dict[str, str]"
                ]
            }
        },
        "gen_key_avgs_from_logs": {
            "name": "gen_key_avgs_from_logs",
            "location": 29,
            "return": [
                "dict",
                "List[str]",
                "List[Dict[str, Any]]",
                "Iterator[object]",
                "bool"
            ],
            "arguments": {
                "key": [
                    "str",
                    "List[Dict]",
                    "Hashable",
                    "Sequence[Hashable]",
                    "int",
                    "range"
                ],
                "logs": [
                    "str",
                    "List[Dict]",
                    "Hashable",
                    "Sequence[Hashable]",
                    "int",
                    "range"
                ]
            }
        },
        "gen_key_avgs_from_iteration": {
            "name": "gen_key_avgs_from_iteration",
            "location": 33,
            "return": [
                "str",
                "dict",
                "Optional[str]",
                "bytes"
            ],
            "arguments": {
                "key": [
                    "str",
                    "dict",
                    "Optional[Callable]"
                ],
                "log": [
                    "str",
                    "dict",
                    "Optional[Callable]"
                ]
            }
        },
        "gen_key_avgs_from_dicts": {
            "name": "gen_key_avgs_from_dicts",
            "location": 37,
            "return": [
                "Set[str]",
                "type",
                "List[Dict]",
                "List[str]",
                "Optional[int]",
                "types.FunctionType",
                "types.MethodType",
                "functools.partial"
            ],
            "arguments": {
                "obj": [
                    "dict",
                    "Mapping[str, Any]",
                    "Optional[Tuple[str, ...]]",
                    "int",
                    "Dict[str, Set[str]]"
                ]
            }
        },
        "gen_dict_extract": {
            "name": "gen_dict_extract",
            "location": 42,
            "return": [
                "typing.Generator[typing.Any, None, None]"
            ],
            "arguments": {
                "key": [
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Sequence[str]"
                ],
                "obj": [
                    "dict",
                    "Dict[str, str]",
                    "str",
                    "List[Dict[str, Any]]",
                    "List[str]"
                ]
            }
        },
        "gen_validator_log": {
            "name": "gen_validator_log",
            "location": 57,
            "return": [
                "dict",
                "str",
                "Callable[..., None]"
            ],
            "arguments": {
                "eval_log": [
                    "int",
                    "Tuple[int]",
                    "float",
                    "bool"
                ],
                "fold_num": [
                    "int",
                    "Tuple[int]",
                    "float",
                    "bool"
                ],
                "test_size": [
                    "int",
                    "Tuple[int]",
                    "float",
                    "bool"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/tuning/__init__.py": {},
    "fklearn-master/src/fklearn/types/types.py": {},
    "fklearn-master/src/fklearn/types/__init__.py": {},
    "fklearn-master/src/fklearn/validation/evaluators.py": {
        "generic_sklearn_evaluator": {
            "name": "generic_sklearn_evaluator",
            "location": 20,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "name_prefix": [
                    "str",
                    "Iterable[str]",
                    "bool"
                ],
                "sklearn_metric": [
                    "str",
                    "Iterable[str]",
                    "bool"
                ]
            }
        },
        "auc_evaluator": {
            "name": "auc_evaluator",
            "location": 58,
            "return": [
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "eval_name": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "roc_auc_evaluator": {
            "name": "roc_auc_evaluator",
            "location": 93,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Optional[str]",
                    "pandas.DataFrame",
                    "List[str]"
                ],
                "prediction_column": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "pr_auc_evaluator": {
            "name": "pr_auc_evaluator",
            "location": 127,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Optional[str]",
                    "pandas.DataFrame",
                    "List[str]"
                ],
                "prediction_column": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "precision_evaluator": {
            "name": "precision_evaluator",
            "location": 160,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "bool",
                    "int",
                    "float"
                ],
                "threshold": [
                    "bool",
                    "int",
                    "float"
                ],
                "prediction_column": [
                    "int",
                    "float",
                    "pandas.DataFrame",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "Dict[str, str]",
                    "dict",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "Dict[str, str]",
                    "dict",
                    "int"
                ]
            }
        },
        "recall_evaluator": {
            "name": "recall_evaluator",
            "location": 198,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "bool",
                    "int",
                    "float"
                ],
                "threshold": [
                    "bool",
                    "int",
                    "float"
                ],
                "prediction_column": [
                    "int",
                    "float",
                    "pandas.DataFrame",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "Dict[str, str]",
                    "dict",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "Dict[str, str]",
                    "dict",
                    "int"
                ]
            }
        },
        "fbeta_score_evaluator": {
            "name": "fbeta_score_evaluator",
            "location": 238,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str",
                    "float"
                ],
                "threshold": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str",
                    "float"
                ],
                "beta": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Dict[str, str]",
                    "int"
                ],
                "prediction_column": [
                    "int",
                    "float",
                    "bool",
                    "pandas.DataFrame"
                ],
                "target_column": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Dict[str, str]",
                    "int"
                ],
                "eval_name": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Dict[str, str]",
                    "int"
                ]
            }
        },
        "logloss_evaluator": {
            "name": "logloss_evaluator",
            "location": 284,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Optional[str]",
                    "pandas.DataFrame",
                    "List[str]"
                ],
                "prediction_column": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "brier_score_evaluator": {
            "name": "brier_score_evaluator",
            "location": 318,
            "return": [
                "Callable",
                "float",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Optional[str]",
                    "pandas.DataFrame",
                    "List[str]"
                ],
                "prediction_column": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "expected_calibration_error_evaluator": {
            "name": "expected_calibration_error_evaluator",
            "location": 352,
            "return": [
                "str",
                "pydantic.types.PaymentCardBrand",
                "Type[Any]",
                "Tuple[str]",
                "List[str]"
            ],
            "arguments": {
                "test_data": [
                    "int"
                ],
                "prediction_column": [
                    "int"
                ],
                "target_column": [
                    "bool",
                    "str",
                    "dict",
                    "List[str]",
                    "Dict[str, str]",
                    "int",
                    "Optional[str]"
                ],
                "eval_name": [
                    "Optional[str]",
                    "Optional[int]",
                    "str"
                ],
                "n_bins": [
                    "int"
                ],
                "bin_choice": [
                    "bool"
                ]
            }
        },
        "r2_evaluator": {
            "name": "r2_evaluator",
            "location": 442,
            "return": [
                "bool",
                "str",
                "dict"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "str",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "Optional[str]"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "mse_evaluator": {
            "name": "mse_evaluator",
            "location": 475,
            "return": [
                "numpy.array",
                "str",
                "int",
                "List[Tuple[str, str]]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "eval_name": [
                    "str",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "mean_prediction_evaluator": {
            "name": "mean_prediction_evaluator",
            "location": 507,
            "return": [
                "str",
                "apistar.types.WSGIEnviron",
                "Mapping[str, Any]",
                "Dict[str, Any]",
                "Dict[str, Dict[str, Any]]"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Callable",
                    "Dict[str, Any]",
                    "bool"
                ],
                "prediction_column": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "Optional[Dict[str, str]]"
                ],
                "eval_name": [
                    "Optional[str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]",
                    "Optional[Union[int, str]]"
                ]
            }
        },
        "correlation_evaluator": {
            "name": "correlation_evaluator",
            "location": 537,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "bool",
                    "set",
                    "str",
                    "List[Dict[str, Any]]",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "bool",
                    "set",
                    "str",
                    "List[Dict[str, Any]]",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "Union[int, str]",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "linear_coefficient_evaluator": {
            "name": "linear_coefficient_evaluator",
            "location": 572,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "str",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[Set[str]]",
                    "bool"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "Union[int, str]",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "spearman_evaluator": {
            "name": "spearman_evaluator",
            "location": 608,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "bool",
                    "set",
                    "str",
                    "List[Dict[str, Any]]",
                    "Optional[str]"
                ],
                "prediction_column": [
                    "bool",
                    "set",
                    "str",
                    "List[Dict[str, Any]]",
                    "Optional[str]"
                ],
                "target_column": [
                    "str",
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "Union[int, str]",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "ndcg_evaluator": {
            "name": "ndcg_evaluator",
            "location": 645,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "int",
                    "bytearray",
                    "Union[starfish.types.Number, Tuple[starfish.types.Number]]",
                    "pandas.DataFrame",
                    "Union[starfish.core.types.Number, Tuple[starfish.core.types.Number]]"
                ],
                "prediction_column": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str",
                    "float"
                ],
                "target_column": [
                    "str",
                    "Optional[str]",
                    "BinaryIO",
                    "Optional[int]",
                    "Dict[str, Any]"
                ],
                "k": [
                    "int",
                    "bytearray",
                    "str",
                    "float"
                ],
                "exponential_gain": [
                    "bool"
                ],
                "eval_name": [
                    "Optional[str]",
                    "Optional[int]",
                    "Optional[Union[int, str]]"
                ]
            }
        },
        "combined_evaluators": {
            "name": "combined_evaluators",
            "location": 712,
            "return": [
                "bool",
                "int",
                "Optional[bool]",
                "Optional[Sequence[str]]",
                "Optional[Callable]"
            ],
            "arguments": {
                "test_data": [
                    "dict",
                    "Dict[str, Any]",
                    "int"
                ],
                "evaluators": [
                    "dict",
                    "Dict[str, Any]",
                    "int"
                ]
            }
        },
        "split_evaluator": {
            "name": "split_evaluator",
            "location": 734,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "test_data": [
                    "Optional[str]",
                    "str"
                ],
                "eval_fn": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "int",
                    "dict"
                ],
                "split_col": [
                    "str",
                    "Callable"
                ],
                "split_values": [
                    "str",
                    "Dict[str, np.ndarray]",
                    "Optional[Dict[str, Any]]",
                    "Optional[str]",
                    "dict",
                    "bool",
                    "Union[int, float]",
                    "int"
                ],
                "eval_name": [
                    "Optional[str]",
                    "Optional[dict]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "bool"
                ]
            }
        },
        "temporal_split_evaluator": {
            "name": "temporal_split_evaluator",
            "location": 778,
            "return": [
                "str"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "Mapping[str, Any]",
                    "Optional[str]",
                    "Dict[str, str]",
                    "bool"
                ],
                "eval_fn": [
                    "str",
                    "Optional[bool]",
                    "Optional[str]",
                    "bool"
                ],
                "time_col": [
                    "str",
                    "Optional[str]",
                    "Dict[str, str]",
                    "Optional[Any]",
                    "bool"
                ],
                "time_format": [
                    "str",
                    "int",
                    "List[dict]",
                    "Optional[Any]"
                ],
                "split_values": [
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "bool",
                    "Sequence[str]",
                    "Iterable",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "Iterable[str]",
                    "Optional[Union[int, str]]",
                    "Optional[object]",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "permutation_evaluator": {
            "name": "permutation_evaluator",
            "location": 835,
            "return": [
                "Tuple[Any, Any, Any]",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "bool",
                    "Optional[int]",
                    "Union[np.ndarray, Dict[str, np.ndarray], loompy.LayerManager]",
                    "int"
                ],
                "predict_fn": [
                    "bool",
                    "Optional[int]",
                    "Union[np.ndarray, Dict[str, np.ndarray], loompy.LayerManager]",
                    "int"
                ],
                "eval_fn": [
                    "bool",
                    "Optional[int]",
                    "Union[np.ndarray, Dict[str, np.ndarray], loompy.LayerManager]",
                    "int"
                ],
                "baseline": [
                    "bool",
                    "int"
                ],
                "features": [
                    "List[str]",
                    "list"
                ],
                "shuffle_all_at_once": [
                    "bool",
                    "int"
                ],
                "random_state": [
                    "bool",
                    "int"
                ]
            }
        },
        "hash_evaluator": {
            "name": "hash_evaluator",
            "location": 907,
            "return": [
                "Iterable[str]",
                "str",
                "dict",
                "List[types.ServiceT]"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "bool"
                ],
                "hash_columns": [
                    "str",
                    "dict",
                    "list",
                    "tuple",
                    "bool",
                    "Dict[str, Any]"
                ],
                "eval_name": [
                    "Optional[str]",
                    "str",
                    "List[str]"
                ],
                "consider_index": [
                    "str",
                    "bool"
                ]
            }
        },
        "exponential_coefficient_evaluator": {
            "name": "exponential_coefficient_evaluator",
            "location": 956,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "int",
                    "Optional[str]",
                    "float",
                    "static_frame.core.util.IndexConstructor",
                    "bool"
                ],
                "prediction_column": [
                    "str",
                    "int",
                    "Optional[str]",
                    "float",
                    "static_frame.core.util.IndexConstructor",
                    "bool"
                ],
                "target_column": [
                    "str",
                    "bool",
                    "List[str]",
                    "int"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "Union[int, str]",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "logistic_coefficient_evaluator": {
            "name": "logistic_coefficient_evaluator",
            "location": 993,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "Dict[str, Any]",
                    "bytes",
                    "int"
                ],
                "prediction_column": [
                    "Dict[str, Any]",
                    "bytes",
                    "int"
                ],
                "target_column": [
                    "bool",
                    "List[str]",
                    "Optional[str]",
                    "Set[str]",
                    "Optional[List[Any]]",
                    "Callable[[float], bool]"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "Union[int, str]",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "generic_sklearn_evaluator.p": {
            "name": "p",
            "location": 38,
            "return": [
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "test_data": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Optional[bool]"
                ],
                "prediction_column": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Optional[bool]"
                ],
                "target_column": [
                    "str",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "eval_name": [
                    "Optional[Set[int]]",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "str"
                ]
            }
        },
        "permutation_evaluator.col_shuffler": {
            "name": "col_shuffler",
            "location": 884,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "f": [
                    "int"
                ]
            }
        },
        "permutation_evaluator.permutation_eval": {
            "name": "permutation_eval",
            "location": 887,
            "return": [
                "str",
                "List[dict]",
                "Dict[str, Any]",
                "numpy.ndarray"
            ],
            "arguments": {
                "features_to_shuffle": [
                    "int",
                    "pandas.DataFrame",
                    "List[list]",
                    "List[bool]"
                ]
            }
        },
        "hash_evaluator.calculate_dataframe_hash": {
            "name": "calculate_dataframe_hash",
            "location": 941,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "df": [
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "Set[str]",
                    "dict"
                ],
                "eval_name": [
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "Set[str]",
                    "dict"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/validation/perturbators.py": {
        "shift_mu": {
            "name": "shift_mu",
            "location": 12,
            "return": [
                "bool",
                "int",
                "Tuple[int]",
                "List[str]"
            ],
            "arguments": {
                "col": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "perc": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "random_noise": {
            "name": "random_noise",
            "location": 34,
            "return": [
                "bool",
                "int",
                "Tuple[int]",
                "List[str]"
            ],
            "arguments": {
                "col": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "List[str]",
                    "str"
                ],
                "mag": [
                    "int",
                    "Optional[int]",
                    "Tuple[int]",
                    "List[Dict[str, Any]]",
                    "FrozenSet[Any]",
                    "bool"
                ]
            }
        },
        "nullify": {
            "name": "nullify",
            "location": 57,
            "return": [
                "bool",
                "List[str]",
                "Set[str]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "col": [
                    "int",
                    "Union[str, bytes]",
                    "pandas.DataFrame",
                    "str",
                    "bytes",
                    "dict"
                ],
                "perc": [
                    "int",
                    "str",
                    "List[str]"
                ]
            }
        },
        "sample_columns": {
            "name": "sample_columns",
            "location": 82,
            "return": [
                "int",
                "List[str]",
                "Optional[bool]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "data": [
                    "pandas.DataFrame",
                    "float",
                    "dict",
                    "Mapping[str, Any]",
                    "Dict[str, Any]",
                    "str",
                    "List[Dict[str, Any]]"
                ],
                "perc": [
                    "pandas.DataFrame",
                    "float",
                    "dict",
                    "Mapping[str, Any]",
                    "Dict[str, Any]",
                    "str",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "perturbator": {
            "name": "perturbator",
            "location": 102,
            "return": [
                "starfish.types.Axes",
                "Optional[float]",
                "bool",
                "Sequence['cirq.Qid']",
                "str"
            ],
            "arguments": {
                "data": [
                    "pandas.DataFrame",
                    "List[str]",
                    "dict",
                    "numpy.ndarray",
                    "str"
                ],
                "cols": [
                    "pandas.DataFrame",
                    "List[str]",
                    "dict",
                    "numpy.ndarray",
                    "str"
                ],
                "corruption_fn": [
                    "pandas.DataFrame",
                    "List[str]",
                    "dict",
                    "numpy.ndarray",
                    "str"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/validation/splitters.py": {
        "_log_time_fold": {
            "name": "_log_time_fold",
            "location": 16,
            "return": [
                "str",
                "int",
                "Dict[str, bool]"
            ],
            "arguments": {
                "time_fold": [
                    "Tuple[pandas.Series, pandas.Series]",
                    "Callable[..., bool]",
                    "list",
                    "datetime.date",
                    "datetime.datetime.datetime",
                    "str",
                    "Optional[List[int]]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "_get_lc_folds": {
            "name": "_get_lc_folds",
            "location": 22,
            "return": [
                "str",
                "datetime.datetime",
                "int",
                "Optional[str]",
                "Optional[datetime.tzinfo]",
                "bool"
            ],
            "arguments": {
                "date_range": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.datetime]",
                    "datetime.datetime",
                    "datetime.datetime.datetime"
                ],
                "date_fold_filter_fn": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.datetime]",
                    "datetime.datetime",
                    "datetime.datetime.datetime"
                ],
                "test_time": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.datetime]",
                    "datetime.datetime",
                    "datetime.datetime.datetime"
                ],
                "time_column": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.datetime]",
                    "datetime.datetime",
                    "datetime.datetime.datetime"
                ],
                "min_samples": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.datetime]",
                    "datetime.datetime",
                    "datetime.datetime.datetime"
                ]
            }
        },
        "_get_sc_folds": {
            "name": "_get_sc_folds",
            "location": 35,
            "return": [
                "str",
                "datetime.datetime",
                "int",
                "Optional[str]",
                "Optional[datetime.tzinfo]",
                "bool"
            ],
            "arguments": {
                "date_range": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.date]",
                    "List[int]",
                    "datetime.datetime"
                ],
                "date_fold_filter_fn": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.date]",
                    "List[int]",
                    "datetime.datetime"
                ],
                "time_column": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.date]",
                    "List[int]",
                    "datetime.datetime"
                ],
                "min_samples": [
                    "int",
                    "str",
                    "pandas.Series",
                    "Optional[datetime.date]",
                    "List[int]",
                    "datetime.datetime"
                ]
            }
        },
        "_get_sc_test_fold_idx_and_logs": {
            "name": "_get_sc_test_fold_idx_and_logs",
            "location": 46,
            "return": [
                "str",
                "bool",
                "int",
                "List[str]"
            ],
            "arguments": {
                "test_data": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "Optional[str]"
                ],
                "train_time": [
                    "pandas.Series",
                    "bool",
                    "dict",
                    "float"
                ],
                "time_column": [
                    "str",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "first_test_moment": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "Optional[str]"
                ],
                "last_test_moment": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "Optional[str]"
                ],
                "min_samples": [
                    "str",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "freq": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "Optional[str]"
                ]
            }
        },
        "_lc_fold_to_indexes": {
            "name": "_lc_fold_to_indexes",
            "location": 65,
            "return": [
                "List[Dict]",
                "List[int]",
                "float",
                "list",
                "List[float]",
                "Tuple[int, int, int]",
                "Union[List[float], List[int]]",
                "List[List[Any]]",
                "List[str]"
            ],
            "arguments": {
                "folds": [
                    "List[Tuple[pandas.Series, pandas.Series]]",
                    "float",
                    "int",
                    "raiden.utils.MessageID",
                    "Dict[str, List[Any]]",
                    "raiden.utils.PaymentID",
                    "Dict[str, Union[Any, Any, Any]]"
                ]
            }
        },
        "k_fold_splitter": {
            "name": "k_fold_splitter",
            "location": 70,
            "return": [
                "str",
                "bool",
                "Union[int, float, complex]",
                "float"
            ],
            "arguments": {
                "train_data": [
                    "int",
                    "pandas.DataFrame",
                    "float",
                    "Optional[Union[int, float]]"
                ],
                "n_splits": [
                    "int",
                    "pandas.DataFrame",
                    "float",
                    "Optional[Union[int, float]]"
                ],
                "random_state": [
                    "int",
                    "pandas.DataFrame",
                    "float",
                    "Optional[Union[int, float]]"
                ],
                "stratify_column": [
                    "str",
                    "int",
                    "Optional[int]",
                    "Optional[bool]"
                ]
            }
        },
        "out_of_time_and_space_splitter": {
            "name": "out_of_time_and_space_splitter",
            "location": 115,
            "return": [
                "dict",
                "Dict[str, bool]",
                "int",
                "Exception",
                "str",
                "Union[Dict, str]"
            ],
            "arguments": {
                "train_data": [
                    "bool",
                    "Dict[int, Set[int]]",
                    "dict",
                    "Optional[List[str]]",
                    "float",
                    "int"
                ],
                "n_splits": [
                    "str",
                    "int",
                    "bool",
                    "List[float]"
                ],
                "in_time_limit": [
                    "datetime.datetime",
                    "float",
                    "str",
                    "Optional[datetime.date]",
                    "bool",
                    "Optional[str]",
                    "Optional[datetime.datetime]"
                ],
                "time_column": [
                    "int",
                    "str",
                    "bool",
                    "Sequence[int]",
                    "numpy.ndarray"
                ],
                "space_column": [
                    "str",
                    "int",
                    "bool",
                    "List[float]"
                ],
                "holdout_gap": [
                    "int",
                    "str",
                    "bool",
                    "Sequence[int]",
                    "numpy.ndarray"
                ]
            }
        },
        "time_and_space_learning_curve_splitter": {
            "name": "time_and_space_learning_curve_splitter",
            "location": 176,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "train_data": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "training_time_limit": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "space_column": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "time_column": [
                    "str",
                    "int"
                ],
                "freq": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "space_hold_percentage": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "holdout_gap": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "random_state": [
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "int",
                    "float",
                    "tuple",
                    "bool"
                ],
                "min_samples": [
                    "str",
                    "int"
                ]
            }
        },
        "time_learning_curve_splitter": {
            "name": "time_learning_curve_splitter",
            "location": 255,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "train_data": [
                    "str",
                    "datetime.timedelta",
                    "fklearn.types.DateType",
                    "pandas.DataFrame",
                    "datetime.datetime",
                    "List[dict]"
                ],
                "training_time_limit": [
                    "str",
                    "datetime.timedelta",
                    "fklearn.types.DateType",
                    "pandas.DataFrame",
                    "datetime.datetime",
                    "List[dict]"
                ],
                "time_column": [
                    "str",
                    "int",
                    "datetime.datetime",
                    "bool",
                    "Optional[List[str]]"
                ],
                "freq": [
                    "str",
                    "datetime.timedelta",
                    "fklearn.types.DateType",
                    "pandas.DataFrame",
                    "datetime.datetime",
                    "List[dict]"
                ],
                "holdout_gap": [
                    "str",
                    "datetime.timedelta",
                    "fklearn.types.DateType",
                    "pandas.DataFrame",
                    "datetime.datetime",
                    "List[dict]"
                ],
                "min_samples": [
                    "str",
                    "int",
                    "datetime.datetime",
                    "bool",
                    "Optional[List[str]]"
                ]
            }
        },
        "reverse_time_learning_curve_splitter": {
            "name": "reverse_time_learning_curve_splitter",
            "location": 315,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]",
                "pandas.DataFrame",
                "dict"
            ],
            "arguments": {
                "train_data": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "bool",
                    "List[\"libkol.Item\"]"
                ],
                "time_column": [
                    "int",
                    "str"
                ],
                "training_time_limit": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "bool",
                    "List[\"libkol.Item\"]"
                ],
                "lower_time_limit": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "bool",
                    "List[\"libkol.Item\"]"
                ],
                "freq": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "bool",
                    "List[\"libkol.Item\"]"
                ],
                "holdout_gap": [
                    "fklearn.types.DateType",
                    "str",
                    "pandas.DataFrame",
                    "datetime.timedelta",
                    "bool",
                    "List[\"libkol.Item\"]"
                ],
                "min_samples": [
                    "int",
                    "str"
                ]
            }
        },
        "spatial_learning_curve_splitter": {
            "name": "spatial_learning_curve_splitter",
            "location": 381,
            "return": [
                "str",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "train_data": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "list",
                    "Optional[int]",
                    "datetime.datetime.timedelta"
                ],
                "space_column": [
                    "int",
                    "bool",
                    "dict",
                    "float"
                ],
                "time_column": [
                    "str",
                    "pandas.DataFrame",
                    "int",
                    "list",
                    "Optional[int]",
                    "datetime.datetime.timedelta"
                ],
                "training_limit": [
                    "int",
                    "float",
                    "bool",
                    "str"
                ],
                "holdout_gap": [
                    "int",
                    "datetime.timedelta",
                    "List[Tuple[int, int]]",
                    "Dict[str, Any]",
                    "dict",
                    "Optional[str]"
                ],
                "train_percentages": [
                    "int",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.Balance"
                ],
                "random_state": [
                    "int",
                    "bool",
                    "raiden.utils.BlockNumber",
                    "Optional[int]",
                    "dict"
                ]
            }
        },
        "stability_curve_time_splitter": {
            "name": "stability_curve_time_splitter",
            "location": 469,
            "return": [
                "int",
                "Union[str, int]",
                "Optional[str]",
                "str",
                "bool"
            ],
            "arguments": {
                "train_data": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "int",
                    "str",
                    "Dict[int, str]"
                ],
                "training_time_limit": [
                    "bool",
                    "Dict[str, Any]",
                    "int",
                    "float"
                ],
                "time_column": [
                    "bool",
                    "Dict[str, Any]",
                    "int",
                    "float"
                ],
                "freq": [
                    "int",
                    "str",
                    "bool",
                    "list",
                    "Optional[float]"
                ],
                "min_samples": [
                    "int",
                    "str",
                    "bool",
                    "list",
                    "Optional[float]"
                ]
            }
        },
        "stability_curve_time_in_space_splitter": {
            "name": "stability_curve_time_in_space_splitter",
            "location": 525,
            "return": [
                "str",
                "int",
                "Optional[str]",
                "Dict[str, int]"
            ],
            "arguments": {
                "train_data": [
                    "int",
                    "bool",
                    "Dict[int, str]",
                    "Optional[int]",
                    "tuple"
                ],
                "training_time_limit": [
                    "bool",
                    "int",
                    "float",
                    "dict"
                ],
                "space_column": [
                    "int",
                    "str",
                    "pandas.DataFrame",
                    "List[str]",
                    "datetime.datetime",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "time_column": [
                    "bool",
                    "int",
                    "float",
                    "dict"
                ],
                "freq": [
                    "int",
                    "str",
                    "bool"
                ],
                "space_hold_percentage": [
                    "int",
                    "str",
                    "pandas.DataFrame",
                    "List[str]",
                    "datetime.datetime",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "random_state": [
                    "int",
                    "Optional[int]",
                    "bool"
                ],
                "min_samples": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "stability_curve_time_space_splitter": {
            "name": "stability_curve_time_space_splitter",
            "location": 602,
            "return": [
                "numpy.ndarray",
                "List[int]",
                "int",
                "List[dict]",
                "datetime.datetime"
            ],
            "arguments": {
                "train_data": [
                    "int",
                    "Optional[int]",
                    "Optional[str]",
                    "str"
                ],
                "training_time_limit": [
                    "int",
                    "str",
                    "dict",
                    "bool",
                    "float",
                    "Optional[str]",
                    "datetime.datetime"
                ],
                "space_column": [
                    "Optional[str]",
                    "str",
                    "bool"
                ],
                "time_column": [
                    "int",
                    "str",
                    "dict",
                    "bool",
                    "float",
                    "Optional[str]",
                    "datetime.datetime"
                ],
                "freq": [
                    "int",
                    "str",
                    "dict"
                ],
                "space_hold_percentage": [
                    "int",
                    "str"
                ],
                "random_state": [
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "min_samples": [
                    "int",
                    "str",
                    "dict"
                ]
            }
        },
        "forward_stability_curve_time_splitter": {
            "name": "forward_stability_curve_time_splitter",
            "location": 681,
            "return": [
                "list",
                "pandas.DataFrame",
                "int",
                "float",
                "bool"
            ],
            "arguments": {
                "train_data": [
                    "int",
                    "Dict[int, datetime.datetime]",
                    "cmk.utils.prediction.TimeSeries",
                    "Optional[datetime.date]",
                    "bool"
                ],
                "training_time_start": [
                    "str",
                    "int",
                    "Optional[datetime.timedelta]",
                    "Optional[datetime.datetime]",
                    "List[str]"
                ],
                "training_time_end": [
                    "datetime.datetime",
                    "bool"
                ],
                "time_column": [
                    "Optional[float]",
                    "int",
                    "datetime.date",
                    "Optional[datetime.datetime]",
                    "datetime.datetime"
                ],
                "holdout_gap": [
                    "datetime.datetime",
                    "int",
                    "Optional[str]"
                ],
                "holdout_size": [
                    "int",
                    "float",
                    "Tuple[int, int]"
                ],
                "step": [
                    "int",
                    "float",
                    "Tuple[int, int]",
                    "bool",
                    "Optional[int]"
                ],
                "move_training_start_with_steps": [
                    "int",
                    "Optional[int]",
                    "str"
                ]
            }
        },
        "_get_sc_test_fold_idx_and_logs.date_filter_fn": {
            "name": "date_filter_fn",
            "location": 55,
            "return": [],
            "arguments": {
                "period": []
            }
        },
        "time_and_space_learning_curve_splitter.date_filter_fn": {
            "name": "date_filter_fn",
            "location": 240,
            "return": [],
            "arguments": {
                "date": []
            }
        },
        "time_learning_curve_splitter.date_filter_fn": {
            "name": "date_filter_fn",
            "location": 301,
            "return": [],
            "arguments": {
                "date": []
            }
        },
        "reverse_time_learning_curve_splitter.date_filter_fn": {
            "name": "date_filter_fn",
            "location": 366,
            "return": [
                "str",
                "int",
                "Dict[str, Any]",
                "Dict[str, numpy.ndarray]",
                "bytes"
            ],
            "arguments": {
                "date": [
                    "fklearn.types.DateType",
                    "str",
                    "T",
                    "pandas.DataFrame",
                    "Dict[str, str]",
                    "Type[int]",
                    "int"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/validation/validator.py": {
        "validator_iteration": {
            "name": "validator_iteration",
            "location": 17,
            "return": [
                "List[Dict[str, Any]]",
                "BaseException",
                "str"
            ],
            "arguments": {
                "data": [
                    "Optional[int]",
                    "float",
                    "int"
                ],
                "train_index": [
                    "bool",
                    "int",
                    "bytes",
                    "tuple",
                    "str"
                ],
                "test_indexes": [
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "fold_num": [
                    "int",
                    "float",
                    "bool",
                    "tuple",
                    "str"
                ],
                "train_fn": [
                    "fklearn.types.LearnerFnType",
                    "int",
                    "float"
                ],
                "eval_fn": [
                    "fklearn.types.EvalFnType",
                    "int",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "predict_oof": [
                    "bool",
                    "int",
                    "float"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "validator": {
            "name": "validator",
            "location": 86,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "train_data": [
                    "bool",
                    "fklearn.types.SplitterFnType",
                    "pandas.DataFrame",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.LearnerFnType",
                    "float",
                    "int",
                    "itsim.types.Protocol"
                ],
                "split_fn": [
                    "bool",
                    "fklearn.types.SplitterFnType",
                    "pandas.DataFrame",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.LearnerFnType",
                    "float",
                    "int",
                    "itsim.types.Protocol"
                ],
                "train_fn": [
                    "bool",
                    "fklearn.types.SplitterFnType",
                    "pandas.DataFrame",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.LearnerFnType",
                    "float",
                    "int",
                    "itsim.types.Protocol"
                ],
                "eval_fn": [
                    "bool",
                    "fklearn.types.SplitterFnType",
                    "pandas.DataFrame",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.LearnerFnType",
                    "float",
                    "int",
                    "itsim.types.Protocol"
                ],
                "perturb_fn_train": [
                    "fklearn.types.PerturbFnType"
                ],
                "perturb_fn_test": [
                    "fklearn.types.PerturbFnType"
                ],
                "predict_oof": [
                    "bool",
                    "fklearn.types.SplitterFnType",
                    "pandas.DataFrame",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.LearnerFnType",
                    "float",
                    "int",
                    "itsim.types.Protocol"
                ],
                "verbose": [
                    "bool",
                    "fklearn.types.SplitterFnType",
                    "pandas.DataFrame",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.LearnerFnType",
                    "float",
                    "int",
                    "itsim.types.Protocol"
                ]
            }
        },
        "parallel_validator_iteration": {
            "name": "parallel_validator_iteration",
            "location": 176,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "train_data": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "bytes",
                    "Optional[Union[Any, Any]]"
                ],
                "fold": [
                    "str",
                    "Callable"
                ],
                "train_fn": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "bytes",
                    "Optional[Union[Any, Any]]"
                ],
                "eval_fn": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "bytes",
                    "Optional[Union[Any, Any]]"
                ],
                "predict_oof": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "bytes",
                    "Optional[Union[Any, Any]]"
                ],
                "verbose": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "bytes",
                    "Optional[Union[Any, Any]]"
                ]
            }
        },
        "parallel_validator": {
            "name": "parallel_validator",
            "location": 187,
            "return": [
                "int"
            ],
            "arguments": {
                "train_data": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ],
                "split_fn": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ],
                "train_fn": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ],
                "eval_fn": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ],
                "n_jobs": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ],
                "predict_oof": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ],
                "verbose": [
                    "int",
                    "bool",
                    "fklearn.types.EvalFnType",
                    "fklearn.types.SplitterFnType",
                    "fklearn.types.LearnerFnType",
                    "pandas.DataFrame"
                ]
            }
        },
        "validator.fold_iter": {
            "name": "fold_iter",
            "location": 143,
            "return": [
                "List[int]",
                "float",
                "bytes",
                "dict",
                "List[dict]"
            ],
            "arguments": {
                "fold": [
                    "int",
                    "float"
                ]
            }
        },
        "validator._join_split_log": {
            "name": "_join_split_log",
            "location": 153,
            "return": [
                "BaseException",
                "Optional[dict]",
                "Tuple[int, int]",
                "float"
            ],
            "arguments": {
                "log_tuple": [
                    "dict",
                    "type",
                    "str",
                    "IO[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "validator.get_perturbed_columns": {
            "name": "get_perturbed_columns",
            "location": 159,
            "return": [
                "int",
                "List[int]",
                "str",
                "float"
            ],
            "arguments": {
                "perturbator": [
                    "int",
                    "str",
                    "Sequence[str]",
                    "Callable[[Any], bool]"
                ]
            }
        },
        "parallel_validator.kwdissoc": {
            "name": "kwdissoc",
            "location": 242,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "d": [
                    "str",
                    "dict",
                    "float",
                    "bool",
                    "Union[int, slice]"
                ],
                "key": [
                    "str",
                    "dict",
                    "float",
                    "bool",
                    "Union[int, slice]"
                ]
            }
        }
    },
    "fklearn-master/src/fklearn/validation/__init__.py": {},
    "fklearn-master/tests/__init__.py": {},
    "fklearn-master/tests/causal/test_debias.py": {
        "test_debias_with_regression_formula": {
            "name": "test_debias_with_regression_formula",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_debias_with_regression": {
            "name": "test_debias_with_regression",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_debias_with_fixed_effects": {
            "name": "test_debias_with_fixed_effects",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_debias_with_double_ml": {
            "name": "test_debias_with_double_ml",
            "location": 97,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/causal/test_effects.py": {
        "test_linear_effect": {
            "name": "test_linear_effect",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_spearman_effect": {
            "name": "test_spearman_effect",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_pearson_effect": {
            "name": "test_pearson_effect",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_exponential_coefficient_effect": {
            "name": "test_exponential_coefficient_effect",
            "location": 43,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_logistic_coefficient_effect": {
            "name": "test_logistic_coefficient_effect",
            "location": 57,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/causal/__init__.py": {},
    "fklearn-master/tests/causal/cate_learning/test_double_machine_learning.py": {
        "test__cv_estimate": {
            "name": "test__cv_estimate",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_non_parametric_double_ml_learner": {
            "name": "test_non_parametric_double_ml_learner",
            "location": 29,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_non_parametric_double_ml_learner_curry": {
            "name": "test_non_parametric_double_ml_learner_curry",
            "location": 63,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/causal/cate_learning/__init__.py": {},
    "fklearn-master/tests/causal/validation/cate.py": {
        "test_delta_mean_by_group_and_bin": {
            "name": "test_delta_mean_by_group_and_bin",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_cate_mean_by_bin_meta_evaluator": {
            "name": "test_cate_mean_by_bin_meta_evaluator",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_cate_mean_by_bin_meta_evaluator_errors": {
            "name": "test_cate_mean_by_bin_meta_evaluator_errors",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {
                "problematic_params_pair": [
                    "dict",
                    "Type"
                ]
            }
        }
    },
    "fklearn-master/tests/causal/validation/test_auc.py": {
        "test_area_under_the_cumulative_effect_curve": {
            "name": "test_area_under_the_cumulative_effect_curve",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_area_under_the_cumulative_gain_curve": {
            "name": "test_area_under_the_cumulative_gain_curve",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_area_under_the_relative_cumulative_gain_curve": {
            "name": "test_area_under_the_relative_cumulative_gain_curve",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/causal/validation/test_curves.py": {
        "test_effect_by_segment": {
            "name": "test_effect_by_segment",
            "location": 9,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_cumulative_effect_curve": {
            "name": "test_cumulative_effect_curve",
            "location": 23,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_cumulative_gain_curve": {
            "name": "test_cumulative_gain_curve",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_relative_cumulative_gain_curve": {
            "name": "test_relative_cumulative_gain_curve",
            "location": 55,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_effect_curves": {
            "name": "test_effect_curves",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/causal/validation/__init__.py": {},
    "fklearn-master/tests/data/test_data.py": {
        "test_make_tutorial_data": {
            "name": "test_make_tutorial_data",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_make_confounded_data": {
            "name": "test_make_confounded_data",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/data/__init__.py": {},
    "fklearn-master/tests/metrics/test_pd_extractors.py": {
        "create_split_logs_and_evaluator": {
            "name": "create_split_logs_and_evaluator",
            "location": 25,
            "return": [
                "float",
                "bool",
                "Sequence",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {}
        },
        "test__split_evaluator_extractor_iteration": {
            "name": "test__split_evaluator_extractor_iteration",
            "location": 41,
            "return": [
                ""
            ],
            "arguments": {
                "eval_name": [
                    "str",
                    "bool",
                    "Optional[bool]"
                ],
                "split_kwargs": [
                    "bool",
                    "str"
                ],
                "create_split_logs_and_evaluator": [
                    "str",
                    "Tuple[str]"
                ]
            }
        },
        "test__split_evaluator_extractor": {
            "name": "test__split_evaluator_extractor",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {
                "eval_name": [
                    "str",
                    "bool",
                    "Optional[bool]"
                ],
                "split_kwargs": [
                    "dict",
                    "str",
                    "Dict[str, Any]",
                    "metrics.ObjectTree"
                ],
                "create_split_logs_and_evaluator": [
                    "str",
                    "Tuple[str]"
                ]
            }
        },
        "test__split_evaluator_extractor__when_split_value_is_missing": {
            "name": "test__split_evaluator_extractor__when_split_value_is_missing",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_extract": {
            "name": "test_extract",
            "location": 144,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "create_split_logs_and_evaluator._create_split_logs_and_evaluator": {
            "name": "_create_split_logs_and_evaluator",
            "location": 26,
            "return": [
                "str",
                "Union[str, int]",
                "bool",
                "Callable"
            ],
            "arguments": {
                "eval_name": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "fklearn-master/tests/metrics/__init__.py": {},
    "fklearn-master/tests/preprocessing/test_rebalancing.py": {
        "test_rebalance_by_categorical": {
            "name": "test_rebalance_by_categorical",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_rebalance_by_continuous": {
            "name": "test_rebalance_by_continuous",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/preprocessing/test_schema.py": {
        "test_feature_duplicator": {
            "name": "test_feature_duplicator",
            "location": 7,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_column_duplicatable_naming": {
            "name": "test_column_duplicatable_naming",
            "location": 51,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/preprocessing/test_splitting.py": {
        "test_time_split_dataset": {
            "name": "test_time_split_dataset",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {
                "test_df": [
                    "str"
                ]
            }
        },
        "test_space_time_split_dataset": {
            "name": "test_space_time_split_dataset",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {
                "test_df": [
                    "int",
                    "Optional[bytes]"
                ],
                "test_df_with_new_id": [
                    "float",
                    "List[str]",
                    "pandas.core.frame.DataFrame"
                ],
                "test_df_only_one_point_per_id": [
                    "pandas.core.frame.DataFrame",
                    "bool",
                    "str",
                    "Optional[\"Page\"]"
                ]
            }
        },
        "gen_stratified_test_data": {
            "name": "gen_stratified_test_data",
            "location": 235,
            "return": [
                "str",
                "bool",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "draw": [
                    "int",
                    "List[int]",
                    "float",
                    "str"
                ]
            }
        },
        "assert_sample_size_per_class": {
            "name": "assert_sample_size_per_class",
            "location": 249,
            "return": [
                ""
            ],
            "arguments": {
                "data": [
                    "str",
                    "List[str]",
                    "Dict[str, str]",
                    "int",
                    "Callable"
                ],
                "target_column_name": [
                    "str",
                    "List[str]",
                    "Dict[str, str]",
                    "int",
                    "Callable"
                ],
                "expected_samples_per_class": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "test_stratified_split_dataset": {
            "name": "test_stratified_split_dataset",
            "location": 259,
            "return": [
                ""
            ],
            "arguments": {
                "sample": [
                    "bool",
                    "str",
                    "dict"
                ],
                "random_state": [
                    "int",
                    "bool"
                ],
                "test_size": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "fklearn-master/tests/preprocessing/__init__.py": {},
    "fklearn-master/tests/training/test_calibration.py": {
        "test_isotonic_calibration_learner": {
            "name": "test_isotonic_calibration_learner",
            "location": 7,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_find_thresholds_with_same_risk": {
            "name": "test_find_thresholds_with_same_risk",
            "location": 33,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_classification.py": {
        "test_logistic_classification_learner": {
            "name": "test_logistic_classification_learner",
            "location": 13,
            "return": [],
            "arguments": {}
        },
        "test_xgb_classification_learner": {
            "name": "test_xgb_classification_learner",
            "location": 86,
            "return": [],
            "arguments": {}
        },
        "test_catboost_classification_learner": {
            "name": "test_catboost_classification_learner",
            "location": 181,
            "return": [],
            "arguments": {}
        },
        "test_nlp_logistic_classification_learner": {
            "name": "test_nlp_logistic_classification_learner",
            "location": 323,
            "return": [],
            "arguments": {}
        },
        "test_lgbm_classification_learner": {
            "name": "test_lgbm_classification_learner",
            "location": 394,
            "return": [],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_ensemble.py": {
        "test_xgb_octopus_classification_learner": {
            "name": "test_xgb_octopus_classification_learner",
            "location": 7,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_imputation.py": {
        "test_imputer": {
            "name": "test_imputer",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_imputer_with_fill_value": {
            "name": "test_imputer_with_fill_value",
            "location": 33,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_placeholder_imputer": {
            "name": "test_placeholder_imputer",
            "location": 57,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_pipeline.py": {
        "test_build_pipeline": {
            "name": "test_build_pipeline",
            "location": 15,
            "return": [
                ""
            ],
            "arguments": {
                "has_repeated_learners": [
                    "str"
                ]
            }
        },
        "test_build_pipeline_no_side_effects": {
            "name": "test_build_pipeline_no_side_effects",
            "location": 56,
            "return": [
                ""
            ],
            "arguments": {
                "has_repeated_learners": [
                    "str"
                ]
            }
        },
        "test_build_pipeline_idempotency": {
            "name": "test_build_pipeline_idempotency",
            "location": 80,
            "return": [
                ""
            ],
            "arguments": {
                "has_repeated_learners": [
                    "str",
                    "bytes"
                ]
            }
        },
        "test_build_pipeline_learner_assertion": {
            "name": "test_build_pipeline_learner_assertion",
            "location": 106,
            "return": [
                ""
            ],
            "arguments": {
                "has_repeated_learners": [
                    "str"
                ]
            }
        },
        "test_build_pipeline_predict_arguments_assertion": {
            "name": "test_build_pipeline_predict_arguments_assertion",
            "location": 122,
            "return": [
                ""
            ],
            "arguments": {
                "has_repeated_learners": [
                    "str",
                    "bool",
                    "set"
                ]
            }
        },
        "test_build_pipeline_serialisation": {
            "name": "test_build_pipeline_serialisation",
            "location": 136,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_build_pipeline_with_onehotencoder": {
            "name": "test_build_pipeline_with_onehotencoder",
            "location": 176,
            "return": [
                ""
            ],
            "arguments": {
                "has_repeated_learners": [
                    "float",
                    "dict",
                    "int",
                    "Dict[str, str]",
                    "str"
                ]
            }
        },
        "test_build_pipeline_repeated_learners_serialisation": {
            "name": "test_build_pipeline_repeated_learners_serialisation",
            "location": 215,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_build_pipeline_no_side_effects.side_effect_learner": {
            "name": "side_effect_learner",
            "location": 60,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_build_pipeline_no_side_effects.kwargs_learner": {
            "name": "kwargs_learner",
            "location": 64,
            "return": [],
            "arguments": {
                "df": []
            }
        },
        "test_build_pipeline_idempotency.kwargs_learner": {
            "name": "kwargs_learner",
            "location": 87,
            "return": [
                "str",
                "int",
                "List[List[str]]",
                "tuple"
            ],
            "arguments": {
                "df": [
                    "Callable[[Mapping], T]",
                    "int",
                    "str"
                ]
            }
        },
        "test_build_pipeline_idempotency.dummy_learner": {
            "name": "dummy_learner",
            "location": 93,
            "return": [],
            "arguments": {
                "df": []
            }
        },
        "test_build_pipeline_learner_assertion.learner": {
            "name": "learner",
            "location": 108,
            "return": [
                "numpy.ndarray",
                "Optional[int]",
                "str"
            ],
            "arguments": {
                "df": [
                    "float",
                    "T",
                    "numpy.ndarray",
                    "int"
                ],
                "a": [
                    "float",
                    "T",
                    "numpy.ndarray",
                    "int"
                ],
                "b": [
                    "float",
                    "T",
                    "numpy.ndarray",
                    "int"
                ],
                "c": [
                    "float",
                    "T",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "test_build_pipeline_predict_arguments_assertion.invalid_learner": {
            "name": "invalid_learner",
            "location": 126,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_build_pipeline_serialisation.dummy_learner": {
            "name": "dummy_learner",
            "location": 146,
            "return": [],
            "arguments": {
                "df": [],
                "fn": [],
                "call": []
            }
        },
        "test_build_pipeline_serialisation.dummy_learner_2": {
            "name": "dummy_learner_2",
            "location": 150,
            "return": [],
            "arguments": {
                "df": [],
                "fn": [],
                "call": []
            }
        },
        "test_build_pipeline_serialisation.dummy_learner_3": {
            "name": "dummy_learner_3",
            "location": 154,
            "return": [
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "float",
                    "bool",
                    "numpy.array",
                    "Iterable[T]"
                ],
                "fn": [
                    "int",
                    "str",
                    "float",
                    "bool",
                    "numpy.array",
                    "Iterable[T]"
                ],
                "call": [
                    "int",
                    "str",
                    "float",
                    "bool",
                    "numpy.array",
                    "Iterable[T]"
                ]
            }
        },
        "test_build_pipeline_repeated_learners_serialisation.dummy_learner": {
            "name": "dummy_learner",
            "location": 225,
            "return": [
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "float",
                    "bool",
                    "numpy.array",
                    "Iterable[T]"
                ],
                "fn": [
                    "list",
                    "List[str]",
                    "List[int]",
                    "Tuple[float, int]",
                    "str"
                ],
                "call": [
                    "int",
                    "str",
                    "float",
                    "bool",
                    "numpy.array",
                    "Iterable[T]"
                ]
            }
        },
        "test_build_pipeline_repeated_learners_serialisation.dummy_learner_2": {
            "name": "dummy_learner_2",
            "location": 229,
            "return": [
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "df": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "fn": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "call": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "test_build_pipeline_no_side_effects.kwargs_learner.p": {
            "name": "p",
            "location": 67,
            "return": [],
            "arguments": {
                "dataset": [],
                "mult": []
            }
        },
        "test_build_pipeline_idempotency.kwargs_learner.p": {
            "name": "p",
            "location": 88,
            "return": [],
            "arguments": {
                "dataset": [],
                "mult": []
            }
        },
        "test_build_pipeline_predict_arguments_assertion.invalid_learner.p": {
            "name": "p",
            "location": 127,
            "return": [
                "pandas.DataFrame",
                "Iterable[Any]",
                "Tuple[str]"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "int",
                    "Set[str]"
                ]
            }
        }
    },
    "fklearn-master/tests/training/test_regression.py": {
        "test_linear_regression_learner": {
            "name": "test_linear_regression_learner",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_gp_regression_learner": {
            "name": "test_gp_regression_learner",
            "location": 48,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_xgb_regression_learner": {
            "name": "test_xgb_regression_learner",
            "location": 89,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_lgbm_regression_learner": {
            "name": "test_lgbm_regression_learner",
            "location": 135,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_catboost_regressor_learner": {
            "name": "test_catboost_regressor_learner",
            "location": 181,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_custom_supervised_model_learner": {
            "name": "test_custom_supervised_model_learner",
            "location": 227,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_transformation.py": {
        "test_selector": {
            "name": "test_selector",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_capper": {
            "name": "test_capper",
            "location": 50,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_floorer": {
            "name": "test_floorer",
            "location": 98,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_prediction_ranger": {
            "name": "test_prediction_ranger",
            "location": 146,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_value_mapper": {
            "name": "test_value_mapper",
            "location": 160,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_truncate_categorical": {
            "name": "test_truncate_categorical",
            "location": 218,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_rank_categorical": {
            "name": "test_rank_categorical",
            "location": 328,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_count_categorizer": {
            "name": "test_count_categorizer",
            "location": 401,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_label_categorizer": {
            "name": "test_label_categorizer",
            "location": 511,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_quantile_biner": {
            "name": "test_quantile_biner",
            "location": 626,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_onehot_categorizer": {
            "name": "test_onehot_categorizer",
            "location": 844,
            "return": [
                ""
            ],
            "arguments": {
                "df_train": [
                    "List[List[int]]",
                    "Collection[str]",
                    "bool",
                    "Iterable[int]",
                    "Dict[str, Any]"
                ],
                "df_test": [
                    "Callable",
                    "bool",
                    "int"
                ],
                "columns_to_categorize": [
                    "float",
                    "Callable",
                    "Optional[int]"
                ],
                "drop_first": [
                    "float",
                    "Callable",
                    "Optional[int]"
                ],
                "hardcode": [
                    "float",
                    "Callable",
                    "Optional[int]"
                ],
                "expected_output_train": [
                    "bytes"
                ],
                "expected_output_test": [
                    "bool",
                    "int",
                    "bytes"
                ]
            }
        },
        "test_target_categorizer": {
            "name": "test_target_categorizer",
            "location": 858,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_standard_scaler": {
            "name": "test_standard_scaler",
            "location": 1141,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_custom_transformer": {
            "name": "test_custom_transformer",
            "location": 1242,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_null_injector": {
            "name": "test_null_injector",
            "location": 1398,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_ecdfer": {
            "name": "test_ecdfer",
            "location": 1451,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_discrete_ecdfer": {
            "name": "test_discrete_ecdfer",
            "location": 1524,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_missing_warner": {
            "name": "test_missing_warner",
            "location": 1582,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_unsupervised.py": {
        "test_anomaly_learner": {
            "name": "test_anomaly_learner",
            "location": 9,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/test_utils.py": {
        "test_expand_features_encoded": {
            "name": "test_expand_features_encoded",
            "location": 9,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/training/__init__.py": {},
    "fklearn-master/tests/tuning/test_model_agnostic_fc.py": {
        "test_correlation_feature_selection": {
            "name": "test_correlation_feature_selection",
            "location": 5,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_variance_feature_selection": {
            "name": "test_variance_feature_selection",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/tuning/test_parameter_tuners.py": {
        "test_random_search_tuner": {
            "name": "test_random_search_tuner",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {
                "tmpdir": [
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_grid_search_tuner": {
            "name": "test_grid_search_tuner",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {
                "tmpdir": [
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_random_search_tuner.param_train_fn": {
            "name": "param_train_fn",
            "location": 27,
            "return": [],
            "arguments": {
                "space": [],
                "train_set": []
            }
        },
        "test_grid_search_tuner.param_train_fn": {
            "name": "param_train_fn",
            "location": 63,
            "return": [
                "numpy.ndarray",
                "Callable"
            ],
            "arguments": {
                "space": [
                    "List[Dict[Any, str]]",
                    "Union[int, float]",
                    "int"
                ],
                "train_set": [
                    "Optional[int]"
                ]
            }
        }
    },
    "fklearn-master/tests/tuning/test_samplers.py": {
        "logs": {
            "name": "logs",
            "location": 15,
            "return": [
                "str",
                "list",
                "float",
                "Dict[str, Any]",
                "tuple",
                "Callable[..., None]",
                "dict"
            ],
            "arguments": {}
        },
        "parallel_logs": {
            "name": "parallel_logs",
            "location": 20,
            "return": [
                "str",
                "List[Dict[str, Any]]",
                "tuple",
                "float",
                "list",
                "int"
            ],
            "arguments": {}
        },
        "base_extractor": {
            "name": "base_extractor",
            "location": 25,
            "return": [
                "str",
                "int",
                "List[Callable]"
            ],
            "arguments": {}
        },
        "metric_name": {
            "name": "metric_name",
            "location": 30,
            "return": [
                "str",
                "int",
                "Dict[str, Any]",
                "Container[str]",
                "bool",
                "Union[List, Dict]"
            ],
            "arguments": {}
        },
        "train_df": {
            "name": "train_df",
            "location": 35,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "holdout_df": {
            "name": "holdout_df",
            "location": 76,
            "return": [
                "str",
                "Union[str, Dict]"
            ],
            "arguments": {}
        },
        "train_fn": {
            "name": "train_fn",
            "location": 91,
            "return": [
                "bytearray",
                "List[int]",
                "float",
                "str"
            ],
            "arguments": {}
        },
        "eval_fn": {
            "name": "eval_fn",
            "location": 99,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "test_remove_by_feature_importance": {
            "name": "test_remove_by_feature_importance",
            "location": 103,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "bool",
                    "Optional[float]"
                ]
            }
        },
        "test_remove_features_subsets": {
            "name": "test_remove_features_subsets",
            "location": 109,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "bool",
                    "str"
                ],
                "base_extractor": [
                    "bool",
                    "str"
                ],
                "metric_name": [
                    "bool",
                    "str"
                ]
            }
        },
        "test_remove_by_shuffling": {
            "name": "test_remove_by_shuffling",
            "location": 114,
            "return": [
                ""
            ],
            "arguments": {
                "train_df": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[float, float, float, float]"
                ],
                "holdout_df": [],
                "train_fn": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[float, float, float, float]"
                ],
                "eval_fn": [],
                "base_extractor": [],
                "metric_name": [],
                "logs": []
            }
        }
    },
    "fklearn-master/tests/tuning/test_selectors.py": {
        "logs": {
            "name": "logs",
            "location": 18,
            "return": [
                "str",
                "list",
                "float",
                "Dict[str, Any]",
                "tuple",
                "Callable[..., None]",
                "dict"
            ],
            "arguments": {}
        },
        "parallel_logs": {
            "name": "parallel_logs",
            "location": 23,
            "return": [
                "str",
                "List[Dict[str, Any]]",
                "tuple",
                "float",
                "list",
                "int"
            ],
            "arguments": {}
        },
        "base_extractor": {
            "name": "base_extractor",
            "location": 28,
            "return": [
                "str",
                "int",
                "MutableSequence[utils.CWLObjectType]",
                "List[Callable]"
            ],
            "arguments": {}
        },
        "metric_name": {
            "name": "metric_name",
            "location": 33,
            "return": [
                "str",
                "int",
                "Dict[str, Any]",
                "Container[str]",
                "bool",
                "Union[List, Dict]"
            ],
            "arguments": {}
        },
        "train_df": {
            "name": "train_df",
            "location": 38,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "holdout_df": {
            "name": "holdout_df",
            "location": 79,
            "return": [
                "str",
                "Union[str, Dict]"
            ],
            "arguments": {}
        },
        "train_fn": {
            "name": "train_fn",
            "location": 94,
            "return": [
                "bytearray",
                "List[int]",
                "float",
                "str"
            ],
            "arguments": {}
        },
        "eval_fn": {
            "name": "eval_fn",
            "location": 102,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "split_fn": {
            "name": "split_fn",
            "location": 107,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "test_feature_importance_backward_selection": {
            "name": "test_feature_importance_backward_selection",
            "location": 111,
            "return": [
                ""
            ],
            "arguments": {
                "train_df": [
                    "str",
                    "bool",
                    "Callable",
                    "Optional[Mapping[str, Any]]"
                ],
                "train_fn": [
                    "str",
                    "bool",
                    "Callable",
                    "Optional[Mapping[str, Any]]"
                ],
                "eval_fn": [
                    "str",
                    "bool",
                    "Callable",
                    "Optional[Mapping[str, Any]]"
                ],
                "split_fn": [
                    "str",
                    "bool",
                    "Callable",
                    "Optional[Mapping[str, Any]]"
                ],
                "base_extractor": [
                    "str",
                    "bool",
                    "Callable",
                    "Optional[Mapping[str, Any]]"
                ],
                "metric_name": [
                    "str",
                    "bool",
                    "Callable",
                    "Optional[Mapping[str, Any]]"
                ]
            }
        },
        "test_poor_man_boruta_selection": {
            "name": "test_poor_man_boruta_selection",
            "location": 132,
            "return": [
                ""
            ],
            "arguments": {
                "train_df": [
                    "float",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ],
                "holdout_df": [
                    "float",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ],
                "train_fn": [
                    "float",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ],
                "eval_fn": [
                    "float",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ],
                "base_extractor": [
                    "float",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ],
                "metric_name": [
                    "float",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ]
            }
        },
        "test_backward_subset_feature_selection": {
            "name": "test_backward_subset_feature_selection",
            "location": 160,
            "return": [
                ""
            ],
            "arguments": {
                "train_df": [
                    "Callable",
                    "str",
                    "bool",
                    "int",
                    "Collection[str]"
                ],
                "train_fn": [
                    "Callable",
                    "str",
                    "bool",
                    "int",
                    "Collection[str]"
                ],
                "eval_fn": [
                    "Callable",
                    "str",
                    "bool",
                    "int",
                    "Collection[str]"
                ],
                "split_fn": [
                    "Callable",
                    "str",
                    "bool",
                    "int",
                    "Collection[str]"
                ],
                "base_extractor": [
                    "Callable",
                    "str",
                    "bool",
                    "int",
                    "Collection[str]"
                ],
                "metric_name": [
                    "Callable",
                    "str",
                    "bool",
                    "int",
                    "Collection[str]"
                ]
            }
        }
    },
    "fklearn-master/tests/tuning/test_stoppers.py": {
        "logs": {
            "name": "logs",
            "location": 12,
            "return": [
                "str",
                "list",
                "float",
                "Dict[str, Any]",
                "tuple",
                "Callable[..., None]",
                "dict"
            ],
            "arguments": {}
        },
        "parallel_logs": {
            "name": "parallel_logs",
            "location": 17,
            "return": [
                "str",
                "List[Dict[str, Any]]",
                "tuple",
                "float",
                "list",
                "int"
            ],
            "arguments": {}
        },
        "base_extractor": {
            "name": "base_extractor",
            "location": 22,
            "return": [
                "str",
                "int",
                "List[Callable]"
            ],
            "arguments": {}
        },
        "metric_name": {
            "name": "metric_name",
            "location": 27,
            "return": [
                "str",
                "int",
                "Dict[str, Any]",
                "Container[str]",
                "bool",
                "Union[List, Dict]"
            ],
            "arguments": {}
        },
        "test_stop_by_iter_num": {
            "name": "test_stop_by_iter_num",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "bool",
                    "tests._TestServerFactory",
                    "bytes"
                ]
            }
        },
        "test_stop_by_no_improvement": {
            "name": "test_stop_by_no_improvement",
            "location": 36,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "bool",
                    "Callable",
                    "int",
                    "Optional[str]"
                ],
                "base_extractor": [
                    "str",
                    "bool",
                    "Callable",
                    "int",
                    "Optional[str]"
                ],
                "metric_name": [
                    "str",
                    "bool",
                    "Callable",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "test_stop_by_num_features": {
            "name": "test_stop_by_num_features",
            "location": 44,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "List[Dict[str, float]]"
                ]
            }
        },
        "test_stop_by_no_improvement_parallel": {
            "name": "test_stop_by_no_improvement_parallel",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "parallel_logs": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "base_extractor": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "metric_name": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "test_stop_by_num_features_parallel": {
            "name": "test_stop_by_num_features_parallel",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {
                "parallel_logs": [
                    "bool",
                    "Optional[str]",
                    "T",
                    "Container[T]",
                    "int"
                ],
                "base_extractor": [
                    "bool",
                    "Optional[str]",
                    "T",
                    "Container[T]",
                    "int"
                ],
                "metric_name": [
                    "bool",
                    "Optional[str]",
                    "T",
                    "Container[T]",
                    "int"
                ]
            }
        }
    },
    "fklearn-master/tests/tuning/test_utils.py": {
        "logs": {
            "name": "logs",
            "location": 12,
            "return": [
                "Tuple[pandas.DataFrame, pandas.DataFrame]",
                "float",
                "List[str]",
                "int",
                "Union[numpy.ndarray, pandas.DataFrame, None]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "base_extractor": {
            "name": "base_extractor",
            "location": 50,
            "return": [
                "str",
                "int",
                "MutableSequence[utils.CWLObjectType]",
                "List[Callable]"
            ],
            "arguments": {}
        },
        "metric_name": {
            "name": "metric_name",
            "location": 55,
            "return": [
                "str",
                "int",
                "Dict[str, Any]",
                "Container[str]",
                "bool",
                "Union[List, Dict]"
            ],
            "arguments": {}
        },
        "train_df": {
            "name": "train_df",
            "location": 60,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "holdout_df": {
            "name": "holdout_df",
            "location": 101,
            "return": [
                "str",
                "Union[str, Dict]"
            ],
            "arguments": {}
        },
        "train_fn": {
            "name": "train_fn",
            "location": 116,
            "return": [
                "bytearray",
                "List[int]",
                "float",
                "str"
            ],
            "arguments": {}
        },
        "test_get_avg_metric_from_extractor": {
            "name": "test_get_avg_metric_from_extractor",
            "location": 123,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str"
                ],
                "base_extractor": [
                    "str"
                ],
                "metric_name": [
                    "str"
                ]
            }
        },
        "test_get_best_performing_log": {
            "name": "test_get_best_performing_log",
            "location": 128,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "List[List[int]]"
                ],
                "base_extractor": [
                    "str",
                    "dict"
                ],
                "metric_name": [
                    "str",
                    "dict"
                ]
            }
        },
        "test_get_used_features": {
            "name": "test_get_used_features",
            "location": 133,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "dict",
                    "Callable",
                    "Sequence[Any]",
                    "Iterable[T]"
                ]
            }
        },
        "test_order_feature_importance_avg_from_logs": {
            "name": "test_order_feature_importance_avg_from_logs",
            "location": 138,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "int"
                ]
            }
        },
        "test_gen_key_avgs_from_logs": {
            "name": "test_gen_key_avgs_from_logs",
            "location": 143,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "str",
                    "dict",
                    "Optional[List[str]]",
                    "float"
                ]
            }
        },
        "test_gen_key_avgs_from_iteration": {
            "name": "test_gen_key_avgs_from_iteration",
            "location": 148,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "Dict[str, Any]",
                    "Dict[str, raiden.utils.Any]",
                    "List[int]",
                    "raiden.utils.List[raiden.utils.FeeAmount]"
                ]
            }
        },
        "test_gen_key_avgs_from_dicts": {
            "name": "test_gen_key_avgs_from_dicts",
            "location": 153,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_gen_dict_extract": {
            "name": "test_gen_dict_extract",
            "location": 160,
            "return": [
                ""
            ],
            "arguments": {
                "logs": [
                    "List[str]",
                    "List[Tuple[str, str, str, str]]",
                    "List[Tuple[str, str, str]]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "fklearn-master/tests/tuning/__init__.py": {},
    "fklearn-master/tests/validation/test_evaluators.py": {
        "test_combined_evaluators": {
            "name": "test_combined_evaluators",
            "location": 17,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_mean_prediction_evaluator": {
            "name": "test_mean_prediction_evaluator",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_auc_evaluator": {
            "name": "test_auc_evaluator",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_roc_auc_evaluator": {
            "name": "test_roc_auc_evaluator",
            "location": 66,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_pr_auc_evaluator": {
            "name": "test_pr_auc_evaluator",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_precision_evaluator": {
            "name": "test_precision_evaluator",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_recall_evaluator": {
            "name": "test_recall_evaluator",
            "location": 118,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_fbeta_score_evaluator": {
            "name": "test_fbeta_score_evaluator",
            "location": 136,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_logloss_evaluator": {
            "name": "test_logloss_evaluator",
            "location": 155,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_brier_score_evaluator": {
            "name": "test_brier_score_evaluator",
            "location": 172,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_binary_calibration_evaluator": {
            "name": "test_binary_calibration_evaluator",
            "location": 189,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_r2_evaluator": {
            "name": "test_r2_evaluator",
            "location": 228,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_mse_evaluator": {
            "name": "test_mse_evaluator",
            "location": 241,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_correlation_evaluator": {
            "name": "test_correlation_evaluator",
            "location": 254,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_spearman_evaluator": {
            "name": "test_spearman_evaluator",
            "location": 267,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_linear_coefficient_evaluator": {
            "name": "test_linear_coefficient_evaluator",
            "location": 280,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_ndcg_evaluator": {
            "name": "test_ndcg_evaluator",
            "location": 294,
            "return": [
                ""
            ],
            "arguments": {
                "exponential_gain": [
                    "str",
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_split_evaluator": {
            "name": "test_split_evaluator",
            "location": 321,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_temporal_split_evaluator": {
            "name": "test_temporal_split_evaluator",
            "location": 340,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_permutation_evaluator": {
            "name": "test_permutation_evaluator",
            "location": 361,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_hash_evaluator": {
            "name": "test_hash_evaluator",
            "location": 415,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_exponential_coefficient_evaluator": {
            "name": "test_exponential_coefficient_evaluator",
            "location": 458,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_logistic_coefficient_evaluator": {
            "name": "test_logistic_coefficient_evaluator",
            "location": 475,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_permutation_evaluator.fake_predict": {
            "name": "fake_predict",
            "location": 372,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_permutation_evaluator.fake_predict2": {
            "name": "fake_predict2",
            "location": 403,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "fklearn-master/tests/validation/test_perturbators.py": {
        "test_shift_mu": {
            "name": "test_shift_mu",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_random_noise": {
            "name": "test_random_noise",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_nullify": {
            "name": "test_nullify",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_sample_columns": {
            "name": "test_sample_columns",
            "location": 29,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_perturbator": {
            "name": "test_perturbator",
            "location": 37,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/validation/test_splitters.py": {
        "test_k_fold_splitter": {
            "name": "test_k_fold_splitter",
            "location": 19,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_out_of_time_and_space_splitter": {
            "name": "test_out_of_time_and_space_splitter",
            "location": 55,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_time_and_space_learning_curve_splitter": {
            "name": "test_time_and_space_learning_curve_splitter",
            "location": 81,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_spatial_learning_curve_splitter": {
            "name": "test_spatial_learning_curve_splitter",
            "location": 109,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_time_learning_curve_splitter": {
            "name": "test_time_learning_curve_splitter",
            "location": 158,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_reverse_time_learning_curve_splitter": {
            "name": "test_reverse_time_learning_curve_splitter",
            "location": 190,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_stability_curve_time_splitter": {
            "name": "test_stability_curve_time_splitter",
            "location": 221,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_stability_curve_time_in_space_splitter": {
            "name": "test_stability_curve_time_in_space_splitter",
            "location": 245,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_stability_curve_time_space_splitter": {
            "name": "test_stability_curve_time_space_splitter",
            "location": 263,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_forward_stability_curve_time_splitter": {
            "name": "test_forward_stability_curve_time_splitter",
            "location": 297,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "fklearn-master/tests/validation/test_validator.py": {
        "train_fn": {
            "name": "train_fn",
            "location": 10,
            "return": [
                "int"
            ],
            "arguments": {
                "df": [
                    "List[int]",
                    "int",
                    "Sequence[T]",
                    "list",
                    "bool",
                    "str"
                ]
            }
        },
        "eval_fn": {
            "name": "eval_fn",
            "location": 29,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "test_data": [
                    "str",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "split_fn": {
            "name": "split_fn",
            "location": 33,
            "return": [
                "Callable[[T], bool]",
                "str",
                "List[Tuple]",
                "bool"
            ],
            "arguments": {
                "df": [
                    "str",
                    "Iterable[T]",
                    "list",
                    "Iterator[T]",
                    "Iterable[str]",
                    "bool"
                ]
            }
        },
        "test_validator_iteration": {
            "name": "test_validator_iteration",
            "location": 47,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_validator": {
            "name": "test_validator",
            "location": 65,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_parallel_validator": {
            "name": "test_parallel_validator",
            "location": 85,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "train_fn.p": {
            "name": "p",
            "location": 11,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "new_df": [
                    "List[str]"
                ]
            }
        }
    },
    "fklearn-master/tests/validation/__init__.py": {}
}
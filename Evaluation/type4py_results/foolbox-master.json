{
    "foolbox-master/setup.py": {},
    "foolbox-master/docs/conf.py": {},
    "foolbox-master/examples/multiple_attacks_pytorch_resnet18.py": {},
    "foolbox-master/examples/single_attack_pytorch_resnet18.py": {
        "main": {
            "name": "main",
            "location": 13,
            "return": [],
            "arguments": {}
        }
    },
    "foolbox-master/examples/single_attack_tensorflow_resnet50.py": {
        "main": {
            "name": "main",
            "location": 8,
            "return": [],
            "arguments": {}
        }
    },
    "foolbox-master/examples/spatial_attack_pytorch_resnet18.py": {
        "main": {
            "name": "main",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "foolbox-master/examples/substituion_model_pytorch_resnet18.py": {
        "main": {
            "name": "main",
            "location": 16,
            "return": [],
            "arguments": {}
        },
        "main.Attack.value_and_grad": {
            "name": "value_and_grad",
            "location": 35,
            "return": [],
            "arguments": {
                "self": [],
                "loss_fn": [],
                "x": []
            }
        },
        "main.Attack.run": {
            "name": "run",
            "location": 41,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "inputs": [],
                "criterion": []
            }
        }
    },
    "foolbox-master/examples/zoo/mnist/foolbox_model.py": {
        "create": {
            "name": "create",
            "location": 9,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {}
        }
    },
    "foolbox-master/foolbox/criteria.py": {
        "Criterion.__repr__": {
            "name": "__repr__",
            "location": 59,
            "return": [
                "builtins.str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Criterion.__call__": {
            "name": "__call__",
            "location": 63,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "perturbed": [
                    "T"
                ],
                "outputs": [
                    "T"
                ]
            }
        },
        "Criterion.__and__": {
            "name": "__and__",
            "location": 75,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "T",
                    "Tuple[int, int]"
                ]
            }
        },
        "_And.__init__": {
            "name": "__init__",
            "location": 80,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "a": [
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "b": [
                    "int",
                    "bytes",
                    "str"
                ]
            }
        },
        "_And.__repr__": {
            "name": "__repr__",
            "location": 85,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_And.__call__": {
            "name": "__call__",
            "location": 88,
            "return": [],
            "arguments": {
                "self": [],
                "perturbed": [
                    "T",
                    "Callable",
                    "\"Shape\""
                ],
                "outputs": [
                    "T",
                    "Callable",
                    "\"Shape\""
                ]
            }
        },
        "Misclassification.__init__": {
            "name": "__init__",
            "location": 104,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "str",
                    "bool",
                    "List[List[Any]]",
                    "Optional[str]"
                ]
            }
        },
        "Misclassification.__repr__": {
            "name": "__repr__",
            "location": 108,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Misclassification.__call__": {
            "name": "__call__",
            "location": 111,
            "return": [],
            "arguments": {
                "self": [],
                "perturbed": [
                    "T",
                    "str",
                    "IO",
                    "float"
                ],
                "outputs": [
                    "T",
                    "\"PerceptionGraphPattern\"",
                    "Callable",
                    "Exception",
                    "int"
                ]
            }
        },
        "TargetedMisclassification.__init__": {
            "name": "__init__",
            "location": 129,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "target_classes": [
                    "bool",
                    "int",
                    "Hashable",
                    "Optional[int]"
                ]
            }
        },
        "TargetedMisclassification.__repr__": {
            "name": "__repr__",
            "location": 133,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TargetedMisclassification.__call__": {
            "name": "__call__",
            "location": 136,
            "return": [],
            "arguments": {
                "self": [],
                "perturbed": [
                    "T",
                    "str",
                    "IO",
                    "float"
                ],
                "outputs": [
                    "T",
                    "\"PerceptionGraphPattern\"",
                    "Callable",
                    "Exception",
                    "int"
                ]
            }
        }
    },
    "foolbox-master/foolbox/devutils.py": {
        "flatten": {
            "name": "flatten",
            "location": 5,
            "return": [
                "bool",
                "int",
                "float"
            ],
            "arguments": {
                "x": [
                    "int",
                    "eagerpy.Tensor",
                    "float",
                    "dict"
                ],
                "keep": [
                    "int",
                    "eagerpy.Tensor",
                    "float",
                    "dict"
                ]
            }
        },
        "atleast_kd": {
            "name": "atleast_kd",
            "location": 9,
            "return": [
                "str"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "int",
                    "List[int]",
                    "Callable[[Any], T]"
                ],
                "k": [
                    "int",
                    "eagerpy.Tensor",
                    "Tuple[\"ndarray\", \"ndarray\", \"ndarray\"]",
                    "str"
                ]
            }
        }
    },
    "foolbox-master/foolbox/distances.py": {
        "Distance.__call__": {
            "name": "__call__",
            "location": 14,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "reference": [
                    "T",
                    "float"
                ],
                "perturbed": [
                    "T",
                    "float"
                ]
            }
        },
        "Distance.clip_perturbation": {
            "name": "clip_perturbation",
            "location": 18,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "references": [
                    "T",
                    "float",
                    "int"
                ],
                "perturbed": [
                    "T",
                    "float",
                    "int"
                ],
                "epsilon": [
                    "T",
                    "float",
                    "int"
                ]
            }
        },
        "LpDistance.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "p": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LpDistance.__repr__": {
            "name": "__repr__",
            "location": 26,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LpDistance.__str__": {
            "name": "__str__",
            "location": 29,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LpDistance.__call__": {
            "name": "__call__",
            "location": 32,
            "return": [],
            "arguments": {
                "self": [],
                "references": [
                    "T"
                ],
                "perturbed": [
                    "T"
                ]
            }
        },
        "LpDistance.clip_perturbation": {
            "name": "clip_perturbation",
            "location": 46,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "references": [
                    "T"
                ],
                "perturbed": [
                    "T"
                ],
                "epsilon": [
                    "float",
                    "Iterable[str]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/gradient_estimators.py": {
        "evolutionary_strategies_gradient_estimator": {
            "name": "evolutionary_strategies_gradient_estimator",
            "location": 7,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "AttackCls": [
                    "Dict[str, int]",
                    "int",
                    "dict"
                ]
            }
        },
        "evolutionary_strategies_gradient_estimator.GradientEstimator.value_and_grad": {
            "name": "value_and_grad",
            "location": 24,
            "return": [
                "str",
                "int",
                "Type[T]"
            ],
            "arguments": {
                "self": [],
                "loss_fn": [
                    "Callable[[eagerpy.Tensor], eagerpy.Tensor]",
                    "int",
                    "float",
                    "str",
                    "list"
                ],
                "x": [
                    "eagerpy.Tensor",
                    "float",
                    "snorkel.types.DataPoint"
                ]
            }
        }
    },
    "foolbox-master/foolbox/plot.py": {
        "images": {
            "name": "images",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "images": [
                    "Tuple[float, float]",
                    "bool",
                    "int",
                    "List[int]",
                    "str"
                ]
            }
        }
    },
    "foolbox-master/foolbox/tensorboard.py": {
        "maybenoop": {
            "name": "maybenoop",
            "location": 12,
            "return": [
                "str",
                "int",
                "dict"
            ],
            "arguments": {
                "f": [
                    "Iterable[str]",
                    "Callable",
                    "T"
                ]
            }
        },
        "maybenoop.wrapper": {
            "name": "wrapper",
            "location": 14,
            "return": [
                "bool",
                "tuple",
                "List[List[str]]"
            ],
            "arguments": {
                "self": [
                    "Callable",
                    "BaseException"
                ]
            }
        },
        "TensorBoard.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "logdir": [
                    "Optional[int]",
                    "Optional[float]",
                    "Optional[str]",
                    "Optional[Callable]",
                    "Optional[Hashable]"
                ]
            }
        },
        "TensorBoard.close": {
            "name": "close",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TensorBoard.scalar": {
            "name": "scalar",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "Optional[str]",
                    "FrozenSet[Any]",
                    "bool"
                ],
                "x": [
                    "Optional[str]",
                    "FrozenSet[Any]",
                    "bool"
                ],
                "step": [
                    "Optional[str]",
                    "FrozenSet[Any]",
                    "bool"
                ]
            }
        },
        "TensorBoard.mean": {
            "name": "mean",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "x": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "step": [
                    "str",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "TensorBoard.probability": {
            "name": "probability",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "bool",
                    "List[str]"
                ],
                "x": [
                    "str",
                    "bool",
                    "List[str]"
                ],
                "step": [
                    "str",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "TensorBoard.conditional_mean": {
            "name": "conditional_mean",
            "location": 55,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "x": [
                    "str",
                    "bool",
                    "Sequence[float]",
                    "float",
                    "list"
                ],
                "cond": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "Sequence"
                ],
                "step": [
                    "str",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "TensorBoard.probability_ratio": {
            "name": "probability_ratio",
            "location": 66,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "int",
                    "Optional[Callable]",
                    "bool",
                    "Optional[int]",
                    "Optional[Union[int, Any]]",
                    "float",
                    "Tuple[int]"
                ],
                "x": [
                    "int",
                    "str",
                    "bool"
                ],
                "y": [
                    "str",
                    "float",
                    "bool",
                    "Callable",
                    "Sequence[float]"
                ],
                "step": [
                    "int",
                    "Optional[Callable]",
                    "bool",
                    "Optional[int]",
                    "Optional[Union[int, Any]]",
                    "float",
                    "Tuple[int]"
                ]
            }
        },
        "TensorBoard.histogram": {
            "name": "histogram",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "List[int]",
                    "bytes",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ],
                "x": [
                    "bytes",
                    "Sequence[Sequence[Any]]",
                    "list",
                    "List[str]"
                ],
                "step": [
                    "List[int]",
                    "bytes",
                    "bool",
                    "str",
                    "int",
                    "List[str]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/types.py": {},
    "foolbox-master/foolbox/utils.py": {
        "accuracy": {
            "name": "accuracy",
            "location": 11,
            "return": [
                "list",
                "List[T]",
                "List[float]",
                "int"
            ],
            "arguments": {
                "fmodel": [
                    "bool",
                    "Sequence[str]",
                    "str"
                ],
                "inputs": [
                    "bool",
                    "int",
                    "numpy.array"
                ],
                "labels": [
                    "bool",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "samples": {
            "name": "samples",
            "location": 20,
            "return": [
                "str",
                "Union[str, List[str]]",
                "PIL.Image.Image",
                "numpy.ndarray"
            ],
            "arguments": {
                "fmodel": [
                    "models.Model",
                    "str",
                    "zerver.models.DefaultStreamGroup",
                    "int"
                ],
                "dataset": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "utils.types.Vec3D",
                    "bool"
                ],
                "index": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "utils.types.Vec3D",
                    "bool"
                ],
                "batchsize": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "utils.types.Vec3D",
                    "bool"
                ],
                "shape": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "utils.types.Vec3D",
                    "bool"
                ],
                "data_format": [
                    "Optional[str]",
                    "int",
                    "bool",
                    "str"
                ],
                "bounds": [
                    "str",
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "_samples": {
            "name": "_samples",
            "location": 62,
            "return": [
                "str",
                "Union[str, List[str]]",
                "PIL.Image.Image",
                "numpy.ndarray"
            ],
            "arguments": {
                "dataset": [
                    "Pattern",
                    "str",
                    "Set[str]",
                    "Optional[int]"
                ],
                "index": [
                    "int",
                    "List[str]"
                ],
                "batchsize": [
                    "int",
                    "List[str]"
                ],
                "shape": [
                    "Tuple[int, int]",
                    "types.Bounds",
                    "str",
                    "int",
                    "tuple",
                    "float"
                ],
                "data_format": [
                    "bool",
                    "Optional[str]",
                    "str",
                    "Iterable[Dict[str, Any]]"
                ],
                "bounds": [
                    "Tuple[int, int]",
                    "types.Bounds",
                    "str",
                    "int",
                    "tuple",
                    "float"
                ]
            }
        }
    },
    "foolbox-master/foolbox/__init__.py": {},
    "foolbox-master/foolbox/attacks/additive_noise.py": {
        "BaseAdditiveNoiseAttack.run": {
            "name": "run",
            "location": 24,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "int",
                    "Union[criteria.Criterion, Any]",
                    "float",
                    "Union[base.Criterion, Any]",
                    "Dict[str, Any]"
                ]
            }
        },
        "BaseAdditiveNoiseAttack.sample_noise": {
            "name": "sample_noise",
            "location": 48,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "BaseAdditiveNoiseAttack.get_epsilons": {
            "name": "get_epsilons",
            "location": 52,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "p": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "min_": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "max_": [
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        },
        "L2Mixin.get_epsilons": {
            "name": "get_epsilons",
            "location": 61,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "p": [
                    "float",
                    "int",
                    "str",
                    "base.cell.Cell"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "str",
                    "base.cell.Cell"
                ],
                "min_": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "max_": [
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        },
        "L2ClippingAwareMixin.get_epsilons": {
            "name": "get_epsilons",
            "location": 71,
            "return": [
                "str",
                "Iterable[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ],
                "p": [
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ],
                "min_": [
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ],
                "max_": [
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        },
        "LinfMixin.get_epsilons": {
            "name": "get_epsilons",
            "location": 82,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "p": [
                    "float",
                    "int",
                    "str",
                    "base.cell.Cell"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "str",
                    "base.cell.Cell"
                ],
                "min_": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "max_": [
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        },
        "GaussianMixin.sample_noise": {
            "name": "sample_noise",
            "location": 90,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "int",
                    "bytes"
                ]
            }
        },
        "UniformMixin.sample_noise": {
            "name": "sample_noise",
            "location": 95,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "int",
                    "bytes"
                ]
            }
        },
        "BaseRepeatedAdditiveNoiseAttack.__init__": {
            "name": "__init__",
            "location": 152,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseRepeatedAdditiveNoiseAttack.run": {
            "name": "run",
            "location": 156,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model",
                    "int",
                    "Callable[[str], str]",
                    "models.base.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "Union[base.Criterion, Any]",
                    "int",
                    "Callable"
                ]
            }
        },
        "BaseRepeatedAdditiveNoiseAttack.sample_noise": {
            "name": "sample_noise",
            "location": 198,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "BaseRepeatedAdditiveNoiseAttack.get_epsilons": {
            "name": "get_epsilons",
            "location": 202,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "p": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "min_": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "max_": [
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/base.py": {
        "get_is_adversarial": {
            "name": "get_is_adversarial",
            "location": 459,
            "return": [
                "bool"
            ],
            "arguments": {
                "criterion": [
                    "models.Model",
                    "str",
                    "bool",
                    "Optional[Any]",
                    "int",
                    "IO"
                ],
                "model": [
                    "models.Model",
                    "str",
                    "bool",
                    "Optional[Any]",
                    "int",
                    "IO"
                ]
            }
        },
        "get_criterion": {
            "name": "get_criterion",
            "location": 469,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "criterion": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ]
            }
        },
        "get_channel_axis": {
            "name": "get_channel_axis",
            "location": 476,
            "return": [
                "Optional[int]",
                "Optional[Dict]",
                "bool",
                "Optional[str]",
                "dict",
                "str"
            ],
            "arguments": {
                "model": [
                    "django.db.models.Model",
                    "zerver.models.Realm",
                    "allennlp.models.Model",
                    "peewee.Model",
                    "models.Model",
                    "str",
                    "dict"
                ],
                "ndim": [
                    "int",
                    "List[Dict[str, str]]",
                    "List[Tuple[str, str]]",
                    "List[str]",
                    "Exception",
                    "dict",
                    "str",
                    "Type[T]"
                ]
            }
        },
        "raise_if_kwargs": {
            "name": "raise_if_kwargs",
            "location": 489,
            "return": [
                "None"
            ],
            "arguments": {
                "kwargs": []
            }
        },
        "verify_input_bounds": {
            "name": "verify_input_bounds",
            "location": 496,
            "return": [
                "None"
            ],
            "arguments": {
                "input": [
                    "Type[T]",
                    "bool",
                    "allennlp.models.Model",
                    "Model",
                    "Type"
                ],
                "model": [
                    "Type[T]",
                    "bool",
                    "allennlp.models.Model",
                    "Model",
                    "Type"
                ]
            }
        },
        "Attack.__call__": {
            "name": "__call__",
            "location": 50,
            "return": [
                "typing.Union[typing.Tuple[typing.List[T], typing.List[T], T], typing.Tuple[T, T, T]]"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "Union[float, None]",
                    "T",
                    "Sequence[Union[float, None]]"
                ],
                "inputs": [
                    "models.Model",
                    "Union[float, None]",
                    "T",
                    "Sequence[Union[float, None]]"
                ],
                "criterion": [
                    "models.Model",
                    "Union[float, None]",
                    "T",
                    "Sequence[Union[float, None]]"
                ]
            }
        },
        "Attack.repeat": {
            "name": "repeat",
            "location": 65,
            "return": [
                "\"Attack\""
            ],
            "arguments": {
                "self": [],
                "times": [
                    "float",
                    "int",
                    "str",
                    "Sequence[str]"
                ]
            }
        },
        "Attack.__repr__": {
            "name": "__repr__",
            "location": 68,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttackWithDistance.distance": {
            "name": "distance",
            "location": 76,
            "return": [
                "distances.Distance"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttackWithDistance.repeat": {
            "name": "repeat",
            "location": 79,
            "return": [
                "int",
                "List[str]",
                "posts.models.Post",
                "str",
                "Optional[float]"
            ],
            "arguments": {
                "self": [],
                "times": [
                    "int",
                    "float"
                ]
            }
        },
        "Repeated.__init__": {
            "name": "__init__",
            "location": 86,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "attack": [
                    "int",
                    "float"
                ],
                "times": [
                    "float",
                    "int",
                    "Tuple[float, float]",
                    "bool"
                ]
            }
        },
        "Repeated.distance": {
            "name": "distance",
            "location": 94,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Repeated.__call__": {
            "name": "__call__",
            "location": 121,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "Iterable[T]",
                    "Callable"
                ],
                "inputs": [
                    "T"
                ],
                "criterion": [
                    "models.Model",
                    "base.Model",
                    "models.base.Model"
                ]
            }
        },
        "Repeated.repeat": {
            "name": "repeat",
            "location": 200,
            "return": [
                "float",
                "str",
                "int",
                "Tuple[int, int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "times": [
                    "float",
                    "int"
                ]
            }
        },
        "FixedEpsilonAttack.run": {
            "name": "run",
            "location": 209,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Optional[float]",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "inputs": [
                    "Optional[float]",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "FixedEpsilonAttack.__call__": {
            "name": "__call__",
            "location": 244,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "models.base.Model",
                    "base.Model",
                    "Iterable[T]",
                    "Callable"
                ],
                "inputs": [
                    "T"
                ],
                "criterion": [
                    "models.base.Model",
                    "TestModule.Model"
                ]
            }
        },
        "MinimizationAttack.run": {
            "name": "run",
            "location": 342,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Optional[float]",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "inputs": [
                    "Optional[float]",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "MinimizationAttack.__call__": {
            "name": "__call__",
            "location": 384,
            "return": [
                "tuple",
                "Type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "models.base.Model",
                    "base.Model",
                    "Iterable[T]",
                    "Callable"
                ],
                "inputs": [
                    "T"
                ],
                "criterion": [
                    "models.base.Model",
                    "TestModule.Model"
                ]
            }
        },
        "FlexibleDistanceMinimizationAttack.__init__": {
            "name": "__init__",
            "location": 444,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FlexibleDistanceMinimizationAttack.distance": {
            "name": "distance",
            "location": 448,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "get_is_adversarial.is_adversarial": {
            "name": "is_adversarial",
            "location": 462,
            "return": [
                "str",
                "List[int]",
                "dict",
                "Iterable[str]"
            ],
            "arguments": {
                "perturbed": [
                    "eagerpy.Tensor",
                    "int",
                    "models.Model"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/basic_iterative_method.py": {
        "L1BasicIterativeAttack.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L2BasicIterativeAttack.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinfBasicIterativeAttack.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L1AdamBasicIterativeAttack.__init__": {
            "name": "__init__",
            "location": 98,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L2AdamBasicIterativeAttack.__init__": {
            "name": "__init__",
            "location": 131,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinfAdamBasicIterativeAttack.__init__": {
            "name": "__init__",
            "location": 164,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinfAdamBasicIterativeAttack.get_optimizer": {
            "name": "get_optimizer",
            "location": 186,
            "return": [
                "str",
                "List[int]",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ],
                "stepsize": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/binarization.py": {
        "BinarizationRefinementAttack.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "BinarizationRefinementAttack.run": {
            "name": "run",
            "location": 45,
            "return": [
                "type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "pystork.model.Model",
                    "numpy.array",
                    "Union[criteria.Criterion, base.T]",
                    "text_recognizer.models.base.Model",
                    "models.Model",
                    "Optional[float]"
                ],
                "inputs": [
                    "base.T",
                    "float",
                    "int"
                ],
                "criterion": [
                    "int",
                    "numpy.array",
                    "float",
                    "Union[criteria.Criterion, base.T]",
                    "models.Model",
                    "Optional[float]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/blended_noise.py": {
        "LinearSearchBlendedUniformNoiseAttack.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinearSearchBlendedUniformNoiseAttack.run": {
            "name": "run",
            "location": 45,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model",
                    "int",
                    "Callable[[str], str]",
                    "models.base.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "Union[base.Criterion, Any]",
                    "int",
                    "Callable"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/blur.py": {
        "GaussianBlurAttack.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianBlurAttack.run": {
            "name": "run",
            "location": 46,
            "return": [
                "magic.models.Card"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "taxonomy.db.models.Taxon",
                    "int",
                    "Iterable[T]"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "str",
                    "models.Model",
                    "Callable",
                    "Union[base.Criterion, Any]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/boundary_attack.py": {
        "draw_proposals": {
            "name": "draw_proposals",
            "location": 328,
            "return": [
                "str",
                "Iterator[str]",
                "Iterable[Sequence[str]]",
                "Sequence[str]"
            ],
            "arguments": {
                "bounds": [
                    "types.Bounds",
                    "bool",
                    "float",
                    "str"
                ],
                "originals": [
                    "float",
                    "Mapping[str, Tuple[float, float, float]]",
                    "Optional[int]"
                ],
                "perturbed": [
                    "str",
                    "Optional[Union[int, slice]]",
                    "Union[int, float]",
                    "starfish.types.Number",
                    "int",
                    "List[Tuple[int, int]]"
                ],
                "unnormalized_source_directions": [
                    "bool",
                    "Union[float, int]",
                    "List[str]",
                    "Optional[int]",
                    "Mapping[str, Any]",
                    "List[Callable]"
                ],
                "source_directions": [
                    "str",
                    "numpy.ndarray"
                ],
                "source_norms": [
                    "eagerpy.Tensor",
                    "bool",
                    "List[int]",
                    "int"
                ],
                "spherical_steps": [
                    "bool",
                    "eagerpy.Tensor",
                    "Tuple[int]",
                    "Callable",
                    "numpy.ndarray",
                    "int"
                ],
                "source_steps": [
                    "eagerpy.Tensor",
                    "Optional[int]",
                    "int",
                    "float",
                    "Optional[numpy.ndarray]",
                    "Tuple[int]",
                    "Callable"
                ]
            }
        },
        "BoundaryAttack.__init__": {
            "name": "__init__",
            "location": 68,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "init_attack": [
                    "bool",
                    "Optional[base.MinimizationAttack]",
                    "Optional[db.models.Taxon]",
                    "Optional[Tuple[float, float]]",
                    "Optional[bool]",
                    "Optional[int]",
                    "Optional[Type[Any]]"
                ],
                "steps": [
                    "str",
                    "int",
                    "bytes"
                ],
                "spherical_step": [
                    "str",
                    "int",
                    "bytes"
                ],
                "source_step": [
                    "type",
                    "dict",
                    "Callable",
                    "models.User",
                    "str",
                    "Optional[Callable]"
                ],
                "source_step_convergance": [
                    "Callable[[T], List[T]]",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ],
                "step_adaptation": [
                    "str",
                    "int",
                    "bytes"
                ],
                "tensorboard": [
                    "str",
                    "int",
                    "bytes"
                ],
                "update_stats_every_k": [
                    "bool"
                ]
            }
        },
        "BoundaryAttack.run": {
            "name": "run",
            "location": 90,
            "return": [
                "type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "pystork.model.Model",
                    "Union[criteria.Criterion, base.T]",
                    "models.Model",
                    "models.Route"
                ],
                "inputs": [
                    "base.T",
                    "int",
                    "bool",
                    "str"
                ],
                "criterion": [
                    "Union[criteria.Criterion, base.T]",
                    "pystork.model.Model",
                    "numpy.array",
                    "int",
                    "models.Model",
                    "float"
                ]
            }
        },
        "ArrayQueue.__init__": {
            "name": "__init__",
            "location": 286,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "maxlen": [
                    "int",
                    "float"
                ],
                "N": [
                    "int",
                    "float"
                ]
            }
        },
        "ArrayQueue.maxlen": {
            "name": "maxlen",
            "location": 294,
            "return": [
                "str",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayQueue.N": {
            "name": "N",
            "location": 298,
            "return": [
                "str",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayQueue.append": {
            "name": "append",
            "location": 301,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "snorkel.types.DataPoint",
                    "Dict[str, Any]",
                    "int",
                    "bool"
                ]
            }
        },
        "ArrayQueue.clear": {
            "name": "clear",
            "location": 309,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dims": [
                    "float",
                    "str",
                    "Iterable[str]",
                    "Union[numpy.ndarray, astropy.units.quantity.Quantity]",
                    "numpy.ndarray",
                    "models.scenes.scenes_base.Scene"
                ]
            }
        },
        "ArrayQueue.mean": {
            "name": "mean",
            "location": 317,
            "return": [
                "int",
                "bool",
                "db.models.taxon.FillDataLevel"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayQueue.isfull": {
            "name": "isfull",
            "location": 322,
            "return": [
                "int",
                "bool",
                "db.models.taxon.FillDataLevel"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "foolbox-master/foolbox/attacks/brendel_bethge.py": {
        "best_other_classes": {
            "name": "best_other_classes",
            "location": 599,
            "return": [],
            "arguments": {
                "logits": [],
                "exclude": []
            }
        },
        "Optimizer.__init__": {
            "name": "__init__",
            "location": 56,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Optimizer.solve": {
            "name": "solve",
            "location": 59,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "Optimizer._max_logit_diff": {
            "name": "_max_logit_diff",
            "location": 101,
            "return": [],
            "arguments": {
                "self": [],
                "x": [],
                "b": [],
                "_ell": [],
                "_u": [],
                "c": []
            }
        },
        "Optimizer._minimum_norm_to_boundary": {
            "name": "_minimum_norm_to_boundary",
            "location": 126,
            "return": [],
            "arguments": {
                "self": [],
                "x": [],
                "b": [],
                "_ell": [],
                "_u": [],
                "c": [],
                "bnorm": []
            }
        },
        "Optimizer.optimize_distance_s_t_boundary_and_trustregion": {
            "name": "optimize_distance_s_t_boundary_and_trustregion",
            "location": 217,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "Optimizer.optimize_boundary_s_t_trustregion_fun_and_jac": {
            "name": "optimize_boundary_s_t_trustregion_fun_and_jac",
            "location": 233,
            "return": [],
            "arguments": {
                "self": [],
                "params": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "Optimizer.safe_div": {
            "name": "safe_div",
            "location": 259,
            "return": [],
            "arguments": {
                "self": [],
                "nominator": [],
                "denominator": []
            }
        },
        "Optimizer.optimize_boundary_s_t_trustregion": {
            "name": "optimize_boundary_s_t_trustregion",
            "location": 267,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "BrendelBethgeAttack.__init__": {
            "name": "__init__",
            "location": 343,
            "return": [],
            "arguments": {
                "self": [],
                "init_attack": [],
                "overshoot": [],
                "steps": [],
                "lr": [],
                "lr_decay": [],
                "lr_num_decay": [],
                "momentum": [],
                "tensorboard": [],
                "binary_search_steps": []
            }
        },
        "BrendelBethgeAttack.run": {
            "name": "run",
            "location": 376,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "inputs": [],
                "criterion": []
            }
        },
        "BrendelBethgeAttack.instantiate_optimizer": {
            "name": "instantiate_optimizer",
            "location": 581,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BrendelBethgeAttack.norms": {
            "name": "norms",
            "location": 585,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "BrendelBethgeAttack.mid_points": {
            "name": "mid_points",
            "location": 589,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x1": [],
                "epsilons": [],
                "bounds": []
            }
        },
        "L2BrendelBethgeAttack.instantiate_optimizer": {
            "name": "instantiate_optimizer",
            "location": 623,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "L2BrendelBethgeAttack.norms": {
            "name": "norms",
            "location": 632,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "L2BrendelBethgeAttack.mid_points": {
            "name": "mid_points",
            "location": 635,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x1": [],
                "epsilons": [],
                "bounds": []
            }
        },
        "LinfinityBrendelBethgeAttack.instantiate_optimizer": {
            "name": "instantiate_optimizer",
            "location": 666,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LinfinityBrendelBethgeAttack.norms": {
            "name": "norms",
            "location": 669,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "LinfinityBrendelBethgeAttack.mid_points": {
            "name": "mid_points",
            "location": 672,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x1": [],
                "epsilons": [],
                "bounds": []
            }
        },
        "L1BrendelBethgeAttack.instantiate_optimizer": {
            "name": "instantiate_optimizer",
            "location": 713,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "L1BrendelBethgeAttack.norms": {
            "name": "norms",
            "location": 716,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "L1BrendelBethgeAttack.mid_points": {
            "name": "mid_points",
            "location": 719,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x1": [],
                "epsilons": [],
                "bounds": []
            }
        },
        "L0BrendelBethgeAttack.instantiate_optimizer": {
            "name": "instantiate_optimizer",
            "location": 760,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "L0BrendelBethgeAttack.norms": {
            "name": "norms",
            "location": 763,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "L0BrendelBethgeAttack.mid_points": {
            "name": "mid_points",
            "location": 766,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x1": [],
                "epsilons": [],
                "bounds": []
            }
        },
        "BFGSB.__init__": {
            "name": "__init__",
            "location": 788,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BFGSB.solve": {
            "name": "solve",
            "location": 791,
            "return": [],
            "arguments": {
                "self": [],
                "fun_and_jac": [],
                "q0": [],
                "bounds": [],
                "args": [],
                "ftol": [],
                "pgtol": [],
                "maxiter": []
            }
        },
        "BFGSB._cauchy_point": {
            "name": "_cauchy_point",
            "location": 903,
            "return": [],
            "arguments": {
                "self": [],
                "x": [],
                "l": [],
                "u": [],
                "g": [],
                "B": []
            }
        },
        "BFGSB._subspace_min": {
            "name": "_subspace_min",
            "location": 957,
            "return": [],
            "arguments": {
                "self": [],
                "x": [],
                "l": [],
                "u": [],
                "x_cp": [],
                "d": [],
                "G": []
            }
        },
        "BFGSB._project": {
            "name": "_project",
            "location": 998,
            "return": [],
            "arguments": {
                "self": [],
                "q": [],
                "l": [],
                "u": []
            }
        },
        "BFGSB._line_search_armijo": {
            "name": "_line_search_armijo",
            "location": 1008,
            "return": [],
            "arguments": {
                "self": [],
                "fun_and_jac": [],
                "pt": [],
                "dpt": [],
                "func_calls": [],
                "m": [],
                "gk": [],
                "l": [],
                "u": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "BFGSB._line_search_wolfe": {
            "name": "_line_search_wolfe",
            "location": 1045,
            "return": [],
            "arguments": {
                "self": [],
                "fun_and_jac": [],
                "xk": [],
                "pk": [],
                "gfk": [],
                "old_fval": [],
                "old_old_fval": [],
                "l": [],
                "u": [],
                "args": []
            }
        },
        "BFGSB._cubicmin": {
            "name": "_cubicmin",
            "location": 1338,
            "return": [],
            "arguments": {
                "self": [],
                "a": [],
                "fa": [],
                "fpa": [],
                "b": [],
                "fb": [],
                "c": [],
                "fc": []
            }
        },
        "BFGSB._quadmin": {
            "name": "_quadmin",
            "location": 1365,
            "return": [],
            "arguments": {
                "self": [],
                "a": [],
                "fa": [],
                "fpa": [],
                "b": [],
                "fb": []
            }
        },
        "L2Optimizer.optimize_distance_s_t_boundary_and_trustregion": {
            "name": "optimize_distance_s_t_boundary_and_trustregion",
            "location": 1389,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "L2Optimizer.fun_and_jac": {
            "name": "fun_and_jac",
            "location": 1513,
            "return": [],
            "arguments": {
                "self": [],
                "params": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "L2Optimizer._get_final_delta": {
            "name": "_get_final_delta",
            "location": 1561,
            "return": [],
            "arguments": {
                "self": [],
                "lam": [],
                "mu": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "touchup": []
            }
        },
        "L2Optimizer._distance": {
            "name": "_distance",
            "location": 1579,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": []
            }
        },
        "L1Optimizer.fun_and_jac": {
            "name": "fun_and_jac",
            "location": 1585,
            "return": [],
            "arguments": {
                "self": [],
                "params": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "L1Optimizer._get_final_delta": {
            "name": "_get_final_delta",
            "location": 1640,
            "return": [],
            "arguments": {
                "self": [],
                "lam": [],
                "mu": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "touchup": []
            }
        },
        "L1Optimizer._distance": {
            "name": "_distance",
            "location": 1731,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": []
            }
        },
        "LinfOptimizer.optimize_distance_s_t_boundary_and_trustregion": {
            "name": "optimize_distance_s_t_boundary_and_trustregion",
            "location": 1737,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "LinfOptimizer.binary_search": {
            "name": "binary_search",
            "location": 1749,
            "return": [],
            "arguments": {
                "self": [],
                "q0": [],
                "bounds": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "etol": [],
                "maxiter": []
            }
        },
        "LinfOptimizer._Linf_bounds": {
            "name": "_Linf_bounds",
            "location": 1787,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "epsilon": [],
                "ell": [],
                "u": []
            }
        },
        "LinfOptimizer.fun": {
            "name": "fun",
            "location": 1805,
            "return": [],
            "arguments": {
                "self": [],
                "epsilon": [],
                "x0": [],
                "x": [],
                "b": [],
                "ell": [],
                "u": [],
                "c": [],
                "r": [],
                "lambda0": []
            }
        },
        "LinfOptimizer._get_final_delta": {
            "name": "_get_final_delta",
            "location": 1907,
            "return": [],
            "arguments": {
                "self": [],
                "lam": [],
                "eps": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "touchup": []
            }
        },
        "LinfOptimizer._distance": {
            "name": "_distance",
            "location": 1925,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": []
            }
        },
        "L0Optimizer.optimize_distance_s_t_boundary_and_trustregion": {
            "name": "optimize_distance_s_t_boundary_and_trustregion",
            "location": 1931,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "L0Optimizer.minimize": {
            "name": "minimize",
            "location": 1943,
            "return": [],
            "arguments": {
                "self": [],
                "q0": [],
                "bounds": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "ftol": [],
                "xtol": [],
                "maxiter": []
            }
        },
        "L0Optimizer.minimize_without_trustregion": {
            "name": "minimize_without_trustregion",
            "location": 1979,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": [],
                "b": [],
                "c": [],
                "r": [],
                "ell": [],
                "u": []
            }
        },
        "L0Optimizer._nelder_mead_algorithm": {
            "name": "_nelder_mead_algorithm",
            "location": 2015,
            "return": [],
            "arguments": {
                "self": [],
                "q0": [],
                "bounds": [],
                "args": [],
                "\u03c1": [],
                "\u03c7": [],
                "\u03b3": [],
                "\u03c3": [],
                "tol_f": [],
                "tol_x": [],
                "max_iter": []
            }
        },
        "L0Optimizer._initialize_simplex": {
            "name": "_initialize_simplex",
            "location": 2175,
            "return": [],
            "arguments": {
                "self": [],
                "x0": []
            }
        },
        "L0Optimizer._check_params": {
            "name": "_check_params",
            "location": 2213,
            "return": [],
            "arguments": {
                "self": [],
                "\u03c1": [],
                "\u03c7": [],
                "\u03b3": [],
                "\u03c3": [],
                "bounds": [],
                "n": []
            }
        },
        "L0Optimizer._check_bounds": {
            "name": "_check_bounds",
            "location": 2255,
            "return": [],
            "arguments": {
                "self": [],
                "x": [],
                "bounds": []
            }
        },
        "L0Optimizer._neg_bounded_fun": {
            "name": "_neg_bounded_fun",
            "location": 2281,
            "return": [],
            "arguments": {
                "self": [],
                "bounds": [],
                "x": [],
                "args": []
            }
        },
        "L0Optimizer.fun": {
            "name": "fun",
            "location": 2309,
            "return": [],
            "arguments": {
                "self": [],
                "params": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": []
            }
        },
        "L0Optimizer._get_final_delta": {
            "name": "_get_final_delta",
            "location": 2356,
            "return": [],
            "arguments": {
                "self": [],
                "lam": [],
                "mu": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "touchup": []
            }
        },
        "L0Optimizer.__get_final_delta": {
            "name": "__get_final_delta",
            "location": 2387,
            "return": [],
            "arguments": {
                "self": [],
                "lam": [],
                "mu": [],
                "x0": [],
                "x": [],
                "b": [],
                "min_": [],
                "max_": [],
                "c": [],
                "r": [],
                "touchup": []
            }
        },
        "L0Optimizer._distance": {
            "name": "_distance",
            "location": 2500,
            "return": [],
            "arguments": {
                "self": [],
                "x0": [],
                "x": []
            }
        },
        "jitclass": {
            "name": "jitclass",
            "location": 32,
            "return": [],
            "arguments": {}
        },
        "BrendelBethgeAttack.run.loss_fun": {
            "name": "loss_fun",
            "location": 466,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "BrendelBethgeAttack.run.logits_diff_and_grads": {
            "name": "logits_diff_and_grads",
            "location": 483,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "jitclass.decorator": {
            "name": "decorator",
            "location": 33,
            "return": [],
            "arguments": {
                "c": []
            }
        }
    },
    "foolbox-master/foolbox/attacks/carlini_wagner.py": {
        "best_other_classes": {
            "name": "best_other_classes",
            "location": 202,
            "return": [
                "Optional[List[mypy.types.Type]]",
                "List[mypy.types.Type]",
                "str",
                "mypy.types.FunctionLike",
                "Union[str, List[str]]",
                "int"
            ],
            "arguments": {
                "logits": [
                    "eagerpy.Tensor",
                    "Optional[str]",
                    "Dict[str, numpy.ndarray]",
                    "str"
                ],
                "exclude": [
                    "eagerpy.Tensor",
                    "Optional[str]",
                    "Dict[str, numpy.ndarray]",
                    "str"
                ]
            }
        },
        "_to_attack_space": {
            "name": "_to_attack_space",
            "location": 207,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "numpy.ndarray",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "_to_model_space": {
            "name": "_to_model_space",
            "location": 217,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "dict"
                ]
            }
        },
        "L2CarliniWagnerAttack.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "binary_search_steps": [
                    "str",
                    "bool"
                ],
                "steps": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "stepsize": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "confidence": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "initial_const": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "abort_early": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ]
            }
        },
        "L2CarliniWagnerAttack.run": {
            "name": "run",
            "location": 65,
            "return": [
                "type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "inputs": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "L2CarliniWagnerAttack.run.is_adversarial": {
            "name": "is_adversarial",
            "location": 94,
            "return": [
                "str",
                "numpy.ndarray",
                "int"
            ],
            "arguments": {
                "perturbed": [
                    "str",
                    "numpy.ndarray",
                    "int"
                ],
                "logits": [
                    "eagerpy.Tensor",
                    "mypy.types.Type",
                    "int"
                ]
            }
        },
        "L2CarliniWagnerAttack.run.loss_fun": {
            "name": "loss_fun",
            "location": 114,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "delta": [
                    "numpy.ndarray",
                    "eagerpy.Tensor",
                    "list",
                    "numpy.array",
                    "Iterable[Any]"
                ],
                "consts": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/contrast.py": {
        "L2ContrastReductionAttack.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L2ContrastReductionAttack.run": {
            "name": "run",
            "location": 32,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "int",
                    "Union[criteria.Criterion, Any]",
                    "float",
                    "Union[base.Criterion, Any]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/contrast_min.py": {
        "BinarySearchContrastReductionAttack.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "BinarySearchContrastReductionAttack.run": {
            "name": "run",
            "location": 43,
            "return": [
                "type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model",
                    "int",
                    "Callable[[str], str]",
                    "models.base.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "str",
                    "models.Model",
                    "Callable",
                    "Union[base.Criterion, Any]"
                ]
            }
        },
        "LinearSearchContrastReductionAttack.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinearSearchContrastReductionAttack.run": {
            "name": "run",
            "location": 96,
            "return": [
                "type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model",
                    "int",
                    "Callable[[str], str]",
                    "models.base.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "str",
                    "models.Model",
                    "Callable",
                    "Union[base.Criterion, Any]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/dataset_attack.py": {
        "DatasetAttack.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetAttack.feed": {
            "name": "feed",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Optional[str]",
                    "dict"
                ],
                "inputs": [
                    "Union['Contributor', 'Coverage']",
                    "rflx.model.Model",
                    "Optional[float]",
                    "allennlp.models.model.Model",
                    "speedwagon.models.TabsModel"
                ]
            }
        },
        "DatasetAttack.process_raw": {
            "name": "process_raw",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetAttack.run": {
            "name": "run",
            "location": 67,
            "return": [
                "magic.models.Card"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model"
                ],
                "inputs": [],
                "criterion": [
                    "bool"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/ddn.py": {
        "normalize_gradient_l2_norms": {
            "name": "normalize_gradient_l2_norms",
            "location": 20,
            "return": [],
            "arguments": {
                "grad": []
            }
        },
        "DDNAttack.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "DDNAttack.run": {
            "name": "run",
            "location": 64,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "inputs": [],
                "criterion": []
            }
        },
        "DDNAttack.run.loss_fn": {
            "name": "loss_fn",
            "location": 100,
            "return": [],
            "arguments": {
                "inputs": [],
                "labels": []
            }
        }
    },
    "foolbox-master/foolbox/attacks/deepfool.py": {
        "DeepFoolAttack.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "DeepFoolAttack._get_loss_fn": {
            "name": "_get_loss_fn",
            "location": 57,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "eagerpy.Tensor",
                    "models.Model",
                    "Callable"
                ],
                "classes": [
                    "eagerpy.Tensor",
                    "models.Model",
                    "Callable"
                ]
            }
        },
        "DeepFoolAttack.run": {
            "name": "run",
            "location": 98,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model",
                    "models.base.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "bool",
                    "Union[criteria.Criterion, base.T]",
                    "Dict[str, Any]"
                ]
            }
        },
        "DeepFoolAttack.get_distances": {
            "name": "get_distances",
            "location": 187,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "losses": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ],
                "grads": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ]
            }
        },
        "DeepFoolAttack.get_perturbations": {
            "name": "get_perturbations",
            "location": 191,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "distances": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ],
                "grads": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ]
            }
        },
        "L2DeepFoolAttack.get_distances": {
            "name": "get_distances",
            "location": 216,
            "return": [
                "str",
                "Dict[Optional[str], Set[abilian.services.security.models.Role]]",
                "abilian.core.models.subjects.Principal",
                "Dict[str, int]",
                "salon.models.Stylist",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "losses": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ],
                "grads": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ]
            }
        },
        "L2DeepFoolAttack.get_perturbations": {
            "name": "get_perturbations",
            "location": 219,
            "return": [
                "str",
                "Dict[Optional[str], Set[abilian.services.security.models.Role]]",
                "abilian.core.models.subjects.Principal",
                "Dict[str, int]",
                "salon.models.Stylist",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "distances": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ],
                "grads": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ]
            }
        },
        "LinfDeepFoolAttack.get_distances": {
            "name": "get_distances",
            "location": 251,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "losses": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ],
                "grads": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ]
            }
        },
        "LinfDeepFoolAttack.get_perturbations": {
            "name": "get_perturbations",
            "location": 254,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "distances": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ],
                "grads": [
                    "str",
                    "bool",
                    "eagerpy.Tensor"
                ]
            }
        },
        "DeepFoolAttack._get_loss_fn.loss_fun": {
            "name": "loss_fun",
            "location": 81,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "pystork.model.Model"
                ],
                "k": [
                    "int",
                    "Sequence[Any]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/ead.py": {
        "_best_other_classes": {
            "name": "_best_other_classes",
            "location": 209,
            "return": [
                "str",
                "Union[str, List[str]]",
                "int"
            ],
            "arguments": {
                "logits": [
                    "eagerpy.Tensor",
                    "Optional[str]",
                    "str"
                ],
                "exclude": [
                    "eagerpy.Tensor",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "_apply_decision_rule": {
            "name": "_apply_decision_rule",
            "location": 214,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "decision_rule": [
                    "bool",
                    "list",
                    "str",
                    "Set[str]",
                    "Optional[List[str]]"
                ],
                "beta": [
                    "int",
                    "float",
                    "bool"
                ],
                "best_advs": [
                    "str",
                    "Tuple[int, int]",
                    "int",
                    "List[int]",
                    "float",
                    "bool",
                    "Dict[str, Any]"
                ],
                "best_advs_norms": [
                    "Mapping[str, Tuple[float, float, float]]"
                ],
                "x_k": [
                    "int",
                    "float",
                    "bool",
                    "tuple",
                    "list",
                    "Tuple[float, float, float]"
                ],
                "x": [
                    "int",
                    "float",
                    "bool",
                    "tuple",
                    "list",
                    "Tuple[float, float, float]"
                ],
                "found_advs": [
                    "int",
                    "bool",
                    "bytes"
                ]
            }
        },
        "_project_shrinkage_thresholding": {
            "name": "_project_shrinkage_thresholding",
            "location": 239,
            "return": [
                "int",
                "float",
                "Callable[[None], bool]",
                "List[str]"
            ],
            "arguments": {
                "z": [
                    "float",
                    "int"
                ],
                "x0": [
                    "float"
                ],
                "regularization": [
                    "float",
                    "int"
                ],
                "min_": [
                    "float",
                    "int",
                    "List[int]",
                    "T"
                ],
                "max_": [
                    "float",
                    "int",
                    "List[int]",
                    "T"
                ]
            }
        },
        "EADAttack.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "binary_search_steps": [
                    "str",
                    "bool"
                ],
                "steps": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "initial_stepsize": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "confidence": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "initial_const": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "regularization": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "decision_rule": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "abort_early": [
                    "bool",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "str",
                    "int"
                ]
            }
        },
        "EADAttack.run": {
            "name": "run",
            "location": 71,
            "return": [
                "type"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "Optional[str]"
                ],
                "inputs": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "EADAttack.run.is_adversarial": {
            "name": "is_adversarial",
            "location": 100,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "perturbed": [
                    "str",
                    "int"
                ],
                "logits": [
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        },
        "EADAttack.run.loss_fun": {
            "name": "loss_fun",
            "location": 114,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "y_k": [
                    "float"
                ],
                "consts": [
                    "int",
                    "bool",
                    "List[int]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/fast_gradient_method.py": {
        "L1FastGradientAttack.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L1FastGradientAttack.run": {
            "name": "run",
            "location": 24,
            "return": [
                "bool",
                "BaseException",
                "Coroutine"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "float"
                ],
                "inputs": [
                    "str",
                    "float"
                ],
                "criterion": [
                    "tensorflow.keras.Model",
                    "bool",
                    "str",
                    "bytes"
                ]
            }
        },
        "L2FastGradientAttack.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L2FastGradientAttack.run": {
            "name": "run",
            "location": 55,
            "return": [
                "bool",
                "BaseException",
                "Coroutine"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "float"
                ],
                "inputs": [
                    "str",
                    "float"
                ],
                "criterion": [
                    "tensorflow.keras.Model",
                    "bool",
                    "str",
                    "bytes"
                ]
            }
        },
        "LinfFastGradientAttack.__init__": {
            "name": "__init__",
            "location": 79,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinfFastGradientAttack.run": {
            "name": "run",
            "location": 86,
            "return": [
                "bool",
                "BaseException",
                "Coroutine"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "float"
                ],
                "inputs": [
                    "str",
                    "float"
                ],
                "criterion": [
                    "tensorflow.keras.Model",
                    "bool",
                    "str",
                    "bytes"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/fast_minimum_norm.py": {
        "best_other_classes": {
            "name": "best_other_classes",
            "location": 22,
            "return": [
                "str",
                "Union[str, List[str]]",
                "int"
            ],
            "arguments": {
                "logits": [
                    "eagerpy.Tensor",
                    "Optional[str]",
                    "str"
                ],
                "exclude": [
                    "eagerpy.Tensor",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "project_onto_l1_ball": {
            "name": "project_onto_l1_ball",
            "location": 27,
            "return": [
                "Tuple[float, float]"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "float"
                ],
                "eps": [
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        },
        "FMNAttackLp.__init__": {
            "name": "__init__",
            "location": 92,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FMNAttackLp.run": {
            "name": "run",
            "location": 115,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']",
                    "models.base.Model",
                    "Optional[base.OrderSpec]"
                ],
                "inputs": [
                    "base.T",
                    "bool",
                    "float",
                    "str",
                    "Tuple[int, int]"
                ],
                "criterion": [
                    "bool",
                    "int",
                    "tuple"
                ]
            }
        },
        "FMNAttackLp.normalize": {
            "name": "normalize",
            "location": 294,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "gradients": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "FMNAttackLp.project": {
            "name": "project",
            "location": 298,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ],
                "x0": [
                    "int",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ],
                "epsilon": [
                    "int",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ]
            }
        },
        "FMNAttackLp.mid_points": {
            "name": "mid_points",
            "location": 302,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "int",
                    "Tuple[float, float]",
                    "Optional[List[Any]]"
                ],
                "x1": [
                    "eagerpy.Tensor",
                    "int",
                    "Tuple[float, float]",
                    "Optional[List[Any]]"
                ],
                "epsilons": [
                    "eagerpy.Tensor",
                    "int",
                    "Tuple[float, float]",
                    "Optional[List[Any]]"
                ],
                "bounds": [
                    "eagerpy.Tensor",
                    "int",
                    "Tuple[float, float]",
                    "Optional[List[Any]]"
                ]
            }
        },
        "L1FMNAttack.get_random_start": {
            "name": "get_random_start",
            "location": 342,
            "return": [
                "List[int]",
                "int",
                "bytes",
                "Union[str, int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "Tuple[int, int, int]"
                ],
                "epsilon": [
                    "float",
                    "int"
                ]
            }
        },
        "L1FMNAttack.project": {
            "name": "project",
            "location": 347,
            "return": [
                "bool",
                "Optional[base.WhereSpec]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "tuple",
                    "int",
                    "Callable[[None], bool]",
                    "bool",
                    "List[int]",
                    "Callable[[int], int]"
                ],
                "x0": [
                    "tuple",
                    "int",
                    "Callable[[None], bool]",
                    "bool",
                    "List[int]",
                    "Callable[[int], int]"
                ],
                "epsilon": [
                    "tuple",
                    "int",
                    "Callable[[None], bool]",
                    "bool",
                    "List[int]",
                    "Callable[[int], int]"
                ]
            }
        },
        "L1FMNAttack.mid_points": {
            "name": "mid_points",
            "location": 350,
            "return": [
                "Dict[str, Any]",
                "base.ConfigOptions",
                "str"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor"
                ],
                "x1": [
                    "eagerpy.Tensor",
                    "int"
                ],
                "epsilons": [
                    "Tuple[float, float]",
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ],
                "bounds": [
                    "Sequence[float]",
                    "float",
                    "dict",
                    "tuple",
                    "int"
                ]
            }
        },
        "L2FMNAttack.get_random_start": {
            "name": "get_random_start",
            "location": 403,
            "return": [
                "List[int]",
                "int",
                "bytes",
                "Union[str, int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "Tuple[int, int, int]"
                ],
                "epsilon": [
                    "float",
                    "int"
                ]
            }
        },
        "L2FMNAttack.project": {
            "name": "project",
            "location": 408,
            "return": [
                "Type",
                "bool",
                "List['cirq.Qid']"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Dict[int, float]"
                ],
                "x0": [
                    "Callable[[int], int]",
                    "float",
                    "eagerpy.Tensor"
                ],
                "epsilon": [
                    "int",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ]
            }
        },
        "L2FMNAttack.mid_points": {
            "name": "mid_points",
            "location": 415,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "Tuple[float, float]",
                    "int"
                ],
                "x1": [
                    "eagerpy.Tensor",
                    "float",
                    "Mapping[str, float]",
                    "int"
                ],
                "epsilons": [
                    "eagerpy.Tensor",
                    "float",
                    "Tuple[float, float]",
                    "int"
                ],
                "bounds": [
                    "eagerpy.Tensor",
                    "int",
                    "Tuple[float, float]",
                    "Optional[List[Any]]"
                ]
            }
        },
        "LInfFMNAttack.get_random_start": {
            "name": "get_random_start",
            "location": 462,
            "return": [
                "int",
                "str",
                "List[int]",
                "Union[str, int]",
                "dict",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        },
        "LInfFMNAttack.project": {
            "name": "project",
            "location": 465,
            "return": [
                "str",
                "float",
                "Set[int]",
                "set"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "str"
                ],
                "x0": [
                    "float",
                    "eagerpy.Tensor",
                    "Sequence[Any]"
                ],
                "epsilon": [
                    "float",
                    "Sequence[cmk.base.check_utils.Service]",
                    "Dict[int, float]"
                ]
            }
        },
        "LInfFMNAttack.mid_points": {
            "name": "mid_points",
            "location": 470,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "Union[int, float]",
                    "int"
                ],
                "x1": [
                    "eagerpy.Tensor",
                    "float",
                    "Mapping[str, float]",
                    "int"
                ],
                "epsilons": [
                    "Tuple[float, float]",
                    "eagerpy.Tensor",
                    "int",
                    "float"
                ],
                "bounds": [
                    "Sequence[float]",
                    "float",
                    "dict",
                    "tuple",
                    "int"
                ]
            }
        },
        "L0FMNAttack.project": {
            "name": "project",
            "location": 522,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "x0": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor",
                    "str"
                ]
            }
        },
        "L0FMNAttack.mid_points": {
            "name": "mid_points",
            "location": 533,
            "return": [
                "Dict[str, Any]",
                "base.ConfigOptions",
                "str"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "int",
                    "float",
                    "Tuple[float, float]"
                ],
                "x1": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "epsilons": [
                    "float",
                    "eagerpy.Tensor"
                ],
                "bounds": [
                    "eagerpy.Tensor",
                    "int",
                    "Tuple[float, float]",
                    "Optional[List[Any]]"
                ]
            }
        },
        "FMNAttackLp.run.loss_fn": {
            "name": "loss_fn",
            "location": 137,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "inputs": [
                    "List[List[Any]]",
                    "List[List[str]]",
                    "str",
                    "Optional[dict]",
                    "Dict[str, float]"
                ],
                "labels": [
                    "str",
                    "Tuple[str, dict]",
                    "bytes"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/gen_attack.py": {
        "GenAttack.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "GenAttack.apply_noise": {
            "name": "apply_noise",
            "location": 59,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "magic.models.Deck",
                    "numpy.array",
                    "float"
                ],
                "noise": [
                    "numpy.array",
                    "magic.models.Deck",
                    "float",
                    "int"
                ],
                "epsilon": [
                    "base.cell.Cell",
                    "int",
                    "str"
                ],
                "channel_axis": [
                    "numpy.array",
                    "magic.models.Deck",
                    "float",
                    "int"
                ]
            }
        },
        "GenAttack.choice": {
            "name": "choice",
            "location": 77,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "a": [
                    "int",
                    "Optional[str]",
                    "str",
                    "Union[int, float]"
                ],
                "size": [
                    "int",
                    "Optional[str]",
                    "str",
                    "Union[int, float]"
                ],
                "replace": [
                    "int",
                    "Optional[str]",
                    "str",
                    "Union[int, float]"
                ],
                "p": [
                    "int",
                    "List[str]",
                    "numpy.ndarray"
                ]
            }
        },
        "GenAttack.run": {
            "name": "run",
            "location": 84,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "app.models.Question",
                    "base.Model"
                ],
                "inputs": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "GenAttack.run.is_adversarial": {
            "name": "is_adversarial",
            "location": 143,
            "return": [
                "str",
                "Callable[..., T]"
            ],
            "arguments": {
                "logits": [
                    "str",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "GenAttack.run.calculate_fitness": {
            "name": "calculate_fitness",
            "location": 156,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "logits": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/gen_attack_utils.py": {
        "rescale_jax": {
            "name": "rescale_jax",
            "location": 5,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ],
                "target_shape": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "rescale_numpy": {
            "name": "rescale_numpy",
            "location": 59,
            "return": [
                "int",
                "List[int]",
                "List[dict]"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ],
                "target_shape": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "rescale_tensorflow": {
            "name": "rescale_tensorflow",
            "location": 110,
            "return": [
                "int",
                "str",
                "bool",
                "torch.Tensor"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "bool",
                    "int"
                ],
                "target_shape": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "rescale_pytorch": {
            "name": "rescale_pytorch",
            "location": 122,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "eagerpy.Tensor",
                    "bool",
                    "int"
                ],
                "target_shape": [
                    "int",
                    "Iterable[str]",
                    "dict",
                    "str"
                ]
            }
        },
        "swap_axes": {
            "name": "swap_axes",
            "location": 134,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "torch.Tensor",
                    "eagerpy.Tensor"
                ],
                "dim0": [
                    "eagerpy.Tensor",
                    "bool",
                    "int"
                ],
                "dim1": [
                    "eagerpy.Tensor",
                    "bool",
                    "int"
                ]
            }
        },
        "rescale_images": {
            "name": "rescale_images",
            "location": 145,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "numpy.array",
                    "float",
                    "int",
                    "Union[int, float]",
                    "torch.Tensor"
                ],
                "target_shape": [
                    "int",
                    "bool"
                ],
                "channel_axis": [
                    "int",
                    "torch.Tensor",
                    "bool",
                    "List[int]"
                ]
            }
        },
        "rescale_jax.interpolate_bilinear": {
            "name": "interpolate_bilinear",
            "location": 15,
            "return": [],
            "arguments": {
                "im": [],
                "rows": [],
                "cols": []
            }
        },
        "rescale_numpy.interpolate_bilinear": {
            "name": "interpolate_bilinear",
            "location": 66,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "im": [
                    "int",
                    "bytes",
                    "np.ndarray",
                    "List[int]",
                    "torch.IntTensor",
                    "bool"
                ],
                "rows": [
                    "int",
                    "bytes",
                    "torch.IntTensor",
                    "np.ndarray",
                    "bool",
                    "str"
                ],
                "cols": [
                    "int",
                    "bytes",
                    "torch.IntTensor",
                    "np.ndarray",
                    "bool",
                    "str"
                ]
            }
        },
        "rescale_jax.interpolate_bilinear.cclip": {
            "name": "cclip",
            "location": 24,
            "return": [],
            "arguments": {
                "cols": []
            }
        },
        "rescale_jax.interpolate_bilinear.rclip": {
            "name": "rclip",
            "location": 27,
            "return": [],
            "arguments": {
                "rows": []
            }
        },
        "rescale_numpy.interpolate_bilinear.cclip": {
            "name": "cclip",
            "location": 75,
            "return": [
                "str",
                "int",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "cols": [
                    "str",
                    "Optional[str]",
                    "TextIO",
                    "int",
                    "dict",
                    "Tuple[str]"
                ]
            }
        },
        "rescale_numpy.interpolate_bilinear.rclip": {
            "name": "rclip",
            "location": 78,
            "return": [
                "List[int]",
                "Optional[numpy.dtype]",
                "list",
                "float",
                "str"
            ],
            "arguments": {
                "rows": [
                    "int",
                    "Dict[str, str]",
                    "List[str]",
                    "Sequence[MutableMapping]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/gradient_descent_base.py": {
        "clip_lp_norms": {
            "name": "clip_lp_norms",
            "location": 178,
            "return": [
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "float"
                ]
            }
        },
        "normalize_lp_norms": {
            "name": "normalize_lp_norms",
            "location": 187,
            "return": [
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "float"
                ]
            }
        },
        "uniform_l1_n_balls": {
            "name": "uniform_l1_n_balls",
            "location": 196,
            "return": [
                "Iterable[int]",
                "models.characters.mods_base.SlotTypes",
                "str",
                "int"
            ],
            "arguments": {
                "dummy": [
                    "int",
                    "Sequence[Any]"
                ],
                "batch_size": [
                    "int",
                    "Sequence[Any]"
                ],
                "n": [
                    "int",
                    "Sequence[Any]"
                ]
            }
        },
        "uniform_l2_n_spheres": {
            "name": "uniform_l2_n_spheres",
            "location": 207,
            "return": [
                "str",
                "float",
                "Tuple[str, str]"
            ],
            "arguments": {
                "dummy": [
                    "float",
                    "int",
                    "Tuple[int, int]",
                    "bool"
                ],
                "batch_size": [
                    "float",
                    "int",
                    "Tuple[int, int]",
                    "bool"
                ],
                "n": [
                    "float",
                    "int",
                    "Tuple[int, int]",
                    "bool"
                ]
            }
        },
        "uniform_l2_n_balls": {
            "name": "uniform_l2_n_balls",
            "location": 214,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "dummy": [
                    "int",
                    "float",
                    "Tuple[int, int]",
                    "eagerpy.Tensor",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Tuple[int, int]",
                    "eagerpy.Tensor",
                    "bool"
                ],
                "n": [
                    "int",
                    "eagerpy.Tensor"
                ]
            }
        },
        "Optimizer.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "str",
                    "eagerpy.Tensor",
                    "float"
                ]
            }
        },
        "Optimizer.__call__": {
            "name": "__call__",
            "location": 28,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "gradient": [
                    "dict"
                ]
            }
        },
        "AdamOptimizer.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "Union[int, bool]",
                    "str"
                ],
                "stepsize": [
                    "float",
                    "int",
                    "base.cell.Cell"
                ],
                "beta1": [
                    "float",
                    "int",
                    "base.cell.Cell"
                ],
                "beta2": [
                    "float",
                    "int",
                    "base.cell.Cell"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "base.cell.Cell"
                ]
            }
        },
        "AdamOptimizer.__call__": {
            "name": "__call__",
            "location": 51,
            "return": [
                "mypy.types.Type",
                "str",
                "Tuple[Tuple[int, Any]]"
            ],
            "arguments": {
                "self": [],
                "gradient": [
                    "bool",
                    "T",
                    "Iterable[Any]",
                    "FrozenSet[int]",
                    "Mapping[starfish.core.types.Axes, int]",
                    "int"
                ]
            }
        },
        "GDOptimizer.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "str",
                    "eagerpy.Tensor",
                    "float"
                ],
                "stepsize": [
                    "float",
                    "int",
                    "base.cell.Cell"
                ]
            }
        },
        "GDOptimizer.__call__": {
            "name": "__call__",
            "location": 70,
            "return": [
                "starlette.types.Receive",
                "Callable",
                "starlette.types.Send",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "gradient": [
                    "starlette.types.Receive",
                    "Callable",
                    "starlette.types.Send",
                    "int",
                    "float"
                ]
            }
        },
        "BaseGradientDescent.__init__": {
            "name": "__init__",
            "location": 78,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseGradientDescent.get_loss_fn": {
            "name": "get_loss_fn",
            "location": 91,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "eagerpy.Tensor",
                    "models.base.Model"
                ],
                "labels": [
                    "eagerpy.Tensor",
                    "models.base.Model"
                ]
            }
        },
        "BaseGradientDescent.get_optimizer": {
            "name": "get_optimizer",
            "location": 101,
            "return": [
                "str",
                "List[int]",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ],
                "stepsize": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        },
        "BaseGradientDescent.value_and_grad": {
            "name": "value_and_grad",
            "location": 105,
            "return": [
                "str",
                "int",
                "float",
                "bool",
                "dict",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "loss_fn": [
                    "eagerpy.Tensor",
                    "Callable[[eagerpy.Tensor], eagerpy.Tensor]",
                    "List[str]",
                    "bool"
                ],
                "x": [
                    "eagerpy.Tensor",
                    "Callable[[eagerpy.Tensor], eagerpy.Tensor]",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "BaseGradientDescent.run": {
            "name": "run",
            "location": 113,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "Union[base.Criterion, Any]",
                    "int",
                    "Union[server.models.Bike, int]",
                    "Callable"
                ]
            }
        },
        "BaseGradientDescent.get_random_start": {
            "name": "get_random_start",
            "location": 164,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "int"
                ],
                "epsilon": [
                    "eagerpy.Tensor",
                    "float",
                    "int"
                ]
            }
        },
        "BaseGradientDescent.normalize": {
            "name": "normalize",
            "location": 168,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "gradients": [
                    "Optional[List[Any]]",
                    "List[List[str]]",
                    "str",
                    "int"
                ]
            }
        },
        "BaseGradientDescent.project": {
            "name": "project",
            "location": 174,
            "return": [
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "snorkel.types.DataPoint",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ],
                "x0": [
                    "int",
                    "snorkel.types.DataPoint",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ],
                "epsilon": [
                    "int",
                    "snorkel.types.DataPoint",
                    "float",
                    "eagerpy.Tensor",
                    "Callable",
                    "Sequence",
                    "Iterable[Any]",
                    "bool",
                    "Literal[False]"
                ]
            }
        },
        "L1BaseGradientDescent.get_random_start": {
            "name": "get_random_start",
            "location": 232,
            "return": [
                "List[int]",
                "int",
                "bytes",
                "Union[str, int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "Tuple[int, int, int]"
                ],
                "epsilon": [
                    "float",
                    "snorkel.types.DataPoint",
                    "int"
                ]
            }
        },
        "L1BaseGradientDescent.normalize": {
            "name": "normalize",
            "location": 237,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "gradients": [
                    "int",
                    "types.Bounds",
                    "Dict[int, Tuple[int, int]]"
                ]
            }
        },
        "L1BaseGradientDescent.project": {
            "name": "project",
            "location": 242,
            "return": [
                "Type",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "Callable[[int], int]",
                    "str"
                ],
                "x0": [
                    "float",
                    "eagerpy.Tensor",
                    "Callable[[int], int]",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor",
                    "Callable[[int], int]",
                    "str"
                ]
            }
        },
        "L2BaseGradientDescent.get_random_start": {
            "name": "get_random_start",
            "location": 249,
            "return": [
                "List[int]",
                "int",
                "bytes",
                "Union[str, int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "eagerpy.Tensor",
                    "float",
                    "Tuple[int, int, int]"
                ],
                "epsilon": [
                    "float",
                    "snorkel.types.DataPoint",
                    "int"
                ]
            }
        },
        "L2BaseGradientDescent.normalize": {
            "name": "normalize",
            "location": 254,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "gradients": [
                    "int",
                    "types.Bounds",
                    "Dict[int, Tuple[int, int]]"
                ]
            }
        },
        "L2BaseGradientDescent.project": {
            "name": "project",
            "location": 259,
            "return": [
                "Type",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "Callable[[int], int]",
                    "str"
                ],
                "x0": [
                    "float",
                    "eagerpy.Tensor",
                    "Callable[[int], int]",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor",
                    "Callable[[int], int]",
                    "str"
                ]
            }
        },
        "LinfBaseGradientDescent.get_random_start": {
            "name": "get_random_start",
            "location": 266,
            "return": [
                "int",
                "str",
                "List[int]",
                "Union[str, int]",
                "dict",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x0": [
                    "float",
                    "eagerpy.Tensor",
                    "snorkel.types.DataPoint"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor",
                    "snorkel.types.DataPoint"
                ]
            }
        },
        "LinfBaseGradientDescent.normalize": {
            "name": "normalize",
            "location": 269,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "gradients": [
                    "int",
                    "types.Bounds",
                    "Dict[int, Tuple[int, int]]"
                ]
            }
        },
        "LinfBaseGradientDescent.project": {
            "name": "project",
            "location": 274,
            "return": [
                "str",
                "set",
                "bool",
                "float",
                "types.signals.SignalHandlerT"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "snorkel.types.DataPoint",
                    "Callable[[int], int]"
                ],
                "x0": [
                    "float",
                    "eagerpy.Tensor",
                    "snorkel.types.DataPoint",
                    "Callable[[int], int]"
                ],
                "epsilon": [
                    "float",
                    "eagerpy.Tensor",
                    "snorkel.types.DataPoint",
                    "Callable[[int], int]"
                ]
            }
        },
        "BaseGradientDescent.get_loss_fn.loss_fn": {
            "name": "loss_fn",
            "location": 95,
            "return": [
                "str",
                "dict",
                "Dict[str, int]",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "inputs": [
                    "int",
                    "eagerpy.Tensor",
                    "float"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/hop_skip_jump.py": {
        "HopSkipJumpAttack.__init__": {
            "name": "__init__",
            "location": 61,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "init_attack": [
                    "Optional[float]",
                    "Optional[Callable]",
                    "Optional[Hashable]",
                    "int",
                    "Optional[base.MinimizationAttack]",
                    "Optional[bool]",
                    "Optional[int]"
                ],
                "steps": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "numpy.ndarray"
                ],
                "initial_gradient_eval_steps": [
                    "int",
                    "str",
                    "bool",
                    "List[Dict]",
                    "Optional[str]"
                ],
                "max_gradient_eval_steps": [
                    "int",
                    "float"
                ],
                "stepsize_search": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "numpy.ndarray"
                ],
                "gamma": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "numpy.ndarray"
                ],
                "tensorboard": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "numpy.ndarray"
                ],
                "constraint": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "HopSkipJumpAttack.run": {
            "name": "run",
            "location": 91,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "pystork.model.Model",
                    "Union[criteria.Criterion, base.T]",
                    "models.Model",
                    "models.Route"
                ],
                "inputs": [
                    "base.T",
                    "int",
                    "bool",
                    "str"
                ],
                "criterion": [
                    "Union[criteria.Criterion, base.T]",
                    "pystork.model.Model",
                    "numpy.array",
                    "int",
                    "models.Model",
                    "float"
                ]
            }
        },
        "HopSkipJumpAttack.approximate_gradients": {
            "name": "approximate_gradients",
            "location": 237,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "is_adversarial": [
                    "Callable[[eagerpy.Tensor], eagerpy.Tensor]",
                    "eagerpy.Tensor",
                    "bool",
                    "numpy.ndarray",
                    "tuple",
                    "int"
                ],
                "x_advs": [
                    "eagerpy.Tensor",
                    "bool",
                    "int",
                    "Mapping[Any, Any]"
                ],
                "steps": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Sequence[numpy.ndarray]"
                ],
                "delta": [
                    "Callable[[eagerpy.Tensor], eagerpy.Tensor]",
                    "eagerpy.Tensor",
                    "bool",
                    "numpy.ndarray",
                    "tuple",
                    "int"
                ]
            }
        },
        "HopSkipJumpAttack._project": {
            "name": "_project",
            "location": 297,
            "return": [
                "int",
                "float",
                "Callable[[None], bool]",
                "List[str]",
                "logging.LogRecord"
            ],
            "arguments": {
                "self": [],
                "originals": [
                    "eagerpy.Tensor",
                    "float"
                ],
                "perturbed": [
                    "eagerpy.Tensor",
                    "Callable"
                ],
                "epsilons": [
                    "eagerpy.Tensor",
                    "numpy.ndarray",
                    "models.scenes.scenes_base.Scene"
                ]
            }
        },
        "HopSkipJumpAttack._binary_search": {
            "name": "_binary_search",
            "location": 324,
            "return": [
                "str",
                "bytes",
                "eagerpy.Tensor",
                "Union[int, float, complex]"
            ],
            "arguments": {
                "self": [],
                "is_adversarial": [
                    "Callable[[eagerpy.Tensor], eagerpy.Tensor]",
                    "bool",
                    "str",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "int"
                ],
                "originals": [
                    "eagerpy.Tensor",
                    "bool",
                    "List[str]",
                    "models.Location",
                    "bytes",
                    "int"
                ],
                "perturbed": [
                    "eagerpy.Tensor",
                    "int",
                    "bool"
                ]
            }
        },
        "HopSkipJumpAttack.select_delta": {
            "name": "select_delta",
            "location": 367,
            "return": [
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "originals": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ],
                "distances": [
                    "eagerpy.Tensor",
                    "int",
                    "bytes",
                    "list"
                ],
                "step": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/inversion.py": {
        "InversionAttack.run": {
            "name": "run",
            "location": 24,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "int",
                    "Union[criteria.Criterion, Any]",
                    "float",
                    "Union[base.Criterion, Any]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/newtonfool.py": {
        "NewtonFoolAttack.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "steps": [
                    "int",
                    "bool",
                    "float"
                ],
                "stepsize": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "NewtonFoolAttack.run": {
            "name": "run",
            "location": 38,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "inputs": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "NewtonFoolAttack.run.loss_fun": {
            "name": "loss_fun",
            "location": 70,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "x": [
                    "list",
                    "str"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/pointwise.py": {
        "PointwiseAttack.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "init_attack": [
                    "bool",
                    "Union[float, Tuple[float, float]]",
                    "int"
                ],
                "l2_binary_search": [
                    "bool",
                    "Union[float, Tuple[float, float]]",
                    "int"
                ]
            }
        },
        "PointwiseAttack.run": {
            "name": "run",
            "location": 40,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "bool",
                    "numpy.array",
                    "pystork.model.Model",
                    "Union[criteria.Criterion, base.T]"
                ],
                "inputs": [
                    "base.T",
                    "bool",
                    "numpy.array",
                    "float",
                    "str",
                    "Tuple[int, int]"
                ],
                "criterion": [
                    "tuple",
                    "Union[str, int]"
                ]
            }
        },
        "PointwiseAttack._binary_search": {
            "name": "_binary_search",
            "location": 227,
            "return": [
                "Type[T]",
                "Iterable[numpy.dtype]",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "x_adv_flat": [
                    "int",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "mask": [
                    "bool",
                    "Tuple[int, int, int]",
                    "Optional[dict]",
                    "Optional[\"GraphLogger\"]",
                    "numpy.array",
                    "Optional[float]"
                ],
                "mask_indices": [
                    "int"
                ],
                "indices": [
                    "int"
                ],
                "adv_values": [
                    "Callable[[List], bool]"
                ],
                "non_adv_values": [
                    "float",
                    "Callable[[List], bool]",
                    "List[int]",
                    "Tuple[int]"
                ],
                "original_shape": [
                    "bool",
                    "Tuple[int, int, int]",
                    "Optional[dict]",
                    "Optional[\"GraphLogger\"]",
                    "numpy.array",
                    "Optional[float]"
                ],
                "is_adversarial": [
                    "bool",
                    "Tuple[int, int, int]",
                    "Optional[dict]",
                    "Optional[\"GraphLogger\"]",
                    "numpy.array",
                    "Optional[float]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/projected_gradient_descent.py": {
        "L1ProjectedGradientDescentAttack.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L2ProjectedGradientDescentAttack.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinfProjectedGradientDescentAttack.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L1AdamProjectedGradientDescentAttack.__init__": {
            "name": "__init__",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L1AdamProjectedGradientDescentAttack.get_optimizer": {
            "name": "get_optimizer",
            "location": 122,
            "return": [
                "str",
                "List[int]",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ],
                "stepsize": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        },
        "L2AdamProjectedGradientDescentAttack.__init__": {
            "name": "__init__",
            "location": 145,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "L2AdamProjectedGradientDescentAttack.get_optimizer": {
            "name": "get_optimizer",
            "location": 167,
            "return": [
                "str",
                "List[int]",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ],
                "stepsize": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        },
        "LinfAdamProjectedGradientDescentAttack.__init__": {
            "name": "__init__",
            "location": 190,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LinfAdamProjectedGradientDescentAttack.get_optimizer": {
            "name": "get_optimizer",
            "location": 212,
            "return": [
                "str",
                "List[int]",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ],
                "stepsize": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "eagerpy.Tensor",
                    "int"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/saltandpepper.py": {
        "SaltAndPepperNoiseAttack.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "steps": [
                    "int",
                    "str",
                    "float"
                ],
                "across_channels": [
                    "int",
                    "str",
                    "float"
                ],
                "channel_axis": [
                    "int"
                ]
            }
        },
        "SaltAndPepperNoiseAttack.run": {
            "name": "run",
            "location": 45,
            "return": [
                "magic.models.Card"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "taxonomy.db.models.Taxon",
                    "int",
                    "Iterable[T]"
                ],
                "inputs": [
                    "base.T"
                ],
                "criterion": [
                    "Union[base.Criterion, Any]",
                    "int",
                    "Union[server.models.Bike, int]",
                    "Callable"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/sparse_l1_descent_attack.py": {
        "SparseL1DescentAttack.normalize": {
            "name": "normalize",
            "location": 29,
            "return": [],
            "arguments": {
                "self": [],
                "gradients": []
            }
        },
        "SparseL1DescentAttack.project": {
            "name": "project",
            "location": 48,
            "return": [],
            "arguments": {
                "self": [],
                "x": [],
                "x0": [],
                "epsilon": []
            }
        },
        "SparseL1DescentAttack.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "foolbox-master/foolbox/attacks/spatial_attack.py": {
        "SpatialAttack.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [],
            "arguments": {
                "self": [],
                "max_translation": [],
                "max_rotation": [],
                "num_translations": [],
                "num_rotations": [],
                "grid_search": [],
                "random_steps": []
            }
        },
        "SpatialAttack.__call__": {
            "name": "__call__",
            "location": 53,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "inputs": [],
                "criterion": []
            }
        },
        "SpatialAttack.run": {
            "name": "run",
            "location": 77,
            "return": [],
            "arguments": {
                "self": [],
                "model": [],
                "inputs": [],
                "criterion": []
            }
        },
        "SpatialAttack.repeat": {
            "name": "repeat",
            "location": 127,
            "return": [],
            "arguments": {
                "self": [],
                "times": []
            }
        },
        "SpatialAttack.run.grid_search_generator": {
            "name": "grid_search_generator",
            "location": 97,
            "return": [],
            "arguments": {}
        },
        "SpatialAttack.run.random_search_generator": {
            "name": "random_search_generator",
            "location": 106,
            "return": [],
            "arguments": {}
        }
    },
    "foolbox-master/foolbox/attacks/spatial_attack_transformations.py": {
        "rotate_and_shift": {
            "name": "rotate_and_shift",
            "location": 8,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "inputs": [
                    "bool",
                    "List[int]",
                    "str",
                    "torch.FloatTensor",
                    "float"
                ],
                "translation": [
                    "int",
                    "Callable",
                    "str"
                ],
                "rotation": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "transform_pt": {
            "name": "transform_pt",
            "location": 24,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "x_e": [
                    "eagerpy.Tensor",
                    "Tuple[float, float]",
                    "float"
                ],
                "translation": [
                    "eagerpy.Tensor",
                    "Tuple[float, float]",
                    "float"
                ],
                "rotation": [
                    "eagerpy.Tensor",
                    "Tuple[float, float]",
                    "float"
                ]
            }
        },
        "transform_tf": {
            "name": "transform_tf",
            "location": 81,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "x_e": [
                    "eagerpy.Tensor",
                    "Tuple[float, float]",
                    "float"
                ],
                "translation": [
                    "eagerpy.Tensor",
                    "Tuple[float, float]",
                    "float"
                ],
                "rotation": [
                    "eagerpy.Tensor",
                    "Tuple[float, float]",
                    "float"
                ]
            }
        },
        "transform_pt.create_meshgrid": {
            "name": "create_meshgrid",
            "location": 57,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "x": [
                    "torch.Tensor",
                    "gluonts.model.common.Tensor",
                    "Tuple[int, int, int]"
                ]
            }
        },
        "transform_tf.get_pixel_value": {
            "name": "get_pixel_value",
            "location": 123,
            "return": [
                "int",
                "str",
                "torch.Tensor",
                "bytes",
                "Type",
                "set"
            ],
            "arguments": {
                "img": [
                    "float",
                    "int",
                    "str"
                ],
                "x": [
                    "tensorflow.Tensor"
                ],
                "y": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "numpy.ndarray",
                    "Iterable",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "transform_tf.bilinear_sampler": {
            "name": "bilinear_sampler",
            "location": 142,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "img": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "gluonts.model.common.Tensor"
                ],
                "x": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "int"
                ],
                "y": [
                    "numpy.ndarray",
                    "int",
                    "Iterable[float]",
                    "torch.Tensor"
                ]
            }
        },
        "transform_tf.affine_grid_generator": {
            "name": "affine_grid_generator",
            "location": 209,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "height": [
                    "int",
                    "List[str]"
                ],
                "width": [
                    "numpy.ndarray",
                    "List[str]",
                    "int",
                    "gluonts.model.common.Tensor",
                    "Optional[torch.device]"
                ],
                "theta": [
                    "int",
                    "float",
                    "List[List[int]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/virtual_adversarial_attack.py": {
        "VirtualAdversarialAttack.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "steps": [
                    "int",
                    "bool",
                    "float"
                ],
                "xi": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "VirtualAdversarialAttack.run": {
            "name": "run",
            "location": 44,
            "return": [],
            "arguments": {
                "self": [],
                "model": [
                    "models.Model",
                    "base.Model",
                    "eagerpy.Tensor",
                    "int"
                ],
                "inputs": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ],
                "criterion": [
                    "Optional[float]",
                    "base.T",
                    "models.Model",
                    "Union[criteria.Misclassification, base.T]",
                    "T"
                ]
            }
        },
        "VirtualAdversarialAttack.run.loss_fun": {
            "name": "loss_fun",
            "location": 74,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "delta": [
                    "str",
                    "int",
                    "Dict[str, Tuple[int, int]]",
                    "eagerpy.Tensor",
                    "Tuple[str]"
                ],
                "logits": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        }
    },
    "foolbox-master/foolbox/attacks/__init__.py": {},
    "foolbox-master/foolbox/external/clipping_aware_rescaling.py": {
        "l2_clipping_aware_rescaling": {
            "name": "l2_clipping_aware_rescaling",
            "location": 13,
            "return": [
                "int",
                "bytearray",
                "Optional[str]"
            ],
            "arguments": {
                "x": [
                    "float",
                    "eagerpy.Tensor",
                    "int"
                ],
                "delta": [
                    "float",
                    "int"
                ],
                "eps": [
                    "bool",
                    "float",
                    "Counter",
                    "List[str]"
                ],
                "a": [
                    "int",
                    "Tuple[float, float, float, float]",
                    "float"
                ],
                "b": [
                    "int",
                    "Tuple[float, float, float, float]",
                    "float"
                ]
            }
        }
    },
    "foolbox-master/foolbox/external/__init__.py": {},
    "foolbox-master/foolbox/models/base.py": {
        "Model.bounds": {
            "name": "bounds",
            "location": 17,
            "return": [
                "types.Bounds"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.__call__": {
            "name": "__call__",
            "location": 21,
            "return": [
                "T"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "dict"
                ]
            }
        },
        "Model.transform_bounds": {
            "name": "transform_bounds",
            "location": 25,
            "return": [
                "str",
                "int",
                "List[str]",
                "List[float]"
            ],
            "arguments": {
                "self": [],
                "bounds": [
                    "str",
                    "int",
                    "bool",
                    "memoryview"
                ]
            }
        },
        "TransformBoundsWrapper.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "float",
                    "List[List[int]]"
                ],
                "bounds": [
                    "int",
                    "float",
                    "List[List[int]]"
                ]
            }
        },
        "TransformBoundsWrapper.bounds": {
            "name": "bounds",
            "location": 37,
            "return": [
                "str",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "TransformBoundsWrapper.__call__": {
            "name": "__call__",
            "location": 40,
            "return": [
                "mypy.types.Type"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "T"
                ]
            }
        },
        "TransformBoundsWrapper.transform_bounds": {
            "name": "transform_bounds",
            "location": 46,
            "return": [
                "int",
                "Optional[int]",
                "List[int]",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "bounds": [
                    "Optional[int]",
                    "str"
                ],
                "inplace": [
                    "bool",
                    "int",
                    "str",
                    "List[Tuple]"
                ]
            }
        },
        "TransformBoundsWrapper._preprocess": {
            "name": "_preprocess",
            "location": 55,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "TransformBoundsWrapper.data_format": {
            "name": "data_format",
            "location": 68,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelWithPreprocessing.__init__": {
            "name": "__init__",
            "location": 76,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "types.Preprocessing",
                    "types.BoundsInput",
                    "int",
                    "float",
                    "Optional[float]",
                    "str"
                ],
                "bounds": [
                    "int",
                    "float",
                    "List[List[int]]"
                ],
                "dummy": [
                    "int",
                    "float",
                    "List[List[int]]"
                ],
                "preprocessing": [
                    "bool",
                    "Optional[Callable]",
                    "Optional[Dict[str, Any]]",
                    "Optional[str]"
                ]
            }
        },
        "ModelWithPreprocessing.bounds": {
            "name": "bounds",
            "location": 92,
            "return": [
                "str",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelWithPreprocessing.dummy": {
            "name": "dummy",
            "location": 96,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelWithPreprocessing.__call__": {
            "name": "__call__",
            "location": 99,
            "return": [
                "mypy.types.Type"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "T"
                ]
            }
        },
        "ModelWithPreprocessing.transform_bounds": {
            "name": "transform_bounds",
            "location": 105,
            "return": [
                "str",
                "List[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "bounds": [
                    "int",
                    "Iterable[Any]",
                    "list"
                ],
                "inplace": [
                    "bool",
                    "int",
                    "str",
                    "List[Tuple]"
                ],
                "wrapper": [
                    "bool",
                    "int",
                    "str",
                    "List[Tuple]"
                ]
            }
        },
        "ModelWithPreprocessing._preprocess": {
            "name": "_preprocess",
            "location": 147,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "eagerpy.Tensor",
                    "Dict[str, Tuple[int, int]]",
                    "float"
                ]
            }
        },
        "ModelWithPreprocessing._process_preprocessing": {
            "name": "_process_preprocessing",
            "location": 159,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "preprocessing": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "ModelWithPreprocessing._process_preprocessing.to_tensor": {
            "name": "to_tensor",
            "location": 172,
            "return": [
                "Optional[str]",
                "bool",
                "Optional[float]",
                "Optional[int]"
            ],
            "arguments": {
                "x": [
                    "Optional[eagerpy.Tensor]",
                    "Optional[Tuple]",
                    "int"
                ]
            }
        },
        "ModelWithPreprocessing._process_preprocessing.apply_axis": {
            "name": "apply_axis",
            "location": 188,
            "return": [
                "Optional[str]",
                "str",
                "bool",
                "Optional[int]",
                "Optional[float]"
            ],
            "arguments": {
                "x": [
                    "Optional[eagerpy.Tensor]",
                    "Optional[Tuple]",
                    "int"
                ],
                "axis": [
                    "float",
                    "eagerpy.Tensor",
                    "int",
                    "bytes"
                ]
            }
        }
    },
    "foolbox-master/foolbox/models/jax.py": {
        "JAXModel.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "bool",
                    "Callable"
                ],
                "bounds": [
                    "str",
                    "bool",
                    "Callable"
                ],
                "preprocessing": [
                    "str",
                    "bool",
                    "Callable"
                ],
                "data_format": [
                    "str",
                    "list",
                    "List[str]",
                    "Union[str, List[str]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "JAXModel.data_format": {
            "name": "data_format",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "foolbox-master/foolbox/models/numpy.py": {
        "NumPyModel.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "list"
                ],
                "bounds": [
                    "str",
                    "list"
                ],
                "data_format": [
                    "Optional[str]",
                    "Optional[List[int]]",
                    "Optional[Dict[str, Any]]",
                    "Optional[List[str]]",
                    "Optional[Match]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "NumPyModel.bounds": {
            "name": "bounds",
            "location": 27,
            "return": [
                "str",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NumPyModel.__call__": {
            "name": "__call__",
            "location": 30,
            "return": [
                "mypy.types.Type"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "T",
                    "base.T"
                ]
            }
        },
        "NumPyModel.data_format": {
            "name": "data_format",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "foolbox-master/foolbox/models/pytorch.py": {
        "get_device": {
            "name": "get_device",
            "location": 10,
            "return": [
                "bytes",
                "bool",
                "dict"
            ],
            "arguments": {
                "device": [
                    "str",
                    "Optional[float]",
                    "int",
                    "Optional[str]",
                    "List[str]"
                ]
            }
        },
        "PyTorchModel.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "Optional[float]",
                    "Iterable[T]",
                    "bool"
                ],
                "bounds": [
                    "types.Preprocessing",
                    "types.BoundsInput",
                    "int",
                    "Optional[float]"
                ],
                "device": [
                    "int",
                    "float",
                    "List[List[int]]"
                ],
                "preprocessing": [
                    "types.Preprocessing",
                    "types.BoundsInput",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "PyTorchModel.__init__._model": {
            "name": "_model",
            "location": 47,
            "return": [
                "Tuple[int, Dict[str, Any]]",
                "bool"
            ],
            "arguments": {
                "x": [
                    "torch.Tensor",
                    "dict",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/models/tensorflow.py": {
        "get_device": {
            "name": "get_device",
            "location": 9,
            "return": [
                "str",
                "bool",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "device": [
                    "int",
                    "str",
                    "Optional[str]",
                    "Optional[float]",
                    "List[str]"
                ]
            }
        },
        "TensorFlowModel.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "types.Preprocessing",
                    "types.BoundsInput",
                    "int",
                    "Optional[float]"
                ],
                "bounds": [
                    "types.Preprocessing",
                    "types.BoundsInput",
                    "int",
                    "Optional[float]"
                ],
                "device": [
                    "opentrons.protocols.execution.types.LoadedLabware",
                    "tuple",
                    "bool"
                ],
                "preprocessing": [
                    "types.Preprocessing",
                    "types.BoundsInput",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "TensorFlowModel.data_format": {
            "name": "data_format",
            "location": 42,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "foolbox-master/foolbox/models/wrappers.py": {
        "ThresholdingWrapper.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "threshold": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ]
            }
        },
        "ThresholdingWrapper.bounds": {
            "name": "bounds",
            "location": 15,
            "return": [
                "bool",
                "int",
                "Optional[Any]",
                "Callable[..., None]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ThresholdingWrapper.__call__": {
            "name": "__call__",
            "location": 18,
            "return": [
                "mypy.types.Type"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "T",
                    "base.T"
                ]
            }
        }
    },
    "foolbox-master/foolbox/models/__init__.py": {},
    "foolbox-master/foolbox/zoo/common.py": {
        "sha256_hash": {
            "name": "sha256_hash",
            "location": 5,
            "return": [
                "bool",
                "str",
                "IO[Any]",
                "float",
                "Tuple[bytes]",
                "int"
            ],
            "arguments": {
                "git_uri": [
                    "str",
                    "Iterable[int]",
                    "dict"
                ]
            }
        },
        "home_directory_path": {
            "name": "home_directory_path",
            "location": 11,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "folder": [
                    "str",
                    "List[str]"
                ],
                "hash_digest": [
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/zoo/git_cloner.py": {
        "clone": {
            "name": "clone",
            "location": 14,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "git_uri": [
                    "str",
                    "int"
                ],
                "overwrite": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "_clone_repo": {
            "name": "_clone_repo",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "git_uri": [
                    "str",
                    "logging.Logger",
                    "Optional[str]"
                ],
                "local_path": [
                    "str",
                    "logging.Logger",
                    "Optional[str]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/zoo/model_loader.py": {
        "ModelLoader.load": {
            "name": "load",
            "location": 13,
            "return": [
                "models.Model"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "int"
                ],
                "module_name": [
                    "str",
                    "int"
                ]
            }
        },
        "ModelLoader.get": {
            "name": "get",
            "location": 29,
            "return": [
                "mypy.types.Type",
                "str",
                "list"
            ],
            "arguments": {
                "key": [
                    "Optional[str]",
                    "str",
                    "Iterable[str]",
                    "bytes",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "ModelLoader._import_module": {
            "name": "_import_module",
            "location": 36,
            "return": [
                "bool",
                "int",
                "app.models.GameMember",
                "app.models.course.Course",
                "Optional[str]"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "module_name": [
                    "str",
                    "List[tensorboard.models.Run]"
                ]
            }
        },
        "DefaultLoader.load": {
            "name": "load",
            "location": 44,
            "return": [
                "model.Model",
                "GPy.models.GPRegression",
                "base.Model",
                "allennlp.models.model.Model",
                "tensorflow.keras.models.Model"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "Optional[str]"
                ],
                "module_name": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/zoo/weights_fetcher.py": {
        "fetch_weights": {
            "name": "fetch_weights",
            "location": 13,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "weights_uri": [],
                "unzip": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "_filename_from_uri": {
            "name": "_filename_from_uri",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "url": [
                    "str",
                    "bool"
                ]
            }
        },
        "_download": {
            "name": "_download",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "Optional[str]"
                ],
                "url": [
                    "str",
                    "logging.Logger"
                ],
                "directory": [
                    "str",
                    "Dict[str, Any]",
                    "List[str]"
                ]
            }
        },
        "_extract": {
            "name": "_extract",
            "location": 76,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "directory": [
                    "str",
                    "int"
                ],
                "filename": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "foolbox-master/foolbox/zoo/zoo.py": {
        "get_model": {
            "name": "get_model",
            "location": 9,
            "return": [
                "model.Model",
                "str",
                "GPy.models.GPRegression",
                "base.Model",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "url": [
                    "str",
                    "int",
                    "List[str]"
                ],
                "module_name": [
                    "str",
                    "int"
                ],
                "overwrite": [
                    "str",
                    "int",
                    "List[str]"
                ]
            }
        }
    },
    "foolbox-master/foolbox/zoo/__init__.py": {},
    "foolbox-master/tests/conftest.py": {
        "pytest_addoption": {
            "name": "pytest_addoption",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "bool"
                ]
            }
        },
        "dummy": {
            "name": "dummy",
            "location": 33,
            "return": [
                "str",
                "bool",
                "models.Profile"
            ],
            "arguments": {
                "request": [
                    "Optional[str]"
                ]
            }
        },
        "register": {
            "name": "register",
            "location": 41,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "backend": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "pytorch_simple_model": {
            "name": "pytorch_simple_model",
            "location": 68,
            "return": [
                "int",
                "List[int]",
                "str",
                "bool"
            ],
            "arguments": {
                "device": [
                    "int",
                    "allennlp.models.Model"
                ],
                "preprocessing": [
                    "int",
                    "allennlp.models.Model"
                ]
            }
        },
        "pytorch_simple_model_default": {
            "name": "pytorch_simple_model_default",
            "location": 92,
            "return": [
                "float"
            ],
            "arguments": {
                "request": []
            }
        },
        "pytorch_simple_model_default_flip": {
            "name": "pytorch_simple_model_default_flip",
            "location": 97,
            "return": [
                "str",
                "Optional[int]",
                "List[dict]",
                "int",
                "List[int]"
            ],
            "arguments": {
                "request": []
            }
        },
        "pytorch_simple_model_default_cpu_native_tensor": {
            "name": "pytorch_simple_model_default_cpu_native_tensor",
            "location": 102,
            "return": [
                "str",
                "bool",
                "esm.models.service_type.ServiceType",
                "int",
                "float"
            ],
            "arguments": {
                "request": []
            }
        },
        "pytorch_simple_model_default_cpu_eagerpy_tensor": {
            "name": "pytorch_simple_model_default_cpu_eagerpy_tensor",
            "location": 111,
            "return": [
                "str",
                "bool",
                "esm.models.service_type.ServiceType",
                "int",
                "float"
            ],
            "arguments": {
                "request": []
            }
        },
        "pytorch_simple_model_string": {
            "name": "pytorch_simple_model_string",
            "location": 118,
            "return": [
                "str",
                "list",
                "bool",
                "dict"
            ],
            "arguments": {
                "request": [
                    "django.db.models.Model",
                    "Optional[django.db.models.Model]",
                    "list",
                    "Dict[str, Any]"
                ]
            }
        },
        "pytorch_simple_model_object": {
            "name": "pytorch_simple_model_object",
            "location": 123,
            "return": [
                "models.PermissionLookup",
                "list",
                "str",
                "bool",
                "Dict[int, Dict[str, Any]]",
                "dict"
            ],
            "arguments": {
                "request": [
                    "Dict[str, Any]",
                    "list"
                ]
            }
        },
        "pytorch_mnist": {
            "name": "pytorch_mnist",
            "location": 130,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ]
            }
        },
        "pytorch_shufflenetv2": {
            "name": "pytorch_shufflenetv2",
            "location": 141,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "request": [
                    "Optional[dict]"
                ]
            }
        },
        "tensorflow_simple_sequential": {
            "name": "tensorflow_simple_sequential",
            "location": 157,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "device": [
                    "models.seat_group.SeatGroup",
                    "torch.Tensor"
                ],
                "preprocessing": [
                    "str",
                    "List[List[Any]]",
                    "List[Dict[str, Any]]",
                    "Type[abilian.core.models.Model]",
                    "GPy.models.GPRegression"
                ]
            }
        },
        "tensorflow_simple_sequential_cpu": {
            "name": "tensorflow_simple_sequential_cpu",
            "location": 177,
            "return": [
                "str",
                "Exception",
                "Optional[str]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ]
            }
        },
        "tensorflow_simple_sequential_native_tensors": {
            "name": "tensorflow_simple_sequential_native_tensors",
            "location": 182,
            "return": [
                "torch.Tensor",
                "Optional[torch.Tensor]",
                "torch.FloatTensor",
                "str",
                "List[dict]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ]
            }
        },
        "tensorflow_simple_sequential_eagerpy_tensors": {
            "name": "tensorflow_simple_sequential_eagerpy_tensors",
            "location": 191,
            "return": [
                "torch.Tensor",
                "Optional[torch.Tensor]",
                "torch.FloatTensor",
                "str",
                "List[dict]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ]
            }
        },
        "tensorflow_simple_subclassing": {
            "name": "tensorflow_simple_subclassing",
            "location": 198,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ]
            }
        },
        "tensorflow_simple_functional": {
            "name": "tensorflow_simple_functional",
            "location": 221,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ]
            }
        },
        "tensorflow_mobilenetv3": {
            "name": "tensorflow_mobilenetv3",
            "location": 241,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "request": [
                    "Optional[dict]"
                ]
            }
        },
        "tensorflow_resnet50": {
            "name": "tensorflow_resnet50",
            "location": 263,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "request": [
                    "Optional[dict]"
                ]
            }
        },
        "jax_simple_model": {
            "name": "jax_simple_model",
            "location": 283,
            "return": [
                "int",
                "List[int]",
                "str",
                "bool"
            ],
            "arguments": {
                "request": [
                    "Dict[str, Any]",
                    "list"
                ]
            }
        },
        "numpy_simple_model": {
            "name": "numpy_simple_model",
            "location": 301,
            "return": [
                "int",
                "List[int]",
                "str",
                "bool"
            ],
            "arguments": {
                "request": [
                    "Dict[str, Any]",
                    "list"
                ]
            }
        },
        "fmodel_and_data_ext": {
            "name": "fmodel_and_data_ext",
            "location": 324,
            "return": [
                "str",
                "Callable",
                "Optional[Union[Any, str]]",
                "bool",
                "List[str]",
                "OrderedDict",
                "dict"
            ],
            "arguments": {
                "request": [
                    "Union[dict, list]",
                    "str"
                ]
            }
        },
        "fmodel_and_data_ext_for_attacks": {
            "name": "fmodel_and_data_ext_for_attacks",
            "location": 332,
            "return": [
                "str",
                "Dict[str, List[Any]]",
                "Sequence[str]",
                "zam_repondeur.models.Lecture",
                "List[str]"
            ],
            "arguments": {
                "request": [
                    "Union[dict, list]"
                ]
            }
        },
        "fmodel_and_data": {
            "name": "fmodel_and_data",
            "location": 340,
            "return": [
                "Dict[str, Any]",
                "IO[bytes]",
                "str",
                "int"
            ],
            "arguments": {
                "fmodel_and_data_ext": [
                    "str",
                    "bytes",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "register.decorator": {
            "name": "decorator",
            "location": 48,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "f": [
                    "Iterable[str]",
                    "Callable",
                    "T"
                ]
            }
        },
        "jax_simple_model.model": {
            "name": "model",
            "location": 286,
            "return": [
                "int",
                "Dict[str, int]",
                "List[str]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "Union[bytes, bytearray, memoryview]",
                    "Iterable[List[T]]"
                ]
            }
        },
        "register.decorator.model": {
            "name": "model",
            "location": 50,
            "return": [],
            "arguments": {
                "request": []
            }
        },
        "pytorch_simple_model.Model.forward": {
            "name": "forward",
            "location": 74,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "float",
                    "eagerpy.Tensor"
                ]
            }
        },
        "tensorflow_simple_subclassing.Model.__init__": {
            "name": "__init__",
            "location": 202,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "tensorflow_simple_subclassing.Model.call": {
            "name": "call",
            "location": 206,
            "return": [
                "str",
                "Union[bool, List[bool]]",
                "bool",
                "Set[int]",
                "dep_check.models.GlobalDependencies"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "str",
                    "Callable",
                    "Awaitable[T]",
                    "Container"
                ]
            }
        },
        "numpy_simple_model.Model.__call__": {
            "name": "__call__",
            "location": 303,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "float"
                ]
            }
        }
    },
    "foolbox-master/tests/test_attacks.py": {
        "get_attack_id": {
            "name": "get_attack_id",
            "location": 29,
            "return": [
                "int",
                "List[int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "int",
                    "Set[str]",
                    "Tuple[int, int, int]",
                    "List[str]",
                    "List[int]"
                ]
            }
        },
        "test_untargeted_attacks": {
            "name": "test_untargeted_attacks",
            "location": 174,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Sequence[str]",
                    "Iterable[Any]"
                ],
                "attack_test_target": [
                    "tuple"
                ]
            }
        },
        "test_targeted_attacks": {
            "name": "test_targeted_attacks",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Sequence[str]",
                    "Iterable[Any]"
                ],
                "attack_test_target": [
                    "tuple"
                ]
            }
        }
    },
    "foolbox-master/tests/test_attacks_base.py": {
        "test_call_one_epsilon": {
            "name": "test_call_one_epsilon",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ],
                "attack": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "float",
                    "int",
                    "Sequence[str]"
                ]
            }
        },
        "test_get_channel_axis": {
            "name": "test_get_channel_axis",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_model_bounds": {
            "name": "test_model_bounds",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_attacks_raise.py": {
        "test_ead_init_raises": {
            "name": "test_ead_init_raises",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_genattack_numpy": {
            "name": "test_genattack_numpy",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_deepfool_run_raises": {
            "name": "test_deepfool_run_raises",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "test_blended_noise_attack_run_warns": {
            "name": "test_blended_noise_attack_run_warns",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "int"
                ]
            }
        },
        "test_boundary_attack_run_raises": {
            "name": "test_boundary_attack_run_raises",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "int"
                ]
            }
        },
        "test_newtonfool_run_raises": {
            "name": "test_newtonfool_run_raises",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "test_fgsm_run_raises": {
            "name": "test_fgsm_run_raises",
            "location": 98,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "test_vat_run_raises": {
            "name": "test_vat_run_raises",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "test_blended_noise_init_raises": {
            "name": "test_blended_noise_init_raises",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_blur_run_raises": {
            "name": "test_blur_run_raises",
            "location": 131,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "test_blur_numpy": {
            "name": "test_blur_numpy",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_dataset_attack_raises": {
            "name": "test_dataset_attack_raises",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "int",
                    "float"
                ]
            }
        },
        "test_targeted_attacks_call_raises_exception": {
            "name": "test_targeted_attacks_call_raises_exception",
            "location": 192,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "bool",
                    "str",
                    "int"
                ],
                "attack_exception_text_and_grad": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "test_genattack_numpy.Model.__call__": {
            "name": "__call__",
            "location": 19,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": []
            }
        },
        "test_blur_numpy.Model.__call__": {
            "name": "__call__",
            "location": 142,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "float"
                ]
            }
        },
        "test_targeted_attacks_call_raises_exception.DummyCriterion.__repr__": {
            "name": "__repr__",
            "location": 216,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "test_targeted_attacks_call_raises_exception.DummyCriterion.__call__": {
            "name": "__call__",
            "location": 219,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "perturbed": [
                    "foolbox.criteria.T",
                    "T"
                ],
                "outputs": [
                    "foolbox.criteria.T",
                    "T"
                ]
            }
        }
    },
    "foolbox-master/tests/test_binarization_attack.py": {
        "test_binarization_attack": {
            "name": "test_binarization_attack",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]",
                    "Iterable[Any]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_brendel_bethge_attack.py": {
        "get_attack_id": {
            "name": "get_attack_id",
            "location": 13,
            "return": [
                "int",
                "List[int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "int",
                    "str"
                ]
            }
        },
        "test_brendel_bethge_untargeted_attack": {
            "name": "test_brendel_bethge_untargeted_attack",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [
                    "str"
                ],
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "attack_and_p": [
                    "int",
                    "Dict[str, str]",
                    "Optional[str]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_criteria.py": {
        "test_correct_unperturbed": {
            "name": "test_correct_unperturbed",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]",
                    "bytes",
                    "str"
                ]
            }
        },
        "test_wrong_unperturbed": {
            "name": "test_wrong_unperturbed",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]",
                    "bytes",
                    "str"
                ]
            }
        },
        "test_repr_object": {
            "name": "test_repr_object",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_repr_misclassification": {
            "name": "test_repr_misclassification",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "str",
                    "float"
                ]
            }
        },
        "test_repr_and": {
            "name": "test_repr_and",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "str",
                    "float"
                ]
            }
        },
        "test_repr_targeted_misclassification": {
            "name": "test_repr_targeted_misclassification",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": []
            }
        }
    },
    "foolbox-master/tests/test_dataset_attack.py": {
        "test_dataset_attack": {
            "name": "test_dataset_attack",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "int",
                    "float"
                ]
            }
        }
    },
    "foolbox-master/tests/test_devutils.py": {
        "test_atleast_kd_1d": {
            "name": "test_atleast_kd_1d",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "eagerpy.Tensor",
                    "bool",
                    "str"
                ],
                "k": [
                    "int",
                    "bool",
                    "List[int]",
                    "Dict[str, Any]",
                    "Optional[List[str]]"
                ]
            }
        },
        "test_atleast_kd_3d": {
            "name": "test_atleast_kd_3d",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "eagerpy.Tensor",
                    "bool",
                    "str"
                ],
                "k": [
                    "int",
                    "bool",
                    "List[int]",
                    "Dict[str, Any]",
                    "Optional[List[str]]"
                ]
            }
        },
        "test_flatten_2d": {
            "name": "test_flatten_2d",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "eagerpy.Tensor"
                ]
            }
        },
        "test_flatten_3d": {
            "name": "test_flatten_3d",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "eagerpy.Tensor"
                ]
            }
        },
        "test_flatten_4d": {
            "name": "test_flatten_4d",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "eagerpy.Tensor"
                ]
            }
        }
    },
    "foolbox-master/tests/test_distances.py": {
        "register": {
            "name": "register",
            "location": 20,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "f": [
                    "str",
                    "Exception",
                    "Union[str, IO[str]]",
                    "bytes"
                ]
            }
        },
        "example_4d": {
            "name": "example_4d",
            "location": 26,
            "return": [
                "str",
                "Dict[str, Any]",
                "dict",
                "set",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "dummy": [
                    "float",
                    "bool",
                    "int"
                ]
            }
        },
        "example_batch": {
            "name": "example_batch",
            "location": 33,
            "return": [
                "Dict[str, Any]",
                "dict",
                "str",
                "set"
            ],
            "arguments": {
                "dummy": [
                    "eagerpy.Tensor",
                    "float",
                    "numpy.ndarray",
                    "str"
                ]
            }
        },
        "reference_perturbed": {
            "name": "reference_perturbed",
            "location": 42,
            "return": [
                "bool",
                "str",
                "Union[Dict, List]",
                "float",
                "int"
            ],
            "arguments": {
                "request": [
                    "eagerpy.Tensor"
                ],
                "dummy": [
                    "eagerpy.Tensor"
                ]
            }
        },
        "test_distance": {
            "name": "test_distance",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "reference_perturbed": [
                    "Tuple[eagerpy.Tensor, eagerpy.Tensor]",
                    "bool",
                    "int"
                ],
                "p": [
                    "Tuple[eagerpy.Tensor, eagerpy.Tensor]",
                    "bool",
                    "int"
                ]
            }
        },
        "test_distance_repr_str": {
            "name": "test_distance_repr_str",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "p": [
                    "float",
                    "int",
                    "bool",
                    "Callable"
                ]
            }
        },
        "test_distance_clip": {
            "name": "test_distance_clip",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "reference_perturbed": [
                    "Tuple[eagerpy.Tensor, eagerpy.Tensor]",
                    "bool",
                    "int"
                ],
                "p": [
                    "str"
                ]
            }
        }
    },
    "foolbox-master/tests/test_fast_minimum_norm_attack.py": {
        "get_attack_id": {
            "name": "get_attack_id",
            "location": 13,
            "return": [
                "int",
                "List[int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "int",
                    "str"
                ]
            }
        },
        "test_fast_minimum_norm_untargeted_attack": {
            "name": "test_fast_minimum_norm_untargeted_attack",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Sequence[str]",
                    "Iterable[Any]",
                    "Callable"
                ],
                "attack_and_p": [
                    "bool",
                    "List[numpy.array]",
                    "List[int]",
                    "str"
                ]
            }
        },
        "test_fast_minimum_norm_targeted_attack": {
            "name": "test_fast_minimum_norm_targeted_attack",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Sequence[str]",
                    "Iterable[Any]",
                    "Callable"
                ],
                "attack_and_p": [
                    "bool",
                    "List[numpy.array]",
                    "List[int]",
                    "str"
                ]
            }
        }
    },
    "foolbox-master/tests/test_fetch_weights.py": {
        "test_fetch_weights_unzipped": {
            "name": "test_fetch_weights_unzipped",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_fetch_weights_zipped": {
            "name": "test_fetch_weights_zipped",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_fetch_weights_returns_404": {
            "name": "test_fetch_weights_returns_404",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "_random_body": {
            "name": "_random_body",
            "location": 78,
            "return": [
                "dict",
                "Sequence['cirq.Qid']",
                "int",
                "bytes",
                "Dict[str, Any]"
            ],
            "arguments": {
                "zipped": [
                    "bool",
                    "str",
                    "Iterable[str]",
                    "dict",
                    "List[dict]"
                ]
            }
        },
        "_expected_path": {
            "name": "_expected_path",
            "location": 90,
            "return": [
                "str"
            ],
            "arguments": {
                "weights_uri": [
                    "str",
                    "int",
                    "bool",
                    "List[str]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_gen_attack_utils.py": {
        "test_rescale_axis": {
            "name": "test_rescale_axis",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [],
                "dummy": [
                    "str"
                ]
            }
        },
        "test_rescale_axis_nhwc": {
            "name": "test_rescale_axis_nhwc",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [],
                "dummy": [
                    "str"
                ]
            }
        }
    },
    "foolbox-master/tests/test_hsj_attack.py": {
        "get_attack_id": {
            "name": "get_attack_id",
            "location": 13,
            "return": [
                "int",
                "List[int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "int",
                    "str"
                ]
            }
        },
        "test_hsj_untargeted_attack": {
            "name": "test_hsj_untargeted_attack",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [
                    "str"
                ],
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "attack_and_p": [
                    "int",
                    "Dict[str, str]",
                    "Optional[str]"
                ]
            }
        },
        "test_hsj_targeted_attack": {
            "name": "test_hsj_targeted_attack",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [
                    "str"
                ],
                "fmodel_and_data_ext_for_attacks": [
                    "Callable",
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "int",
                    "Union[str, Iterable[str]]"
                ],
                "attack_and_p": [
                    "int",
                    "Dict[str, str]",
                    "Optional[str]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_models.py": {
        "test_bounds": {
            "name": "test_bounds",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]"
                ]
            }
        },
        "test_forward_unwrapped": {
            "name": "test_forward_unwrapped",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]"
                ]
            }
        },
        "test_forward_wrapped": {
            "name": "test_forward_wrapped",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]"
                ]
            }
        },
        "test_pytorch_training_warning": {
            "name": "test_pytorch_training_warning",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_pytorch_invalid_model": {
            "name": "test_pytorch_invalid_model",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_jax_no_data_format": {
            "name": "test_jax_no_data_format",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_transform_bounds": {
            "name": "test_transform_bounds",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]",
                    "bool"
                ],
                "bounds": [
                    "str",
                    "int",
                    "bytes"
                ]
            }
        },
        "test_transform_bounds_inplace": {
            "name": "test_transform_bounds_inplace",
            "location": 119,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]",
                    "bool"
                ],
                "bounds": [
                    "foolbox.types.BoundsInput",
                    "dict"
                ]
            }
        },
        "test_transform_bounds_wrapper": {
            "name": "test_transform_bounds_wrapper",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]",
                    "bool"
                ],
                "bounds": [
                    "str",
                    "int",
                    "Optional[Callable[[Dict], bool]]"
                ],
                "manual": [
                    "bool",
                    "str"
                ]
            }
        },
        "test_preprocessing": {
            "name": "test_preprocessing",
            "location": 184,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]"
                ]
            }
        },
        "test_transform_bounds_wrapper_data_format": {
            "name": "test_transform_bounds_wrapper_data_format",
            "location": 239,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_transform_bounds_wrapper_missing_data_format": {
            "name": "test_transform_bounds_wrapper_missing_data_format",
            "location": 259,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_pytorch_training_warning.Model.forward": {
            "name": "forward",
            "location": 54,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "test_pytorch_invalid_model.Model.forward": {
            "name": "forward",
            "location": 69,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "test_jax_no_data_format.Model.__call__": {
            "name": "__call__",
            "location": 84,
            "return": [],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "test_transform_bounds_wrapper_data_format.Model.bounds": {
            "name": "bounds",
            "location": 244,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "test_transform_bounds_wrapper_data_format.Model.__call__": {
            "name": "__call__",
            "location": 247,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": []
            }
        },
        "test_transform_bounds_wrapper_missing_data_format.Model.bounds": {
            "name": "bounds",
            "location": 262,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "test_transform_bounds_wrapper_missing_data_format.Model.__call__": {
            "name": "__call__",
            "location": 265,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "dict"
                ]
            }
        }
    },
    "foolbox-master/tests/test_plot.py": {
        "test_plot": {
            "name": "test_plot",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "dummy": [
                    "str",
                    "Union[int, float]",
                    "Sequence[Union[int, float]]",
                    "IO[bytes]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_pointwise_attack.py": {
        "get_attack_id": {
            "name": "get_attack_id",
            "location": 12,
            "return": [
                "int",
                "List[int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "int",
                    "str"
                ]
            }
        },
        "test_pointwise_untargeted_attack": {
            "name": "test_pointwise_untargeted_attack",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [
                    "set",
                    "BinaryIO"
                ],
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "attack": [
                    "bool",
                    "int"
                ]
            }
        },
        "test_pointwise_targeted_attack": {
            "name": "test_pointwise_targeted_attack",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [
                    "set",
                    "BinaryIO"
                ],
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "attack": [
                    "bool",
                    "int",
                    "List[List[int]]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_spatial_attack.py": {
        "get_attack_id": {
            "name": "get_attack_id",
            "location": 9,
            "return": [
                "int",
                "List[int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "int",
                    "str"
                ]
            }
        },
        "test_spatial_attacks": {
            "name": "test_spatial_attacks",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data_ext_for_attacks": [
                    "Tuple[Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor], bool]",
                    "Sequence[str]"
                ],
                "attack_grad_real": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "foolbox-master/tests/test_tensorboard.py": {
        "test_tensorboard": {
            "name": "test_tensorboard",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "logdir": [
                    "str"
                ],
                "tmp_path": [
                    "list",
                    "Optional[str]",
                    "bool",
                    "str"
                ],
                "dummy": [
                    "eagerpy.Tensor",
                    "bool"
                ]
            }
        }
    },
    "foolbox-master/tests/test_utils.py": {
        "test_accuracy": {
            "name": "test_accuracy",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Tuple[foolbox.Model, eagerpy.Tensor, eagerpy.Tensor]"
                ]
            }
        },
        "test_samples": {
            "name": "test_samples",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Dict[str, Optional[str]]",
                    "dict",
                    "Dict[str, Dict[str, str]]",
                    "str"
                ],
                "batchsize": [
                    "int",
                    "bytes",
                    "bool"
                ],
                "dataset": [
                    "str",
                    "bool",
                    "Union[List, Dict]",
                    "float",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "test_samples_large_batch": {
            "name": "test_samples_large_batch",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "fmodel_and_data": [
                    "Dict[str, Optional[str]]",
                    "dict",
                    "Dict[str, Dict[str, str]]",
                    "str"
                ],
                "batchsize": [
                    "int",
                    "str",
                    "List[float]"
                ],
                "dataset": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "foolbox-master/tests/test_zoo.py": {
        "unload_foolbox_model_module": {
            "name": "unload_foolbox_model_module",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_loading_model": {
            "name": "test_loading_model",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "request": [],
                "url": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_loading_invalid_model": {
            "name": "test_loading_invalid_model",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_non_default_module_throws_error": {
            "name": "test_non_default_module_throws_error",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    }
}
{
    "fox-audio-master/audioset/mel_features.py": {
        "frame": {
            "name": "frame",
            "location": 21,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "data": [
                    "Callable",
                    "List[Dict[str, Any]]"
                ],
                "window_length": [
                    "int",
                    "bytes"
                ],
                "hop_length": [
                    "int",
                    "bool",
                    "bytes",
                    "numpy.ndarray"
                ]
            }
        },
        "periodic_hann": {
            "name": "periodic_hann",
            "location": 48,
            "return": [
                "str",
                "int",
                "bytearray",
                "numpy.ndarray"
            ],
            "arguments": {
                "window_length": [
                    "str",
                    "Tuple[List, List, List]",
                    "bytes",
                    "bool"
                ]
            }
        },
        "stft_magnitude": {
            "name": "stft_magnitude",
            "location": 70,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "signal": [
                    "int",
                    "bytes",
                    "bool",
                    "str",
                    "List[str]"
                ],
                "fft_length": [
                    "float",
                    "Dict[str, Any]",
                    "List[str]",
                    "str",
                    "List[int]",
                    "int"
                ],
                "hop_length": [
                    "int",
                    "bytes",
                    "bool",
                    "str",
                    "List[str]"
                ],
                "window_length": [
                    "bool",
                    "float",
                    "int"
                ]
            }
        },
        "hertz_to_mel": {
            "name": "hertz_to_mel",
            "location": 97,
            "return": [
                "Callable",
                "Tuple[Any, Any, Any]",
                "str"
            ],
            "arguments": {
                "frequencies_hertz": [
                    "float",
                    "str",
                    "int"
                ]
            }
        },
        "spectrogram_to_mel_matrix": {
            "name": "spectrogram_to_mel_matrix",
            "location": 112,
            "return": [
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "num_mel_bins": [
                    "int",
                    "float",
                    "List[float]"
                ],
                "num_spectrogram_bins": [
                    "int",
                    "float",
                    "Optional[int]",
                    "str",
                    "Optional[float]",
                    "Union[int, float]"
                ],
                "audio_sample_rate": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "lower_edge_hertz": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "float",
                    "List[str]",
                    "Optional[\"Address\"]"
                ],
                "upper_edge_hertz": [
                    "str",
                    "float"
                ]
            }
        },
        "log_mel_spectrogram": {
            "name": "log_mel_spectrogram",
            "location": 198,
            "return": [
                "List[List[int]]",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "data": [
                    "bool",
                    "int",
                    "Dict[str, int]"
                ],
                "audio_sample_rate": [
                    "int",
                    "Optional[int]",
                    "Callable",
                    "bool"
                ],
                "log_offset": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "window_length_secs": [
                    "int",
                    "Optional[int]",
                    "bool"
                ],
                "hop_length_secs": [
                    "int",
                    "Optional[int]",
                    "bool"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_inference.py": {
        "get_last_row": {
            "name": "get_last_row",
            "location": 101,
            "return": [
                "str",
                "Optional[str]",
                "int",
                "Optional[Dict]"
            ],
            "arguments": {
                "csv_filename": [
                    "str"
                ]
            }
        },
        "embedding": {
            "name": "embedding",
            "location": 110,
            "return": [
                ""
            ],
            "arguments": {
                "wav": [
                    "Mapping[str, object]",
                    "str",
                    "Callable",
                    "AbstractSet[str]",
                    "TextIO"
                ],
                "tf_record_filename": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 262,
            "return": [
                ""
            ],
            "arguments": {
                "_": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_inference_demo.py": {
        "main": {
            "name": "main",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {
                "_": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_inference_score.py": {
        "embedding": {
            "name": "embedding",
            "location": 87,
            "return": [
                ""
            ],
            "arguments": {
                "wav": [
                    "Optional[int]",
                    "str",
                    "Iterable[str]",
                    "Mapping[str, bool]",
                    "Deque[str]",
                    "Sequence[str]",
                    "Sequence[Sequence[str]]",
                    "FrozenSet[str]"
                ],
                "tf_record_filename": [
                    "str",
                    "dict",
                    "Exception",
                    "Optional[int]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 163,
            "return": [
                ""
            ],
            "arguments": {
                "_": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_input.py": {
        "waveform_to_examples": {
            "name": "waveform_to_examples",
            "location": 26,
            "return": [
                "Dict[str, Any]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "data": [
                    "int",
                    "str",
                    "bytes"
                ],
                "sample_rate": [
                    "bytes",
                    "str",
                    "dict"
                ]
            }
        },
        "wavfile_to_examples": {
            "name": "wavfile_to_examples",
            "location": 75,
            "return": [
                "Dict[str, Any]"
            ],
            "arguments": {
                "wav_file": [
                    "int",
                    "List[str]"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_params.py": {},
    "fox-audio-master/audioset/vggish_postprocess.py": {
        "Postprocessor.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "pca_params_npz_path": [
                    "str",
                    "Optional[int]",
                    "dict",
                    "Exception",
                    "Dict[str, Any]"
                ]
            }
        },
        "Postprocessor.postprocess": {
            "name": "postprocess",
            "location": 55,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "embeddings_batch": [
                    "int",
                    "Optional[int]",
                    "str"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_slim.py": {
        "define_vggish_slim": {
            "name": "define_vggish_slim",
            "location": 39,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "training": []
            }
        },
        "load_vggish_slim_checkpoint": {
            "name": "load_vggish_slim_checkpoint",
            "location": 106,
            "return": [
                ""
            ],
            "arguments": {
                "session": [
                    "str",
                    "dict"
                ],
                "checkpoint_path": [
                    "str",
                    "dict"
                ]
            }
        }
    },
    "fox-audio-master/audioset/vggish_smoke_test.py": {},
    "fox-audio-master/audioset/vggish_train_demo.py": {
        "_get_examples_batch": {
            "name": "_get_examples_batch",
            "location": 84,
            "return": [
                "str"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 132,
            "return": [
                ""
            ],
            "arguments": {
                "_": [
                    "int",
                    "Collection[str]",
                    "numpy.random.RandomState",
                    "numpy.ndarray",
                    "float"
                ]
            }
        }
    },
    "fox-audio-master/audioset/__init__.py": {},
    "fox-audio-master/microsoft/tfrecord.py": {
        "read": {
            "name": "read",
            "location": 6,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "record_path": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "is_sequence_example": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "print_example": {
            "name": "print_example",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "record_path": [
                    "str",
                    "Optional['Directory']",
                    "Dict[str, Any]"
                ],
                "is_sequence_example": [
                    "str",
                    "Optional['Directory']",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "fox-audio-master/microsoft/white_noise_padding.py": {
        "wav_length": {
            "name": "wav_length",
            "location": 15,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "filename": [
                    "str",
                    "bytes"
                ]
            }
        },
        "combinations": {
            "name": "combinations",
            "location": 23,
            "return": [
                "float",
                "numpy.ndarray",
                "int"
            ],
            "arguments": {
                "lst": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "target": [
                    "str"
                ],
                "with_replacement": [
                    "str"
                ]
            }
        },
        "padding": {
            "name": "padding",
            "location": 36,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {
                "wav": [
                    "str",
                    "list",
                    "Mapping"
                ],
                "white_noise_duration": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "padding_output": {
            "name": "padding_output",
            "location": 227,
            "return": [
                ""
            ],
            "arguments": {
                "f": [
                    "multiprocessing.Queue",
                    "str",
                    "Callable",
                    "IO"
                ]
            }
        },
        "combinations._a": {
            "name": "_a",
            "location": 24,
            "return": [
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "idx": [
                    "int",
                    "numpy.ndarray",
                    "Sequence[int]",
                    "bool",
                    "Optional[T]",
                    "Sequence[T]",
                    "str"
                ],
                "l": [
                    "numpy.ndarray",
                    "T"
                ],
                "r": [
                    "list",
                    "bytes",
                    "str",
                    "List[bytes]",
                    "Sequence[T]"
                ],
                "t": [
                    "numpy.ndarray",
                    "str",
                    "int"
                ],
                "w": [
                    "int",
                    "Optional[int]",
                    "bool"
                ]
            }
        },
        "parse_args": {
            "name": "parse_args",
            "location": 334,
            "return": [
                "argparse.Namespace",
                "argparse.ArgumentParser"
            ],
            "arguments": {}
        }
    },
    "fox-audio-master/microsoft/__init__.py": {},
    "fox-audio-master/microsoft/validation/inference_json.py": {
        "format_lines": {
            "name": "format_lines",
            "location": 84,
            "return": [
                ""
            ],
            "arguments": {
                "video_ids": [
                    "int",
                    "str",
                    "List[str]",
                    "bool",
                    "bytes"
                ],
                "predictions": [
                    "str",
                    "List[str]",
                    "cmk.utils.type_defs.HostName",
                    "bool",
                    "int"
                ],
                "top_k": [
                    "bool",
                    "int",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "get_input_data_tensors": {
            "name": "get_input_data_tensors",
            "location": 102,
            "return": [
                "AbstractSet[str]",
                "raiden.utils.Dict[str, raiden.utils.Any]",
                "int",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "reader": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[int, int]"
                ],
                "data_pattern": [
                    "int",
                    "float",
                    "str"
                ],
                "batch_size": [
                    "int"
                ],
                "num_readers": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[int, int]"
                ]
            }
        },
        "inference": {
            "name": "inference",
            "location": 142,
            "return": [
                ""
            ],
            "arguments": {
                "reader": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "train_dir": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "data_pattern": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "out_file_location": [
                    "str",
                    "logging.Logger",
                    "bool",
                    "int"
                ],
                "batch_size": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "top_k": [
                    "str",
                    "rotkehlchen.db.utils.BlockchainAccounts",
                    "Optional[str]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 236,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "inference.set_up_init_ops": {
            "name": "set_up_init_ops",
            "location": 173,
            "return": [
                "str",
                "Union[int, float, complex]",
                "bool",
                "int"
            ],
            "arguments": {
                "variables": [
                    "Optional[Mapping[str, Any]]",
                    "dict",
                    "Callable"
                ]
            }
        }
    },
    "fox-audio-master/microsoft/validation/k_inference_json.py": {
        "main": {
            "name": "main",
            "location": 17,
            "return": [
                ""
            ],
            "arguments": {
                "_": [
                    "str",
                    "Dict[str, str]",
                    "Optional[List[str]]"
                ]
            }
        },
        "get_2d_conv_model": {
            "name": "get_2d_conv_model",
            "location": 71,
            "return": [
                "Optional[str]",
                "bool",
                "Optional[List[Any]]",
                "Optional[Sequence[str]]"
            ],
            "arguments": {
                "config": [
                    "Dict[str, Any]",
                    "sphinx.config.Config"
                ]
            }
        }
    },
    "fox-audio-master/microsoft/validation/yt8m_inference_json_formatter.py": {
        "main": {
            "name": "main",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "_": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "parse_args": {
            "name": "parse_args",
            "location": 84,
            "return": [
                "argparse.Namespace",
                "argparse.ArgumentParser"
            ],
            "arguments": {}
        }
    },
    "fox-audio-master/youtube8m/average_precision_calculator.py": {
        "AveragePrecisionCalculator.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "top_n": [
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "AveragePrecisionCalculator.heap_size": {
            "name": "heap_size",
            "location": 84,
            "return": [
                "dict",
                "bool",
                "Dict[str, int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "AveragePrecisionCalculator.num_accumulated_positives": {
            "name": "num_accumulated_positives",
            "location": 89,
            "return": [
                "int",
                "numpy.ndarray",
                "str",
                "deque"
            ],
            "arguments": {
                "self": []
            }
        },
        "AveragePrecisionCalculator.accumulate": {
            "name": "accumulate",
            "location": 93,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "int",
                    "list",
                    "List[str]",
                    "Sized",
                    "Sequence",
                    "List[int]"
                ],
                "actuals": [
                    "int",
                    "list"
                ],
                "num_positives": [
                    "Optional[int]",
                    "float",
                    "int",
                    "Union[int, None]",
                    "numpy.ndarray"
                ]
            }
        },
        "AveragePrecisionCalculator.clear": {
            "name": "clear",
            "location": 136,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "AveragePrecisionCalculator.peek_ap_at_n": {
            "name": "peek_ap_at_n",
            "location": 141,
            "return": [
                "int",
                "float",
                "numpy.ndarray",
                "str",
                "Tuple[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "AveragePrecisionCalculator.ap": {
            "name": "ap",
            "location": 162,
            "return": [
                "str",
                "List[str]",
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "predictions": [
                    "float",
                    "random.Random"
                ],
                "actuals": [
                    "float",
                    "random.Random"
                ]
            }
        },
        "AveragePrecisionCalculator.ap_at_n": {
            "name": "ap_at_n",
            "location": 182,
            "return": [
                "int",
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "predictions": [
                    "numpy.ndarray",
                    "int",
                    "numpy.ma.MaskedArray",
                    "list",
                    "float"
                ],
                "actuals": [
                    "numpy.ndarray",
                    "int",
                    "numpy.ma.MaskedArray",
                    "List[float]"
                ],
                "n": [
                    "Optional[int]",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Optional[float]",
                    "Optional[numpy.ndarray]"
                ],
                "total_num_positives": [
                    "int",
                    "Optional[int]",
                    "Optional[Union[Any, Any]]",
                    "List[int]",
                    "Optional[float]",
                    "Optional[Callable[[str], bool]]",
                    "Optional[str]"
                ]
            }
        },
        "AveragePrecisionCalculator._shuffle": {
            "name": "_shuffle",
            "location": 249,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "list",
                    "int",
                    "str",
                    "List[float]",
                    "Dict[str, str]"
                ],
                "actuals": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AveragePrecisionCalculator._zero_one_normalize": {
            "name": "_zero_one_normalize",
            "location": 257,
            "return": [
                "bool",
                "List[str]",
                "Set[str]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "str",
                    "Mapping[str, Any]"
                ],
                "epsilon": [
                    "Pattern",
                    "str",
                    "int"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/convert_prediction_from_json_to_csv.py": {
        "get_csv_header": {
            "name": "get_csv_header",
            "location": 50,
            "return": [
                "bool",
                "str",
                "List[str]",
                "int"
            ],
            "arguments": {}
        },
        "to_csv_row": {
            "name": "to_csv_row",
            "location": 54,
            "return": [
                "bool",
                "int",
                "dict"
            ],
            "arguments": {
                "json_data": [
                    "dict",
                    "Sequence",
                    "Dict[str, Any]",
                    "Type['Declared']",
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/eval.py": {
        "find_class_by_name": {
            "name": "find_class_by_name",
            "location": 62,
            "return": [
                "int",
                "Optional[dict]",
                "str",
                "List[str]",
                "Tuple[int, int]",
                "Sequence[int]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "T"
                ],
                "modules": [
                    "str",
                    "bool",
                    "T"
                ]
            }
        },
        "get_input_evaluation_tensors": {
            "name": "get_input_evaluation_tensors",
            "location": 68,
            "return": [
                "bool",
                "bytes",
                "Optional[float]"
            ],
            "arguments": {
                "reader": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Union[Tuple[int, int], int]",
                    "bool",
                    "Union[int, float]"
                ],
                "data_pattern": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "hackathon.utils.utils.ResultsMessage",
                    "list"
                ],
                "batch_size": [
                    "int",
                    "logging.Logger",
                    "float"
                ],
                "num_readers": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Union[Tuple[int, int], int]",
                    "bool",
                    "Union[int, float]"
                ]
            }
        },
        "build_graph": {
            "name": "build_graph",
            "location": 104,
            "return": [
                ""
            ],
            "arguments": {
                "reader": [
                    "int",
                    "bool"
                ],
                "model": [
                    "Optional[int]",
                    "Optional[cmk.gui.plugins.userdb.utils.UserConnector]",
                    "bool"
                ],
                "eval_data_pattern": [
                    "int",
                    "bool"
                ],
                "label_loss_fn": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "bool"
                ],
                "num_readers": [
                    "int",
                    "bool"
                ]
            }
        },
        "get_latest_checkpoint": {
            "name": "get_latest_checkpoint",
            "location": 157,
            "return": [
                "str",
                "Optional[dict]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {}
        },
        "evaluation_loop": {
            "name": "evaluation_loop",
            "location": 178,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "video_id_batch": [
                    "int",
                    "Optional[str]"
                ],
                "prediction_batch": [
                    "int",
                    "Optional[str]"
                ],
                "label_batch": [
                    "int",
                    "Optional[str]"
                ],
                "loss": [
                    "int",
                    "Optional[str]"
                ],
                "summary_op": [
                    "int",
                    "Optional[str]"
                ],
                "saver": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "summary_writer": [
                    "Optional[bool]",
                    "int",
                    "List[str]",
                    "bool",
                    "recidiviz.utils.regions.Region",
                    "Optional[str]",
                    "str"
                ],
                "evl_metrics": [
                    "bool",
                    "str",
                    "Dict[str, Any]",
                    "List[str]"
                ],
                "last_global_step_val": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "Optional[int]",
                    "list"
                ]
            }
        },
        "evaluate": {
            "name": "evaluate",
            "location": 296,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 372,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/eval_util.py": {
        "flatten": {
            "name": "flatten",
            "location": 25,
            "return": [
                "Dict[int, int]",
                "List[str]",
                "str",
                "Set[str]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "Dict[str, Set[str]]",
                    "List[List[str]]",
                    "numpy.ndarray"
                ]
            }
        },
        "calculate_hit_at_one": {
            "name": "calculate_hit_at_one",
            "location": 30,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "actuals": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "calculate_precision_at_equal_recall_rate": {
            "name": "calculate_precision_at_equal_recall_rate",
            "location": 47,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "int",
                    "numpy.random.RandomState",
                    "float",
                    "str"
                ],
                "actuals": [
                    "int",
                    "List[str]",
                    "tensorflow.Tensor",
                    "numpy.ndarray",
                    "bool",
                    "dict"
                ]
            }
        },
        "calculate_gap": {
            "name": "calculate_gap",
            "location": 74,
            "return": [
                "str",
                "List[str]",
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "predictions": [
                    "int",
                    "float",
                    "List[str]",
                    "bool"
                ],
                "actuals": [
                    "int",
                    "float",
                    "List[str]",
                    "bool"
                ],
                "top_k": [
                    "int",
                    "float",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "top_k_by_class": {
            "name": "top_k_by_class",
            "location": 99,
            "return": [
                "Tuple[str]",
                "str",
                "bytes"
            ],
            "arguments": {
                "predictions": [
                    "Optional[str]",
                    "int",
                    "numpy.ndarray"
                ],
                "labels": [
                    "Union[datetime.datetime, datetime.date]",
                    "str"
                ],
                "k": [
                    "str",
                    "Type[T]",
                    "float",
                    "Dict[str, Any]",
                    "Iterator[Any]"
                ]
            }
        },
        "top_k_triplets": {
            "name": "top_k_triplets",
            "location": 138,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "bytes",
                    "str",
                    "int",
                    "Tuple[int, int, str]"
                ],
                "labels": [
                    "List[Tuple[str, Any, Any]]"
                ],
                "k": [
                    "bytes",
                    "str",
                    "Iterable[str]",
                    "float"
                ]
            }
        },
        "EvaluationMetrics.__init__": {
            "name": "__init__",
            "location": 150,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "num_class": [
                    "float",
                    "Tuple[int, int]",
                    "numpy.ndarray",
                    "bool"
                ],
                "top_k": [
                    "int",
                    "bool",
                    "Tuple[str, str]"
                ]
            }
        },
        "EvaluationMetrics.accumulate": {
            "name": "accumulate",
            "location": 169,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictions": [],
                "labels": [
                    "List[int]",
                    "int"
                ],
                "loss": [
                    "numpy.ndarray",
                    "float",
                    "List[str]",
                    "Sequence[str]"
                ]
            }
        },
        "EvaluationMetrics.get": {
            "name": "get",
            "location": 207,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationMetrics.clear": {
            "name": "clear",
            "location": 236,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "fox-audio-master/youtube8m/export_model.py": {
        "ModelExporter.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "frame_features": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "str",
                    "bool",
                    "Callable"
                ],
                "model": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "str",
                    "bool",
                    "Callable"
                ],
                "reader": [
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "str",
                    "bool",
                    "Callable"
                ]
            }
        },
        "ModelExporter.export_model": {
            "name": "export_model",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model_dir": [
                    "bool",
                    "str",
                    "cmk.utils.type_defs.HostName",
                    "Optional[str]",
                    "Optional[List[str]]",
                    "dict"
                ],
                "global_step_val": [
                    "bool",
                    "str"
                ],
                "last_checkpoint": [
                    "bool",
                    "int",
                    "str",
                    "Optional[bool]"
                ]
            }
        },
        "ModelExporter.build_inputs_and_outputs": {
            "name": "build_inputs_and_outputs",
            "location": 66,
            "return": [
                "str",
                "Optional[str]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelExporter.build_prediction_graph": {
            "name": "build_prediction_graph",
            "location": 96,
            "return": [
                "str",
                "int",
                "Union[str, int]"
            ],
            "arguments": {
                "self": [],
                "serialized_examples": [
                    "int",
                    "Callable[[int], None]"
                ]
            }
        },
        "ModelExporter.build_inputs_and_outputs.fn": {
            "name": "fn",
            "location": 70,
            "return": [
                "str",
                "qutebrowser.utils.usertypes.Backend",
                "List[str]"
            ],
            "arguments": {
                "x": [
                    "int",
                    "tensorflow.data.Dataset",
                    "List[List[Any]]",
                    "Optional[int]",
                    "list",
                    "set",
                    "Callable[[], bool]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/frame_level_models.py": {
        "FrameLevelLogisticModel.create_model": {
            "name": "create_model",
            "location": 62,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model_input": [
                    "int",
                    "bool",
                    "contests.models.Contest"
                ],
                "vocab_size": [
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "num_frames": [
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "DbofModel.create_model": {
            "name": "create_model",
            "location": 122,
            "return": [
                "bool",
                "Union['AbstractSetIntStr', 'MappingIntStrAny']",
                "str"
            ],
            "arguments": {
                "self": [],
                "model_input": [
                    "List[int]",
                    "Callable[[List], bool]",
                    "int",
                    "float",
                    "str"
                ],
                "vocab_size": [
                    "int",
                    "Union[None, int]",
                    "Callable"
                ],
                "num_frames": [
                    "int",
                    "float",
                    "List[int]",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "iterations": [
                    "int",
                    "Optional[float]",
                    "bool",
                    "List[int]",
                    "str"
                ],
                "add_batch_norm": [
                    "bool",
                    "allennlp.models.model.Model",
                    "int",
                    "str",
                    "dict"
                ],
                "sample_random_frames": [
                    "int",
                    "bool",
                    "Callable",
                    "List['cirq.Circuit']",
                    "str",
                    "Optional[List[str]]"
                ],
                "cluster_size": [
                    "int",
                    "bool",
                    "str"
                ],
                "hidden_size": [
                    "int",
                    "bool",
                    "str",
                    "Tuple[int, int, int]",
                    "Optional[int]"
                ],
                "is_training": [
                    "str",
                    "bytes",
                    "Dict[str, List[str]]",
                    "Sequence[str]",
                    "Optional[Mapping[str, Any]]"
                ]
            }
        },
        "LstmModel.create_model": {
            "name": "create_model",
            "location": 230,
            "return": [
                "cmk.utils.type_defs.UserId",
                "int",
                "bool",
                "Callable",
                "Dict[int, dict]"
            ],
            "arguments": {
                "self": [],
                "model_input": [
                    "int",
                    "Optional[int]",
                    "str",
                    "float"
                ],
                "vocab_size": [
                    "int",
                    "Optional[int]",
                    "float",
                    "bool",
                    "Callable"
                ],
                "num_frames": [
                    "int",
                    "float",
                    "Optional[int]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/inference.py": {
        "format_lines": {
            "name": "format_lines",
            "location": 89,
            "return": [
                ""
            ],
            "arguments": {
                "video_ids": [
                    "int",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "predictions": [
                    "str",
                    "List[str]",
                    "cmk.utils.type_defs.HostName",
                    "bool",
                    "int"
                ],
                "top_k": [
                    "bool",
                    "int",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "get_input_data_tensors": {
            "name": "get_input_data_tensors",
            "location": 103,
            "return": [
                "AbstractSet[str]",
                "raiden.utils.Dict[str, raiden.utils.Any]",
                "int",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "reader": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[int, int]"
                ],
                "data_pattern": [
                    "int",
                    "float",
                    "str"
                ],
                "batch_size": [
                    "int"
                ],
                "num_readers": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[int, int]"
                ]
            }
        },
        "inference": {
            "name": "inference",
            "location": 143,
            "return": [
                ""
            ],
            "arguments": {
                "reader": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "train_dir": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "data_pattern": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "out_file_location": [
                    "str",
                    "logging.Logger",
                    "bool",
                    "int"
                ],
                "batch_size": [
                    "bool",
                    "List[str]",
                    "str",
                    "list"
                ],
                "top_k": [
                    "str",
                    "rotkehlchen.db.utils.BlockchainAccounts",
                    "Optional[str]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 228,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "inference.set_up_init_ops": {
            "name": "set_up_init_ops",
            "location": 174,
            "return": [
                "str",
                "Union[int, float, complex]",
                "bool",
                "int"
            ],
            "arguments": {
                "variables": [
                    "Optional[Mapping[str, Any]]",
                    "dict",
                    "Callable"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/losses.py": {
        "BaseLoss.calculate_loss": {
            "name": "calculate_loss",
            "location": 23,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "unused_predictions": [
                    "bool",
                    "int",
                    "Mapping"
                ],
                "unused_labels": [
                    "bool",
                    "int",
                    "Mapping"
                ]
            }
        },
        "CrossEntropyLoss.calculate_loss": {
            "name": "calculate_loss",
            "location": 44,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "float"
                ],
                "labels": [
                    "bytes"
                ]
            }
        },
        "HingeLoss.calculate_loss": {
            "name": "calculate_loss",
            "location": 63,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "int",
                    "List[List[int]]",
                    "str"
                ],
                "labels": [
                    "bytes",
                    "bool",
                    "float"
                ],
                "b": [
                    "int",
                    "List[List[int]]",
                    "str"
                ]
            }
        },
        "SoftmaxLoss.calculate_loss": {
            "name": "calculate_loss",
            "location": 87,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "str",
                    "int",
                    "Iterable[str]"
                ],
                "labels": [
                    "bytes"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/mean_average_precision_calculator.py": {
        "MeanAveragePrecisionCalculator.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "num_class": [
                    "bool",
                    "str",
                    "List[str]"
                ]
            }
        },
        "MeanAveragePrecisionCalculator.accumulate": {
            "name": "accumulate",
            "location": 72,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "List[int]",
                    "int",
                    "List[str]"
                ],
                "actuals": [
                    "int",
                    "List[List[int]]"
                ],
                "num_positives": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "list",
                    "str"
                ]
            }
        },
        "MeanAveragePrecisionCalculator.clear": {
            "name": "clear",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "MeanAveragePrecisionCalculator.is_empty": {
            "name": "is_empty",
            "location": 100,
            "return": [
                "List[List[int]]",
                "tuple",
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MeanAveragePrecisionCalculator.peek_map_at_n": {
            "name": "peek_map_at_n",
            "location": 105,
            "return": [
                "int",
                "float",
                "numpy.ndarray",
                "str",
                "Tuple[int]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "fox-audio-master/youtube8m/models.py": {
        "BaseModel.create_model": {
            "name": "create_model",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "unused_model_input": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/model_utils.py": {
        "SampleRandomSequence": {
            "name": "SampleRandomSequence",
            "location": 24,
            "return": [],
            "arguments": {
                "model_input": [
                    "int",
                    "bool",
                    "List[float]",
                    "List[str]",
                    "Tuple[int, int, int]",
                    "str",
                    "Optional[int]"
                ],
                "num_frames": [
                    "int",
                    "Optional[int]",
                    "float",
                    "Union[int, float]"
                ],
                "num_samples": [
                    "int",
                    "float",
                    "Union[int, float]"
                ]
            }
        },
        "SampleRandomFrames": {
            "name": "SampleRandomFrames",
            "location": 56,
            "return": [],
            "arguments": {
                "model_input": [
                    "int",
                    "bool",
                    "List[float]",
                    "List[str]",
                    "Tuple[int, int, int]",
                    "str",
                    "Optional[int]"
                ],
                "num_frames": [
                    "int",
                    "bool",
                    "List[float]",
                    "float"
                ],
                "num_samples": [
                    "int",
                    "bool",
                    "List[float]",
                    "float"
                ]
            }
        },
        "FramePooling": {
            "name": "FramePooling",
            "location": 80,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "frames": [
                    "hypothesis.extra.numpy.Shape",
                    "List[numpy.ndarray]",
                    "int",
                    "float",
                    "str",
                    "bytes"
                ],
                "method": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/readers.py": {
        "resize_axis": {
            "name": "resize_axis",
            "location": 23,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "str",
                    "Callable[..., None]",
                    "int",
                    "Optional[List[Any]]",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "float"
                ],
                "axis": [
                    "int",
                    "Dict[str, str]",
                    "float",
                    "str"
                ],
                "new_size": [
                    "str",
                    "float",
                    "Union[int, float]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "bool"
                ],
                "fill_value": [
                    "int",
                    "tuple"
                ]
            }
        },
        "BaseReader.prepare_reader": {
            "name": "prepare_reader",
            "location": 67,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "unused_filename_queue": [
                    "bool",
                    "str",
                    "Iterable[str]",
                    "Mapping[str, Any]",
                    "List[int]",
                    "int"
                ]
            }
        },
        "YT8MAggregatedFeatureReader.__init__": {
            "name": "__init__",
            "location": 80,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "num_classes": [
                    "Optional[List[str]]",
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[str]"
                ],
                "feature_sizes": [
                    "int",
                    "list",
                    "List[str]",
                    "bool"
                ],
                "feature_names": [
                    "int",
                    "Optional[str]",
                    "float",
                    "bool",
                    "Optional[Sequence[str]]"
                ]
            }
        },
        "YT8MAggregatedFeatureReader.prepare_reader": {
            "name": "prepare_reader",
            "location": 104,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "filename_queue": [
                    "str",
                    "Optional[\"Address\"]",
                    "bytes",
                    "int"
                ],
                "batch_size": [
                    "str",
                    "Optional[\"Address\"]",
                    "bytes",
                    "int"
                ]
            }
        },
        "YT8MAggregatedFeatureReader.prepare_serialized_examples": {
            "name": "prepare_serialized_examples",
            "location": 119,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "serialized_examples": [
                    "bytes",
                    "str"
                ]
            }
        },
        "YT8MFrameFeatureReader.__init__": {
            "name": "__init__",
            "location": 162,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "num_classes": [
                    "Optional[List[str]]",
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[str]"
                ],
                "feature_sizes": [
                    "int",
                    "list",
                    "List[str]",
                    "bool"
                ],
                "feature_names": [
                    "int",
                    "Optional[str]",
                    "float",
                    "bool",
                    "Optional[Sequence[str]]"
                ],
                "max_frames": [
                    "int",
                    "float"
                ]
            }
        },
        "YT8MFrameFeatureReader.get_video_matrix": {
            "name": "get_video_matrix",
            "location": 189,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "features": [
                    "int",
                    "Callable[[tensorflow.Tensor], tensorflow.Tensor]",
                    "Optional[float]",
                    "float"
                ],
                "feature_size": [
                    "int",
                    "Callable[[tensorflow.Tensor], tensorflow.Tensor]",
                    "Optional[float]",
                    "float"
                ],
                "max_frames": [
                    "float",
                    "int",
                    "str"
                ],
                "max_quantized_value": [
                    "int",
                    "float"
                ],
                "min_quantized_value": [
                    "int",
                    "float"
                ]
            }
        },
        "YT8MFrameFeatureReader.prepare_reader": {
            "name": "prepare_reader",
            "location": 221,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "filename_queue": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "max_quantized_value": [
                    "int",
                    "Union[int, str]",
                    "float",
                    "Optional[int]"
                ],
                "min_quantized_value": [
                    "int",
                    "Union[int, str]",
                    "float",
                    "Optional[int]"
                ]
            }
        },
        "YT8MFrameFeatureReader.prepare_serialized_examples": {
            "name": "prepare_serialized_examples",
            "location": 241,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "serialized_example": [
                    "bool",
                    "Optional[str]",
                    "Callable[[], None]",
                    "Tuple[str, int]"
                ],
                "max_quantized_value": [
                    "float",
                    "int",
                    "Optional[int]"
                ],
                "min_quantized_value": [
                    "float",
                    "int",
                    "Optional[int]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/retrain.py": {
        "validate_class_name": {
            "name": "validate_class_name",
            "location": 124,
            "return": [
                "bool"
            ],
            "arguments": {
                "flag_value": [
                    "str",
                    "bool"
                ],
                "category": [
                    "bool",
                    "str",
                    "List[str]",
                    "Callable[[str], str]",
                    "IO[Any]"
                ],
                "modules": [
                    "Optional[str]",
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Optional[List[str]]",
                    "zerver.lib.requesResultT",
                    "Optional[Set[str]]"
                ],
                "expected_superclass": [
                    "dict",
                    "str",
                    "bool"
                ]
            }
        },
        "get_input_data_tensors": {
            "name": "get_input_data_tensors",
            "location": 154,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]",
                "Callable[[None, None], bool]",
                "dict"
            ],
            "arguments": {
                "reader": [
                    "int",
                    "List[float]",
                    "List[str]"
                ],
                "data_pattern": [
                    "int",
                    "bool",
                    "float",
                    "tuple",
                    "Iterable[List[str]]",
                    "Iterable[List[Any]]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "float"
                ],
                "num_epochs": [
                    "bool",
                    "float",
                    "int",
                    "str",
                    "Dict[str, int]"
                ],
                "num_readers": [
                    "int",
                    "List[float]",
                    "List[str]"
                ]
            }
        },
        "find_class_by_name": {
            "name": "find_class_by_name",
            "location": 200,
            "return": [
                "int",
                "Optional[dict]",
                "str",
                "List[str]",
                "Tuple[int, int]",
                "Sequence[int]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "T"
                ],
                "modules": [
                    "str",
                    "bool",
                    "T"
                ]
            }
        },
        "build_graph": {
            "name": "build_graph",
            "location": 206,
            "return": [
                ""
            ],
            "arguments": {
                "reader": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "model": [
                    "int",
                    "float"
                ],
                "train_data_pattern": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "label_loss_fn": [
                    "list",
                    "int",
                    "trezor.utils.Writer",
                    "str",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "base_learning_rate": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "learning_rate_decay_examples": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "learning_rate_decay": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "optimizer_class": [
                    "int",
                    "bool",
                    "str",
                    "dict"
                ],
                "clip_gradient_norm": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "regularization_penalty": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "num_readers": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "num_epochs": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ]
            }
        },
        "get_reader": {
            "name": "get_reader",
            "location": 720,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "start_server": {
            "name": "start_server",
            "location": 765,
            "return": [
                "int",
                "Tuple[str, str]",
                "str",
                "list"
            ],
            "arguments": {
                "cluster": [
                    "raiden.utils.SecretHash",
                    "Dict[str, Any]"
                ],
                "task": [
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        },
        "task_as_string": {
            "name": "task_as_string",
            "location": 788,
            "return": [
                "Dict[str, Any]",
                "T",
                "str",
                "List[str]"
            ],
            "arguments": {
                "task": []
            }
        },
        "main": {
            "name": "main",
            "location": 792,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "Trainer.__init__": {
            "name": "__init__",
            "location": 379,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "cluster": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "task": [
                    "bool",
                    "Optional[cmk.utils.type_defs.HostAddress]",
                    "dict",
                    "app.models.dto.ClientInfo",
                    "str",
                    "logging.LogRecord"
                ],
                "train_dir": [
                    "str",
                    "bool"
                ],
                "model": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "reader": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "model_exporter": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "log_device_placement": [
                    "bool"
                ],
                "max_steps": [
                    "int",
                    "str",
                    "float"
                ],
                "export_model_steps": [
                    "bool",
                    "int",
                    "Tuple[str, Optional[str]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Trainer.run": {
            "name": "run",
            "location": 418,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "start_new_model": [
                    "int",
                    "Callable[[str], int]",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "Trainer.restore_last_checkpoint": {
            "name": "restore_last_checkpoint",
            "location": 576,
            "return": [
                "Dict[str, Any]",
                "Optional[bool]",
                "Set[VT]",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.export_model": {
            "name": "export_model",
            "location": 601,
            "return": [
                "app.models.Article",
                "Iterator[Dict[str, str]]",
                "str"
            ],
            "arguments": {
                "self": [],
                "global_step_val": [
                    "Optional[str]"
                ],
                "saver": [
                    "str",
                    "Union[str, bytes]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ],
                "save_path": [
                    "str",
                    "Union[str, bytes]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ],
                "session": [
                    "str",
                    "Union[str, bytes]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ]
            }
        },
        "Trainer.start_server_if_distributed": {
            "name": "start_server_if_distributed",
            "location": 623,
            "return": [
                "int",
                "Tuple[str, str]",
                "str",
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.remove_training_directory": {
            "name": "remove_training_directory",
            "location": 644,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "train_dir": [
                    "str"
                ]
            }
        },
        "Trainer.get_meta_filename": {
            "name": "get_meta_filename",
            "location": 660,
            "return": [
                "Optional[int]",
                "bool",
                "Optional[str]",
                "dict",
                "Optional[Dict]"
            ],
            "arguments": {
                "self": [],
                "start_new_model": [
                    "bool",
                    "List[str]"
                ],
                "train_dir": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "Set[str]"
                ]
            }
        },
        "Trainer.recover_model": {
            "name": "recover_model",
            "location": 687,
            "return": [
                "bytearray",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "meta_filename": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "Trainer.build_model": {
            "name": "build_model",
            "location": 695,
            "return": [
                "dict",
                "Iterable[str]",
                "Sequence[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "tensorflow.keras.Model",
                    "List[cmk.gui.plugins.visuals.utils.Filter]",
                    "Pattern"
                ],
                "reader": [
                    "tensorflow.keras.Model",
                    "List[cmk.gui.plugins.visuals.utils.Filter]",
                    "Pattern"
                ]
            }
        },
        "ParameterServer.__init__": {
            "name": "__init__",
            "location": 741,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "cluster": [
                    "Dict[str, Any]",
                    "str",
                    "Optional[int]"
                ],
                "task": [
                    "str",
                    "Sequence[Dict[str, str]]",
                    "int",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "Callable[[Dict], None]"
                ]
            }
        },
        "ParameterServer.run": {
            "name": "run",
            "location": 753,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "fox-audio-master/youtube8m/train.py": {
        "validate_class_name": {
            "name": "validate_class_name",
            "location": 140,
            "return": [
                "bool"
            ],
            "arguments": {
                "flag_value": [
                    "str",
                    "bool"
                ],
                "category": [
                    "bool",
                    "str",
                    "List[str]",
                    "Callable[[str], str]",
                    "IO[Any]"
                ],
                "modules": [
                    "Optional[str]",
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Optional[List[str]]",
                    "zerver.lib.requesResultT",
                    "Optional[Set[str]]"
                ],
                "expected_superclass": [
                    "dict",
                    "str",
                    "bool"
                ]
            }
        },
        "get_input_data_tensors": {
            "name": "get_input_data_tensors",
            "location": 170,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]",
                "Callable[[None, None], bool]",
                "dict"
            ],
            "arguments": {
                "reader": [
                    "int",
                    "List[float]",
                    "List[str]"
                ],
                "data_pattern": [
                    "int",
                    "bool",
                    "float",
                    "tuple",
                    "Iterable[List[str]]",
                    "Iterable[List[Any]]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "float"
                ],
                "num_epochs": [
                    "bool",
                    "float",
                    "int",
                    "str",
                    "Dict[str, int]"
                ],
                "num_readers": [
                    "int",
                    "List[float]",
                    "List[str]"
                ]
            }
        },
        "find_class_by_name": {
            "name": "find_class_by_name",
            "location": 216,
            "return": [
                "int",
                "Optional[dict]",
                "str",
                "List[str]",
                "Tuple[int, int]",
                "Sequence[int]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "T"
                ],
                "modules": [
                    "str",
                    "bool",
                    "T"
                ]
            }
        },
        "build_graph": {
            "name": "build_graph",
            "location": 222,
            "return": [
                ""
            ],
            "arguments": {
                "reader": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "model": [
                    "int",
                    "float"
                ],
                "train_data_pattern": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "label_loss_fn": [
                    "list",
                    "int",
                    "trezor.utils.Writer",
                    "str",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "base_learning_rate": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "learning_rate_decay_examples": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "learning_rate_decay": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "optimizer_class": [
                    "int",
                    "bool",
                    "str",
                    "dict"
                ],
                "clip_gradient_norm": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "regularization_penalty": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "num_readers": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "num_epochs": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ]
            }
        },
        "get_reader": {
            "name": "get_reader",
            "location": 710,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "start_server": {
            "name": "start_server",
            "location": 755,
            "return": [
                "int",
                "Tuple[str, str]",
                "str",
                "list"
            ],
            "arguments": {
                "cluster": [
                    "raiden.utils.SecretHash",
                    "Dict[str, Any]"
                ],
                "task": [
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        },
        "task_as_string": {
            "name": "task_as_string",
            "location": 778,
            "return": [
                "Dict[str, Any]",
                "T",
                "str",
                "List[str]"
            ],
            "arguments": {
                "task": []
            }
        },
        "main": {
            "name": "main",
            "location": 782,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "Trainer.__init__": {
            "name": "__init__",
            "location": 395,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "cluster": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "task": [
                    "bool",
                    "Optional[cmk.utils.type_defs.HostAddress]",
                    "dict",
                    "app.models.dto.ClientInfo",
                    "str",
                    "logging.LogRecord"
                ],
                "train_dir": [
                    "str",
                    "bool"
                ],
                "model": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "reader": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "model_exporter": [
                    "bool",
                    "Optional[List[Any]]",
                    "Union[Callable, str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "log_device_placement": [
                    "bool"
                ],
                "max_steps": [
                    "int",
                    "str",
                    "float"
                ],
                "export_model_steps": [
                    "bool",
                    "int",
                    "Tuple[str, Optional[str]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Trainer.run": {
            "name": "run",
            "location": 434,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "start_new_model": [
                    "int",
                    "Callable[[str], int]",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "Trainer.export_model": {
            "name": "export_model",
            "location": 592,
            "return": [
                "app.models.Article",
                "Iterator[Dict[str, str]]",
                "str"
            ],
            "arguments": {
                "self": [],
                "global_step_val": [
                    "Optional[str]"
                ],
                "saver": [
                    "str",
                    "Union[str, bytes]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ],
                "save_path": [
                    "str",
                    "Union[str, bytes]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ],
                "session": [
                    "str",
                    "Union[str, bytes]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ]
            }
        },
        "Trainer.start_server_if_distributed": {
            "name": "start_server_if_distributed",
            "location": 614,
            "return": [
                "int",
                "Tuple[str, str]",
                "str",
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.remove_training_directory": {
            "name": "remove_training_directory",
            "location": 635,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "train_dir": [
                    "str"
                ]
            }
        },
        "Trainer.get_meta_filename": {
            "name": "get_meta_filename",
            "location": 651,
            "return": [
                "Optional[int]",
                "bool",
                "Optional[str]",
                "dict",
                "Optional[Dict]"
            ],
            "arguments": {
                "self": [],
                "start_new_model": [
                    "bool",
                    "List[str]"
                ],
                "train_dir": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "Set[str]"
                ]
            }
        },
        "Trainer.recover_model": {
            "name": "recover_model",
            "location": 677,
            "return": [
                "bytearray",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "meta_filename": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "Trainer.build_model": {
            "name": "build_model",
            "location": 685,
            "return": [
                "dict",
                "Iterable[str]",
                "Sequence[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "tensorflow.keras.Model",
                    "List[cmk.gui.plugins.visuals.utils.Filter]",
                    "Pattern"
                ],
                "reader": [
                    "tensorflow.keras.Model",
                    "List[cmk.gui.plugins.visuals.utils.Filter]",
                    "Pattern"
                ]
            }
        },
        "ParameterServer.__init__": {
            "name": "__init__",
            "location": 731,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "cluster": [
                    "Dict[str, Any]",
                    "str",
                    "Optional[int]"
                ],
                "task": [
                    "str",
                    "Sequence[Dict[str, str]]",
                    "int",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "Callable[[Dict], None]"
                ]
            }
        },
        "ParameterServer.run": {
            "name": "run",
            "location": 743,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "fox-audio-master/youtube8m/transfer.py": {
        "build_graph": {
            "name": "build_graph",
            "location": 137,
            "return": [
                ""
            ],
            "arguments": {
                "reader": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "model": [
                    "int",
                    "float"
                ],
                "train_data_pattern": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "label_loss_fn": [
                    "list",
                    "int",
                    "trezor.utils.Writer",
                    "str",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "base_learning_rate": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "learning_rate_decay_examples": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "learning_rate_decay": [
                    "int",
                    "List[float]",
                    "float",
                    "List[str]",
                    "str"
                ],
                "optimizer_class": [
                    "int",
                    "bool",
                    "str",
                    "dict"
                ],
                "clip_gradient_norm": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "regularization_penalty": [
                    "int",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "bool"
                ],
                "num_readers": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ],
                "num_epochs": [
                    "int",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Union[Iterable, str]",
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 527,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "TransferTrainer.recover_model": {
            "name": "recover_model",
            "location": 318,
            "return": [
                "bytearray",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "meta_filename": [
                    "str",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "TransferTrainer.run": {
            "name": "run",
            "location": 321,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "start_new_model": [
                    "int",
                    "Callable[[str], int]",
                    "Optional[float]",
                    "float"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/utils.py": {
        "Dequantize": {
            "name": "Dequantize",
            "location": 28,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "feat_vector": [
                    "bool",
                    "float",
                    "Optional[float]",
                    "Tuple[int, int, int]",
                    "Optional[\"GraphLogger\"]"
                ],
                "max_quantized_value": [
                    "float",
                    "int"
                ],
                "min_quantized_value": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MakeSummary": {
            "name": "MakeSummary",
            "location": 46,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Union[str, Callable]",
                    "Sequence[Union[str, Any]]"
                ],
                "value": [
                    "dict",
                    "int",
                    "Iterable",
                    "Set[int]",
                    "str"
                ]
            }
        },
        "AddGlobalStepSummary": {
            "name": "AddGlobalStepSummary",
            "location": 55,
            "return": [
                "str",
                "bytes",
                "OrderedDict",
                "Dict[str, Set[str]]"
            ],
            "arguments": {
                "summary_writer": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ],
                "global_step_val": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ],
                "global_step_info_dict": [
                    "str",
                    "dict",
                    "Dict[str, Any]",
                    "bool"
                ],
                "summary_scope": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ]
            }
        },
        "AddEpochSummary": {
            "name": "AddEpochSummary",
            "location": 104,
            "return": [
                "str",
                "bytes",
                "OrderedDict",
                "Dict[str, Set[str]]"
            ],
            "arguments": {
                "summary_writer": [
                    "Dict[str, Any]",
                    "int"
                ],
                "global_step_val": [
                    "Dict[str, Any]",
                    "int"
                ],
                "epoch_info_dict": [
                    "Set[str]",
                    "str",
                    "dict",
                    "Optional[Mapping[str, Any]]",
                    "Dict[str, Any]",
                    "Optional[Dict[str, Any]]"
                ],
                "summary_scope": [
                    "Dict[str, Any]",
                    "int"
                ]
            }
        },
        "GetListOfFeatureNamesAndSizes": {
            "name": "GetListOfFeatureNamesAndSizes",
            "location": 152,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "feature_names": [
                    "str",
                    "bool",
                    "int",
                    "dict"
                ],
                "feature_sizes": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "clip_gradient_norms": {
            "name": "clip_gradient_norms",
            "location": 181,
            "return": [
                "DefaultDict[int, List[Any]]",
                "OrderedDict",
                "int"
            ],
            "arguments": {
                "gradients_to_variables": [
                    "bool",
                    "List[str]",
                    "str",
                    "Optional[str]"
                ],
                "max_norm": [
                    "int",
                    "str",
                    "Optional[bool]",
                    "float"
                ]
            }
        },
        "combine_gradients": {
            "name": "combine_gradients",
            "location": 203,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tower_grads": [
                    "Iterable[Any]",
                    "bytes",
                    "Optional[List[float]]",
                    "str"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/video_level_models.py": {
        "LogisticModel.create_model": {
            "name": "create_model",
            "location": 36,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model_input": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "vocab_size": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "l2_penalty": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "MoeModel.create_model": {
            "name": "create_model",
            "location": 59,
            "return": [
                "int",
                "Tuple[bytes]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "model_input": [
                    "str",
                    "Optional[Sequence[str]]",
                    "bool",
                    "float",
                    "int",
                    "tuple"
                ],
                "vocab_size": [
                    "str",
                    "Optional[Sequence[str]]",
                    "bool",
                    "float",
                    "int",
                    "tuple"
                ],
                "num_mixtures": [
                    "Optional[int]",
                    "int"
                ],
                "l2_penalty": [
                    "str",
                    "Optional[Sequence[str]]",
                    "bool",
                    "float",
                    "int",
                    "tuple"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/__init__.py": {},
    "fox-audio-master/youtube8m/feature_extractor/extract_tfrecords_main.py": {
        "frame_iterator": {
            "name": "frame_iterator",
            "location": 106,
            "return": [
                "app.models.Article",
                "Iterator"
            ],
            "arguments": {
                "filename": [
                    "str",
                    "int"
                ],
                "every_ms": [
                    "str",
                    "Tuple['cirq.Qid']",
                    "bool",
                    "Dict[str, Optional[str]]",
                    "Dict[str, str]",
                    "Dict[str, Any]"
                ],
                "max_num_frames": [
                    "int",
                    "Callable[[], float]"
                ]
            }
        },
        "_int64_list_feature": {
            "name": "_int64_list_feature",
            "location": 139,
            "return": [
                "Tuple[numpy.ndarray]",
                "str",
                "list"
            ],
            "arguments": {
                "int64_list": [
                    "list",
                    "List[List[int]]",
                    "List[Tuple[str, int]]",
                    "Union[str, List[str], None]",
                    "List[Union[int, float]]"
                ]
            }
        },
        "_bytes_feature": {
            "name": "_bytes_feature",
            "location": 143,
            "return": [
                "Callable",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "value": [
                    "float",
                    "list",
                    "List[str]",
                    "T"
                ]
            }
        },
        "_make_bytes": {
            "name": "_make_bytes",
            "location": 147,
            "return": [
                "str",
                "Dict[str, Any]",
                "Dict[str, int]",
                "float"
            ],
            "arguments": {
                "int_array": [
                    "str",
                    "int",
                    "bytes",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "quantize": {
            "name": "quantize",
            "location": 154,
            "return": [
                "str",
                "bytearray",
                "bytes",
                "int"
            ],
            "arguments": {
                "features": [
                    "int",
                    "str",
                    "list",
                    "List[numpy.array]"
                ],
                "min_quantized_value": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "List[int]",
                    "Optional[bool]",
                    "Optional[float]"
                ],
                "max_quantized_value": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "List[int]",
                    "Optional[bool]",
                    "Optional[float]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 166,
            "return": [
                ""
            ],
            "arguments": {
                "unused_argv": [
                    "List[str]",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/feature_extractor/feature_extractor.py": {
        "YouTube8MFeatureExtractor.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model_dir": [
                    "str",
                    "bool",
                    "Union[str, os.PathLike]"
                ]
            }
        },
        "YouTube8MFeatureExtractor.extract_rgb_frame_features": {
            "name": "extract_rgb_frame_features",
            "location": 85,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "frame_rgb": [
                    "int",
                    "Union[bool, numpy.ndarray]"
                ],
                "apply_pca": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "YouTube8MFeatureExtractor.apply_pca": {
            "name": "apply_pca",
            "location": 115,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "frame_features": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "YouTube8MFeatureExtractor._maybe_download": {
            "name": "_maybe_download",
            "location": 134,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "url": [
                    "str",
                    "Dict[str, Union[str, int]]"
                ]
            }
        },
        "YouTube8MFeatureExtractor._load_inception": {
            "name": "_load_inception",
            "location": 153,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "proto_file": [
                    "str",
                    "bool"
                ]
            }
        },
        "YouTube8MFeatureExtractor._load_pca": {
            "name": "_load_pca",
            "location": 169,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "YouTube8MFeatureExtractor._maybe_download._progress": {
            "name": "_progress",
            "location": 141,
            "return": [
                ""
            ],
            "arguments": {
                "count": [
                    "int"
                ],
                "block_size": [
                    "int"
                ],
                "total_size": [
                    "int"
                ]
            }
        }
    },
    "fox-audio-master/youtube8m/feature_extractor/feature_extractor_test.py": {
        "_FilePath": {
            "name": "_FilePath",
            "location": 25,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "_MeanElementWiseDifference": {
            "name": "_MeanElementWiseDifference",
            "location": 29,
            "return": [
                "str",
                "int",
                "dict"
            ],
            "arguments": {
                "a": [
                    "int",
                    "Callable[[str], None]",
                    "bool"
                ],
                "b": [
                    "int",
                    "Callable[[str], None]",
                    "bool"
                ]
            }
        },
        "FeatureExtractorTest.setUp": {
            "name": "setUp",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FeatureExtractorTest.testPCAOnFeatureVector": {
            "name": "testPCAOnFeatureVector",
            "location": 42,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    }
}
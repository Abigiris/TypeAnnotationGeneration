{
    "jupyter-master/pandas_util.py": {
        "toPercentNP": {
            "name": "toPercentNP",
            "location": 35,
            "return": [
                "float",
                "List[int]",
                "int"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "toPercentForMonkeyPatch": {
            "name": "toPercentForMonkeyPatch",
            "location": 39,
            "return": [
                "Iterable[int]",
                "pandas.DataFrame",
                "IO[str]"
            ],
            "arguments": {
                "appliable": [
                    "Any",
                    "Type['Payload']",
                    "str",
                    "Hashable"
                ]
            }
        },
        "time_it": {
            "name": "time_it",
            "location": 59,
            "return": [
                "int",
                "float",
                "pathlib.Path",
                "str"
            ],
            "arguments": {
                "message": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "Measure_Helper.stop": {
            "name": "stop",
            "location": 55,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "jupyter-master/PlayCustomerData.py": {
        "isFlatDistribution": {
            "name": "isFlatDistribution",
            "location": 143,
            "return": [
                "List[Dict[str, Any]]",
                "Dict[str, int]",
                "Dict[str, numpy.ndarray]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "d": [
                    "numpy.ndarray",
                    "Callable[[Any], T]",
                    "int"
                ]
            }
        },
        "plot_distribution_for": {
            "name": "plot_distribution_for",
            "location": 180,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "int",
                    "float",
                    "Tuple[float, float]"
                ],
                "count_buckets": [
                    "int",
                    "bool",
                    "Dict[str, Any]",
                    "float",
                    "str",
                    "Union[float, int]"
                ],
                "minimum_call_count": [
                    "int",
                    "numpy.ndarray",
                    "List[int]"
                ]
            }
        },
        "df_w_multi_customers": {
            "name": "df_w_multi_customers",
            "location": 200,
            "return": [
                "dict",
                "bool"
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "cid_by_freq": {
            "name": "cid_by_freq",
            "location": 235,
            "return": [
                "numpy.array",
                "str",
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "T"
                ],
                "freq": [
                    "pandas.DataFrame",
                    "int",
                    "T"
                ]
            }
        },
        "print_freq": {
            "name": "print_freq",
            "location": 247,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "dict"
                ],
                "freq": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "dict"
                ],
                "cuteName": [
                    "str",
                    "MutableMapping[str, Any]",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "minUsage": [
                    "str",
                    "MutableMapping[str, Any]",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "filter_work_hours": {
            "name": "filter_work_hours",
            "location": 303,
            "return": [
                "float",
                "Callable[[None], bool]",
                "pandas.DataFrame",
                "List[str]",
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "dict",
                    "bool",
                    "T"
                ]
            }
        },
        "by_hour_count": {
            "name": "by_hour_count",
            "location": 307,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Sequence[int]",
                    "List[List[str]]"
                ]
            }
        },
        "pivot_day_by_hour_no_melt": {
            "name": "pivot_day_by_hour_no_melt",
            "location": 310,
            "return": [
                "int",
                "pathlib.Path"
            ],
            "arguments": {
                "df": [
                    "int",
                    "T"
                ],
                "agg": [
                    "pandas.Series",
                    "type",
                    "List['cirq.Qid']",
                    "str",
                    "Type",
                    "Mapping[str, Sequence[str]]",
                    "Mapping[str, str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "pivot_day_by_hour": {
            "name": "pivot_day_by_hour",
            "location": 317,
            "return": [
                "int",
                "float",
                "pathlib.Path"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List['cirq.Qid']",
                    "pandas.Series",
                    "Dict[str, Any]",
                    "int",
                    "type",
                    "Mapping[str, str]"
                ],
                "agg": [
                    "str",
                    "List['cirq.Qid']",
                    "pandas.Series",
                    "Dict[str, Any]",
                    "int",
                    "type",
                    "Mapping[str, str]"
                ]
            }
        },
        "heat_map": {
            "name": "heat_map",
            "location": 323,
            "return": [
                "str"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "\"ComplexNumber\"",
                    "str"
                ],
                "agg": [
                    "bool",
                    "\"ComplexNumber\"",
                    "str"
                ],
                "title": [
                    "int",
                    "float"
                ],
                "is_pivoted": [
                    "bool",
                    "\"ComplexNumber\"",
                    "str"
                ]
            }
        }
    },
    "jupyter-master/PlayNLP.py": {
        "get_nlp_model": {
            "name": "get_nlp_model",
            "location": 78,
            "return": [],
            "arguments": {
                "model": []
            }
        },
        "LoadCorpus": {
            "name": "LoadCorpus",
            "location": 101,
            "return": [],
            "arguments": {
                "corpus_path": []
            }
        },
        "DocForCorpus": {
            "name": "DocForCorpus",
            "location": 186,
            "return": [],
            "arguments": {
                "nlp": [],
                "corpus": []
            }
        },
        "glob750_latest": {
            "name": "glob750_latest",
            "location": 219,
            "return": [],
            "arguments": {
                "year": [],
                "month": []
            }
        },
        "glob750_new_archive": {
            "name": "glob750_new_archive",
            "location": 224,
            "return": [],
            "arguments": {
                "year": [],
                "month": []
            }
        },
        "glob750_old_archive": {
            "name": "glob750_old_archive",
            "location": 230,
            "return": [],
            "arguments": {
                "year": [],
                "month": []
            }
        },
        "corpus_paths_months_for_year": {
            "name": "corpus_paths_months_for_year",
            "location": 236,
            "return": [],
            "arguments": {
                "year": []
            }
        },
        "GraphWordDistribution": {
            "name": "GraphWordDistribution",
            "location": 284,
            "return": [],
            "arguments": {
                "words": [],
                "title": [],
                "skip": [],
                "length": [],
                "includeCDF": []
            }
        },
        "GetInterestingWords": {
            "name": "GetInterestingWords",
            "location": 351,
            "return": [],
            "arguments": {
                "pos": [],
                "doc": [],
                "corpus": []
            }
        },
        "GraphPoSForDoc": {
            "name": "GraphPoSForDoc",
            "location": 359,
            "return": [],
            "arguments": {
                "pos": [],
                "doc": [],
                "corpus": []
            }
        },
        "GraphScratchForCorpus": {
            "name": "GraphScratchForCorpus",
            "location": 368,
            "return": [],
            "arguments": {
                "corpus_path": [],
                "pos": []
            }
        },
        "GetInterestingForCorpusPath": {
            "name": "GetInterestingForCorpusPath",
            "location": 374,
            "return": [],
            "arguments": {
                "corpus_path": [],
                "pos": []
            }
        },
        "MakePDF": {
            "name": "MakePDF",
            "location": 415,
            "return": [],
            "arguments": {
                "words": [],
                "name": []
            }
        },
        "PathToFriendlyTitle": {
            "name": "PathToFriendlyTitle",
            "location": 422,
            "return": [],
            "arguments": {
                "path": []
            }
        },
        "animate": {
            "name": "animate",
            "location": 482,
            "return": [],
            "arguments": {
                "i": []
            }
        },
        "Corpus.__hash__": {
            "name": "__hash__",
            "location": 96,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LoadCorpus.capitalizeProperNouns": {
            "name": "capitalizeProperNouns",
            "location": 136,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "LoadCorpus.fixTypos": {
            "name": "fixTypos",
            "location": 165,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "GraphWordDistribution.GetPDFCDF": {
            "name": "GetPDFCDF",
            "location": 285,
            "return": [],
            "arguments": {
                "words": []
            }
        },
        "GraphWordDistribution.PlotOnAxis": {
            "name": "PlotOnAxis",
            "location": 294,
            "return": [],
            "arguments": {
                "series": [],
                "ax": [],
                "label": [],
                "color": []
            }
        },
        "MakePDF.ToPercent": {
            "name": "ToPercent",
            "location": 416,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "GraphWordDistribution.GetPDFCDF.ToPercent": {
            "name": "ToPercent",
            "location": 286,
            "return": [],
            "arguments": {
                "x": []
            }
        }
    },
    "jupyter-master/py_generated/Array.py": {
        "unsortedMin": {
            "name": "unsortedMin",
            "location": 17,
            "return": [
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "xs": [
                    "str",
                    "int",
                    "List[int]",
                    "bool",
                    "dict"
                ],
                "i": [
                    "Tuple[int, int]",
                    "int",
                    "str",
                    "List[float]"
                ],
                "iMin": [
                    "int",
                    "str",
                    "bool",
                    "dict"
                ]
            }
        },
        "unsortedRange": {
            "name": "unsortedRange",
            "location": 35,
            "return": [
                "str"
            ],
            "arguments": {
                "xs": [
                    "int",
                    "dict",
                    "Sequence[T]",
                    "list"
                ]
            }
        },
        "plusOne": {
            "name": "plusOne",
            "location": 68,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "ds": [
                    "str",
                    "Sequence[T]",
                    "list",
                    "List[FrozenSet[str]]",
                    "int"
                ]
            }
        }
    },
    "jupyter-master/py_generated/BitTwiddling.py": {
        "printB": {
            "name": "printB",
            "location": 15,
            "return": [
                ""
            ],
            "arguments": {
                "x": [
                    "int"
                ]
            }
        },
        "InsertBits": {
            "name": "InsertBits",
            "location": 34,
            "return": [
                "bytes",
                "str",
                "bool"
            ],
            "arguments": {
                "src": [
                    "str",
                    "int",
                    "Optional[\"Address\"]"
                ],
                "dst": [
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "start": [
                    "int",
                    "bool",
                    "str"
                ],
                "end": [
                    "bool",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "PrintDoubleAsString": {
            "name": "PrintDoubleAsString",
            "location": 51,
            "return": [
                "Optional[Any]",
                "Optional[str]",
                "Sequence[str]",
                "Optional[int]",
                "str",
                "List[str]"
            ],
            "arguments": {
                "d": [
                    "str",
                    "Set[int]",
                    "List[str]",
                    "List[int]",
                    "bytes"
                ]
            }
        }
    },
    "jupyter-master/py_generated/ElegantPython.py": {
        "merge": {
            "name": "merge",
            "location": 161,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "xs": [
                    "int",
                    "float",
                    "str",
                    "T"
                ],
                "ys": [
                    "int",
                    "float",
                    "Optional[float]"
                ]
            }
        },
        "maxAlive": {
            "name": "maxAlive",
            "location": 186,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "bds": [
                    "str",
                    "int"
                ]
            }
        },
        "gen3": {
            "name": "gen3",
            "location": 286,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "start": [
                    "int",
                    "bool"
                ]
            }
        },
        "gen4": {
            "name": "gen4",
            "location": 293,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "start": [
                    "int",
                    "str",
                    "T"
                ]
            }
        },
        "PeekIterator.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "iter": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "PeekIterator.peek": {
            "name": "peek",
            "location": 100,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.__iter__": {
            "name": "__iter__",
            "location": 107,
            "return": [
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.__next__": {
            "name": "__next__",
            "location": 110,
            "return": [
                "List[str]",
                "bool",
                "List[Mapping[str, Any]]",
                "Tuple[type]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.is_empty": {
            "name": "is_empty",
            "location": 120,
            "return": [
                "Callable[[Union, Union], Tuple[Any, ...],]",
                "int",
                "Iterable[int]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.has_elements": {
            "name": "has_elements",
            "location": 123,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.pop": {
            "name": "pop",
            "location": 126,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "jupyter-master/py_generated/Heap.py": {
        "lhs": {
            "name": "lhs",
            "location": 19,
            "return": [
                "int",
                "slice",
                "str",
                "float",
                "Optional[int]"
            ],
            "arguments": {
                "i": [
                    "int",
                    "slice",
                    "T",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "rhs": {
            "name": "rhs",
            "location": 23,
            "return": [
                "int",
                "slice",
                "str",
                "float",
                "Optional[int]"
            ],
            "arguments": {
                "i": [
                    "int",
                    "slice",
                    "T",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "parent": {
            "name": "parent",
            "location": 27,
            "return": [
                "bytes",
                "str",
                "tuple",
                "dict"
            ],
            "arguments": {
                "i": [
                    "int",
                    "str"
                ]
            }
        },
        "isEven": {
            "name": "isEven",
            "location": 31,
            "return": [
                "int",
                "float",
                "Optional[int]"
            ],
            "arguments": {
                "i": [
                    "int",
                    "slice"
                ]
            }
        },
        "heapify_up": {
            "name": "heapify_up",
            "location": 35,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "storage": [
                    "list",
                    "List[str]",
                    "Callable"
                ],
                "lastElement": [
                    "List[str]",
                    "str",
                    "int",
                    "Dict[str, str]",
                    "List[T]"
                ]
            }
        },
        "heapify_down": {
            "name": "heapify_down",
            "location": 52,
            "return": [],
            "arguments": {
                "storage": [
                    "list",
                    "List[List[str]]",
                    "int",
                    "List[str]"
                ]
            }
        },
        "Heap.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "Heap.last": {
            "name": "last",
            "location": 92,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "i": [
                    "int",
                    "bool"
                ]
            }
        },
        "Heap.head": {
            "name": "head",
            "location": 95,
            "return": [
                "Optional[str]",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Heap.push": {
            "name": "push",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "i": [
                    "int",
                    "list"
                ]
            }
        },
        "Heap.pop": {
            "name": "pop",
            "location": 105,
            "return": [
                "Dict[str, Dict[str, int]]",
                "bool",
                "Dict[str, Any]",
                "Set[str]",
                "str",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Heap.__str__": {
            "name": "__str__",
            "location": 119,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "jupyter-master/py_generated/HtmlToMarkdown.py": {
        "dump": {
            "name": "dump",
            "location": 24,
            "return": [
                ""
            ],
            "arguments": {
                "el": [
                    "int",
                    "Callable",
                    "str"
                ],
                "indent": [
                    "dict",
                    "int",
                    "str"
                ]
            }
        }
    },
    "jupyter-master/py_generated/InterviewPythonTips.py": {
        "merge": {
            "name": "merge",
            "location": 161,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "xs": [
                    "int",
                    "float",
                    "str",
                    "T"
                ],
                "ys": [
                    "int",
                    "float",
                    "Optional[float]"
                ]
            }
        },
        "maxAlive": {
            "name": "maxAlive",
            "location": 186,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "bds": [
                    "str",
                    "int"
                ]
            }
        },
        "PeekIterator.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "iter": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "PeekIterator.peek": {
            "name": "peek",
            "location": 100,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.__iter__": {
            "name": "__iter__",
            "location": 107,
            "return": [
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.__next__": {
            "name": "__next__",
            "location": 110,
            "return": [
                "List[str]",
                "bool",
                "List[Mapping[str, Any]]",
                "Tuple[type]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.is_empty": {
            "name": "is_empty",
            "location": 120,
            "return": [
                "Callable[[Union, Union], Tuple[Any, ...],]",
                "int",
                "Iterable[int]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.has_elements": {
            "name": "has_elements",
            "location": 123,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeekIterator.pop": {
            "name": "pop",
            "location": 126,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "jupyter-master/py_generated/Math.py": {
        "Primes": {
            "name": "Primes",
            "location": 16,
            "return": [
                "Set[str]",
                "Dict[int, int]",
                "List[list]",
                "List[T]",
                "List[int]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "crossOff": {
            "name": "crossOff",
            "location": 30,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "possible": [
                    "str",
                    "List[int]",
                    "List[float]",
                    "list"
                ],
                "prime": [
                    "str",
                    "List[Dict]"
                ]
            }
        }
    },
    "jupyter-master/py_generated/pandasPdfCdf.py": {},
    "jupyter-master/py_generated/PickYourProject.py": {},
    "jupyter-master/py_generated/play-opencv.py": {
        "remove_background.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "base_filename": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bool"
                ],
                "in_fps": [
                    "int",
                    "str",
                    "Optional[int]",
                    "float",
                    "bytes"
                ]
            }
        },
        "remove_background.create": {
            "name": "create",
            "location": 38,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_video": [
                    "str",
                    "Iterator[str]",
                    "bool",
                    "float"
                ]
            }
        },
        "remove_background.destroy": {
            "name": "destroy",
            "location": 41,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "remove_background.frame": {
            "name": "frame",
            "location": 44,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "bool",
                    "dict",
                    "list",
                    "Optional[str]"
                ],
                "original_frame": [
                    "int",
                    "Optional[int]",
                    "float",
                    "PIL.Image.Image"
                ]
            }
        }
    },
    "jupyter-master/py_generated/PlayAnimation.py": {
        "init": {
            "name": "init",
            "location": 65,
            "return": [
                "str",
                "List[str]",
                "Union[str, List[str]]"
            ],
            "arguments": {}
        },
        "animate": {
            "name": "animate",
            "location": 70,
            "return": [
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "i": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ]
            }
        }
    },
    "jupyter-master/py_generated/PlayCustomerData.py": {
        "isFlatDistribution": {
            "name": "isFlatDistribution",
            "location": 130,
            "return": [
                "List[Dict[str, Any]]",
                "Dict[str, int]",
                "Dict[str, numpy.ndarray]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "d": [
                    "numpy.ndarray",
                    "Callable[[Any], T]",
                    "int"
                ]
            }
        },
        "plot_distribution_for": {
            "name": "plot_distribution_for",
            "location": 165,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "int",
                    "float",
                    "Tuple[float, float]"
                ],
                "count_buckets": [
                    "int",
                    "bool",
                    "Dict[str, Any]",
                    "float",
                    "str",
                    "Union[float, int]"
                ],
                "minimum_call_count": [
                    "int",
                    "numpy.ndarray",
                    "List[int]"
                ]
            }
        },
        "df_w_multi_customers": {
            "name": "df_w_multi_customers",
            "location": 185,
            "return": [
                "dict",
                "bool"
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "cid_by_freq": {
            "name": "cid_by_freq",
            "location": 219,
            "return": [
                "numpy.array",
                "str",
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "int",
                    "T"
                ],
                "freq": [
                    "pandas.DataFrame",
                    "int",
                    "T"
                ]
            }
        },
        "print_freq": {
            "name": "print_freq",
            "location": 231,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "dict"
                ],
                "freq": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "dict"
                ],
                "cuteName": [
                    "str",
                    "MutableMapping[str, Any]",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "minUsage": [
                    "str",
                    "MutableMapping[str, Any]",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "filter_work_hours": {
            "name": "filter_work_hours",
            "location": 285,
            "return": [
                "float",
                "Callable[[None], bool]",
                "pandas.DataFrame",
                "List[str]",
                "int"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "dict",
                    "bool",
                    "T"
                ]
            }
        },
        "by_hour_count": {
            "name": "by_hour_count",
            "location": 289,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df": [
                    "int",
                    "Sequence[int]",
                    "List[List[str]]"
                ]
            }
        },
        "pivot_day_by_hour_no_melt": {
            "name": "pivot_day_by_hour_no_melt",
            "location": 292,
            "return": [
                "int",
                "pathlib.Path"
            ],
            "arguments": {
                "df": [
                    "int",
                    "T"
                ],
                "agg": [
                    "pandas.Series",
                    "type",
                    "List['cirq.Qid']",
                    "str",
                    "Type",
                    "Mapping[str, Sequence[str]]",
                    "Mapping[str, str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "pivot_day_by_hour": {
            "name": "pivot_day_by_hour",
            "location": 299,
            "return": [
                "int",
                "float",
                "pathlib.Path"
            ],
            "arguments": {
                "df": [
                    "str",
                    "List['cirq.Qid']",
                    "pandas.Series",
                    "Dict[str, Any]",
                    "int",
                    "type",
                    "Mapping[str, str]"
                ],
                "agg": [
                    "str",
                    "List['cirq.Qid']",
                    "pandas.Series",
                    "Dict[str, Any]",
                    "int",
                    "type",
                    "Mapping[str, str]"
                ]
            }
        },
        "heat_map": {
            "name": "heat_map",
            "location": 305,
            "return": [
                "str"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "\"ComplexNumber\"",
                    "str"
                ],
                "agg": [
                    "bool",
                    "\"ComplexNumber\"",
                    "str"
                ],
                "title": [
                    "int",
                    "float"
                ],
                "is_pivoted": [
                    "bool",
                    "\"ComplexNumber\"",
                    "str"
                ]
            }
        }
    },
    "jupyter-master/py_generated/PlayML.py": {},
    "jupyter-master/py_generated/PlayNLP.py": {
        "get_nlp_model": {
            "name": "get_nlp_model",
            "location": 77,
            "return": [],
            "arguments": {
                "model": []
            }
        },
        "LoadCorpus": {
            "name": "LoadCorpus",
            "location": 100,
            "return": [],
            "arguments": {
                "corpus_path": []
            }
        },
        "DocForCorpus": {
            "name": "DocForCorpus",
            "location": 185,
            "return": [],
            "arguments": {
                "nlp": [],
                "corpus": []
            }
        },
        "glob750_latest": {
            "name": "glob750_latest",
            "location": 220,
            "return": [],
            "arguments": {
                "year": [],
                "month": []
            }
        },
        "glob750_new_archive": {
            "name": "glob750_new_archive",
            "location": 226,
            "return": [],
            "arguments": {
                "year": [],
                "month": []
            }
        },
        "glob750_old_archive": {
            "name": "glob750_old_archive",
            "location": 232,
            "return": [],
            "arguments": {
                "year": [],
                "month": []
            }
        },
        "corpus_paths_months_for_year": {
            "name": "corpus_paths_months_for_year",
            "location": 238,
            "return": [],
            "arguments": {
                "year": []
            }
        },
        "GraphWordDistribution": {
            "name": "GraphWordDistribution",
            "location": 288,
            "return": [],
            "arguments": {
                "words": [],
                "title": [],
                "skip": [],
                "length": [],
                "includeCDF": []
            }
        },
        "GetInterestingWords": {
            "name": "GetInterestingWords",
            "location": 355,
            "return": [],
            "arguments": {
                "pos": [],
                "doc": [],
                "corpus": []
            }
        },
        "GraphPoSForDoc": {
            "name": "GraphPoSForDoc",
            "location": 363,
            "return": [],
            "arguments": {
                "pos": [],
                "doc": [],
                "corpus": []
            }
        },
        "GraphScratchForCorpus": {
            "name": "GraphScratchForCorpus",
            "location": 372,
            "return": [],
            "arguments": {
                "corpus_path": [],
                "pos": []
            }
        },
        "GetInterestingForCorpusPath": {
            "name": "GetInterestingForCorpusPath",
            "location": 378,
            "return": [],
            "arguments": {
                "corpus_path": [],
                "pos": []
            }
        },
        "MakePDF": {
            "name": "MakePDF",
            "location": 416,
            "return": [],
            "arguments": {
                "words": [],
                "name": []
            }
        },
        "PathToFriendlyTitle": {
            "name": "PathToFriendlyTitle",
            "location": 423,
            "return": [],
            "arguments": {
                "path": []
            }
        },
        "animate": {
            "name": "animate",
            "location": 485,
            "return": [],
            "arguments": {
                "i": []
            }
        },
        "Corpus.__hash__": {
            "name": "__hash__",
            "location": 95,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LoadCorpus.capitalizeProperNouns": {
            "name": "capitalizeProperNouns",
            "location": 135,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "LoadCorpus.fixTypos": {
            "name": "fixTypos",
            "location": 164,
            "return": [],
            "arguments": {
                "s": []
            }
        },
        "GraphWordDistribution.GetPDFCDF": {
            "name": "GetPDFCDF",
            "location": 289,
            "return": [],
            "arguments": {
                "words": []
            }
        },
        "GraphWordDistribution.PlotOnAxis": {
            "name": "PlotOnAxis",
            "location": 298,
            "return": [],
            "arguments": {
                "series": [],
                "ax": [],
                "label": [],
                "color": []
            }
        },
        "MakePDF.ToPercent": {
            "name": "ToPercent",
            "location": 417,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "GraphWordDistribution.GetPDFCDF.ToPercent": {
            "name": "ToPercent",
            "location": 290,
            "return": [],
            "arguments": {
                "x": []
            }
        }
    },
    "jupyter-master/py_generated/ProductivityGraphs.py": {},
    "jupyter-master/py_generated/Recursion.py": {
        "CountSteps": {
            "name": "CountSteps",
            "location": 20,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "CountMakeChangeExternal": {
            "name": "CountMakeChangeExternal",
            "location": 45,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "denoms": [
                    "int",
                    "Callable",
                    "str"
                ],
                "total": [
                    "str",
                    "bool",
                    "Iterable"
                ]
            }
        },
        "CountMakeChange": {
            "name": "CountMakeChange",
            "location": 56,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "denoms": [
                    "int",
                    "Callable",
                    "str"
                ],
                "total": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "combsN": {
            "name": "combsN",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {
                "xs": [
                    "int",
                    "float",
                    "bool"
                ],
                "n": [
                    "int"
                ]
            }
        },
        "NQueensE": {
            "name": "NQueensE",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {
                "N": [
                    "int",
                    "float"
                ]
            }
        },
        "NQueens": {
            "name": "NQueens",
            "location": 105,
            "return": [
                "Iterator",
                "Iterator[T]"
            ],
            "arguments": {
                "board": [
                    "Tuple[int, int]",
                    "List[Tuple[int, int]]",
                    "List[str]",
                    "int",
                    "List[int]",
                    "List[Tuple[str, str]]",
                    "bytes",
                    "list"
                ],
                "toPlace": [
                    "int",
                    "bytes",
                    "List[Dict]",
                    "List[str]",
                    "Dict[int, str]",
                    "Tuple[int]",
                    "Set[str]",
                    "List[Tuple[int, int]]"
                ]
            }
        },
        "lost": {
            "name": "lost",
            "location": 122,
            "return": [
                "bool"
            ],
            "arguments": {
                "board": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "genBalancedE": {
            "name": "genBalancedE",
            "location": 139,
            "return": [
                ""
            ],
            "arguments": {
                "n": [
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "genBalanced": {
            "name": "genBalanced",
            "location": 143,
            "return": [
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "partial": [
                    "float",
                    "Tuple[int, int]",
                    "str",
                    "Tuple[float, float]",
                    "int"
                ],
                "cUnMatchedOpen": [
                    "float",
                    "Tuple[int, int]",
                    "str",
                    "Tuple[float, float]",
                    "int"
                ],
                "rOpen": [
                    "float",
                    "str",
                    "int"
                ],
                "rClosed": [
                    "float",
                    "str",
                    "int"
                ]
            }
        },
        "decomposePalindrome": {
            "name": "decomposePalindrome",
            "location": 163,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "s": [
                    "str",
                    "Optional[str]",
                    "bytes",
                    "float"
                ]
            }
        },
        "isPalindrome": {
            "name": "isPalindrome",
            "location": 173,
            "return": [
                "bool"
            ],
            "arguments": {
                "s": [
                    "str",
                    "bytes",
                    "Sequence[str]",
                    "Union[str, bytes]"
                ]
            }
        },
        "between": {
            "name": "between",
            "location": 196,
            "return": [
                "str",
                "bool",
                "int",
                "Match"
            ],
            "arguments": {
                "t": [
                    "Iterable[float]"
                ],
                "s": [
                    "Iterable[float]"
                ],
                "e": [
                    "Iterable[float]"
                ]
            }
        },
        "isRotated": {
            "name": "isRotated",
            "location": 200,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "s": [
                    "Callable",
                    "str",
                    "int"
                ],
                "e": [
                    "Callable",
                    "str",
                    "int"
                ]
            }
        },
        "onLeft": {
            "name": "onLeft",
            "location": 204,
            "return": [
                "tuple",
                "Type",
                "bool"
            ],
            "arguments": {
                "xs": [
                    "int",
                    "Mapping[str, float]",
                    "str",
                    "Literal"
                ],
                "t": [
                    "int"
                ],
                "s": [
                    "int",
                    "Mapping[str, float]",
                    "float"
                ],
                "m": [
                    "int",
                    "Mapping[str, float]",
                    "float"
                ],
                "e": [
                    "Callable[[str, str], float]",
                    "float",
                    "int"
                ]
            }
        },
        "findRotatedE": {
            "name": "findRotatedE",
            "location": 217,
            "return": [
                "int",
                "bool",
                "Optional[float]",
                "Optional[bytes]",
                "List[int]"
            ],
            "arguments": {
                "xs": [
                    "list",
                    "List[Dict[str, Any]]",
                    "bool",
                    "Match",
                    "int"
                ],
                "t": [
                    "list",
                    "List[Dict[str, Any]]",
                    "bool",
                    "Match",
                    "int"
                ]
            }
        },
        "findRotated": {
            "name": "findRotated",
            "location": 221,
            "return": [
                "Optional[int]",
                "Optional[Dict]",
                "bool",
                "Optional[List[Any]]",
                "Optional[List[str]]",
                "Optional[Union[str, Any]]",
                "Optional[Dict[str, Any]]"
            ],
            "arguments": {
                "xs": [
                    "str",
                    "Union[int, float]",
                    "int"
                ],
                "t": [
                    "int"
                ],
                "s": [
                    "int"
                ],
                "e": [
                    "int",
                    "T"
                ]
            }
        }
    },
    "jupyter-master/py_generated/SleepAnalysis.py": {
        "toDecimal": {
            "name": "toDecimal",
            "location": 46,
            "return": [
                "datetime.datetime",
                "str"
            ],
            "arguments": {
                "dt": [
                    "datetime.datetime",
                    "str"
                ]
            }
        },
        "box_plot_metric": {
            "name": "box_plot_metric",
            "location": 106,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "int",
                    "bytes",
                    "Sequence[int]",
                    "Tuple[float, float]"
                ],
                "x": [
                    "int",
                    "bytes",
                    "Sequence[int]",
                    "Tuple[float, float]"
                ],
                "fact": [
                    "int",
                    "Optional[bytes]"
                ],
                "title": [
                    "str",
                    "Dict[str, Any]",
                    "numpy.ndarray",
                    "FrozenSet"
                ],
                "domain": [
                    "str",
                    "Callable"
                ]
            }
        },
        "box_plot_metric_vegas_broken_sort_order": {
            "name": "box_plot_metric_vegas_broken_sort_order",
            "location": 121,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "bool",
                    "numpy.ndarray",
                    "float",
                    "str",
                    "Union[int, float]",
                    "int"
                ],
                "x": [
                    "bool",
                    "numpy.ndarray",
                    "float",
                    "str",
                    "Union[int, float]",
                    "int"
                ],
                "fact": [
                    "bool",
                    "numpy.ndarray",
                    "float",
                    "str",
                    "Union[int, float]",
                    "int"
                ],
                "title": [
                    "bool",
                    "numpy.ndarray",
                    "float",
                    "str",
                    "Union[int, float]",
                    "int"
                ],
                "domain": [
                    "bool",
                    "numpy.ndarray",
                    "float",
                    "str",
                    "Union[int, float]",
                    "int"
                ]
            }
        },
        "quantile_support_empty": {
            "name": "quantile_support_empty",
            "location": 212,
            "return": [
                "Optional[str]",
                "str",
                "bool",
                "Optional[int]",
                "Optional[float]"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int"
                ],
                "q": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "p25": {
            "name": "p25",
            "location": 223,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "p50": {
            "name": "p50",
            "location": 227,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "p90": {
            "name": "p90",
            "location": 231,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "FixUpBedtime": {
            "name": "FixUpBedtime",
            "location": 172,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        }
    },
    "jupyter-master/py_generated/StackAndQueue.py": {
        "QueueFromStacks.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "QueueFromStacks.push": {
            "name": "push",
            "location": 24,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "v": [
                    "list",
                    "Callable",
                    "bool",
                    "List[T]",
                    "float"
                ]
            }
        },
        "QueueFromStacks.pop": {
            "name": "pop",
            "location": 27,
            "return": [
                "List[int]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "jupyter-master/py_generated/stock_analysis.py": {
        "display_correlation_matrix": {
            "name": "display_correlation_matrix",
            "location": 93,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "Type",
                    "click.core.Context",
                    "Optional[AbstractSet[str]]",
                    "str",
                    "Optional[matplotlib.axes.Axes]"
                ],
                "earliest": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str"
                ],
                "latest": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str"
                ]
            }
        }
    },
    "jupyter-master/py_generated/Strings.py": {
        "reverse": {
            "name": "reverse",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {
                "s": [
                    "int",
                    "Optional[int]",
                    "str",
                    "Optional[float]",
                    "float"
                ],
                "start": [
                    "int",
                    "float"
                ],
                "end": [
                    "int"
                ]
            }
        },
        "words": {
            "name": "words",
            "location": 25,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "s": [
                    "str",
                    "bytes",
                    "int"
                ]
            }
        },
        "reverseWords": {
            "name": "reverseWords",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {
                "s": [
                    "int",
                    "str",
                    "bytes",
                    "float"
                ]
            }
        },
        "computeLongestFirstSubPaths": {
            "name": "computeLongestFirstSubPaths",
            "location": 64,
            "return": [
                "Optional[str]",
                "Optional[int]",
                "bool",
                "Optional[float]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "jupyter-master/py_generated/SubArray.py": {
        "len1d": {
            "name": "len1d",
            "location": 16,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "x": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "smallest": {
            "name": "smallest",
            "location": 20,
            "return": [
                "Optional[int]",
                "str",
                "int"
            ],
            "arguments": {
                "x": [
                    "int"
                ],
                "y": [
                    "int"
                ]
            }
        }
    },
    "jupyter-master/py_generated/sympy.py": {},
    "jupyter-master/py_generated/Technology vs Entrepreneur.py": {},
    "jupyter-master/py_generated/TF-IFD.py": {
        "path_glob_to_string_of_words": {
            "name": "path_glob_to_string_of_words",
            "location": 45,
            "return": [
                "Union[shap.utils._legacy.Data, pandas.DataFrame, numpy.ndarray, scipy.sparse.spmatrix]",
                "dict",
                "Dict[str, str]",
                "TextIO",
                "Union[str, bytes]"
            ],
            "arguments": {
                "path": [
                    "str",
                    "pathlib.Path",
                    "pathlib.PurePath",
                    "Optional[pathlib.Path]"
                ]
            }
        }
    },
    "jupyter-master/py_generated/Tree Questions.py": {
        "printTree": {
            "name": "printTree",
            "location": 87,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "tree": [
                    "dict"
                ],
                "depth": [
                    "dict"
                ]
            }
        },
        "InOrderTraverse": {
            "name": "InOrderTraverse",
            "location": 109,
            "return": [
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "tree": []
            }
        },
        "IsBst": {
            "name": "IsBst",
            "location": 117,
            "return": [
                "bool"
            ],
            "arguments": {
                "tree": []
            }
        },
        "FindFlip": {
            "name": "FindFlip",
            "location": 140,
            "return": [
                "List[str]",
                "bool",
                "Iterable[str]",
                "Callable",
                "Optional[str]"
            ],
            "arguments": {
                "a": [
                    "Sequence[int]"
                ]
            }
        },
        "FindFlipR": {
            "name": "FindFlipR",
            "location": 144,
            "return": [
                "Optional[str]",
                "bool",
                "Optional[float]"
            ],
            "arguments": {
                "a": [
                    "int",
                    "str",
                    "Type[object]"
                ],
                "start": [
                    "int",
                    "float",
                    "Tuple[int, int]"
                ],
                "end": [
                    "int",
                    "float",
                    "Tuple[int, int]"
                ]
            }
        },
        "Tree.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "i": [
                    "int",
                    "list",
                    "Tuple[int, int]",
                    "bool",
                    "Tuple[int, int, int]"
                ],
                "lhs": [
                    "int",
                    "Iterable[List[str]]",
                    "List[int]",
                    "Tuple[int]"
                ],
                "rhs": [
                    "int",
                    "Iterable[List[str]]",
                    "List[int]",
                    "Tuple[int]"
                ]
            }
        },
        "Tree.__str__": {
            "name": "__str__",
            "location": 80,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Tree.__repr__": {
            "name": "__repr__",
            "location": 83,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "jupyter-master/py_generated/Weight Analysis.py": {
        "box_plot_weight_over_time": {
            "name": "box_plot_weight_over_time",
            "location": 86,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "numpy.ndarray",
                    "pandas.DataFrame"
                ],
                "x": [
                    "numpy.ndarray",
                    "pandas.DataFrame"
                ],
                "title": [
                    "str",
                    "bool",
                    "Dict[str, Any]",
                    "float"
                ]
            }
        },
        "box_plot_weight_over_time_sigh_vegas_broken": {
            "name": "box_plot_weight_over_time_sigh_vegas_broken",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "bool",
                    "str"
                ],
                "x": [
                    "int",
                    "numpy.ndarray",
                    "matplotlib.axes.Axes",
                    "List[bytes]"
                ],
                "title": [
                    "int",
                    "numpy.ndarray",
                    "matplotlib.axes.Axes",
                    "List[bytes]"
                ],
                "domain": [
                    "int",
                    "numpy.ndarray",
                    "matplotlib.axes.Axes",
                    "List[bytes]"
                ]
            }
        },
        "graph_weight_as_line": {
            "name": "graph_weight_as_line",
            "location": 127,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "Type[numpy.number]",
                    "float",
                    "Tuple[str]"
                ],
                "freq": [
                    "int",
                    "str"
                ],
                "domain": [
                    "str",
                    "bool"
                ]
            }
        },
        "animate": {
            "name": "animate",
            "location": 184,
            "return": [
                "numpy.ndarray",
                "Callable",
                "str"
            ],
            "arguments": {
                "i": [
                    "str",
                    "int",
                    "float"
                ]
            }
        }
    }
}
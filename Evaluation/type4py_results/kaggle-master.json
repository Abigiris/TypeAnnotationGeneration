{
    "kaggle-master/digit-recognizer/keras_convnet.py": {
        "build_model": {
            "name": "build_model",
            "location": 9,
            "return": [
                "denite.util.UserContext",
                "src.autoks.callbacks.CallbackList",
                "Pattern"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/digit-recognizer/pytorch_convnet.py": {
        "train_model": {
            "name": "train_model",
            "location": 32,
            "return": [
                "int",
                "float",
                "denite.util.UserContext",
                "dict",
                "Optional[str]"
            ],
            "arguments": {
                "model": [
                    "Type[T]",
                    "str",
                    "torch.nn.Module"
                ],
                "optimizer": [
                    "bool",
                    "float",
                    "int",
                    "torch.optim.Optimizer"
                ],
                "loader": [
                    "str",
                    "List[int]"
                ]
            }
        },
        "evaluate_model": {
            "name": "evaluate_model",
            "location": 49,
            "return": [
                "int",
                "float",
                "denite.util.UserContext",
                "dict",
                "Optional[str]"
            ],
            "arguments": {
                "model": [
                    "Type[T]",
                    "str",
                    "torch.nn.Module"
                ],
                "loader": [
                    "str",
                    "List[int]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 63,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "ConvNet.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "ConvNet.forward": {
            "name": "forward",
            "location": 23,
            "return": [
                "Dict[str, Any]",
                "Dict[str, int]",
                "List[Dict[str, Any]]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "Union[int, slice]",
                    "numpy.ma.MaskedArray",
                    "torch.Tensor",
                    "List[float]",
                    "float"
                ]
            }
        }
    },
    "kaggle-master/digit-recognizer/tensorflow_convnet.py": {
        "weight_variable": {
            "name": "weight_variable",
            "location": 10,
            "return": [
                "T",
                "bool",
                "str"
            ],
            "arguments": {
                "shape": [
                    "str",
                    "Iterator",
                    "Dict[str, Any]",
                    "int"
                ]
            }
        },
        "bias_variable": {
            "name": "bias_variable",
            "location": 14,
            "return": [
                "T",
                "bool",
                "str"
            ],
            "arguments": {
                "shape": [
                    "str",
                    "Iterator",
                    "Dict[str, Any]",
                    "int"
                ]
            }
        },
        "conv2d": {
            "name": "conv2d",
            "location": 19,
            "return": [
                "Dict[str, int]",
                "numpy.ndarray",
                "int",
                "trezor.utils.Writer",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Union[bytes, bytearray, memoryview]"
                ],
                "W": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Union[bytes, bytearray, memoryview]"
                ]
            }
        },
        "max_pool": {
            "name": "max_pool",
            "location": 22,
            "return": [
                "trezor.utils.Writer",
                "numpy.ndarray",
                "utils.Node",
                "Callable"
            ],
            "arguments": {
                "x": [
                    "int",
                    "List[int]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/digit-recognizer/util.py": {
        "load_train_data": {
            "name": "load_train_data",
            "location": 9,
            "return": [
                "int",
                "tuple",
                "List[int]"
            ],
            "arguments": {}
        },
        "load_test_data": {
            "name": "load_test_data",
            "location": 16,
            "return": [
                "int",
                "tuple",
                "List[int]",
                "str"
            ],
            "arguments": {}
        },
        "save_predictions": {
            "name": "save_predictions",
            "location": 22,
            "return": [
                ""
            ],
            "arguments": {
                "labels": [
                    "str",
                    "int",
                    "bool"
                ],
                "output_file": [
                    "str"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/config.py": {
        "Config.save": {
            "name": "save",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "pathlib.Path",
                    "bool"
                ]
            }
        },
        "Config.load": {
            "name": "load",
            "location": 43,
            "return": [
                "dict",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "pathlib.Path"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/data.py": {
        "load_train_val_examples": {
            "name": "load_train_val_examples",
            "location": 44,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "random_seed": [
                    "int",
                    "List[str]",
                    "str",
                    "Callable[[Any], str]",
                    "raiden.utils.BlockTimeout",
                    "raiden.utils.PaymentID"
                ],
                "train_size": [
                    "int",
                    "List[str]",
                    "str",
                    "Callable[[Any], str]",
                    "raiden.utils.BlockTimeout",
                    "raiden.utils.PaymentID"
                ]
            }
        },
        "load_test_examples": {
            "name": "load_test_examples",
            "location": 55,
            "return": [
                "str",
                "Tuple[int, int]",
                "int",
                "Dict[str, List[str]]"
            ],
            "arguments": {
                "tsv_path": [
                    "str",
                    "pathlib.Path",
                    "Union[str, pathlib.Path]"
                ]
            }
        },
        "_load_gap": {
            "name": "_load_gap",
            "location": 60,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "tsv_path": [
                    "pathlib.Path",
                    "str",
                    "Union[str, pathlib.Path]"
                ]
            }
        },
        "_create_example": {
            "name": "_create_example",
            "location": 70,
            "return": [
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "row": [
                    "int",
                    "float"
                ]
            }
        },
        "_word_tokenizer": {
            "name": "_word_tokenizer",
            "location": 107,
            "return": [
                "bool",
                "dict",
                "Iterable[str]",
                "List[List[str]]",
                "str"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        },
        "_char_to_token_offset": {
            "name": "_char_to_token_offset",
            "location": 120,
            "return": [
                "str",
                "Optional[str]",
                "Optional[List[Any]]"
            ],
            "arguments": {
                "text": [
                    "str"
                ],
                "mention": [
                    "str",
                    "int"
                ],
                "char_offset": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Optional[str]",
                    "List[Dict[str, Any]]",
                    "bool"
                ],
                "text_tokens": [
                    "str"
                ]
            }
        },
        "GAPDataset.__init__": {
            "name": "__init__",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "int",
                    "bool",
                    "float"
                ],
                "flip_prob": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "GAPDataset.__getitem__": {
            "name": "__getitem__",
            "location": 143,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "GAPDataset.__len__": {
            "name": "__len__",
            "location": 151,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GAPDataset._flip_example": {
            "name": "_flip_example",
            "location": 154,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "str",
                "allennlp.data.vocabulary.Vocabulary"
            ],
            "arguments": {
                "self": [],
                "example": [
                    "str"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/ensemble.py": {
        "ensemble": {
            "name": "ensemble",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {
                "models_dir": [
                    "pathlib.Path",
                    "str",
                    "bool",
                    "path.Path",
                    "bytes"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/hyperparam_search.py": {
        "objective": {
            "name": "objective",
            "location": 22,
            "return": [
                "str",
                "bool",
                "revlibs.connections.config.Config",
                "qutebrowser.config.config.Config"
            ],
            "arguments": {
                "config_dict": [
                    "dict",
                    "bytes",
                    "str",
                    "bool",
                    "datetime"
                ],
                "device": [
                    "str"
                ],
                "progress_bar": [
                    "pathlib.Path",
                    "tqdm.tqdm",
                    "str",
                    "Union[str, pathlib.Path]",
                    "path.Path"
                ],
                "base_output_dir": [
                    "pathlib.Path",
                    "str",
                    "path.Path",
                    "Union[str, pathlib.Path]",
                    "tqdm.tqdm"
                ]
            }
        },
        "load_config_space": {
            "name": "load_config_space",
            "location": 65,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "config_space_file": [
                    "pathlib.Path",
                    "str",
                    "IO[Any]",
                    "Optional[str]",
                    "Optional[pathlib.Path]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/model.py": {
        "init_weights": {
            "name": "init_weights",
            "location": 17,
            "return": [
                ""
            ],
            "arguments": {
                "module": [
                    "str",
                    "Dict[int, int]",
                    "Type[T]"
                ]
            }
        },
        "BertFeatures.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model_name": [
                    "str",
                    "Optional[str]",
                    "Optional[object]"
                ],
                "cache_dir": [
                    "str"
                ],
                "device": [
                    "bool",
                    "str",
                    "Callable"
                ]
            }
        },
        "BertFeatures._wordpiece_tokenizer": {
            "name": "_wordpiece_tokenizer",
            "location": 48,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[str]",
                    "str",
                    "Tuple[int, str]"
                ]
            }
        },
        "BertFeatures._prepare_input": {
            "name": "_prepare_input",
            "location": 62,
            "return": [
                "bool",
                "str",
                "dict",
                "int"
            ],
            "arguments": {
                "self": [],
                "wordpiece_tokens": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ],
                "padding_length": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "torch.Tensor"
                ]
            }
        },
        "BertFeatures.generate": {
            "name": "generate",
            "location": 89,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "tokens_batch": [
                    "str",
                    "torch.Tensor",
                    "Iterator[str]",
                    "List[str]"
                ]
            }
        },
        "FeedForward.__init__": {
            "name": "__init__",
            "location": 126,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "Optional[torch.nn.Module]",
                    "float"
                ],
                "output_size": [
                    "int",
                    "Optional[torch.nn.Module]",
                    "float"
                ],
                "hidden_layers": [
                    "int",
                    "List[int]"
                ],
                "hidden_size": [
                    "int",
                    "Optional[torch.nn.Module]",
                    "float"
                ],
                "dropout": [
                    "list",
                    "List[Tuple[str, str]]",
                    "List[int]",
                    "Dict[int, str]"
                ],
                "activation": [
                    "list",
                    "List[Tuple[str, str]]",
                    "List[int]",
                    "Dict[int, str]"
                ]
            }
        },
        "FeedForward.forward": {
            "name": "forward",
            "location": 151,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "dict"
                ],
                "device": [
                    "sphinx.config.Config",
                    "Dict[str, Any]",
                    "config.Config",
                    "str"
                ]
            }
        },
        "Model.forward": {
            "name": "forward",
            "location": 194,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "bool",
                    "str"
                ]
            }
        },
        "Model._calculate_mention_vector": {
            "name": "_calculate_mention_vector",
            "location": 235,
            "return": [
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "input_tokens": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "List[List[str]]",
                    "bool",
                    "List[numpy.ndarray]"
                ],
                "input_length": [
                    "List[int]",
                    "str",
                    "bool"
                ],
                "pronoun_index": [
                    "List[int]",
                    "str",
                    "bool"
                ],
                "spans": [
                    "List[Tuple[int, int]]",
                    "List[int]",
                    "torch.nn.utils.rnn.PackedSequence"
                ]
            }
        },
        "Model._calculate_context_vector": {
            "name": "_calculate_context_vector",
            "location": 254,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_tokens": [
                    "float",
                    "Dict[str, torch.Tensor]",
                    "Optional[torch.Tensor]",
                    "torch.Tensor"
                ],
                "input_length": [
                    "List[int]",
                    "torch.nn.utils.rnn.PackedSequence",
                    "float",
                    "allennlp.data.vocabulary.Vocabulary",
                    "List[Tuple[int, int]]",
                    "Optional[torch.Tensor]"
                ],
                "pronoun_index": [
                    "torch.Tensor",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "Model._calculate_pronoun_mention_distance": {
            "name": "_calculate_pronoun_mention_distance",
            "location": 287,
            "return": [
                "str",
                "numpy.ndarray",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "pronoun_index": [
                    "int",
                    "Callable",
                    "str"
                ],
                "mention_span": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Model._calculate_features": {
            "name": "_calculate_features",
            "location": 297,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "set",
                "str",
                "allennlp.data.vocabulary.Vocabulary"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "Model.calculate_loss": {
            "name": "calculate_loss",
            "location": 316,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "List[torch.Tensor]",
                    "bytes",
                    "float"
                ],
                "reduction": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/optim.py": {
        "lr_schedule": {
            "name": "lr_schedule",
            "location": 13,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "step": [
                    "int",
                    "Callable",
                    "str"
                ],
                "total_steps": [
                    "int",
                    "Callable",
                    "str"
                ],
                "lr": [
                    "int",
                    "Callable",
                    "str"
                ],
                "lr_warmup": [
                    "int",
                    "float",
                    "Iterable[Optional[Any]]",
                    "Optional[int]"
                ],
                "lr_cooldown": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "Adam.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "named_parameters": [
                    "str",
                    "bool",
                    "List[str]"
                ],
                "lr": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "beta1": [
                    "bool",
                    "Optional[str]",
                    "Dict[str, float]"
                ],
                "beta2": [
                    "bool",
                    "Optional[str]",
                    "Dict[str, float]"
                ],
                "eps": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "weight_decay": [
                    "Optional[str]",
                    "bool",
                    "List[str]",
                    "Type",
                    "int"
                ],
                "max_grad_norm": [
                    "int",
                    "Optional[float]",
                    "Optional[int]",
                    "Optional[str]",
                    "Optional[allennlp.nn.RegularizerApplicator]"
                ],
                "lr_warmup": [
                    "Optional[int]",
                    "int",
                    "Callable",
                    "bool"
                ],
                "lr_cooldown": [
                    "Optional[int]",
                    "int",
                    "Optional[str]",
                    "float",
                    "str"
                ],
                "total_steps": [
                    "Optional[int]",
                    "int",
                    "bool"
                ]
            }
        },
        "Adam.step": {
            "name": "step",
            "location": 113,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "closure": [
                    "Optional[str]",
                    "Optional[int]",
                    "Optional[float]",
                    "bool"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/optim_test.py": {
        "LRScheduleTest.test_constant": {
            "name": "test_constant",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LRScheduleTest.test_warmup_only": {
            "name": "test_warmup_only",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "LRScheduleTest.test_warmup_and_linear_cooldown": {
            "name": "test_warmup_and_linear_cooldown",
            "location": 34,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "AdamTest.assertListAlmostEqual": {
            "name": "assertListAlmostEqual",
            "location": 53,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "list_a": [
                    "List[str]",
                    "str",
                    "List[int]",
                    "Type[List[Any]]",
                    "int",
                    "list",
                    "List[List]"
                ],
                "list_b": [
                    "List[str]",
                    "str",
                    "List[int]",
                    "Type[List[Any]]",
                    "int",
                    "list",
                    "List[List]"
                ]
            }
        },
        "AdamTest.test_sphere": {
            "name": "test_sphere",
            "location": 58,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/predict.py": {
        "generate_predictions": {
            "name": "generate_predictions",
            "location": 22,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "asyncpg_migrate.model.Config",
                    "Dict[str, model.Integration]",
                    "model.Model",
                    "model.predictor.PredictorModel",
                    "numpy.ndarray",
                    "int"
                ],
                "config": [
                    "model.corpus.QADataset",
                    "dict"
                ],
                "examples": [
                    "dict"
                ]
            }
        },
        "optimize_thresholds": {
            "name": "optimize_thresholds",
            "location": 59,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "pandas.DataFrame",
                    "Dict[str, Any]",
                    "bytearray",
                    "str"
                ],
                "threshold_steps": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "apply_thresholds": {
            "name": "apply_thresholds",
            "location": 83,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "List[int]",
                    "dict",
                    "int"
                ],
                "thresholds": [
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "Dict[str, Dict[str, int]]",
                    "Optional[Dict[str, Any]]",
                    "Dict[str, str]"
                ]
            }
        },
        "calculate_losses": {
            "name": "calculate_losses",
            "location": 92,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predictions": [
                    "int",
                    "bool",
                    "hackathon.utils.utils.DataMessage"
                ]
            }
        },
        "predict": {
            "name": "predict",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "model_dir": [
                    "str",
                    "Dict[str, Any]",
                    "List[str]",
                    "bool",
                    "cmk.utils.type_defs.HostName"
                ],
                "device": [
                    "List[Tuple[str, str]]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/gendered-pronoun-resolution/train.py": {
        "train": {
            "name": "train",
            "location": 24,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "config": [
                    "dict",
                    "Config",
                    "Tuple[pathlib.Path, pathlib.Path]",
                    "str",
                    "List[str]"
                ],
                "device": [
                    "torch.device",
                    "dss.config.Replica",
                    "Optional[str]",
                    "bool",
                    "float",
                    "Dict[str, Any]",
                    "str"
                ],
                "output_dir": [
                    "pathlib.Path",
                    "str",
                    "cerulean.Path"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/clean_data.py": {
        "_InputCSV.count": {
            "name": "count",
            "location": 18,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "type",
                    "Type",
                    "Type[T]"
                ]
            }
        },
        "_InputCSV.output": {
            "name": "output",
            "location": 23,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Match[str]",
                    "Optional[Callable]"
                ]
            }
        },
        "_InputCSV.read": {
            "name": "read",
            "location": 28,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "T",
                    "bytes",
                    "Iterable[str]"
                ]
            }
        },
        "_OrdersTask.requires": {
            "name": "requires",
            "location": 44,
            "return": [
                "dict",
                "Iterable[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OrdersTask._read_orders_input": {
            "name": "_read_orders_input",
            "location": 50,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OrdersTask._read_order_products_input": {
            "name": "_read_order_products_input",
            "location": 63,
            "return": [
                "int",
                "Tuple[str, int]",
                "bytearray",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OrdersTask._write_orders": {
            "name": "_write_orders",
            "location": 77,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "bool",
                    "list"
                ]
            }
        },
        "_OrdersTask.read": {
            "name": "read",
            "location": 106,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompleteOrders.output": {
            "name": "output",
            "location": 117,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompleteOrders.run": {
            "name": "run",
            "location": 121,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "SubmissionOrders.output": {
            "name": "output",
            "location": 133,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "SubmissionOrders.run": {
            "name": "run",
            "location": 137,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "_SplitOrdersTask.requires": {
            "name": "requires",
            "location": 152,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_SplitOrdersTask._run": {
            "name": "_run",
            "location": 155,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "op": [
                    "str",
                    "float",
                    "int",
                    "Set[str]"
                ]
            }
        },
        "TestOrders.output": {
            "name": "output",
            "location": 166,
            "return": [
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestOrders.run": {
            "name": "run",
            "location": 170,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingOrders.output": {
            "name": "output",
            "location": 176,
            "return": [
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainingOrders.run": {
            "name": "run",
            "location": 180,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/config.py": {},
    "kaggle-master/instacart-basket-analysis/pipelines/evaluation.py": {
        "EvaluateModel.requires": {
            "name": "requires",
            "location": 18,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluateModel.output": {
            "name": "output",
            "location": 24,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluateModel.run": {
            "name": "run",
            "location": 29,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluateAllModels.requires": {
            "name": "requires",
            "location": 85,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/input_data.py": {
        "OrdersInput.output": {
            "name": "output",
            "location": 10,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "OrderProductsInput.output": {
            "name": "output",
            "location": 19,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/submissions.py": {
        "Submission.requires": {
            "name": "requires",
            "location": 14,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Submission.output": {
            "name": "output",
            "location": 19,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Submission.run": {
            "name": "run",
            "location": 24,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/__init__.py": {},
    "kaggle-master/instacart-basket-analysis/pipelines/models/empty.py": {
        "PredictEmpty.model_name": {
            "name": "model_name",
            "location": 13,
            "return": [
                "int",
                "Dict[str, Any]",
                "str",
                "Container[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictEmpty.run": {
            "name": "run",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/f1_maximization.py": {
        "get_expectations": {
            "name": "get_expectations",
            "location": 11,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "P": [
                    "Sequence[str]",
                    "bool",
                    "int"
                ]
            }
        },
        "maximize_expected_f1": {
            "name": "maximize_expected_f1",
            "location": 40,
            "return": [
                "int",
                "dict",
                "str"
            ],
            "arguments": {
                "P": [
                    "str",
                    "int",
                    "list"
                ]
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/frequent_products.py": {
        "PredictFrequentProducts.model_name": {
            "name": "model_name",
            "location": 22,
            "return": [
                "str",
                "zerver.models.Realm",
                "Mapping"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictFrequentProducts.run": {
            "name": "run",
            "location": 25,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/lightfm_v1.py": {
        "LightFMv1.model_name": {
            "name": "model_name",
            "location": 32,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LightFMv1._generate_row": {
            "name": "_generate_row",
            "location": 39,
            "return": [
                "Tuple[int, int]",
                "List[str]",
                "str",
                "numpy.matrix",
                "pandas.DataFrame"
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "float",
                    "Union[float, int]",
                    "int",
                    "dict",
                    "pandas.DataFrame"
                ],
                "prior_orders": [
                    "str",
                    "Iterable[str]",
                    "List[str]",
                    "dict",
                    "List[Tuple[str, str]]"
                ]
            }
        },
        "LightFMv1._generate_rows": {
            "name": "_generate_rows",
            "location": 52,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "str",
                    "dict"
                ],
                "training": [
                    "Optional[dict]",
                    "dict",
                    "int",
                    "str"
                ]
            }
        },
        "LightFMv1._generate_matrices": {
            "name": "_generate_matrices",
            "location": 61,
            "return": [
                "bool",
                "str",
                "Sequence"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "training": [
                    "str",
                    "int"
                ]
            }
        },
        "FitLightFMv1._fit_ranking_model": {
            "name": "_fit_ranking_model",
            "location": 96,
            "return": [
                "allennlp.models.model.Model",
                "float",
                "List[app.models.Question]",
                "app.models.Question"
            ],
            "arguments": {
                "self": [],
                "user_features": [
                    "pandas.DataFrame",
                    "dict",
                    "Dict[str, Any]",
                    "zerver.models.UserProfile",
                    "zerver.models.Recipient",
                    "django.contrib.auth.models.User"
                ],
                "interactions": [
                    "pandas.DataFrame",
                    "dict",
                    "Dict[str, Any]",
                    "zerver.models.UserProfile",
                    "zerver.models.Recipient",
                    "django.contrib.auth.models.User"
                ]
            }
        },
        "FitLightFMv1._f1_score": {
            "name": "_f1_score",
            "location": 105,
            "return": [
                "str",
                "Optional[str]",
                "int",
                "pandas.DataFrame"
            ],
            "arguments": {
                "self": [],
                "y_true": [
                    "Tuple[int, int]",
                    "List[list]",
                    "numpy.ndarray",
                    "List[str]",
                    "List[Tuple[int, int]]",
                    "Sequence[T]",
                    "bytes",
                    "bytearray",
                    "Tuple[int]"
                ],
                "y_pred": [
                    "Tuple[int, int]",
                    "List[list]",
                    "numpy.ndarray",
                    "List[str]",
                    "List[Tuple[int, int]]",
                    "Sequence[T]",
                    "bytes",
                    "bytearray",
                    "Tuple[int]"
                ]
            }
        },
        "FitLightFMv1._fit_threshold_model": {
            "name": "_fit_threshold_model",
            "location": 111,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "user_features": [
                    "zerver.models.UserProfile",
                    "server.models.User",
                    "Optional[Dict[str, str]]",
                    "dict"
                ],
                "interactions": [
                    "django.contrib.auth.models.AbstractBaseUser",
                    "server.models.Bike",
                    "str",
                    "dict"
                ],
                "ranking_model": [
                    "zerver.models.UserProfile",
                    "zerver.models.UserGroup",
                    "django.contrib.auth.models.User"
                ]
            }
        },
        "FitLightFMv1.run": {
            "name": "run",
            "location": 167,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv1.requires": {
            "name": "requires",
            "location": 187,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv1.run": {
            "name": "run",
            "location": 196,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/lightfm_v2.py": {
        "LightFMv2.model_name": {
            "name": "model_name",
            "location": 30,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LightFMv2._generate_row": {
            "name": "_generate_row",
            "location": 37,
            "return": [
                "Tuple[int, int]",
                "List[str]",
                "str",
                "numpy.matrix",
                "pandas.DataFrame"
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "float",
                    "Union[float, int]",
                    "int",
                    "dict",
                    "pandas.DataFrame"
                ],
                "prior_orders": [
                    "str",
                    "Iterable[str]",
                    "List[str]",
                    "dict",
                    "List[Tuple[str, str]]"
                ]
            }
        },
        "LightFMv2._generate_rows": {
            "name": "_generate_rows",
            "location": 50,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "dict",
                    "set",
                    "Dict[str, Any]"
                ],
                "max_prior_orders": [
                    "Optional[dict]",
                    "dict",
                    "int",
                    "str"
                ]
            }
        },
        "LightFMv2._generate_matrices": {
            "name": "_generate_matrices",
            "location": 62,
            "return": [
                "bool",
                "str",
                "Sequence"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "max_prior_orders": [
                    "str",
                    "int",
                    "Callable[[int, int], None]",
                    "zerver.models.UserProfile",
                    "float"
                ]
            }
        },
        "FitLightFMv2.run": {
            "name": "run",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv2ReorderSizeKnown.requires": {
            "name": "requires",
            "location": 114,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictLightFMv2ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 124,
            "return": [
                "str",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "order": [
                    "bool",
                    "BaseException",
                    "List[Dict[str, str]]",
                    "Optional[str]"
                ]
            }
        },
        "PredictLightFMv2ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 131,
            "return": [
                "int",
                "float",
                "Dict[int, int]",
                "str",
                "Union[numpy.ndarray, PIL.Image.Image]",
                "bool",
                "Type[Exception]"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "PredictLightFMv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 141,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/lightfm_v3.py": {
        "FitLightFMv3Embeddings.model_name": {
            "name": "model_name",
            "location": 31,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings.read": {
            "name": "read",
            "location": 36,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings._load_products": {
            "name": "_load_products",
            "location": 41,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings._get_num_items": {
            "name": "_get_num_items",
            "location": 50,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitLightFMv3Embeddings._get_item_id": {
            "name": "_get_item_id",
            "location": 59,
            "return": [
                "str",
                "int",
                "socialhome.users.models.Profile",
                "tuple",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "product_id": [
                    "str",
                    "int"
                ]
            }
        },
        "FitLightFMv3Embeddings._generate_row": {
            "name": "_generate_row",
            "location": 68,
            "return": [
                "Tuple[int, int]",
                "List[str]",
                "str",
                "numpy.matrix"
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "float",
                    "Union[float, int]",
                    "int",
                    "dict"
                ],
                "prior_orders": [
                    "str",
                    "Iterable[str]",
                    "List[str]",
                    "dict",
                    "List[Tuple[str, str]]"
                ]
            }
        },
        "FitLightFMv3Embeddings._generate_rows": {
            "name": "_generate_rows",
            "location": 83,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "List[Dict[Any, Any]]",
                    "Dict[str, Any]",
                    "list",
                    "List[dict]",
                    "numpy.ndarray"
                ],
                "num_orders": [
                    "bool",
                    "str",
                    "List[Optional['Cell']]",
                    "Iterable[Dict]",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "FitLightFMv3Embeddings._generate_matrices": {
            "name": "_generate_matrices",
            "location": 95,
            "return": [
                "bool",
                "str",
                "Sequence"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "FitLightFMv3Embeddings.run": {
            "name": "run",
            "location": 125,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FitAllLightFMv3Embeddings.run": {
            "name": "run",
            "location": 157,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/mlp_v1.py": {
        "MLPv1.model_name": {
            "name": "model_name",
            "location": 27,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv1._generate_user_features": {
            "name": "_generate_user_features",
            "location": 34,
            "return": [
                "int",
                "str",
                "List[List[float]]"
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "dict",
                    "str"
                ]
            }
        },
        "MLPv1._generate_product_features": {
            "name": "_generate_product_features",
            "location": 70,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "Optional[Any]",
                    "Sequence[int]",
                    "bool",
                    "Callable[..., None]"
                ]
            }
        },
        "MLPv1._generate_user_product_features": {
            "name": "_generate_user_product_features",
            "location": 108,
            "return": [
                "str",
                "dict",
                "Iterable[numpy.dtype]",
                "int"
            ],
            "arguments": {
                "self": [],
                "orders": [
                    "float",
                    "models.characters.mods_base.Mod",
                    "numpy.ndarray",
                    "int",
                    "List[Tuple[int, int]]",
                    "str",
                    "bool"
                ]
            }
        },
        "MLPv1._load_data": {
            "name": "_load_data",
            "location": 155,
            "return": [
                "str",
                "cmk.utils.type_defs.UserId",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitMLPv1.run": {
            "name": "run",
            "location": 206,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FitMLPv1._split_data": {
            "name": "_split_data",
            "location": 225,
            "return": [
                "raiden.utils.signer.Signer",
                "Optional[float]",
                "bool",
                "IO[bytes]",
                "str"
            ],
            "arguments": {
                "self": [],
                "order_ids": [
                    "int",
                    "List[int]",
                    "str",
                    "List[str]",
                    "Counter[int]"
                ],
                "product_ids": [
                    "list",
                    "int",
                    "bool",
                    "List[int]",
                    "List[raiden.utils.ChannelID]"
                ],
                "inputs": [
                    "int",
                    "str",
                    "Sequence[Sequence[str]]",
                    "List[int]",
                    "Union[Callable, str]",
                    "Optional[str]"
                ],
                "predictions": [
                    "int",
                    "str",
                    "Sequence[Sequence[str]]",
                    "List[int]",
                    "Union[Callable, str]",
                    "Optional[str]"
                ],
                "training_size": [
                    "int",
                    "Union[int, str]"
                ]
            }
        },
        "FitMLPv1._tapered_layers": {
            "name": "_tapered_layers",
            "location": 260,
            "return": [
                "List[str]",
                "str",
                "Optional[dict]",
                "int",
                "Counter",
                "Sequence[int]"
            ],
            "arguments": {
                "from_dim": [
                    "int",
                    "Sequence[int]"
                ],
                "to_dim": [
                    "int",
                    "Sequence[int]"
                ],
                "num_layers": [
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "FitMLPv1._build_model": {
            "name": "_build_model",
            "location": 264,
            "return": [
                "src.autoks.callbacks.CallbackList",
                "Pattern"
            ],
            "arguments": {
                "self": [],
                "training_inputs": [
                    "bool"
                ]
            }
        },
        "PredictMLPv1.requires": {
            "name": "requires",
            "location": 286,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv1.run": {
            "name": "run",
            "location": 295,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv1._load_data.add_example": {
            "name": "add_example",
            "location": 166,
            "return": [
                ""
            ],
            "arguments": {
                "user_id": [
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "order_id": [
                    "str",
                    "List[str]",
                    "list"
                ],
                "product_id": [
                    "List[int]",
                    "int",
                    "str",
                    "Dict[int, int]",
                    "list",
                    "Set[int]"
                ],
                "prediction": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/mlp_v2.py": {
        "MLPv2.model_name": {
            "name": "model_name",
            "location": 45,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv2._count_lines": {
            "name": "_count_lines",
            "location": 57,
            "return": [
                "Tuple[Any, Any, Any]",
                "Tuple[numpy.ndarray]",
                "float",
                "Dict[Tuple[int, int], int]"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "MLPv2._open_shuffled": {
            "name": "_open_shuffled",
            "location": 62,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "MLPv2._generate_examples": {
            "name": "_generate_examples",
            "location": 67,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "int",
                    "str",
                    "float",
                    "numpy.ndarray"
                ],
                "prior_orders": [
                    "int",
                    "Optional[List[str]]",
                    "List[List[int]]"
                ]
            }
        },
        "MLPv2._generate_user_examples": {
            "name": "_generate_user_examples",
            "location": 104,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "metaswitch_tinder.database.models.Request",
                    "pandas.DataFrame",
                    "Dict[str, str]",
                    "dict",
                    "Dict[str, int]"
                ],
                "num_orders_per_user": [
                    "List[str]",
                    "bool",
                    "str",
                    "Optional[List[str]]"
                ]
            }
        },
        "MLPv2._load_data": {
            "name": "_load_data",
            "location": 118,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str",
                    "List[str]"
                ],
                "num_orders_per_user": [
                    "bool",
                    "Optional[int]",
                    "Optional[float]",
                    "Optional[bool]",
                    "int"
                ]
            }
        },
        "MLPv2._create_data_generator": {
            "name": "_create_data_generator",
            "location": 147,
            "return": [
                "bool",
                "str",
                "List[str]",
                "Generator"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "bool",
                    "str",
                    "int",
                    "Iterable[int]"
                ],
                "num_orders_per_user": [
                    "bool",
                    "str",
                    "int",
                    "Iterable[int]"
                ],
                "batch_size": [
                    "bool",
                    "str",
                    "int",
                    "Iterable[int]"
                ]
            }
        },
        "MLPv2._hidden_layer_units": {
            "name": "_hidden_layer_units",
            "location": 204,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "num_layers": [
                    "int"
                ],
                "from_dim": [
                    "int"
                ],
                "to_dim": [
                    "int"
                ]
            }
        },
        "MLPv2._build_model": {
            "name": "_build_model",
            "location": 209,
            "return": [
                "src.autoks.callbacks.CallbackList",
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitMLPv2.run": {
            "name": "run",
            "location": 248,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "_PredictMLPv2.requires": {
            "name": "requires",
            "location": 288,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 307,
            "return": [
                "str",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "order": [
                    "bool",
                    "BaseException",
                    "List[Dict[str, str]]",
                    "Optional[str]"
                ]
            }
        },
        "PredictMLPv2ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 314,
            "return": [
                "int",
                "str",
                "List[float]",
                "float",
                "zerver.models.Realm"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 324,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeMLPv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 362,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2Threshold.model_name": {
            "name": "model_name",
            "location": 381,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2Threshold.run": {
            "name": "run",
            "location": 386,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictMLPv2Threshold.run": {
            "name": "run",
            "location": 415,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ThresholdVariable.model_name": {
            "name": "model_name",
            "location": 424,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ThresholdVariable._determine_reorder_thresholds": {
            "name": "_determine_reorder_thresholds",
            "location": 429,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "Union[tensorflow.Tensor, numpy.ndarray]",
                    "str"
                ],
                "scores": [
                    "Mapping[str, str]",
                    "OrderedDict",
                    "Mapping",
                    "str"
                ]
            }
        },
        "PredictMLPv2ThresholdVariable.run": {
            "name": "run",
            "location": 483,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeMLPv2ThresholdVariable.run": {
            "name": "run",
            "location": 522,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ExpectedF1.model_name": {
            "name": "model_name",
            "location": 539,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictMLPv2ExpectedF1._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 544,
            "return": [
                "int",
                "str",
                "List[float]",
                "float",
                "zerver.models.Realm"
            ],
            "arguments": {
                "self": [],
                "scores": [
                    "audio_profiling.models.AudioPage",
                    "List[List[str]]"
                ]
            }
        },
        "PredictMLPv2ExpectedF1.run": {
            "name": "run",
            "location": 554,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "MLPv2._load_data.add_example": {
            "name": "add_example",
            "location": 125,
            "return": [
                ""
            ],
            "arguments": {
                "user_id": [
                    "str",
                    "List[int]",
                    "Optional[Any]",
                    "int",
                    "bool",
                    "transfer.models.ListID"
                ],
                "order_id": [
                    "str",
                    "List[str]",
                    "list"
                ],
                "product_id": [
                    "str",
                    "List[str]",
                    "int",
                    "Type[str]"
                ],
                "inputs": [
                    "int",
                    "str",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "prediction": [
                    "str",
                    "int"
                ]
            }
        },
        "MLPv2._create_data_generator.generator": {
            "name": "generator",
            "location": 159,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/previous_order.py": {
        "PredictPreviousOrder.model_name": {
            "name": "model_name",
            "location": 12,
            "return": [
                "str",
                "Mapping"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictPreviousOrder.run": {
            "name": "run",
            "location": 15,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/product_name_vectors.py": {
        "ProductNameVectors.model_name": {
            "name": "model_name",
            "location": 20,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ProductNameVectors.read": {
            "name": "read",
            "location": 24,
            "return": [
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ProductNameVectors.run": {
            "name": "run",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FitAllProductNameVectors.run": {
            "name": "run",
            "location": 53,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "ProductNameVectors.run.get_vector": {
            "name": "get_vector",
            "location": 34,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "product_name": [
                    "str",
                    "zerver.models.Realm",
                    "Optional[str]",
                    "Optional[bool]",
                    "Callable"
                ]
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v1.py": {
        "hinge_loss": {
            "name": "hinge_loss",
            "location": 24,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "y_true": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "dict"
                ],
                "y_pred": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "margin": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "RNNv1.model_name": {
            "name": "model_name",
            "location": 43,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv1._count_lines": {
            "name": "_count_lines",
            "location": 54,
            "return": [
                "Tuple[Any, Any, Any]",
                "Tuple[numpy.ndarray]",
                "float",
                "Dict[Tuple[int, int], int]"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv1._open_shuffled": {
            "name": "_open_shuffled",
            "location": 59,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv1._generate_order_samples": {
            "name": "_generate_order_samples",
            "location": 64,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "bool",
                    "List[str]",
                    "Iterable"
                ],
                "prior_orders": [
                    "bool",
                    "List[str]",
                    "Iterable"
                ]
            }
        },
        "RNNv1._generate_samples": {
            "name": "_generate_samples",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "dict",
                    "Optional[Dict]"
                ],
                "include_prior_orders": [
                    "dict",
                    "List[Dict[str, Any]]",
                    "Optional[dict]"
                ]
            }
        },
        "RNNv1.create_generator": {
            "name": "create_generator",
            "location": 104,
            "return": [
                "str",
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable[int]"
                ],
                "users_per_batch": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable[int]"
                ],
                "shuffle": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable[int]"
                ],
                "include_prior_orders": [
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable[int]"
                ]
            }
        },
        "FitRNNv1._build_model": {
            "name": "_build_model",
            "location": 139,
            "return": [
                "src.autoks.callbacks.CallbackList",
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitRNNv1.run": {
            "name": "run",
            "location": 162,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv1.requires": {
            "name": "requires",
            "location": 204,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv1.run": {
            "name": "run",
            "location": 214,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv1.create_generator.generator": {
            "name": "generator",
            "location": 109,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v2.py": {
        "RNNv2.model_name": {
            "name": "model_name",
            "location": 46,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._count_lines": {
            "name": "_count_lines",
            "location": 63,
            "return": [
                "Tuple[Any, Any, Any]",
                "Tuple[numpy.ndarray]",
                "float",
                "Dict[Tuple[int, int], int]"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv2._open_shuffled": {
            "name": "_open_shuffled",
            "location": 68,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv2._generate_order_examples": {
            "name": "_generate_order_examples",
            "location": 73,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "int",
                    "Dict[int, dict]",
                    "float"
                ],
                "prior_orders": [
                    "int",
                    "Optional[List[str]]",
                    "List[List[int]]"
                ]
            }
        },
        "RNNv2._generate_user_examples": {
            "name": "_generate_user_examples",
            "location": 105,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "dict",
                    "Dict[str, Any]"
                ],
                "max_prior_orders": [
                    "str",
                    "dict",
                    "Iterable[str]",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "RNNv2._load_data": {
            "name": "_load_data",
            "location": 117,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "RNNv2._create_data_generator": {
            "name": "_create_data_generator",
            "location": 142,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "int",
                    "bool",
                    "str"
                ],
                "users_per_batch": [
                    "int",
                    "bool",
                    "str"
                ],
                "max_prior_orders": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "RNNv2._hidden_layer_units": {
            "name": "_hidden_layer_units",
            "location": 173,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "num_layers": [
                    "int"
                ],
                "from_dim": [
                    "int"
                ],
                "to_dim": [
                    "int"
                ]
            }
        },
        "RNNv2._build_product_embedding_submodel": {
            "name": "_build_product_embedding_submodel",
            "location": 178,
            "return": [
                "Dict[str, Any]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._build_days_attention_submodel": {
            "name": "_build_days_attention_submodel",
            "location": 186,
            "return": [
                "str",
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._build_model": {
            "name": "_build_model",
            "location": 198,
            "return": [
                "src.autoks.callbacks.CallbackList",
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitRNNv2.run": {
            "name": "run",
            "location": 255,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "_PredictRNNv2.requires": {
            "name": "requires",
            "location": 297,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 321,
            "return": [
                "str",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "order": [
                    "bool",
                    "BaseException",
                    "List[Dict[str, str]]",
                    "Optional[str]"
                ]
            }
        },
        "PredictRNNv2ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 328,
            "return": [
                "int",
                "float",
                "Dict[int, int]",
                "str",
                "Union[numpy.ndarray, PIL.Image.Image]",
                "bool",
                "Type[Exception]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 339,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeRNNv2ReorderSizeKnown.run": {
            "name": "run",
            "location": 381,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizePercentile.model_name": {
            "name": "model_name",
            "location": 409,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2ReorderSizePercentile._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 414,
            "return": [
                "int",
                "str",
                "List[float]",
                "float",
                "zerver.models.Realm"
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictRNNv2ReorderSizePercentile.run": {
            "name": "run",
            "location": 431,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2Threshold.model_name": {
            "name": "model_name",
            "location": 441,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv2Threshold.run": {
            "name": "run",
            "location": 446,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictRNNv2Threshold.run": {
            "name": "run",
            "location": 473,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv2._load_data.add_example": {
            "name": "add_example",
            "location": 122,
            "return": [
                ""
            ],
            "arguments": {
                "order_id": [
                    "str",
                    "Callable",
                    "list",
                    "List[Union[int, float]]",
                    "numpy.ndarray",
                    "int"
                ],
                "product": [
                    "int",
                    "list",
                    "Optional[int]",
                    "List[str]",
                    "Container[str]"
                ],
                "orders": [
                    "int",
                    "list",
                    "Optional[int]",
                    "List[str]",
                    "Container[str]"
                ],
                "prediction": [
                    "int",
                    "list",
                    "Optional[int]",
                    "List[str]",
                    "Container[str]"
                ]
            }
        },
        "RNNv2._create_data_generator.generator": {
            "name": "generator",
            "location": 146,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v3.py": {
        "RNNv3.model_name": {
            "name": "model_name",
            "location": 71,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv3._count_lines": {
            "name": "_count_lines",
            "location": 86,
            "return": [
                "Tuple[Any, Any, Any]",
                "Tuple[numpy.ndarray]",
                "float",
                "Dict[Tuple[int, int], int]"
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv3._open_shuffled": {
            "name": "_open_shuffled",
            "location": 91,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv3._generate_examples": {
            "name": "_generate_examples",
            "location": 96,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "last_order": [
                    "int",
                    "Dict[int, dict]",
                    "raiden.utils.Address",
                    "float"
                ],
                "prior_orders": [
                    "int",
                    "Optional[List[str]]",
                    "List[List[int]]"
                ]
            }
        },
        "RNNv3._generate_user_examples": {
            "name": "_generate_user_examples",
            "location": 126,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "user_data": [
                    "Mapping[str, Any]",
                    "dict"
                ],
                "max_prior_orders": [
                    "str",
                    "dict",
                    "Iterable[str]",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "RNNv3._load_data": {
            "name": "_load_data",
            "location": 138,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "RNNv3._create_data_generator": {
            "name": "_create_data_generator",
            "location": 164,
            "return": [
                "bool",
                "str",
                "List[str]",
                "Generator"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "bool",
                    "str",
                    "List[str]"
                ],
                "max_prior_orders": [
                    "bool",
                    "str",
                    "List[str]"
                ],
                "batch_size": [
                    "bool",
                    "str",
                    "List[str]"
                ]
            }
        },
        "RNNv3._hidden_layer_units": {
            "name": "_hidden_layer_units",
            "location": 215,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "num_layers": [
                    "int"
                ],
                "from_dim": [
                    "int"
                ],
                "to_dim": [
                    "int"
                ]
            }
        },
        "RNNv3._build_model": {
            "name": "_build_model",
            "location": 220,
            "return": [
                "src.autoks.callbacks.CallbackList",
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitRNNv3.run": {
            "name": "run",
            "location": 277,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "_PredictRNNv3.requires": {
            "name": "requires",
            "location": 320,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3ReorderSizeKnown._count_reordered_products": {
            "name": "_count_reordered_products",
            "location": 342,
            "return": [
                "str",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "order": [
                    "bool",
                    "BaseException",
                    "List[Dict[str, str]]",
                    "Optional[str]"
                ]
            }
        },
        "PredictRNNv3ReorderSizeKnown._determine_reorder_size": {
            "name": "_determine_reorder_size",
            "location": 349,
            "return": [
                "int",
                "float",
                "Dict[int, int]",
                "str",
                "Union[numpy.ndarray, PIL.Image.Image]",
                "bool",
                "Type[Exception]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3ReorderSizeKnown.run": {
            "name": "run",
            "location": 360,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizeRNNv3ReorderSizeKnown.run": {
            "name": "run",
            "location": 402,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3Threshold.model_name": {
            "name": "model_name",
            "location": 427,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictRNNv3Threshold.run": {
            "name": "run",
            "location": 432,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OptimizePredictRNNv3Threshold.run": {
            "name": "run",
            "location": 461,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv3._load_data.add_example": {
            "name": "add_example",
            "location": 143,
            "return": [
                ""
            ],
            "arguments": {
                "order_id": [
                    "str",
                    "Callable",
                    "list",
                    "List[Union[int, float]]",
                    "numpy.ndarray",
                    "int"
                ],
                "product": [
                    "int",
                    "list",
                    "Optional[int]",
                    "List[str]",
                    "Container[str]"
                ],
                "orders": [
                    "int",
                    "list",
                    "Optional[int]",
                    "List[str]",
                    "Container[str]"
                ],
                "prediction": [
                    "int",
                    "list",
                    "Optional[int]",
                    "List[str]",
                    "Container[str]"
                ]
            }
        },
        "RNNv3._create_data_generator.generator": {
            "name": "generator",
            "location": 176,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v4.py": {
        "open_shuffled": {
            "name": "open_shuffled",
            "location": 33,
            "return": [
                ""
            ],
            "arguments": {
                "file_path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "layer_units": {
            "name": "layer_units",
            "location": 187,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "input_size": [
                    "int",
                    "bool",
                    "List[int]"
                ],
                "output_size": [
                    "int",
                    "bool",
                    "List[int]"
                ],
                "num_layers": [
                    "int",
                    "bool",
                    "List[int]"
                ]
            }
        },
        "RNNv4.model_name": {
            "name": "model_name",
            "location": 54,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv4._init_random_state": {
            "name": "_init_random_state",
            "location": 65,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv4._iter_user_data": {
            "name": "_iter_user_data",
            "location": 70,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "shuffle": [
                    "str"
                ]
            }
        },
        "RNNv4._generate_example": {
            "name": "_generate_example",
            "location": 76,
            "return": [
                "str",
                "int",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "prior_orders": [
                    "int",
                    "zam_repondeur.models.Lecture",
                    "str",
                    "Optional[int]",
                    "Optional[Set[str]]",
                    "Optional[str]"
                ],
                "last_order": [
                    "int",
                    "zam_repondeur.models.Lecture",
                    "str",
                    "Optional[int]",
                    "Optional[Set[str]]",
                    "Optional[str]"
                ]
            }
        },
        "RNNv4._generate_examples": {
            "name": "_generate_examples",
            "location": 121,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ],
                "target_orders": [
                    "str"
                ],
                "shuffle": [
                    "str"
                ]
            }
        },
        "RNNv4._format_as_tensors": {
            "name": "_format_as_tensors",
            "location": 147,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "product_history": [
                    "int"
                ],
                "next_products": [
                    "int",
                    "bytes",
                    "datetime"
                ],
                "next_products_targets": [
                    "numpy.array",
                    "bool",
                    "Callable",
                    "list"
                ]
            }
        },
        "RNNv4._load_model": {
            "name": "_load_model",
            "location": 172,
            "return": [
                "GPy.models.GPRegression",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "Projection.__init__": {
            "name": "__init__",
            "location": 195,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "Optional[torch.nn.Module]",
                    "float"
                ],
                "output_size": [
                    "int",
                    "Optional[torch.nn.Module]",
                    "float"
                ],
                "hidden_layers": [
                    "int",
                    "Optional[torch.nn.Module]",
                    "float"
                ],
                "nonlinearity": [
                    "list",
                    "List[str]",
                    "int",
                    "float",
                    "str"
                ],
                "dropout": [
                    "list",
                    "List[int]",
                    "int",
                    "Type[List[Any]]"
                ]
            }
        },
        "Projection.forward": {
            "name": "forward",
            "location": 223,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 229,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "weekday_dim": [
                    "int"
                ],
                "department_dim": [
                    "int"
                ],
                "aisle_dim": [
                    "int"
                ],
                "product_dim": [
                    "int"
                ],
                "scoring_dim": [
                    "str",
                    "bool"
                ],
                "hidden_layers": [
                    "str",
                    "bool"
                ],
                "hidden_nonlinearily": [
                    "str",
                    "bool"
                ],
                "dropout": [
                    "str",
                    "bool"
                ]
            }
        },
        "Model._init_embeddings": {
            "name": "_init_embeddings",
            "location": 248,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "weekday_dim": [
                    "bool",
                    "int"
                ],
                "department_dim": [
                    "bool",
                    "int"
                ],
                "aisle_dim": [
                    "bool",
                    "int"
                ],
                "product_dim": [
                    "bool",
                    "Optional[List[Any]]",
                    "int",
                    "Optional[bool]",
                    "numpy.ndarray"
                ]
            }
        },
        "Model._init_lstm": {
            "name": "_init_lstm",
            "location": 260,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "scoring_dim": [
                    "Optional[Iterable[T]]",
                    "bool",
                    "Callable",
                    "pandas.DataFrame",
                    "salon.models.Stylist",
                    "str"
                ]
            }
        },
        "Model.forward": {
            "name": "forward",
            "location": 277,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "product_history": [
                    "Optional[float]",
                    "str",
                    "float",
                    "int"
                ],
                "next_products": [
                    "int",
                    "bool",
                    "List[int]",
                    "pandas.DataFrame",
                    "str",
                    "Dict[str, torch.LongTensor]"
                ]
            }
        },
        "FitRNNv4._split_orders": {
            "name": "_split_orders",
            "location": 327,
            "return": [
                "Callable[[T], bool]",
                "str",
                "List[Tuple]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "orders_path": [
                    "str"
                ]
            }
        },
        "FitRNNv4._train_model": {
            "name": "_train_model",
            "location": 341,
            "return": [
                "pandas.DataFrame",
                "subprocess.Popen",
                "Optional[str]",
                "models.PermissionLookup",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "float",
                    "int",
                    "Dict[str, str]"
                ],
                "optimizer": [
                    "bool",
                    "Sequence[str]",
                    "list",
                    "int"
                ],
                "orders_path": [
                    "Optional[str]",
                    "Optional[int]",
                    "dict"
                ]
            }
        },
        "FitRNNv4._evaluate_model": {
            "name": "_evaluate_model",
            "location": 356,
            "return": [
                "pandas.DataFrame",
                "subprocess.Popen",
                "Optional[str]",
                "models.PermissionLookup",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "List[str]",
                    "Dict[str, str]"
                ],
                "orders_path": [
                    "IO[str]",
                    "list",
                    "str"
                ]
            }
        },
        "FitRNNv4.run": {
            "name": "run",
            "location": 368,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNv4._format_as_tensors.create_tensor": {
            "name": "create_tensor",
            "location": 149,
            "return": [
                "Mapping[str, Any]",
                "List[zerver.models.DefaultStreamGroup]",
                "Iterator[Dict[str, str]]",
                "Optional[List[\"custom_index\"]]"
            ],
            "arguments": {
                "tensor_type": [
                    "bool",
                    "Optional[type]"
                ],
                "orders": [
                    "bool",
                    "Optional[type]"
                ],
                "field": [
                    "bool",
                    "Optional[type]"
                ]
            }
        }
    },
    "kaggle-master/instacart-basket-analysis/pipelines/models/rnn_v5.py": {},
    "kaggle-master/instacart-basket-analysis/pipelines/models/__init__.py": {
        "FitModel.requires": {
            "name": "requires",
            "location": 17,
            "return": [
                "Callable",
                "str",
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.model_name": {
            "name": "model_name",
            "location": 23,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.output": {
            "name": "output",
            "location": 26,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.requires": {
            "name": "requires",
            "location": 33,
            "return": [
                "bool",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.model_name": {
            "name": "model_name",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.output": {
            "name": "output",
            "location": 42,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.output": {
            "name": "output",
            "location": 52,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.read": {
            "name": "read",
            "location": 56,
            "return": [
                "int",
                "bool",
                "Optional[float]",
                "Dict[str, str]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/common.py": {
        "pack_example": {
            "name": "pack_example",
            "location": 37,
            "return": [
                ""
            ],
            "arguments": {
                "example": [
                    "str"
                ],
                "fout": [
                    "str"
                ]
            }
        },
        "unpack_example": {
            "name": "unpack_example",
            "location": 50,
            "return": [
                "bool",
                "dict",
                "Dict[str, Type[Any]]",
                "Set[str]",
                "Dict[int, str]",
                "list",
                "str"
            ],
            "arguments": {
                "fin": [
                    "int",
                    "Dict[str, str]",
                    "List[str]",
                    "dict",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "unpack_examples": {
            "name": "unpack_examples",
            "location": 68,
            "return": [
                ""
            ],
            "arguments": {
                "fin": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/convnet_data.py": {
        "_process_strokes": {
            "name": "_process_strokes",
            "location": 12,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "strokes": [
                    "bool",
                    "numpy.ndarray",
                    "Iterable[str]",
                    "float"
                ],
                "image_size": [
                    "numpy.ndarray",
                    "Union[str, IO[bytes]]",
                    "Tuple[numpy.ndarray, numpy.ndarray]",
                    "tuple"
                ],
                "augmentation": [
                    "bool",
                    "float"
                ]
            }
        },
        "_process_drawing": {
            "name": "_process_drawing",
            "location": 25,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "drawing": [
                    "List[str]",
                    "bytes",
                    "list",
                    "int",
                    "ValueError",
                    "bool"
                ],
                "image_size": [
                    "float",
                    "Tuple[int, int]",
                    "int",
                    "str"
                ],
                "augmentation": [
                    "float",
                    "Tuple[int, int]",
                    "int",
                    "str"
                ]
            }
        },
        "_csv_generator": {
            "name": "_csv_generator",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {
                "csv_file": [
                    "str",
                    "Optional[str]",
                    "bool"
                ],
                "image_size": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ],
                "augmentation": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ],
                "read_label": [
                    "str",
                    "bool"
                ]
            }
        },
        "_bin_generator": {
            "name": "_bin_generator",
            "location": 43,
            "return": [
                ""
            ],
            "arguments": {
                "bin_file": [
                    "str",
                    "List[str]"
                ],
                "image_size": [
                    "int",
                    "str",
                    "float"
                ],
                "augmentation": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "_load_train_sample": {
            "name": "_load_train_sample",
            "location": 50,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "random_seed": [
                    "str",
                    "Union[int, str]",
                    "Optional[int]",
                    "int"
                ],
                "name": [
                    "str",
                    "Union[int, str]",
                    "Optional[int]",
                    "int"
                ],
                "image_size": [
                    "str",
                    "bool",
                    "int"
                ],
                "augmentation": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "load_train_val_datasets": {
            "name": "load_train_val_datasets",
            "location": 79,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "image_size": [
                    "int",
                    "bool",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "float"
                ],
                "augmentation": [
                    "int",
                    "bool",
                    "float"
                ],
                "random_seed": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "load_test_dataset": {
            "name": "load_test_dataset",
            "location": 93,
            "return": [
                "str",
                "Tuple[int, int]",
                "int",
                "Dict[str, List[str]]"
            ],
            "arguments": {
                "image_size": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Union[int, float]",
                    "numpy.array"
                ],
                "batch_size": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Union[int, float]",
                    "numpy.array"
                ],
                "augmentation": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Union[int, float]",
                    "numpy.array"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/drawing.py": {
        "parse_drawing": {
            "name": "parse_drawing",
            "location": 9,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "drawing": [
                    "Dict[str, Any]",
                    "str"
                ],
                "normalize": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "normalize_strokes": {
            "name": "normalize_strokes",
            "location": 19,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "List[str]"
                ]
            }
        },
        "simplify_strokes": {
            "name": "simplify_strokes",
            "location": 31,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "float",
                    "numpy.ndarray",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "numpy.ndarray",
                    "str"
                ]
            }
        },
        "rotate_strokes": {
            "name": "rotate_strokes",
            "location": 37,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "Dict[str, Any]",
                    "str",
                    "bool",
                    "List[dict]",
                    "numpy.ndarray"
                ],
                "degrees": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "mirror_strokes": {
            "name": "mirror_strokes",
            "location": 45,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "Dict[str, Any]",
                    "str",
                    "bool",
                    "List[dict]",
                    "numpy.ndarray"
                ]
            }
        },
        "render_image": {
            "name": "render_image",
            "location": 63,
            "return": [
                "int",
                "tuple"
            ],
            "arguments": {
                "strokes": [
                    "int",
                    "str"
                ],
                "image_size": [
                    "List[list]",
                    "Tuple[int, int]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/generate_train_sample.py": {
        "write_partitions": {
            "name": "write_partitions",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "str",
                    "bool"
                ],
                "output_dir": [
                    "str",
                    "bool",
                    "Optional[bool]"
                ]
            }
        },
        "generate_train_sample": {
            "name": "generate_train_sample",
            "location": 25,
            "return": [
                ""
            ],
            "arguments": {
                "spark": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "List[str]"
                ],
                "train_examples_per_class": [
                    "int"
                ],
                "val_examples_per_class": [
                    "int",
                    "bool"
                ],
                "random_seed": [
                    "List[int]",
                    "int",
                    "Optional[int]",
                    "bool"
                ]
            }
        },
        "write_partitions.write_partition": {
            "name": "write_partition",
            "location": 16,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "i": [
                    "str",
                    "bool",
                    "Optional[float]",
                    "int"
                ],
                "iterator": [
                    "int",
                    "slice",
                    "T",
                    "Optional[bool]",
                    "bool"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/models.py": {
        "get_model_wrapper": {
            "name": "get_model_wrapper",
            "location": 9,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "_config": [
                    "str",
                    "int",
                    "bool",
                    "Callable[[str], None]"
                ]
            }
        },
        "_BaseModelWrapper.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "_config": []
            }
        },
        "_BaseModelWrapper.train": {
            "name": "train",
            "location": 22,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "dataset": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "_BaseModelWrapper.validate": {
            "name": "validate",
            "location": 25,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "_BaseModelWrapper.predict": {
            "name": "predict",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "_BaseModelWrapper.calculate_map": {
            "name": "calculate_map",
            "location": 32,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "scores": [
                    "int",
                    "Union[Callable, Type]",
                    "Dict[str, Dict[str, Any]]",
                    "bool"
                ],
                "labels": [
                    "int",
                    "gluonts.model.common.Tensor",
                    "float",
                    "List[numpy.array]"
                ],
                "k": [
                    "bool",
                    "int",
                    "float",
                    "list",
                    "Union[Callable, Type]",
                    "Dict[str, Dict[str, Any]]"
                ]
            }
        },
        "CustomFlatten.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "rl_algorithms.common.abstraclearner.TensorTuple",
                    "Union[rl_algorithms.common.abstraclearner.TensorTuple, Tuple[rl_algorithms.common.abstraclearner.TensorTuple]]",
                    "int"
                ]
            }
        },
        "CustomFlatten.call": {
            "name": "call",
            "location": 59,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "input_tensor": [
                    "int",
                    "str"
                ],
                "training": [
                    "dict"
                ]
            }
        },
        "ConvNetWrapper.__init__": {
            "name": "__init__",
            "location": 68,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "_config": [
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "ConvNetWrapper.calculate_loss": {
            "name": "calculate_loss",
            "location": 109,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "numpy.array",
                    "bool"
                ],
                "labels": [
                    "numpy.array",
                    "bool"
                ]
            }
        },
        "ConvNetWrapper.train": {
            "name": "train",
            "location": 115,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "int",
                    "str",
                    "Dict[int, Any]"
                ],
                "dataset": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "ConvNetWrapper.validate": {
            "name": "validate",
            "location": 143,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "ConvNetWrapper.predict": {
            "name": "predict",
            "location": 164,
            "return": [
                "str",
                "dict",
                "int"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/submit.py": {
        "submit": {
            "name": "submit",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {
                "experiment_name": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/train_convnet.py": {
        "config": {
            "name": "config",
            "location": 27,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "_run": [
                    "str",
                    "Dict[str, Any]",
                    "cmk.utils.type_defs.OptionalConfigSerial"
                ],
                "_config": [
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str",
                    "Optional[Dict[str, Any]]"
                ],
                "_log": [
                    "core.models.Subtask",
                    "bool",
                    "Callable",
                    "int",
                    "dict",
                    "str"
                ]
            }
        },
        "generate_predictions": {
            "name": "generate_predictions",
            "location": 149,
            "return": [
                "int"
            ],
            "arguments": {
                "_config": [
                    "dict"
                ],
                "_log": [
                    "str",
                    "Optional[Callable]",
                    "core.models.Subtask"
                ],
                "model_wrapper": [
                    "utils.config_generator.Configurations",
                    "str",
                    "dict"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/common.py": {
        "pack_example": {
            "name": "pack_example",
            "location": 360,
            "return": [
                ""
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "int",
                    "Tuple[numpy.ndarray, float]"
                ],
                "label": [
                    "str",
                    "List[str]",
                    "memoryview"
                ],
                "fout": [
                    "List[str]",
                    "Iterable[str]",
                    "object",
                    "dict",
                    "Tuple[int, int]",
                    "bytes"
                ]
            }
        },
        "unpack_example": {
            "name": "unpack_example",
            "location": 365,
            "return": [
                "int",
                "Iterable['cirq.Qid']"
            ],
            "arguments": {
                "fin": [
                    "int",
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "unpack_examples": {
            "name": "unpack_examples",
            "location": 374,
            "return": [
                ""
            ],
            "arguments": {
                "fin": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "roundrobin": {
            "name": "roundrobin",
            "location": 383,
            "return": [
                ""
            ],
            "arguments": {
                "iterables": [
                    "str",
                    "numpy.ndarray",
                    "int"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/convnet.py": {
        "get_model": {
            "name": "get_model",
            "location": 6,
            "return": [
                "str"
            ],
            "arguments": {}
        },
        "CustomFlatten.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "rl_algorithms.common.abstraclearner.TensorTuple",
                    "Union[rl_algorithms.common.abstraclearner.TensorTuple, Tuple[rl_algorithms.common.abstraclearner.TensorTuple]]",
                    "int"
                ]
            }
        },
        "CustomFlatten.call": {
            "name": "call",
            "location": 62,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "input_tensor": [
                    "int",
                    "str"
                ],
                "training": [
                    "dict"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/drawing.py": {
        "process_drawing": {
            "name": "process_drawing",
            "location": 6,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "drawing": [
                    "List[str]",
                    "bytes",
                    "list",
                    "int",
                    "ValueError",
                    "bool"
                ],
                "image_size": [
                    "float",
                    "Tuple[int, int]",
                    "int",
                    "str"
                ],
                "augmentation": [
                    "float",
                    "Tuple[int, int]",
                    "int",
                    "str"
                ]
            }
        },
        "process_strokes": {
            "name": "process_strokes",
            "location": 12,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "strokes": [
                    "bool",
                    "numpy.ndarray",
                    "Iterable[str]",
                    "float"
                ],
                "image_size": [
                    "numpy.ndarray",
                    "Union[str, IO[bytes]]",
                    "Tuple[numpy.ndarray, numpy.ndarray]",
                    "tuple"
                ],
                "augmentation": [
                    "bool",
                    "float"
                ]
            }
        },
        "parse_drawing": {
            "name": "parse_drawing",
            "location": 25,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "drawing": [
                    "Dict[str, Any]",
                    "str"
                ],
                "normalize": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "rotate_strokes": {
            "name": "rotate_strokes",
            "location": 35,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "Dict[str, Any]",
                    "str",
                    "bool",
                    "List[dict]",
                    "numpy.ndarray"
                ],
                "degrees": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "mirror_strokes": {
            "name": "mirror_strokes",
            "location": 43,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "Dict[str, Any]",
                    "str",
                    "bool",
                    "List[dict]",
                    "numpy.ndarray"
                ]
            }
        },
        "normalize_strokes": {
            "name": "normalize_strokes",
            "location": 49,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "strokes": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "List[str]"
                ]
            }
        },
        "render_image": {
            "name": "render_image",
            "location": 61,
            "return": [
                "int",
                "tuple"
            ],
            "arguments": {
                "strokes": [
                    "int",
                    "str"
                ],
                "image_size": [
                    "List[list]",
                    "Tuple[int, int]",
                    "str"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/generate_train_data.py": {
        "write_partitions": {
            "name": "write_partitions",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "str",
                    "bool"
                ],
                "output_dir": [
                    "str",
                    "bool",
                    "Optional[bool]"
                ]
            }
        },
        "generate_train_data": {
            "name": "generate_train_data",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {
                "spark": [
                    "bytes",
                    "Optional[Any]",
                    "str",
                    "Optional[int]"
                ],
                "num_partitions": [
                    "Optional[int]",
                    "int",
                    "Callable"
                ]
            }
        },
        "write_partitions.write_partition": {
            "name": "write_partition",
            "location": 16,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "i": [
                    "int",
                    "numpy.random.RandomState",
                    "bytes"
                ],
                "iterator": [
                    "int",
                    "bytes",
                    "numpy.ndarray",
                    "str",
                    "Union[int, str]"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/onecycle.py": {
        "OneCycleLR.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int",
                    "Type[tensorflow.keras.layers.Layer]"
                ],
                "num_epochs": [
                    "int",
                    "Type[tensorflow.keras.layers.Layer]"
                ],
                "batch_size": [
                    "int",
                    "List[float]",
                    "List[str]",
                    "Union[Tuple[int, int], int]"
                ],
                "max_lr": [
                    "int",
                    "float",
                    "Optional[int]",
                    "str"
                ],
                "end_percentage": [
                    "float",
                    "int",
                    "bool",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "scale_percentage": [
                    "Optional[str]",
                    "Optional[int]",
                    "int",
                    "Union[int, None]"
                ],
                "maximum_momentum": [
                    "int",
                    "float"
                ],
                "minimum_momentum": [
                    "int",
                    "float"
                ],
                "verbose": [
                    "int",
                    "float"
                ]
            }
        },
        "OneCycleLR._reset": {
            "name": "_reset",
            "location": 76,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "OneCycleLR.compute_lr": {
            "name": "compute_lr",
            "location": 83,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "OneCycleLR.compute_momentum": {
            "name": "compute_momentum",
            "location": 113,
            "return": [
                "Iterable[str]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "OneCycleLR.on_train_begin": {
            "name": "on_train_begin",
            "location": 138,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "logs": [
                    "str",
                    "Optional[dict]",
                    "int",
                    "dict"
                ]
            }
        },
        "OneCycleLR.on_batch_end": {
            "name": "on_batch_end",
            "location": 151,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "Optional[dict]",
                    "str",
                    "bool",
                    "List[float]"
                ],
                "logs": [
                    "int",
                    "dict",
                    "str",
                    "T",
                    "Dict[str, Any]"
                ]
            }
        },
        "OneCycleLR.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 172,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "Optional[dict]",
                    "str",
                    "bool",
                    "List[float]"
                ],
                "logs": [
                    "int",
                    "Optional[dict]",
                    "str",
                    "bool",
                    "List[float]"
                ]
            }
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/predict_convnet.py": {
        "get_test_generator": {
            "name": "get_test_generator",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Union[List[str], str]",
                    "bool",
                    "str"
                ],
                "augmentation": [
                    "bool",
                    "str",
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ]
            }
        },
        "generate_predictions": {
            "name": "generate_predictions",
            "location": 34,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "Optional[float]",
                    "int"
                ],
                "augmented_images": [
                    "float",
                    "str",
                    "numpy.ndarray",
                    "List[numpy.ndarray]",
                    "tensorflow.Tensor"
                ]
            }
        },
        "write_submission": {
            "name": "write_submission",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "predictions": [
                    "str",
                    "bool",
                    "numpy.ndarray",
                    "Dict[str, str]"
                ],
                "output_file": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 62,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/quickdraw-doodle-recognition/gcloud/train_convnet.py": {
        "bin_generator": {
            "name": "bin_generator",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {
                "bin_file": [
                    "str"
                ]
            }
        },
        "get_train_generator": {
            "name": "get_train_generator",
            "location": 17,
            "return": [
                ""
            ],
            "arguments": {
                "batch_size": [
                    "float",
                    "numpy.ndarray",
                    "List[int]",
                    "list"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 36,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/titanic/util.py": {
        "get_random_seed": {
            "name": "get_random_seed",
            "location": 9,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "num_bytes": [
                    "int"
                ]
            }
        },
        "ModelImputer.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int"
                ],
                "y_column": [
                    "int"
                ],
                "X_columns": [
                    "int"
                ]
            }
        },
        "ModelImputer._get_X_columns": {
            "name": "_get_X_columns",
            "location": 21,
            "return": [
                "str",
                "bool",
                "Union[int, float, complex]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float"
                ]
            }
        },
        "ModelImputer.fit": {
            "name": "fit",
            "location": 25,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray"
                ],
                "y": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "ModelImputer.transform": {
            "name": "transform",
            "location": 32,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ]
            }
        },
        "ColumnSelector.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "columns": [
                    "int",
                    "str",
                    "Union[str, float]",
                    "float",
                    "List[str]"
                ]
            }
        },
        "ColumnSelector.fit": {
            "name": "fit",
            "location": 47,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "numpy.array"
                ],
                "y": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "ColumnSelector._get_support_mask": {
            "name": "_get_support_mask",
            "location": 51,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/base.py": {
        "CommentsDataset.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "df": [
                    "int",
                    "numpy.ndarray",
                    "Callable",
                    "torch.Tensor",
                    "Optional[int]",
                    "pandas.DataFrame",
                    "Tuple[numpy.dtype]"
                ],
                "fields": [
                    "Union[type, Tuple[type, ...]]",
                    "Dict[str, Any]",
                    "rflx.model.Field",
                    "Dict[str, Iterable[Any]]"
                ]
            }
        },
        "BaseModel.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "int",
                    "bool"
                ],
                "random_seed": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "BaseModel.main": {
            "name": "main",
            "location": 58,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.load_preprocessed_data": {
            "name": "load_preprocessed_data",
            "location": 117,
            "return": [
                "dict",
                "Optional[float]",
                "str",
                "Optional[Dict[str, Any]]",
                "IO[bytes]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.build_fields_and_vocab": {
            "name": "build_fields_and_vocab",
            "location": 121,
            "return": [
                "str",
                "bool",
                "List[str]",
                "dict",
                "Dict[str, Optional[str]]"
            ],
            "arguments": {
                "self": [],
                "preprocessed_data": [
                    "str",
                    "int",
                    "Optional[str]",
                    "pandas.DataFrame"
                ]
            }
        },
        "BaseModel.train": {
            "name": "train",
            "location": 154,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "pandas.Series",
                    "Dict[str, Any]",
                    "bool",
                    "float"
                ],
                "train_df": [
                    "Union[numpy.ndarray, numpy.void]",
                    "bool",
                    "List[Dict[Any, Any]]",
                    "int",
                    "Tuple[int]"
                ],
                "val_df": [
                    "Callable[[numpy.ndarray, numpy.ndarray], numpy.ndarray]",
                    "int",
                    "bool",
                    "Optional[float]"
                ]
            }
        },
        "BaseModel.predict": {
            "name": "predict",
            "location": 236,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "List[str]",
                    "Optional[str]"
                ],
                "df": [
                    "str",
                    "Sequence[str]"
                ],
                "output_path": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "BaseModel.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 250,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "df": [
                    "bool",
                    "list",
                    "Iterable[str]"
                ]
            }
        },
        "BaseModel.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 253,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "df": [
                    "bool",
                    "list",
                    "Iterable[str]"
                ]
            }
        },
        "BaseModel.build_model": {
            "name": "build_model",
            "location": 256,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.calculate_loss": {
            "name": "calculate_loss",
            "location": 259,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Mapping[str, Any]",
                    "str"
                ],
                "batch": [
                    "str",
                    "type",
                    "bool"
                ]
            }
        },
        "BaseModel.update_parameters": {
            "name": "update_parameters",
            "location": 265,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "list",
                    "List[Tuple[str, str]]",
                    "Type[T]",
                    "str",
                    "List[str]"
                ],
                "optimizer": [
                    "float",
                    "dict",
                    "datetime.datetime",
                    "Union[str, int]",
                    "List[Exception]"
                ],
                "loss": [
                    "list",
                    "List[Tuple[str, str]]",
                    "Type[T]",
                    "str",
                    "List[str]"
                ]
            }
        },
        "BaseModel.evaluate_model": {
            "name": "evaluate_model",
            "location": 268,
            "return": [
                "pandas.DataFrame",
                "Optional[str]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "int"
                ],
                "batch_iter": []
            }
        },
        "BaseModel.save_model": {
            "name": "save_model",
            "location": 281,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int"
                ],
                "model": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "BaseModel.load_model": {
            "name": "load_model",
            "location": 285,
            "return": [],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int"
                ]
            }
        },
        "BaseModule.__init__": {
            "name": "__init__",
            "location": 294,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "bytes",
                    "gluonts.datasecommon.Dataset",
                    "float",
                    "allennlp.data.Vocabulary"
                ]
            }
        },
        "Dense.__init__": {
            "name": "__init__",
            "location": 311,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "List[None]",
                    "str"
                ],
                "output_size": [
                    "int",
                    "List[None]",
                    "str"
                ],
                "output_nonlinearity": [
                    "list"
                ],
                "hidden_layers": [
                    "int",
                    "List[int]"
                ],
                "hidden_nonlinearity": [
                    "str",
                    "Iterable",
                    "List[float]",
                    "int",
                    "list"
                ],
                "input_dropout": [
                    "str",
                    "List[float]",
                    "List[List[float]]"
                ],
                "hidden_dropout": [
                    "str",
                    "List[float]",
                    "List[List[float]]"
                ],
                "dropout": [
                    "str",
                    "bool",
                    "List[str]",
                    "List[Tuple[str, Any, Any]]"
                ]
            }
        },
        "Dense.forward": {
            "name": "forward",
            "location": 359,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "WeightDrop.__init__": {
            "name": "__init__",
            "location": 366,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "module": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "weights": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "dropout": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "WeightDrop.no_op": {
            "name": "no_op",
            "location": 373,
            "return": [
                "Iterator[Tuple[str, str]]",
                "int"
            ],
            "arguments": {}
        },
        "WeightDrop._setup": {
            "name": "_setup",
            "location": 376,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "WeightDrop._setweights": {
            "name": "_setweights",
            "location": 386,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "WeightDrop.forward": {
            "name": "forward",
            "location": 392,
            "return": [
                "bool",
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseModel.build_fields_and_vocab.getitem": {
            "name": "getitem",
            "location": 146,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "bytes",
                    "List[int]",
                    "int"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/common.py": {
        "params_str": {
            "name": "params_str",
            "location": 24,
            "return": [
                "str",
                "float"
            ],
            "arguments": {
                "params": [
                    "list",
                    "set",
                    "pandas.DataFrame",
                    "List[Tuple[Any, Any]]",
                    "List[tuple]",
                    "bytes",
                    "Dict[int, Dict[str, Any]]"
                ]
            }
        },
        "load_raw_data": {
            "name": "load_raw_data",
            "location": 31,
            "return": [
                "dict",
                "Optional[float]",
                "str",
                "Optional[Dict[str, Any]]",
                "IO[bytes]"
            ],
            "arguments": {}
        },
        "load_data": {
            "name": "load_data",
            "location": 43,
            "return": [
                "bool",
                "str",
                "List[str]",
                "Generator"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "bool",
                    "pandas.DataFrame"
                ]
            }
        },
        "stratified_kfold": {
            "name": "stratified_kfold",
            "location": 50,
            "return": [
                ""
            ],
            "arguments": {
                "df": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]",
                    "List[int]"
                ],
                "random_seed": [
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "bool",
                    "float"
                ],
                "k": [
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/dpcnn.py": {
        "ConvBlock.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "channels": [
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[str]"
                ],
                "dropout": [
                    "float",
                    "bool",
                    "int"
                ]
            }
        },
        "ConvBlock._init_batchnorm": {
            "name": "_init_batchnorm",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Union[str, Callable]"
                ]
            }
        },
        "ConvBlock._init_conv": {
            "name": "_init_conv",
            "location": 36,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "module": [
                    "Optional[str]",
                    "str",
                    "Union[str, Callable]"
                ]
            }
        },
        "ConvBlock.forward": {
            "name": "forward",
            "location": 40,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "list",
                    "List[float]",
                    "float"
                ]
            }
        },
        "DPCNNModule.__init__": {
            "name": "__init__",
            "location": 56,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "bool",
                    "allennlp.data.vocabulary.Vocabulary",
                    "str"
                ],
                "conv_blocks": [
                    "eth.chains.base.MiningChain",
                    "int",
                    "Optional[int]"
                ],
                "conv_dropout": [
                    "Optional[List[float]]",
                    "int",
                    "Tuple[int]",
                    "Type[object]",
                    "str",
                    "Union[int, float]"
                ],
                "dense_layers": [
                    "int"
                ],
                "dense_nonlinearily": [
                    "int"
                ],
                "dense_dropout": [
                    "int"
                ]
            }
        },
        "DPCNNModule.forward": {
            "name": "forward",
            "location": 72,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "Sequence[Dict[str, str]]",
                    "Optional[Dict[str, Any]]"
                ],
                "text_lengths": [
                    "str",
                    "bool",
                    "Union[str, List[Any]]"
                ]
            }
        },
        "DPCNN.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 90,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "Iterable[allennlp.data.instance.Instance]",
                    "bool"
                ]
            }
        },
        "DPCNN.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 97,
            "return": [
                "int",
                "bool",
                "bytes",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "DPCNN.build_model": {
            "name": "build_model",
            "location": 105,
            "return": [
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/evaluation.py": {
        "main": {
            "name": "main",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "kaggle-master/toxic-comment-classification/gcnn.py": {
        "GLU.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "in_channels": [
                    "int",
                    "float",
                    "bool"
                ],
                "out_channels": [
                    "int",
                    "bool"
                ],
                "kernel_size": [
                    "int",
                    "Dict[str, torch.LongTensor]"
                ]
            }
        },
        "GLU._init_conv": {
            "name": "_init_conv",
            "location": 30,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "module": [
                    "Optional[str]",
                    "str",
                    "Union[str, Callable]"
                ]
            }
        },
        "GLU.forward": {
            "name": "forward",
            "location": 34,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "gluonts.model.common.Tensor",
                    "Tuple[int]",
                    "common.SVGBoundaries"
                ]
            }
        },
        "ResidualBlock.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "in_channels": [
                    "bool",
                    "int",
                    "float"
                ],
                "out_channels": [
                    "bool",
                    "int",
                    "float"
                ],
                "kernel_size": [
                    "bool",
                    "int",
                    "float"
                ],
                "num_layers": [
                    "int",
                    "str"
                ]
            }
        },
        "ResidualBlock.forward": {
            "name": "forward",
            "location": 59,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "GCNNModule.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "bool",
                    "str"
                ],
                "num_blocks": [
                    "int",
                    "str"
                ],
                "num_layers": [
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "num_channels": [
                    "int",
                    "float",
                    "Union[None, int]"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "Union[None, int]"
                ],
                "dense_layers": [
                    "int",
                    "hackathon.utils.utils.ResultsMessage",
                    "Optional[int]",
                    "Optional[str]",
                    "List[int]",
                    "str"
                ],
                "dense_dropout": [
                    "int",
                    "hackathon.utils.utils.ResultsMessage",
                    "Optional[int]",
                    "Optional[str]",
                    "List[int]",
                    "str"
                ]
            }
        },
        "GCNNModule.forward": {
            "name": "forward",
            "location": 90,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "Sequence[Dict[str, str]]",
                    "Optional[Dict[str, Any]]"
                ],
                "text_lengths": [
                    "str",
                    "bool",
                    "Union[str, List[Any]]"
                ]
            }
        },
        "GCNN.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 107,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "Iterable[allennlp.data.instance.Instance]",
                    "bool"
                ]
            }
        },
        "GCNN.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 114,
            "return": [
                "int",
                "bool",
                "bytes",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "GCNN.build_model": {
            "name": "build_model",
            "location": 122,
            "return": [
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "GCNN.update_parameters": {
            "name": "update_parameters",
            "location": 133,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Type[T]",
                    "keanu.vertex.base.Vertex",
                    "str"
                ],
                "optimizer": [
                    "float",
                    "cmk.utils.type_defs.HostName",
                    "dict",
                    "Union[str, int]",
                    "List[Exception]"
                ],
                "loss": [
                    "list",
                    "List[Tuple[str, str]]",
                    "Type[T]",
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/gru.py": {
        "minimal_preprocessing": {
            "name": "minimal_preprocessing",
            "location": 25,
            "return": [
                "Tuple[int, int]",
                "numpy.matrix",
                "float",
                "bool",
                "Union[numpy.ndarray, numpy.void]",
                "int"
            ],
            "arguments": {
                "row": [
                    "int",
                    "Dict[str, str]",
                    "List[str]",
                    "Sequence[MutableMapping]"
                ]
            }
        },
        "GRUModule.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str"
                ],
                "annotation_dropout": [
                    "int",
                    "bool",
                    "Optional[Union[int, float]]",
                    "Optional[int]",
                    "rl_algorithms.utils.config.ConfigDict"
                ],
                "prediction_dropout": [
                    "int",
                    "str"
                ]
            }
        },
        "GRUModule.forward": {
            "name": "forward",
            "location": 84,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "Sequence[Dict[str, str]]",
                    "Optional[Dict[str, Any]]"
                ],
                "text_lengths": [
                    "str",
                    "Sequence[str]"
                ]
            }
        },
        "GRU.load_preprocessed_data": {
            "name": "load_preprocessed_data",
            "location": 112,
            "return": [
                "dict",
                "Optional[float]",
                "str",
                "Optional[Dict[str, Any]]",
                "IO[bytes]",
                "Set[cmk.utils.type_defs.HostName]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GRU.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 142,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "Iterable[allennlp.data.instance.Instance]",
                    "bool"
                ]
            }
        },
        "GRU.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 151,
            "return": [
                "int",
                "bool",
                "bytes",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "cmk.utils.type_defs.HostName",
                    "cmk.utils.type_defs.Ruleset"
                ]
            }
        },
        "GRU.build_model": {
            "name": "build_model",
            "location": 163,
            "return": [
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "GRU.update_parameters": {
            "name": "update_parameters",
            "location": 172,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Type[T]",
                    "keanu.vertex.base.Vertex",
                    "str"
                ],
                "optimizer": [
                    "float",
                    "cmk.utils.type_defs.HostName",
                    "dict",
                    "Union[str, int]",
                    "List[Exception]"
                ],
                "loss": [
                    "list",
                    "List[Tuple[str, str]]",
                    "Type[T]",
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/label_stacking.py": {
        "LabelStacking.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Optional[dict]"
                ],
                "params": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Optional[dict]",
                    "bytes"
                ],
                "random_seed": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Optional[dict]"
                ]
            }
        },
        "LabelStacking.main": {
            "name": "main",
            "location": 145,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelStacking.load_inputs": {
            "name": "load_inputs",
            "location": 199,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "ids": [
                    "str",
                    "Iterable[int]"
                ],
                "dataset": [
                    "str",
                    "int",
                    "List[str]"
                ]
            }
        },
        "LabelStacking.train": {
            "name": "train",
            "location": 210,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "bool",
                    "float",
                    "datetime.datetime",
                    "numpy.ndarray",
                    "list",
                    "pandas.DataFrame"
                ],
                "label": [
                    "int",
                    "bool",
                    "float",
                    "datetime.datetime",
                    "numpy.ndarray",
                    "list",
                    "pandas.DataFrame"
                ],
                "X_train": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ],
                "y_train": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ],
                "X_val": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ],
                "y_val": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ]
            }
        },
        "LabelStacking.save_model": {
            "name": "save_model",
            "location": 230,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "bool",
                    "Union[float, str]",
                    "str",
                    "Optional[Union[int, str]]"
                ],
                "label": [
                    "int",
                    "bool",
                    "Union[float, str]",
                    "str",
                    "Optional[Union[int, str]]"
                ],
                "model": [
                    "numpy.ndarray",
                    "bool",
                    "sensibility.model.lstm.DualLSTMModel",
                    "float"
                ]
            }
        },
        "LabelStacking.load_model": {
            "name": "load_model",
            "location": 234,
            "return": [
                "base.Model"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "label": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "LabelStacking.predict": {
            "name": "predict",
            "location": 239,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "List[float]"
                ],
                "X": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "List[float]"
                ]
            }
        },
        "Stacking.__init__": {
            "name": "__init__",
            "location": 246,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "List[str]"
                ],
                "params": [
                    "str"
                ],
                "random_seed": [
                    "str",
                    "dict",
                    "bool"
                ]
            }
        },
        "Stacking.main": {
            "name": "main",
            "location": 257,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/lstm.py": {
        "LSTMModule.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "bool",
                    "float"
                ],
                "rnn_size": [
                    "int",
                    "float"
                ],
                "rnn_layers": [
                    "int",
                    "float"
                ],
                "rnn_dropout": [
                    "int",
                    "str",
                    "List[int]",
                    "float"
                ],
                "dense_layers": [
                    "int",
                    "float"
                ],
                "dense_nonlinearily": [
                    "int",
                    "float"
                ],
                "dense_dropout": [
                    "int",
                    "float"
                ]
            }
        },
        "LSTMModule.forward": {
            "name": "forward",
            "location": 48,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bool",
                    "Optional[float]",
                    "float"
                ],
                "text_lengths": [
                    "str",
                    "Sequence[str]"
                ]
            }
        },
        "LSTM.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 70,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "Iterable[allennlp.data.instance.Instance]",
                    "bool"
                ]
            }
        },
        "LSTM.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 78,
            "return": [
                "int",
                "bool",
                "bytes",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "cmk.utils.type_defs.HostName",
                    "cmk.utils.type_defs.Ruleset"
                ]
            }
        },
        "LSTM.build_model": {
            "name": "build_model",
            "location": 89,
            "return": [
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        },
        "LSTM.update_parameters": {
            "name": "update_parameters",
            "location": 100,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Type[T]",
                    "keanu.vertex.base.Vertex",
                    "str"
                ],
                "optimizer": [
                    "float",
                    "cmk.utils.type_defs.HostName",
                    "dict",
                    "Union[str, int]",
                    "List[Exception]"
                ],
                "loss": [
                    "list",
                    "List[Tuple[str, str]]",
                    "Type[T]",
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/mlp.py": {
        "MLPModule.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "allennlp.data.Vocabulary",
                    "Callable",
                    "Optional[str]"
                ],
                "hidden_layers": [
                    "torch.Tensor",
                    "str",
                    "bool",
                    "List[List[T]]",
                    "float"
                ],
                "hidden_units": [
                    "torch.Tensor",
                    "str",
                    "bool",
                    "List[List[T]]",
                    "float"
                ],
                "hidden_nonlinearity": [
                    "torch.Tensor",
                    "str",
                    "bool",
                    "List[List[T]]",
                    "float"
                ],
                "input_dropout": [
                    "torch.Tensor",
                    "str",
                    "bool",
                    "List[List[T]]",
                    "float"
                ],
                "hidden_dropout": [
                    "torch.Tensor",
                    "str",
                    "bool",
                    "List[List[T]]",
                    "float"
                ]
            }
        },
        "MLPModule.forward": {
            "name": "forward",
            "location": 23,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bool",
                    "Sequence[Dict[str, str]]",
                    "Optional[Dict[str, Any]]"
                ],
                "text_lengths": [
                    "str",
                    "int"
                ]
            }
        },
        "MLP.build_train_iterator": {
            "name": "build_train_iterator",
            "location": 33,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "Iterable[allennlp.data.instance.Instance]",
                    "bool"
                ]
            }
        },
        "MLP.build_prediction_iterator": {
            "name": "build_prediction_iterator",
            "location": 40,
            "return": [
                "int",
                "bool",
                "bytes",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "MLP.build_model": {
            "name": "build_model",
            "location": 48,
            "return": [
                "Pattern"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/toxic-comment-classification/ngram.py": {
        "NGram.main": {
            "name": "main",
            "location": 27,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "NGram.train": {
            "name": "train",
            "location": 84,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int",
                    "bool",
                    "Optional[Union[int, str]]"
                ],
                "vectorizer": [
                    "bool",
                    "str"
                ],
                "train_df": [
                    "Optional[numpy.ndarray]",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Union[int, float]"
                ],
                "val_df": [
                    "bool",
                    "int",
                    "Iterable[T]",
                    "Sequence[str]",
                    "float"
                ]
            }
        },
        "NGram.predict": {
            "name": "predict",
            "location": 106,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "models": [
                    "bool",
                    "str",
                    "int"
                ],
                "vectorizer": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bool",
                    "type"
                ],
                "df": [
                    "bool",
                    "float",
                    "str",
                    "allennlp.common.util.JsonDict"
                ],
                "output_path": [
                    "str",
                    "numpy.ndarray",
                    "MutableMapping[domain.Identifier, datetime.date]"
                ]
            }
        },
        "NGram.build_vectorizer": {
            "name": "build_vectorizer",
            "location": 118,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "int"
                ],
                "test_df": [
                    "int",
                    "bool",
                    "Tuple[int]",
                    "str",
                    "Optional[Dict[str, Any]]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/preprocessing.py": {
        "load": {
            "name": "load",
            "location": 25,
            "return": [
                "bytes",
                "int",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "params": [
                    "str",
                    "bool",
                    "IO",
                    "int"
                ]
            }
        },
        "preprocess_row": {
            "name": "preprocess_row",
            "location": 67,
            "return": [
                "int",
                "Optional[int]",
                "tuple"
            ],
            "arguments": {
                "row": [
                    "List[int]",
                    "Dict[str, Any]",
                    "dict",
                    "Optional[Any]",
                    "bool"
                ]
            }
        },
        "preprocess": {
            "name": "preprocess",
            "location": 71,
            "return": [
                "str",
                "Optional[str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/stacking.py": {
        "Stacking.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "bool"
                ],
                "random_seed": [
                    "int",
                    "str"
                ]
            }
        },
        "Stacking.main": {
            "name": "main",
            "location": 144,
            "return": [
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stacking.load_inputs": {
            "name": "load_inputs",
            "location": 218,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "int",
                    "Optional[bool]"
                ],
                "ids": [
                    "Iterable[int]",
                    "str",
                    "Union[None, int, str]"
                ],
                "dataset": [
                    "str"
                ]
            }
        },
        "Stacking.train": {
            "name": "train",
            "location": 233,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "bool",
                    "float",
                    "datetime.datetime",
                    "numpy.ndarray",
                    "list",
                    "pandas.DataFrame"
                ],
                "label": [
                    "int",
                    "bool",
                    "float",
                    "datetime.datetime",
                    "numpy.ndarray",
                    "list",
                    "pandas.DataFrame"
                ],
                "X_train": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ],
                "y_train": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ],
                "X_val": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ],
                "y_val": [
                    "List[numpy.array]",
                    "List[str]",
                    "pandas.DataFrame",
                    "int",
                    "str"
                ]
            }
        },
        "Stacking.save_model": {
            "name": "save_model",
            "location": 253,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "int",
                    "bool",
                    "Union[float, str]",
                    "str",
                    "Optional[Union[int, str]]"
                ],
                "label": [
                    "int",
                    "bool",
                    "Union[float, str]",
                    "str",
                    "Optional[Union[int, str]]"
                ],
                "model": [
                    "numpy.ndarray",
                    "bool",
                    "sensibility.model.lstm.DualLSTMModel",
                    "float"
                ]
            }
        },
        "Stacking.load_model": {
            "name": "load_model",
            "location": 257,
            "return": [
                "base.Model"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "label": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Stacking.predict": {
            "name": "predict",
            "location": 262,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "List[float]"
                ],
                "X": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "List[float]"
                ]
            }
        }
    },
    "kaggle-master/toxic-comment-classification/xgb.py": {
        "XGB.main": {
            "name": "main",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "XGB.train": {
            "name": "train",
            "location": 83,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "fold_num": [
                    "str",
                    "int",
                    "bool",
                    "Optional[Union[int, str]]"
                ],
                "vectorizer": [
                    "str",
                    "int",
                    "float"
                ],
                "train_df": [
                    "numpy.ndarray",
                    "Mapping[str, Tuple[float, float, float]]",
                    "Union[int, float]"
                ],
                "val_df": [
                    "numpy.ndarray",
                    "Mapping[str, Tuple[float, float, float]]",
                    "Union[int, float]"
                ]
            }
        },
        "XGB.predict": {
            "name": "predict",
            "location": 113,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "models": [
                    "bool",
                    "str",
                    "int"
                ],
                "vectorizer": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bool",
                    "type"
                ],
                "df": [
                    "bool",
                    "float",
                    "str",
                    "allennlp.common.util.JsonDict"
                ],
                "output_path": [
                    "str",
                    "numpy.ndarray",
                    "MutableMapping[domain.Identifier, datetime.date]"
                ]
            }
        },
        "XGB.build_vectorizer": {
            "name": "build_vectorizer",
            "location": 125,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "preprocessed_data": [
                    "str",
                    "float",
                    "bytes",
                    "bool"
                ]
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/config.py": {},
    "kaggle-master/web-traffic-forecasting/pipelines/data.py": {
        "get_data_dir": {
            "name": "get_data_dir",
            "location": 127,
            "return": [
                "str"
            ],
            "arguments": {
                "stage": [
                    "str",
                    "Optional[str]"
                ],
                "imputation": [
                    "str",
                    "Optional[str]"
                ],
                "sample_ratio": [
                    "str",
                    "Optional[str]"
                ],
                "random_seed": [
                    "str",
                    "Optional[str]"
                ],
                "deploy_date": [
                    "str",
                    "Optional[str]"
                ],
                "from_date": [
                    "str",
                    "Optional[str]"
                ],
                "to_date": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "Key.output": {
            "name": "output",
            "location": 17,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Key.read": {
            "name": "read",
            "location": 21,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "InputData.output": {
            "name": "output",
            "location": 29,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "InputData.read": {
            "name": "read",
            "location": 33,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.requires": {
            "name": "requires",
            "location": 42,
            "return": [
                "str",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.output": {
            "name": "output",
            "location": 45,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.read": {
            "name": "read",
            "location": 49,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData.run": {
            "name": "run",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedData._interpolate": {
            "name": "_interpolate",
            "location": 76,
            "return": [
                "str",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "page_data": [
                    "bytes",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "ImputedDataSample.requires": {
            "name": "requires",
            "location": 101,
            "return": [
                "bytes",
                "List[Dict[str, Any]]",
                "bool",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedDataSample.output": {
            "name": "output",
            "location": 104,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedDataSample.read": {
            "name": "read",
            "location": 110,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputedDataSample.run": {
            "name": "run",
            "location": 115,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/evaluation.py": {
        "calculate_smape": {
            "name": "calculate_smape",
            "location": 14,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "y_true": [
                    "int",
                    "str",
                    "dict",
                    "List[Exception]"
                ],
                "y_pred": [
                    "bool",
                    "BaseException",
                    "str",
                    "Tuple[str]"
                ]
            }
        },
        "ModelEvaluation.requires": {
            "name": "requires",
            "location": 26,
            "return": [
                "str",
                "Dict[str, str]",
                "bool",
                "Sequence[str]",
                "Optional[pandas.DataFrame]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelEvaluation.output": {
            "name": "output",
            "location": 32,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelEvaluation.run": {
            "name": "run",
            "location": 39,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.complete": {
            "name": "complete",
            "location": 65,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.output": {
            "name": "output",
            "location": 68,
            "return": [
                "str",
                "Optional[str]",
                "bool",
                "TextIO",
                "BinaryIO"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.requires": {
            "name": "requires",
            "location": 72,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvaluationSummary.run": {
            "name": "run",
            "location": 86,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/submissions.py": {
        "Submission.requires": {
            "name": "requires",
            "location": 17,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Submission.output": {
            "name": "output",
            "location": 25,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Submission.run": {
            "name": "run",
            "location": 33,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/__init__.py": {},
    "kaggle-master/web-traffic-forecasting/pipelines/models/common.py": {
        "init_random_state": {
            "name": "init_random_state",
            "location": 14,
            "return": [
                "float",
                "str",
                "int"
            ],
            "arguments": {
                "random_seed": [
                    "float",
                    "List[int]",
                    "str",
                    "bool",
                    "int",
                    "list"
                ]
            }
        },
        "layer_units": {
            "name": "layer_units",
            "location": 21,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_size": [
                    "int",
                    "bool",
                    "List[int]"
                ],
                "output_size": [
                    "int",
                    "bool",
                    "List[int]"
                ],
                "num_layers": [
                    "int",
                    "bool",
                    "List[int]"
                ]
            }
        },
        "generate_training_data": {
            "name": "generate_training_data",
            "location": 87,
            "return": [
                "float",
                "bool",
                "int",
                "str",
                "List[Tuple[str, int]]"
            ],
            "arguments": {
                "data": [
                    "datetime.datetime",
                    "datetime.date",
                    "str",
                    "int"
                ],
                "deploy_date": [
                    "str",
                    "datetime.date",
                    "list",
                    "Set[str]",
                    "datetime.timedelta",
                    "Optional[str]"
                ],
                "from_date": [
                    "datetime.datetime",
                    "datetime.date",
                    "str",
                    "Optional[bool]"
                ],
                "to_date": [
                    "str",
                    "int",
                    "datetime.datetime",
                    "datetime.date",
                    "Optional[datetime.datetime]"
                ],
                "num_days_before": [
                    "str",
                    "float",
                    "int",
                    "datetime.datetime",
                    "Set[str]"
                ]
            }
        },
        "generate_training_sample": {
            "name": "generate_training_sample",
            "location": 148,
            "return": [
                "float",
                "torch.FloatTensor",
                "Optional[int]",
                "Optional[List[int]]",
                "str"
            ],
            "arguments": {
                "page": [
                    "datetime.timedelta",
                    "bool",
                    "List[str]",
                    "str"
                ],
                "page_data": [
                    "int",
                    "Dict[str, Any]",
                    "List[str]",
                    "numpy.ndarray",
                    "torch.LongTensor",
                    "Optional[float]"
                ],
                "last_year_f": [
                    "str",
                    "bytes",
                    "int",
                    "Dict[str, str]"
                ],
                "last_year_t": [
                    "str",
                    "bytes",
                    "int",
                    "Dict[str, str]"
                ],
                "d": [
                    "int",
                    "Optional[float]",
                    "str",
                    "List[numpy.ndarray]"
                ],
                "f": [
                    "int",
                    "list",
                    "List[numpy.ndarray]",
                    "bytearray",
                    "List[int]",
                    "Sequence[List[int]]"
                ],
                "t": [
                    "int",
                    "list",
                    "List[numpy.ndarray]",
                    "bytearray",
                    "List[int]",
                    "Sequence[List[int]]"
                ],
                "num_days_target": [
                    "Sequence[int]",
                    "int",
                    "Optional[int]",
                    "raiden.utils.PaymentAmount",
                    "bool"
                ],
                "num_days_before": [
                    "int",
                    "bool",
                    "Hashable",
                    "Optional[float]",
                    "Optional[str]",
                    "str",
                    "float"
                ]
            }
        },
        "generate_prediction_data": {
            "name": "generate_prediction_data",
            "location": 167,
            "return": [
                "float",
                "bool",
                "int",
                "str",
                "List[Tuple[str, int]]"
            ],
            "arguments": {
                "data": [
                    "str",
                    "Optional[str]",
                    "Optional[float]",
                    "raiden.utils.BlockNumber"
                ],
                "deploy_date": [
                    "str",
                    "Optional[str]",
                    "datetime.datetime",
                    "int"
                ],
                "from_date": [
                    "int",
                    "datetime.date",
                    "datetime.datetime",
                    "Optional[bool]"
                ],
                "to_date": [
                    "str",
                    "int",
                    "datetime.datetime",
                    "Optional[datetime.datetime]"
                ],
                "num_days_before": [
                    "datetime.datetime",
                    "str",
                    "Optional[str]",
                    "datetime.date",
                    "Optional[datetime.date]"
                ]
            }
        },
        "generate_prediction_sample": {
            "name": "generate_prediction_sample",
            "location": 203,
            "return": [
                "float",
                "torch.FloatTensor",
                "Optional[int]",
                "Optional[List[int]]",
                "str"
            ],
            "arguments": {
                "page": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "Optional[int]"
                ],
                "page_data": [
                    "bytes",
                    "Mapping[str, Any]",
                    "bool",
                    "int",
                    "Sequence[str]"
                ],
                "last_year_from_date": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str",
                    "Optional[str]",
                    "List[int]"
                ],
                "last_year_to_date": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str",
                    "Optional[str]",
                    "List[int]"
                ],
                "deploy_date": [
                    "str",
                    "Optional[bool]",
                    "Dict[str, str]",
                    "Any",
                    "Optional[str]"
                ],
                "num_days_target": [
                    "int",
                    "Optional[int]",
                    "List[str]",
                    "Union[None, int, str]",
                    "str",
                    "mode.utils.imports.SymbolArg[Type[mode.SupervisorStrategyT]]"
                ],
                "num_days_before": [
                    "bool",
                    "str",
                    "int",
                    "dict",
                    "list"
                ]
            }
        },
        "Projection.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "List[Tuple[Any, float]]",
                    "List[str]",
                    "List[None]"
                ],
                "output_size": [
                    "int",
                    "List[Tuple[Any, float]]",
                    "List[str]",
                    "List[None]"
                ],
                "output_nonlinearity": [
                    "str",
                    "list",
                    "Dict[int, str]"
                ],
                "hidden_layers": [
                    "int",
                    "List[Tuple[Any, float]]",
                    "List[str]",
                    "List[None]"
                ],
                "hidden_nonlinearity": [
                    "List[str]",
                    "list",
                    "List[float]",
                    "List[int]",
                    "int",
                    "Iterable",
                    "str"
                ],
                "dropout": [
                    "list",
                    "List[str]",
                    "str",
                    "Iterator[Tuple[Any, Any]]"
                ]
            }
        },
        "Projection.forward": {
            "name": "forward",
            "location": 66,
            "return": [
                "str",
                "utils.Node",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "MultiTensorDataset.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "target_tensor": [
                    "bytes"
                ]
            }
        },
        "MultiTensorDataset.__getitem__": {
            "name": "__getitem__",
            "location": 78,
            "return": [
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "dict",
                    "float",
                    "Dict[str, Any]"
                ]
            }
        },
        "MultiTensorDataset.__len__": {
            "name": "__len__",
            "location": 83,
            "return": [
                "float",
                "T",
                "torch.nn.utils.rnn.PackedSequence",
                "List[allennlp.data.iterators.data_iterator.TensorDict]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/models/historical_median.py": {
        "FitHistoricalMedian.run": {
            "name": "run",
            "location": 14,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictHistoricalMedian.requires": {
            "name": "requires",
            "location": 37,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictHistoricalMedian.run": {
            "name": "run",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "kaggle-master/web-traffic-forecasting/pipelines/models/rnn_v1.py": {},
    "kaggle-master/web-traffic-forecasting/pipelines/models/__init__.py": {
        "_ModelTask.requires": {
            "name": "requires",
            "location": 20,
            "return": [
                "Dict[str, Any]",
                "Dict[str, str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ModelTask.data_dir": {
            "name": "data_dir",
            "location": 31,
            "return": [
                "str",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.model_name": {
            "name": "model_name",
            "location": 45,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "FitModel.output": {
            "name": "output",
            "location": 48,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.model_name": {
            "name": "model_name",
            "location": 59,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "PredictModel.output": {
            "name": "output",
            "location": 62,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.output": {
            "name": "output",
            "location": 74,
            "return": [
                "str",
                "TextIO",
                "BinaryIO",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelPredictions.read": {
            "name": "read",
            "location": 78,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    }
}
{
    "keanu-master/docs/bin/freezeAtVersion.py": {
        "update_file": {
            "name": "update_file",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {
                "destination": [
                    "Sequence[str]"
                ],
                "version": [
                    "str",
                    "bool"
                ]
            }
        },
        "freeze_shiny": {
            "name": "freeze_shiny",
            "location": 17,
            "return": [
                ""
            ],
            "arguments": {
                "version": [
                    "str",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "copy_to_versioned_legacy_path": {
            "name": "copy_to_versioned_legacy_path",
            "location": 23,
            "return": [
                "str"
            ],
            "arguments": {
                "source_path": [
                    "str",
                    "Tuple[int, int]",
                    "Optional[str]"
                ],
                "legacy_root": [
                    "str",
                    "Optional[str]"
                ],
                "version": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "freeze_python": {
            "name": "freeze_python",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "version": [
                    "str",
                    "bool",
                    "Tuple[str, str]",
                    "int"
                ]
            }
        }
    },
    "keanu-master/docs/bin/snippet_writer.py": {
        "record_error": {
            "name": "record_error",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {
                "output_str": [
                    "str",
                    "set",
                    "bytes"
                ]
            }
        },
        "printd": {
            "name": "printd",
            "location": 27,
            "return": [
                ""
            ],
            "arguments": {
                "debug_str": [
                    "int",
                    "str"
                ]
            }
        },
        "read_file_snippets": {
            "name": "read_file_snippets",
            "location": 31,
            "return": [
                ""
            ],
            "arguments": {
                "file": [
                    "str",
                    "Optional[str]",
                    "io.BytesIO"
                ],
                "snippet_store": [
                    "bool",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "replace_tags": {
            "name": "replace_tags",
            "location": 76,
            "return": [
                ""
            ],
            "arguments": {
                "in_name": [
                    "str",
                    "List[str]"
                ],
                "out_name": [
                    "bool",
                    "str",
                    "int",
                    "Iterable[str]",
                    "List[str]"
                ],
                "snippet_store": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "do_rewrites": {
            "name": "do_rewrites",
            "location": 95,
            "return": [
                ""
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "in_loc": [
                    "str"
                ],
                "out_loc": [
                    "str"
                ],
                "snippet_store": [
                    "str",
                    "Dict[str, str]",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "for_all_files_in_dir": {
            "name": "for_all_files_in_dir",
            "location": 102,
            "return": [
                ""
            ],
            "arguments": {
                "directory": [
                    "str",
                    "Optional[str]"
                ],
                "action": [
                    "bool",
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "subtractStrings": {
            "name": "subtractStrings",
            "location": 108,
            "return": [
                "str",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "str1": [
                    "str",
                    "Union[str, int]"
                ],
                "str2": [
                    "str",
                    "Union[str, int]"
                ]
            }
        },
        "for_all_in_subdirs": {
            "name": "for_all_in_subdirs",
            "location": 114,
            "return": [
                ""
            ],
            "arguments": {
                "directory": [
                    "str",
                    "int"
                ],
                "action": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "check_output_dir_exists": {
            "name": "check_output_dir_exists",
            "location": 121,
            "return": [
                ""
            ],
            "arguments": {
                "output_dir": [
                    "str",
                    "int"
                ]
            }
        },
        "strip_block_whitespace": {
            "name": "strip_block_whitespace",
            "location": 126,
            "return": [
                "str",
                "dict",
                "tuple",
                "float",
                "bytes"
            ],
            "arguments": {
                "string_list": [
                    "str",
                    "List[str]",
                    "int",
                    "dict",
                    "Set[str]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 133,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "keanu-master/docs/src/test/python/test_autocorrelation.py": {
        "test_autocorrelation_example_scalar": {
            "name": "test_autocorrelation_example_scalar",
            "location": 7,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_autocorrelation_example_nd": {
            "name": "test_autocorrelation_example_nd",
            "location": 24,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "keanu-master/docs/src/test/python/test_lorenz.py": {
        "add_time": {
            "name": "add_time",
            "location": 39,
            "return": [
                "List[int]",
                "int",
                "bool"
            ],
            "arguments": {
                "current": [
                    "Tuple[keanu.vertex.Vertex, keanu.vertex.Vertex, keanu.vertex.Vertex]",
                    "str",
                    "Union[str, int]"
                ]
            }
        },
        "build_graph": {
            "name": "build_graph",
            "location": 49,
            "return": [
                ""
            ],
            "arguments": {
                "initial": [
                    "Tuple[keanu.vertex.Vertex, keanu.vertex.Vertex, keanu.vertex.Vertex]",
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "apply_observations": {
            "name": "apply_observations",
            "location": 57,
            "return": [
                ""
            ],
            "arguments": {
                "graph_time_steps": [
                    "float",
                    "int",
                    "Optional[str]"
                ],
                "window": [
                    "Optional[int]",
                    "Tuple[int, int]",
                    "Callable[[str, str], float]",
                    "int"
                ],
                "observed": [
                    "int",
                    "bool",
                    "float",
                    "bytes"
                ]
            }
        },
        "get_time_slice_values": {
            "name": "get_time_slice_values",
            "location": 66,
            "return": [
                "List[str]",
                "list"
            ],
            "arguments": {
                "time_steps": [
                    "float",
                    "str",
                    "int",
                    "bool"
                ],
                "time": [
                    "float",
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "test_run_lorenz": {
            "name": "test_run_lorenz",
            "location": 70,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "LorenzModel.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sigma": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "beta": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "rho": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "time_step": [
                    "int",
                    "float",
                    "Union[str, float]"
                ]
            }
        },
        "LorenzModel.run_model": {
            "name": "run_model",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "num_time_steps": [
                    "int",
                    "float"
                ]
            }
        },
        "LorenzModel.__get_next_position": {
            "name": "__get_next_position",
            "location": 33,
            "return": [
                "bool",
                "str",
                "int",
                "Hashable",
                "type",
                "Callable[[KT], VT]"
            ],
            "arguments": {
                "self": [],
                "current": [
                    "List[List[int]]",
                    "Tuple[float, float]",
                    "List[int]"
                ]
            }
        }
    },
    "keanu-master/docs/src/test/python/test_optimizer.py": {
        "build_model": {
            "name": "build_model",
            "location": 6,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "test_gradient_optimzer_example": {
            "name": "test_gradient_optimzer_example",
            "location": 14,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_non_gradient_optimizer_example": {
            "name": "test_non_gradient_optimizer_example",
            "location": 27,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "keanu-master/docs/src/test/python/test_sampling.py": {
        "test_inference_example_metropolis": {
            "name": "test_inference_example_metropolis",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_inference_example_hmc_nuts": {
            "name": "test_inference_example_hmc_nuts",
            "location": 26,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "keanu-master/docs/src/test/python/test_save_load.py": {
        "test_can_save_and_load": {
            "name": "test_can_save_and_load",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "dict"
                ]
            }
        }
    },
    "keanu-master/docs/src/test/python/test_tensors.py": {
        "test_tensor_example_creation": {
            "name": "test_tensor_example_creation",
            "location": 5,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "keanu-master/docs/src/test/python/test_thermometers.py": {
        "test_thermometers_example": {
            "name": "test_thermometers_example",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-project/src/test/resources/model.py": {},
    "keanu-master/keanu-python/setup.py": {
        "readme": {
            "name": "readme",
            "location": 6,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/docs/conf.py": {},
    "keanu-master/keanu-python/docs/remove_underscores.py": {},
    "keanu-master/keanu-python/examples/coal_mining.py": {
        "CoalMining.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CoalMining.model": {
            "name": "model",
            "location": 15,
            "return": [
                "Callable",
                "Optional[str]",
                "Type"
            ],
            "arguments": {
                "self": []
            }
        },
        "CoalMining.training_data": {
            "name": "training_data",
            "location": 30,
            "return": [
                "dict",
                "Dict[str, Any]",
                "List['PydanticModelField']",
                "str",
                "int",
                "Dict[str, numpy.ndarray]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/examples/lorenz_model.py": {
        "LorenzModel.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sigma": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "beta": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "rho": [
                    "int",
                    "float",
                    "Union[str, float]"
                ],
                "time_step": [
                    "int",
                    "float",
                    "Union[str, float]"
                ]
            }
        },
        "LorenzModel.run_model": {
            "name": "run_model",
            "location": 15,
            "return": [
                "typing.Generator[Coordinates, None, None]"
            ],
            "arguments": {
                "self": [],
                "num_time_steps": [
                    "int",
                    "float"
                ]
            }
        },
        "LorenzModel.__get_next_position": {
            "name": "__get_next_position",
            "location": 22,
            "return": [
                "bool",
                "str",
                "int",
                "Hashable",
                "type",
                "Callable[[KT], VT]"
            ],
            "arguments": {
                "self": [],
                "current": [
                    "List[List[int]]",
                    "Tuple[float, float]",
                    "List[int]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/examples/thermometers.py": {
        "model": {
            "name": "model",
            "location": 5,
            "return": [
                "Callable",
                "Optional[str]",
                "Type"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/examples/__init__.py": {},
    "keanu-master/keanu-python/keanu/base.py": {
        "JavaObjectWrapper.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "val": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "JavaObjectWrapper.__repr__": {
            "name": "__repr__",
            "location": 11,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "JavaObjectWrapper.__getattr__": {
            "name": "__getattr__",
            "location": 14,
            "return": [
                "typing.Callable"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "str",
                    "Optional[str]",
                    "int",
                    "float"
                ]
            }
        },
        "JavaObjectWrapper.__check_if_constructed_without_error": {
            "name": "__check_if_constructed_without_error",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "str",
                    "bool",
                    "bytes",
                    "int",
                    "Sequence[str]"
                ]
            }
        },
        "JavaObjectWrapper.__check_if_unwrapped": {
            "name": "__check_if_unwrapped",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "str",
                    "KT",
                    "int"
                ]
            }
        },
        "JavaObjectWrapper.unwrap": {
            "name": "unwrap",
            "location": 31,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/context.py": {
        "Singleton.__call__": {
            "name": "__call__",
            "location": 20,
            "return": [],
            "arguments": {
                "cls": [
                    "type",
                    "Set[str]",
                    "str"
                ]
            }
        },
        "KeanuContext.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KeanuContext.__build_classpath": {
            "name": "__build_classpath",
            "location": 41,
            "return": [
                "str",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "KeanuContext.__stderr_with_redirect_disabled_for_jupyter": {
            "name": "__stderr_with_redirect_disabled_for_jupyter",
            "location": 46,
            "return": [
                "Optional[str]",
                "Optional[int]",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "KeanuContext.__get_random_port_for_callback_server": {
            "name": "__get_random_port_for_callback_server",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KeanuContext.jvm_view": {
            "name": "jvm_view",
            "location": 61,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "KeanuContext.to_java_map": {
            "name": "to_java_map",
            "location": 64,
            "return": [
                "float",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "python_map": [
                    "dict",
                    "Dict[Tuple[int, ...], float]"
                ]
            }
        },
        "KeanuContext.to_java_object_list": {
            "name": "to_java_object_list",
            "location": 82,
            "return": [
                "IO[str]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "bool",
                    "int"
                ]
            }
        },
        "KeanuContext.to_java_object_set": {
            "name": "to_java_object_set",
            "location": 95,
            "return": [
                "Set[str]",
                "set",
                "Callable[..., None]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "bool",
                    "List[T]",
                    "List[str]"
                ]
            }
        },
        "KeanuContext.to_java_array": {
            "name": "to_java_array",
            "location": 103,
            "return": [
                "float",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "float",
                    "\"Lattice\"",
                    "bool",
                    "str"
                ],
                "klass": [
                    "Sequence[str]",
                    "Optional[Tuple]",
                    "Optional[str]"
                ]
            }
        },
        "KeanuContext.to_java_long_array": {
            "name": "to_java_long_array",
            "location": 113,
            "return": [
                "int",
                "dict",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "KeanuContext.to_java_int_array": {
            "name": "to_java_int_array",
            "location": 116,
            "return": [
                "int",
                "dict",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "KeanuContext.to_java_boolean_array": {
            "name": "to_java_boolean_array",
            "location": 119,
            "return": [
                "int",
                "dict",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "KeanuContext.to_java_string_array": {
            "name": "to_java_string_array",
            "location": 122,
            "return": [
                "BaseException",
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "int",
                    "str"
                ]
            }
        },
        "KeanuContext.to_java_vertex_array": {
            "name": "to_java_vertex_array",
            "location": 125,
            "return": [
                "int",
                "dict",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "KeanuContext.__infer_class_from_array": {
            "name": "__infer_class_from_array",
            "location": 129,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "l": [
                    "List[List[str]]",
                    "int",
                    "Set[str]",
                    "List[str]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/description_creator.py": {
        "create_description": {
            "name": "create_description",
            "location": 13,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "vertex": [
                    "str"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/infer_type.py": {
        "infer_type_and_execute": {
            "name": "infer_type_and_execute",
            "location": 11,
            "return": [
                "Callable",
                "Optional[str]",
                "Type[Any]"
            ],
            "arguments": {
                "value": [
                    "Dict[type, Callable]",
                    "keanu.vartypes.tensor_arg_types",
                    "type",
                    "str",
                    "bytes"
                ],
                "actions": [
                    "Dict[type, Callable]",
                    "keanu.vartypes.tensor_arg_types",
                    "type",
                    "str",
                    "bytes"
                ]
            }
        },
        "get_type_of_value": {
            "name": "get_type_of_value",
            "location": 15,
            "return": [
                "Iterable[str]",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "t": [
                    "Type",
                    "Callable"
                ]
            }
        },
        "__infer_type_from_ndarray": {
            "name": "__infer_type_from_ndarray",
            "location": 30,
            "return": [
                "bool"
            ],
            "arguments": {
                "ndarray": [
                    "keanu.vartypes.numpy_types",
                    "Optional[numpy.ndarray]",
                    "dict",
                    "numpy.ndarray",
                    "Union[int, float]"
                ]
            }
        },
        "__infer_type_from_scalar": {
            "name": "__infer_type_from_scalar",
            "location": 41,
            "return": [
                "bool"
            ],
            "arguments": {
                "scalar": [
                    "keanu.vartypes.primitive_types",
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/java_exception.py": {
        "JavaException.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "e": [
                    "str",
                    "Exception"
                ]
            }
        },
        "JavaException.get_class": {
            "name": "get_class",
            "location": 11,
            "return": [
                "str",
                "dict",
                "List[\"Source\"]"
            ],
            "arguments": {
                "self": []
            }
        },
        "JavaException.get_message": {
            "name": "get_message",
            "location": 14,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "JavaException.__repr__": {
            "name": "__repr__",
            "location": 17,
            "return": [
                "str",
                "Union[str, List[str]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/keanu_random.py": {
        "set_deterministic_state": {
            "name": "set_deterministic_state",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "KeanuRandom.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "Optional[str]",
                    "float",
                    "bool"
                ]
            }
        },
        "KeanuRandom.next_double": {
            "name": "next_double",
            "location": 20,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "KeanuRandom.set_default_random_seed": {
            "name": "set_default_random_seed",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "int",
                    "Union[int, float]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/model.py": {
        "Model.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "bytes",
                    "dict",
                    "int",
                    "Dict[str, Dict[str, str]]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "Model.to_bayes_net": {
            "name": "to_bayes_net",
            "location": 12,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.__setattr__": {
            "name": "__setattr__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "dict",
                    "str",
                    "\"QuerySet[MODEL]\"",
                    "int"
                ],
                "v": [
                    "dict",
                    "models.base.Model"
                ]
            }
        },
        "Model.__getattr__": {
            "name": "__getattr__",
            "location": 23,
            "return": [
                "bool",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "dict",
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "Model.__enter__": {
            "name": "__enter__",
            "location": 28,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.__exit__": {
            "name": "__exit__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/net.py": {
        "BayesNet.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "float",
                    "int",
                    "dict"
                ]
            }
        },
        "BayesNet.iter_latent_or_observed_vertices": {
            "name": "iter_latent_or_observed_vertices",
            "location": 23,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BayesNet.iter_latent_vertices": {
            "name": "iter_latent_vertices",
            "location": 26,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BayesNet.iter_observed_vertices": {
            "name": "iter_observed_vertices",
            "location": 29,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BayesNet.iter_continuous_latent_vertices": {
            "name": "iter_continuous_latent_vertices",
            "location": 32,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BayesNet.iter_discrete_latent_vertices": {
            "name": "iter_discrete_latent_vertices",
            "location": 35,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BayesNet.iter_all_vertices": {
            "name": "iter_all_vertices",
            "location": 38,
            "return": [
                "str",
                "bool",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BayesNet.probe_for_non_zero_probability": {
            "name": "probe_for_non_zero_probability",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "attempts": [
                    "bool",
                    "str"
                ],
                "random": [
                    "bool",
                    "str"
                ]
            }
        },
        "BayesNet.get_vertex_by_label": {
            "name": "get_vertex_by_label",
            "location": 44,
            "return": [
                "int",
                "List[str]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bytes",
                    "int"
                ]
            }
        },
        "ProbabilisticModel.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "net": [
                    "str"
                ]
            }
        },
        "ProbabilisticModelWithGradient.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "net": [
                    "int",
                    "Optional[str]",
                    "str",
                    "bool"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/network_io.py": {
        "NetworkSaver.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "saver_object": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ]
            }
        },
        "NetworkSaver.save": {
            "name": "save",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str",
                    "Callable",
                    "bool"
                ],
                "save_values": [
                    "str",
                    "dict"
                ],
                "metadata": [
                    "Optional[Dict[str, str]]",
                    "Type[T]",
                    "planetsclub.users.base.BaseUser",
                    "golem_messages.message.base.Message"
                ]
            }
        },
        "ProtobufSaver.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "net": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "DotSaver.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "net_or_vertices": [
                    "Callable"
                ]
            }
        },
        "JsonSaver.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "net": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "MIRSaver.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "net": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "NetworkLoader.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "loader_object": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ]
            }
        },
        "NetworkLoader.load": {
            "name": "load",
            "location": 72,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ProtobufLoader.__init__": {
            "name": "__init__",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "JsonLoader.__init__": {
            "name": "__init__",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MIRLoader.__init__": {
            "name": "__init__",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/sequence.py": {
        "SequenceItem.add": {
            "name": "add",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "str",
                    "Sequence[Sequence[str]]",
                    "Sequence[str]",
                    "Union[str, Callable[[], str]]",
                    "Dict[\"core.Edge\", \"state.State\"]",
                    "int"
                ],
                "label": [
                    "Union[str, Callable[[], str]]"
                ]
            }
        },
        "SequenceItem.get": {
            "name": "get",
            "location": 35,
            "return": [
                "int",
                "bool",
                "List[str]",
                "Set[int]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str"
                ]
            }
        },
        "SequenceItem.get_contents": {
            "name": "get_contents",
            "location": 38,
            "return": [
                "str",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceItem.add_double_proxy_for": {
            "name": "add_double_proxy_for",
            "location": 50,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bytes",
                    "IO",
                    "float",
                    "Callable"
                ],
                "shape": [
                    "str",
                    "Optional[Dict[str, str]]",
                    "Sequence[float]",
                    "Optional[Tuple[float, float]]",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "SequenceItem.add_integer_proxy_for": {
            "name": "add_integer_proxy_for",
            "location": 59,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bytes",
                    "IO",
                    "float",
                    "Callable"
                ],
                "shape": [
                    "str",
                    "Optional[Dict[str, str]]",
                    "Sequence[float]",
                    "Optional[Tuple[float, float]]",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "SequenceItem.add_boolean_proxy_for": {
            "name": "add_boolean_proxy_for",
            "location": 68,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bytes",
                    "IO",
                    "float",
                    "Callable"
                ],
                "shape": [
                    "str",
                    "Optional[Dict[str, str]]",
                    "Sequence[float]",
                    "Optional[Tuple[float, float]]",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "Sequence.__init__": {
            "name": "__init__",
            "location": 91,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "factories": [
                    "Optional[Any]",
                    "Optional[dict]",
                    "int",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Optional[str]"
                ],
                "count": [
                    "int",
                    "Optional[str]",
                    "Optional[float]",
                    "Optional[dict]"
                ],
                "name": [
                    "str",
                    "Optional[Mapping[str, str]]",
                    "list"
                ],
                "data_generator": [
                    "str",
                    "float",
                    "Optional[Callable[[str], bool]]",
                    "Optional[str]",
                    "Optional[List[str]]",
                    "Optional[float]"
                ],
                "initial_state": [
                    "Optional[float]",
                    "Optional[bool]",
                    "Optional[str]",
                    "Optional[Dict[str, str]]",
                    "int"
                ]
            }
        },
        "Sequence.__iter__": {
            "name": "__iter__",
            "location": 131,
            "return": [
                "typing.Generator[SequenceItem, None, None]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Sequence.size": {
            "name": "size",
            "location": 136,
            "return": [
                "Callable[[T], List[T]]",
                "str",
                "Set[str]",
                "List[float]",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "Sequence.get_last_item": {
            "name": "get_last_item",
            "location": 139,
            "return": [
                "str",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Sequence.to_bayes_net": {
            "name": "to_bayes_net",
            "location": 142,
            "return": [
                "float",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Sequence.proxy_label_for": {
            "name": "proxy_label_for",
            "location": 150,
            "return": [
                "str"
            ],
            "arguments": {
                "label": [
                    "str",
                    "Awaitable[Any]",
                    "Dict[object, Dict[str, Any]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "SequenceItem.get_contents.get_unqualified_name_or_proxy_name": {
            "name": "get_unqualified_name_or_proxy_name",
            "location": 40,
            "return": [
                "Optional[str]",
                "bool",
                "str"
            ],
            "arguments": {
                "key": [
                    "str"
                ],
                "vertex": [
                    "str",
                    "int",
                    "Hashable",
                    "Union[str, int]",
                    "Tuple[int, int]",
                    "Set[int]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/shape_validation.py": {
        "check_index_is_valid": {
            "name": "check_index_is_valid",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {
                "shape": [
                    "int",
                    "List[int]"
                ],
                "index": [
                    "int",
                    "List[int]"
                ]
            }
        },
        "check_all_shapes_match": {
            "name": "check_all_shapes_match",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "shapes": [
                    "Set[str]",
                    "str",
                    "dict",
                    "List[int]",
                    "list"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/stats.py": {
        "autocorrelation": {
            "name": "autocorrelation",
            "location": 15,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "arg": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "Hashable"
                ]
            }
        },
        "check_all_floats": {
            "name": "check_all_floats",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "arg": [
                    "bool",
                    "Awaitable[T]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/tensor.py": {
        "Tensor.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "int",
                    "str",
                    "Set[str]"
                ]
            }
        },
        "Tensor.is_scalar": {
            "name": "is_scalar",
            "location": 32,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Tensor.scalar": {
            "name": "scalar",
            "location": 35,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Tensor.apply": {
            "name": "apply",
            "location": 38,
            "return": [
                "Sequence['cirq.Qid']",
                "tuple",
                "bool"
            ],
            "arguments": {
                "self": [],
                "lambda_function": [
                    "Callable"
                ]
            }
        },
        "Tensor.get_tensor_type": {
            "name": "get_tensor_type",
            "location": 41,
            "return": [
                "str",
                "Optional[Dict[str, str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Tensor.__get_tensor_from_ndarray": {
            "name": "__get_tensor_from_ndarray",
            "location": 50,
            "return": [
                "Type[T]",
                "Iterable[numpy.dtype]",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "ndarray": [
                    "vartypes.numpy_types",
                    "str",
                    "Any"
                ]
            }
        },
        "Tensor.__get_java_array_from_ndarray": {
            "name": "__get_java_array_from_ndarray",
            "location": 59,
            "return": [
                "bool",
                "List[dict]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "ndarray": [
                    "vartypes.numpy_types",
                    "bytes",
                    "dict",
                    "str",
                    "golem_messages.message.base.Message",
                    "int"
                ]
            }
        },
        "Tensor.__infer_tensor_ctor_from_ndarray": {
            "name": "__infer_tensor_ctor_from_ndarray",
            "location": 77,
            "return": [
                "numpy.array",
                "bool",
                "str",
                "Optional[float]",
                "float"
            ],
            "arguments": {
                "ndarray": [
                    "vartypes.numpy_types",
                    "numpy.ndarray",
                    "Optional[list]",
                    "int"
                ]
            }
        },
        "Tensor.__get_tensor_from_scalar": {
            "name": "__get_tensor_from_scalar",
            "location": 89,
            "return": [
                "bool",
                "str",
                "List[dict]",
                "List[Dict[str, Any]]",
                "Set[str]"
            ],
            "arguments": {
                "scalar": [
                    "str",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "Tensor._to_ndarray": {
            "name": "_to_ndarray",
            "location": 100,
            "return": [
                "Optional[bool]",
                "Optional[int]",
                "dict",
                "str"
            ],
            "arguments": {
                "java_tensor": [
                    "py4j.java_gateway.JavaObject",
                    "str"
                ]
            }
        },
        "Tensor.__get_ndarray_from_tensor": {
            "name": "__get_ndarray_from_tensor",
            "location": 107,
            "return": [
                "dict",
                "str",
                "numpy.ndarray",
                "int"
            ],
            "arguments": {
                "java_tensor": [
                    "Optional[bytes]",
                    "Union[int, str]",
                    "List[Tuple[int, bytes]]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vartypes.py": {},
    "keanu-master/keanu-python/keanu/__init__.py": {},
    "keanu-master/keanu-python/keanu/__version__.py": {},
    "keanu-master/keanu-python/keanu/algorithm/optimization.py": {
        "relative": {
            "name": "relative",
            "location": 40,
            "return": [
                "bool",
                "str",
                "Optional[str]",
                "List[str]",
                "Optional[float]"
            ],
            "arguments": {
                "norm": [
                    "str",
                    "float",
                    "int"
                ],
                "tolerance": [
                    "str",
                    "float",
                    "int"
                ]
            }
        },
        "absolute": {
            "name": "absolute",
            "location": 44,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "norm": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "tolerance": [
                    "float",
                    "str",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "_OptimizedResult.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "result_object": [
                    "py4j.java_gateway.JavaObject",
                    "List[str]",
                    "Sequence[str]",
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "_OptimizedResult.fitness": {
            "name": "fitness",
            "location": 30,
            "return": [
                "bool",
                "Optional[Any]",
                "str",
                "Callable[..., None]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OptimizedResult.value_for": {
            "name": "value_for",
            "location": 33,
            "return": [
                "Union[int, float, complex]",
                "Dict[str, int]",
                "int",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "str",
                    "Callable",
                    "Dict[str, Any]"
                ]
            }
        },
        "ConvergenceChecker.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "difference": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ],
                "norm": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ],
                "tolerance": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ]
            }
        },
        "Optimizer.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "int",
                    "bool",
                    "float"
                ],
                "net": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Optimizer.max_a_posteriori": {
            "name": "max_a_posteriori",
            "location": 75,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Optimizer.max_likelihood": {
            "name": "max_likelihood",
            "location": 78,
            "return": [
                "List[int]",
                "Dict[str, int]",
                "List[dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Optimizer._build_bayes_net": {
            "name": "_build_bayes_net",
            "location": 82,
            "return": [
                "Type[T]",
                "Callable[..., None]",
                "Optional[str]"
            ],
            "arguments": {
                "factory_class": [
                    "List[str]",
                    "Type[T]",
                    "str"
                ],
                "net": [
                    "Union[keanu.neBayesNet, keanu.vertex.base.Vertex]",
                    "str",
                    "bool"
                ]
            }
        },
        "GradientOptimizer.__init__": {
            "name": "__init__",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "net": [
                    "Union[keanu.neBayesNet, keanu.vertex.base.Vertex]",
                    "dict",
                    "bool",
                    "tensorflow.Tensor",
                    "cmk.base.events.EventContext"
                ],
                "algorithm": [
                    "Optional[float]",
                    "Optional[bool]",
                    "torch.Tensor"
                ]
            }
        },
        "ConjugateGradient.__init__": {
            "name": "__init__",
            "location": 105,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_evaluations": [
                    "Optional[int]",
                    "bytes",
                    "Union[str, int]",
                    "Optional[str]",
                    "int"
                ],
                "relative_threshold": [
                    "Optional[float]",
                    "bool",
                    "int",
                    "Optional[bool]",
                    "Optional[Any]",
                    "Optional[List[str]]",
                    "Optional[str]"
                ],
                "absolute_threshold": [
                    "Optional[float]",
                    "bool",
                    "int",
                    "Optional[bool]",
                    "Optional[Any]",
                    "Optional[List[str]]",
                    "Optional[str]"
                ]
            }
        },
        "Adam.__init__": {
            "name": "__init__",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_evaluations": [
                    "Optional[int]",
                    "int",
                    "Optional[str]"
                ],
                "alpha": [
                    "Optional[float]",
                    "Optional[bool]",
                    "torch.Tensor"
                ],
                "beta1": [
                    "Optional[float]",
                    "Optional[bool]",
                    "torch.Tensor"
                ],
                "beta2": [
                    "Optional[float]",
                    "Optional[bool]",
                    "torch.Tensor"
                ],
                "epsilon": [
                    "Optional[float]",
                    "Optional[bool]",
                    "torch.Tensor"
                ],
                "convergence_checker": [
                    "Optional[float]",
                    "Optional[bool]",
                    "Optional[int]"
                ]
            }
        },
        "NonGradientOptimizer.__init__": {
            "name": "__init__",
            "location": 152,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "net": [
                    "Union[keanu.neBayesNet, keanu.vertex.base.Vertex]",
                    "dict",
                    "bool",
                    "tensorflow.Tensor",
                    "Optional[str]"
                ],
                "algorithm": [
                    "Optional[float]",
                    "Optional[bool]",
                    "torch.Tensor"
                ]
            }
        },
        "BOBYQA.__init__": {
            "name": "__init__",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_evaluations": [
                    "Optional[int]",
                    "int"
                ],
                "bounds_range": [
                    "Optional[float]",
                    "bool",
                    "Optional[Type[Any]]",
                    "Optional[List]",
                    "Optional[Tuple[float, float]]"
                ],
                "initial_trust_region_radius": [
                    "Optional[float]",
                    "Optional[int]",
                    "Union[None, float, int]",
                    "Optional[gluonts.model.common.Tensor]",
                    "Optional[List[int]]",
                    "Optional[str]"
                ],
                "stopping_trust_region_radius": [
                    "Optional[float]",
                    "Optional[int]",
                    "Union[None, float, int]",
                    "Optional[gluonts.model.common.Tensor]",
                    "Optional[List[int]]",
                    "Optional[str]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/algorithm/proposal_listeners.py": {
        "AcceptanceRateTracker.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AcceptanceRateTracker.get_acceptance_rate": {
            "name": "get_acceptance_rate",
            "location": 21,
            "return": [
                "str",
                "Callable",
                "Dict[str, Dict[str, Any]]",
                "bytes",
                "Optional[List[str]]",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "str"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/algorithm/sampling.py": {
        "sample": {
            "name": "sample",
            "location": 130,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "net": [
                    "int",
                    "str"
                ],
                "sample_from": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[int]",
                    "Tuple[numpy.ndarray, numpy.ndarray]"
                ],
                "sampling_algorithm": [
                    "numpy.ndarray",
                    "str",
                    "bool",
                    "Sequence[str]",
                    "Optional[base.MinimizationAttack]"
                ],
                "draws": [
                    "str",
                    "bool",
                    "alerta.database.base.Query"
                ],
                "drop": [
                    "str",
                    "bool",
                    "alerta.database.base.Query"
                ],
                "down_sample_interval": [
                    "str",
                    "bool",
                    "alerta.database.base.Query"
                ],
                "plot": [
                    "bool",
                    "list"
                ],
                "ax": [
                    "bool",
                    "int",
                    "str",
                    "List[int]",
                    "bytes"
                ]
            }
        },
        "generate_samples": {
            "name": "generate_samples",
            "location": 188,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "net": [
                    "int",
                    "Callable",
                    "Optional[Any]",
                    "Dict[int, Dict[int, Any]]",
                    "Dict[str, Any]",
                    "Dict[int, dict]"
                ],
                "sample_from": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[int]",
                    "Tuple[numpy.ndarray, numpy.ndarray]"
                ],
                "sampling_algorithm": [
                    "numpy.ndarray",
                    "str",
                    "bool",
                    "Sequence[str]",
                    "Optional[base.MinimizationAttack]"
                ],
                "drop": [
                    "int",
                    "Set[Tuple[str, ...]]",
                    "float",
                    "torch.Tensor",
                    "Sequence[str]"
                ],
                "down_sample_interval": [
                    "int",
                    "Set[Tuple[str, ...]]",
                    "float",
                    "torch.Tensor",
                    "Sequence[str]"
                ],
                "live_plot": [
                    "Dict[str, Any]",
                    "bool",
                    "Optional[int]"
                ],
                "refresh_every": [
                    "Dict[str, Any]",
                    "bool",
                    "Optional[int]"
                ],
                "ax": [
                    "Dict[str, Any]",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "__all_scalar": {
            "name": "__all_scalar",
            "location": 245,
            "return": [
                "bool",
                "str",
                "Hashable"
            ],
            "arguments": {
                "sample_from": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "gluonts.model.common.Tensor"
                ]
            }
        },
        "_samples_generator": {
            "name": "_samples_generator",
            "location": 249,
            "return": [
                "keanu.vartypes.sample_generator_types"
            ],
            "arguments": {
                "sample_iterator": [
                    "Optional[Collection[int]]",
                    "int",
                    "bool"
                ],
                "vertices_unwrapped": [
                    "int",
                    "numpy.ndarray"
                ],
                "live_plot": [
                    "str",
                    "bool",
                    "Set[str]",
                    "Optional[List[str]]",
                    "list"
                ],
                "refresh_every": [
                    "int",
                    "float",
                    "bool",
                    "numpy.random.RandomState"
                ],
                "ax": [
                    "float",
                    "int",
                    "torch.Tensor",
                    "List[torch.Tensor]"
                ],
                "all_scalar": [
                    "str",
                    "bool",
                    "Set[str]",
                    "Optional[List[str]]",
                    "list"
                ],
                "id_to_label": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "__check_if_vertices_are_labelled": {
            "name": "__check_if_vertices_are_labelled",
            "location": 278,
            "return": [
                "bool",
                "Dict[str, Any]",
                "Dict[str, int]",
                "Union[int, float, complex]"
            ],
            "arguments": {
                "vertices": [
                    "Dict[str, Any]",
                    "str",
                    "Callable[[], object]",
                    "bool"
                ]
            }
        },
        "__create_single_indexed_samples": {
            "name": "__create_single_indexed_samples",
            "location": 289,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "network_samples": [
                    "str",
                    "Dict[str, Any]"
                ],
                "vertices_unwrapped": [
                    "str",
                    "list",
                    "int",
                    "List[dict]",
                    "float"
                ],
                "id_to_label": [
                    "bool",
                    "eth.chains.base.MiningChain",
                    "bytes",
                    "Sequence[str]",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "__create_multi_indexed_samples": {
            "name": "__create_multi_indexed_samples",
            "location": 299,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "vertices_unwrapped": [
                    "str",
                    "list",
                    "int",
                    "List[dict]",
                    "float"
                ],
                "network_samples": [
                    "str",
                    "Dict[str, Any]"
                ],
                "id_to_label": [
                    "bool",
                    "eth.chains.base.MiningChain",
                    "bytes",
                    "Sequence[str]",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "__create_multi_indexed_samples_generated": {
            "name": "__create_multi_indexed_samples_generated",
            "location": 316,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "vertices_unwrapped": [
                    "str",
                    "list",
                    "int",
                    "List[dict]",
                    "float"
                ],
                "network_samples": [
                    "Dict[str, int]",
                    "int",
                    "bytes",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "Optional[Callable]"
                ],
                "id_to_label": [
                    "bool",
                    "eth.chains.base.MiningChain",
                    "bytes",
                    "Sequence[str]",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "__add_sample_to_dict": {
            "name": "__add_sample_to_dict",
            "location": 332,
            "return": [
                ""
            ],
            "arguments": {
                "sample_value": [
                    "str",
                    "dict",
                    "list",
                    "float",
                    "bool",
                    "Match"
                ],
                "vertex_sample": [
                    "Dict[str, bool]",
                    "list"
                ]
            }
        },
        "__get_vertex_samples": {
            "name": "__get_vertex_samples",
            "location": 340,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "network_samples": [
                    "int",
                    "dict"
                ],
                "vertex": [
                    "int",
                    "dict"
                ]
            }
        },
        "PosteriorSamplingAlgorithm.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "sampler": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "PosteriorSamplingAlgorithm.get_sampler": {
            "name": "get_sampler",
            "location": 31,
            "return": [
                "str",
                "bool",
                "Vertex",
                "eagerpy.Tensor"
            ],
            "arguments": {
                "self": []
            }
        },
        "ForwardSampler.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetropolisHastingsSampler.__init__": {
            "name": "__init__",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "proposal_distribution": [
                    "Optional[int]",
                    "tuple",
                    "Optional[str]"
                ],
                "latents": [
                    "str",
                    "dict"
                ],
                "proposal_listeners": [
                    "Optional[int]",
                    "tuple",
                    "Optional[str]"
                ],
                "proposal_distribution_sigma": [
                    "str"
                ]
            }
        },
        "NUTSSampler.__init__": {
            "name": "__init__",
            "location": 91,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "adapt_count": [
                    "Optional[int]",
                    "Union[int, None]",
                    "Optional[float]"
                ],
                "adapt_step_size_enabled": [
                    "Optional[float]",
                    "Optional[List[int]]",
                    "Optional[numpy.ndarray]",
                    "Optional[int]"
                ],
                "adapt_potential_enabled": [
                    "Optional[float]",
                    "Optional[str]",
                    "Optional[numpy.ndarray]",
                    "bool",
                    "Tuple[numpy.dtype]",
                    "Optional[base.MinimizationAttack]"
                ],
                "target_acceptance_prob": [
                    "bool",
                    "Optional[dict]",
                    "List[str]",
                    "Optional[List[str]]"
                ],
                "initial_step_size": [
                    "int",
                    "Union[float, int]",
                    "bool",
                    "Optional[float]",
                    "List[float]",
                    "tuple"
                ],
                "potential_adapt_window_size": [
                    "Optional[int]",
                    "int",
                    "Optional[float]",
                    "Optional[numpy.ndarray]"
                ],
                "max_energy_change": [
                    "int",
                    "Optional[int]",
                    "str",
                    "Union[None, int]"
                ],
                "max_tree_height": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]",
                    "List[int]",
                    "Optional[numpy.ndarray]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/algorithm/_proposal_distribution.py": {
        "ProposalDistribution.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "type_": [
                    "Type",
                    "bool",
                    "str",
                    "BaseException",
                    "Exception",
                    "Type[BaseException]",
                    "type"
                ],
                "latents": [
                    "Optional[Sequence[str]]",
                    "Iterable[str]",
                    "Sequence[str]",
                    "List[Dict]",
                    "str"
                ],
                "sigma": [],
                "listeners": [
                    "str",
                    "Callable",
                    "List[Dict[str, str]]",
                    "Optional[List[str]]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/algorithm/__init__.py": {},
    "keanu-master/keanu-python/keanu/functional/biconsumer.py": {
        "BiConsumer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lambda_function": [
                    "str",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "BiConsumer.accept": {
            "name": "accept",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "arg1": [
                    "int"
                ],
                "arg2": [
                    "int"
                ]
            }
        },
        "BiConsumer.hashCode": {
            "name": "hashCode",
            "location": 21,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/functional/consumer.py": {
        "Consumer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lambda_function": [
                    "str",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "Consumer.accept": {
            "name": "accept",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "arg": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Consumer.hashCode": {
            "name": "hashCode",
            "location": 21,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/functional/function.py": {
        "Function.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lambda_function": [
                    "str",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "Function.apply": {
            "name": "apply",
            "location": 11,
            "return": [
                "Sequence['cirq.Qid']",
                "bool"
            ],
            "arguments": {
                "self": [],
                "arg": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/functional/hash_shortener.py": {
        "shorten_hash": {
            "name": "shorten_hash",
            "location": 1,
            "return": [
                "dict",
                "Dict[str, Any]",
                "Mapping[str, Any]",
                "str"
            ],
            "arguments": {
                "original_hash": [
                    "int",
                    "Dict[str, int]",
                    "List[list]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/functional/iterator.py": {
        "JavaIterator.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "python_iterator": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "JavaIterator.next": {
            "name": "next",
            "location": 17,
            "return": [
                "Optional[bool]",
                "Optional[int]",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "JavaIterator.hasNext": {
            "name": "hasNext",
            "location": 25,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/functional/supplier.py": {
        "Supplier.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "lambda_function": [
                    "str",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "Supplier.get": {
            "name": "get",
            "location": 11,
            "return": [
                "str",
                "Sequence['cirq.Qid']"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/keanu/functional/__init__.py": {},
    "keanu-master/keanu-python/keanu/plots/autocorrelation.py": {
        "__create_new_mpl": {
            "name": "__create_new_mpl",
            "location": 11,
            "return": [
                "int",
                "str"
            ],
            "arguments": {}
        },
        "__plot_corr": {
            "name": "__plot_corr",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "ax": [
                    "str",
                    "bool"
                ],
                "acf_x": [
                    "int",
                    "Dict[int, Tuple[int, int]]",
                    "str"
                ],
                "nlags": [
                    "int",
                    "Dict[int, Tuple[int, int]]",
                    "str"
                ]
            }
        },
        "__calc_max_lag": {
            "name": "__calc_max_lag",
            "location": 30,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "data_len": [
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "plot_acf": {
            "name": "plot_acf",
            "location": 35,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "str",
                    "bytes"
                ],
                "nlags": [
                    "dict",
                    "int",
                    "Sequence[T]",
                    "list"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/plots/traceplot.py": {
        "traceplot": {
            "name": "traceplot",
            "location": 12,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "trace": [
                    "Sequence[Sequence[str]]",
                    "Sequence[str]",
                    "int",
                    "Optional[Tuple[int, ...]]",
                    "Dict[\"core.Edge\", \"state.State\"]"
                ],
                "labels": [
                    "numpy.array",
                    "List[List[str]]",
                    "numpy.ndarray",
                    "Tuple[numpy.ndarray, numpy.ndarray]"
                ],
                "ax": [
                    "Tuple[numpy.ndarray, numpy.ndarray]",
                    "Optional[Any]",
                    "bool",
                    "List[List[str]]",
                    "numpy.ndarray",
                    "numpy.array"
                ],
                "x0": [
                    "int",
                    "OrderedDict",
                    "List[list]",
                    "List[int]",
                    "Optional[List[str]]",
                    "Dict[int, str]",
                    "Union[int, str]",
                    "List[List[Any]]"
                ]
            }
        },
        "__integer_xaxis": {
            "name": "__integer_xaxis",
            "location": 40,
            "return": [
                "str"
            ],
            "arguments": {
                "ax": [
                    "int",
                    "float",
                    "dict",
                    "str"
                ],
                "x0": [
                    "float",
                    "bool",
                    "Iterable[float]"
                ],
                "n": [
                    "float",
                    "bool",
                    "Iterable[float]"
                ]
            }
        },
        "__pause_for_crude_animation": {
            "name": "__pause_for_crude_animation",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/keanu/plots/__init__.py": {},
    "keanu-master/keanu-python/keanu/vertex/base.py": {
        "__cast_to": {
            "name": "__cast_to",
            "location": 370,
            "return": [
                "str",
                "Literal"
            ],
            "arguments": {
                "arg": [
                    "keanu.vartypes.tensor_arg_types",
                    "float",
                    "str"
                ],
                "cast_to_type": [
                    "type",
                    "Set[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "Type[T]",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "cast_tensor_arg_to_double": {
            "name": "cast_tensor_arg_to_double",
            "location": 381,
            "return": [
                "eth.chains.base.MiningChain",
                "Dict[str, Any]"
            ],
            "arguments": {
                "arg": [
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "cast_tensor_arg_to_integer": {
            "name": "cast_tensor_arg_to_integer",
            "location": 385,
            "return": [
                "eth.chains.base.MiningChain",
                "Dict[str, Any]"
            ],
            "arguments": {
                "arg": [
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "cast_tensor_arg_to_boolean": {
            "name": "cast_tensor_arg_to_boolean",
            "location": 389,
            "return": [
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "arg": [
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "is_floating_type": {
            "name": "is_floating_type",
            "location": 393,
            "return": [
                "str",
                "Optional[str]",
                "keanu.vartypes.primitive_types"
            ],
            "arguments": {
                "other": [
                    "Type",
                    "numpy.array",
                    "bool"
                ]
            }
        },
        "cast_to_double_vertex_if_integer_vertex": {
            "name": "cast_to_double_vertex_if_integer_vertex",
            "location": 400,
            "return": [
                "str",
                "numpy.ndarray",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "vertex": [
                    "str",
                    "int"
                ]
            }
        },
        "Vertex.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "val_or_ctor": [
                    "str"
                ],
                "label": [
                    "Optional[str]",
                    "List[str]",
                    "Optional[Tuple[numpy.ndarray, numpy.ndarray]]",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "Vertex.cast": {
            "name": "cast",
            "location": 38,
            "return": [
                "str",
                "bool",
                "Tuple[str]",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "int",
                    "bytes",
                    "str",
                    "bool",
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "Vertex.__bool__": {
            "name": "__bool__",
            "location": 41,
            "return": [
                "builtins.bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.__hash__": {
            "name": "__hash__",
            "location": 46,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.observe": {
            "name": "observe",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "int",
                    "list",
                    "str",
                    "Optional[float]"
                ]
            }
        },
        "Vertex.unobserve": {
            "name": "unobserve",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.set_value": {
            "name": "set_value",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "str",
                    "bool",
                    "Callable"
                ]
            }
        },
        "Vertex.set_and_cascade": {
            "name": "set_and_cascade",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "int",
                    "bool",
                    "Union[str, int, float]"
                ]
            }
        },
        "Vertex.set_label": {
            "name": "set_label",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "Optional[str]",
                    "str",
                    "Optional[Sequence[str]]",
                    "bytes",
                    "Union[str, None]"
                ]
            }
        },
        "Vertex.sample": {
            "name": "sample",
            "location": 66,
            "return": [
                "eth.chains.base.MiningChain"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.get_value": {
            "name": "get_value",
            "location": 69,
            "return": [
                "bool",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.iter_connected_graph": {
            "name": "iter_connected_graph",
            "location": 72,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.get_id": {
            "name": "get_id",
            "location": 75,
            "return": [
                "str",
                "Union[int, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.get_label": {
            "name": "get_label",
            "location": 78,
            "return": [
                "Optional[str]",
                "str",
                "Union[None, List[str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.get_label_without_outer_namespace": {
            "name": "get_label_without_outer_namespace",
            "location": 82,
            "return": [
                "Optional[str]",
                "Optional[Dict]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.iter_parents": {
            "name": "iter_parents",
            "location": 86,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.iter_children": {
            "name": "iter_children",
            "location": 89,
            "return": [
                "int",
                "Union[base.Criterion, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.is_observed": {
            "name": "is_observed",
            "location": 92,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.has_value": {
            "name": "has_value",
            "location": 95,
            "return": [
                "str",
                "dict",
                "int",
                "Dict[str, Any]",
                "Iterable[numpy.dtype]",
                "Callable[[Mapping], T]",
                "tuple"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.__array_ufunc__": {
            "name": "__array_ufunc__",
            "location": 104,
            "return": [
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "ufunc": [
                    "str"
                ],
                "method": [
                    "str",
                    "Optional[str]"
                ],
                "input0": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "List[str]"
                ],
                "_": [
                    "str",
                    "Callable",
                    "List[str]"
                ]
            }
        },
        "Vertex.__add__": {
            "name": "__add__",
            "location": 129,
            "return": [
                "bool",
                "Tuple[float, float]",
                "Optional[bool]",
                "Callable[..., None]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "bool"
                ]
            }
        },
        "Vertex.__radd__": {
            "name": "__radd__",
            "location": 134,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vertex.__sub__": {
            "name": "__sub__",
            "location": 138,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[int]"
                ]
            }
        },
        "Vertex.__rsub__": {
            "name": "__rsub__",
            "location": 143,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vertex.__mul__": {
            "name": "__mul__",
            "location": 147,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[int]"
                ]
            }
        },
        "Vertex.__rmul__": {
            "name": "__rmul__",
            "location": 152,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vertex.__pow__": {
            "name": "__pow__",
            "location": 156,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[int]"
                ]
            }
        },
        "Vertex.__rpow__": {
            "name": "__rpow__",
            "location": 161,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vertex.__truediv__": {
            "name": "__truediv__",
            "location": 165,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[int]"
                ]
            }
        },
        "Vertex.__rtruediv__": {
            "name": "__rtruediv__",
            "location": 170,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vertex.__floordiv__": {
            "name": "__floordiv__",
            "location": 174,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[int]",
                    "str"
                ]
            }
        },
        "Vertex.__rfloordiv__": {
            "name": "__rfloordiv__",
            "location": 181,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "numpy.array",
                    "str"
                ]
            }
        },
        "Vertex.__eq__": {
            "name": "__eq__",
            "location": 186,
            "return": [
                "Tuple[Any, Any, Any]",
                "str",
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[base.WhereSpec]",
                    "Tuple[int, int]"
                ]
            }
        },
        "Vertex.__ne__": {
            "name": "__ne__",
            "location": 190,
            "return": [
                "numpy.ndarray",
                "float",
                "Dict[str, Any]",
                "int",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[base.WhereSpec]",
                    "Tuple[int, int]"
                ]
            }
        },
        "Vertex.__gt__": {
            "name": "__gt__",
            "location": 194,
            "return": [
                "numpy.ndarray",
                "float",
                "Dict[str, Any]",
                "int",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[base.WhereSpec]",
                    "Tuple[int, int]"
                ]
            }
        },
        "Vertex.__ge__": {
            "name": "__ge__",
            "location": 197,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Iterable[List[T]]",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "Vertex.__lt__": {
            "name": "__lt__",
            "location": 200,
            "return": [
                "numpy.ndarray",
                "float",
                "Dict[str, Any]",
                "int",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[base.WhereSpec]",
                    "Tuple[int, int]"
                ]
            }
        },
        "Vertex.__le__": {
            "name": "__le__",
            "location": 203,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Iterable[List[T]]",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "Vertex.__abs__": {
            "name": "__abs__",
            "location": 206,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.__round__": {
            "name": "__round__",
            "location": 209,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "ndigits": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "Vertex.__floor__": {
            "name": "__floor__",
            "location": 214,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.__ceil__": {
            "name": "__ceil__",
            "location": 217,
            "return": [
                "str",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vertex.__parse_args": {
            "name": "__parse_args",
            "location": 221,
            "return": [
                "List[Dict]",
                "List[str]",
                "List[int]",
                "list",
                "Tuple[int]",
                "Union[str, List[Any]]",
                "Union[List[float], List[int]]",
                "List[float]",
                "Tuple[int, int, int]"
            ],
            "arguments": {
                "args": []
            }
        },
        "Vertex.__parse_arg": {
            "name": "__parse_arg",
            "location": 225,
            "return": [
                "int",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "arg": [
                    "Type"
                ]
            }
        },
        "Vertex._from_java_vertex": {
            "name": "_from_java_vertex",
            "location": 236,
            "return": [
                "Optional[bool]",
                "bool",
                "Optional[str]",
                "str",
                "list",
                "Optional[float]"
            ],
            "arguments": {
                "java_vertex": [
                    "py4j.java_gateway.JavaObject",
                    "float",
                    "str",
                    "int",
                    "Union[numpy.ndarray, astropy.units.quantity.Quantity]"
                ]
            }
        },
        "Vertex._to_generator": {
            "name": "_to_generator",
            "location": 251,
            "return": [
                "int",
                "List[str]",
                "dict",
                "bytes",
                "Dict[str, str]",
                "Optional[str]"
            ],
            "arguments": {
                "java_vertices": [
                    "numpy.ndarray",
                    "float",
                    "Dict[str, numpy.ndarray]",
                    "dict",
                    "str",
                    "int"
                ]
            }
        },
        "Vertex._get_python_id": {
            "name": "_get_python_id",
            "location": 255,
            "return": [
                "str",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "java_vertex": [
                    "py4j.java_gateway.JavaObject",
                    "int",
                    "numpy.ndarray",
                    "str"
                ]
            }
        },
        "Double.cast": {
            "name": "cast",
            "location": 261,
            "return": [
                "dict",
                "Dict[str, int]",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "keanu.vartypes.tensor_arg_types",
                    "Sequence[Any]",
                    "tensorflow.Tensor"
                ]
            }
        },
        "Integer.cast": {
            "name": "cast",
            "location": 267,
            "return": [
                "dict",
                "Dict[str, int]",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "keanu.vartypes.tensor_arg_types",
                    "Sequence[Any]",
                    "tensorflow.Tensor"
                ]
            }
        },
        "Integer.__array_ufunc__": {
            "name": "__array_ufunc__",
            "location": 270,
            "return": [
                "bool",
                "str",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "ufunc": [
                    "Dict[str, torch.Tensor]",
                    "Type[T]",
                    "Callable",
                    "str",
                    "Dict[str, str]",
                    "Callable[[], None]",
                    "cmk.base.events.EventContext",
                    "dict"
                ],
                "method": [
                    "str",
                    "Mapping[str, Any]"
                ],
                "input0": [
                    "str",
                    "Mapping[str, Any]",
                    "List[str]",
                    "Dict[str, Any]"
                ],
                "_": [
                    "Iterable[List[T]]",
                    "numpy.ndarray"
                ]
            }
        },
        "Integer.__op_based_on_other_type": {
            "name": "__op_based_on_other_type",
            "location": 289,
            "return": [
                "Optional[numpy.ndarray]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[str]",
                    "Sequence[numpy.ndarray]"
                ],
                "op": [
                    "bool",
                    "int",
                    "dict",
                    "List[List]",
                    "Union[int, float]"
                ],
                "integer_op_ctr": [
                    "Callable"
                ]
            }
        },
        "Integer.__add__": {
            "name": "__add__",
            "location": 297,
            "return": [
                "bool",
                "Optional[Dict[str, str]]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__radd__": {
            "name": "__radd__",
            "location": 303,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__sub__": {
            "name": "__sub__",
            "location": 309,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__rsub__": {
            "name": "__rsub__",
            "location": 315,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__mul__": {
            "name": "__mul__",
            "location": 321,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__rmul__": {
            "name": "__rmul__",
            "location": 327,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__pow__": {
            "name": "__pow__",
            "location": 333,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__rpow__": {
            "name": "__rpow__",
            "location": 339,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__truediv__": {
            "name": "__truediv__",
            "location": 345,
            "return": [
                "str",
                "numpy.ndarray",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Callable"
                ]
            }
        },
        "Integer.__rtruediv__": {
            "name": "__rtruediv__",
            "location": 348,
            "return": [
                "str",
                "numpy.ndarray",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Callable"
                ]
            }
        },
        "Integer.__floordiv__": {
            "name": "__floordiv__",
            "location": 351,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Integer.__rfloordiv__": {
            "name": "__rfloordiv__",
            "location": 357,
            "return": [
                "Optional[Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Boolean.cast": {
            "name": "cast",
            "location": 366,
            "return": [
                "dict",
                "Dict[str, int]",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "v": [
                    "keanu.vartypes.tensor_arg_types",
                    "Sequence[Any]",
                    "tensorflow.Tensor"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vertex/const.py": {
        "Const": {
            "name": "Const",
            "location": 8,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "t": [],
                "label": [
                    "Optional[str]",
                    "Optional[int]",
                    "list",
                    "Union[str, bool]",
                    "Optional[float]",
                    "dict"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vertex/generated.py": {
        "cast_to_double_vertex": {
            "name": "cast_to_double_vertex",
            "location": 30,
            "return": [
                "str",
                "Dict[str, Any]",
                "Type"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_integer_vertex": {
            "name": "cast_to_integer_vertex",
            "location": 34,
            "return": [
                "str",
                "Dict[str, Any]",
                "Type"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_boolean_vertex": {
            "name": "cast_to_boolean_vertex",
            "location": 38,
            "return": [
                "str",
                "Dict[str, Any]",
                "Type"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_vertex": {
            "name": "cast_to_vertex",
            "location": 42,
            "return": [
                "bool",
                "Type",
                "List[List[str]]",
                "Callable"
            ],
            "arguments": {
                "input": [
                    "base.vertex_constructor_param_types",
                    "Iterable[Mapping[str, Any]]",
                    "Iterable['cirq.Qid']",
                    "Iterable[int]"
                ]
            }
        },
        "Broadcast": {
            "name": "Broadcast",
            "location": 189,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "to_shape": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ]
            }
        },
        "DiagPart": {
            "name": "DiagPart",
            "location": 193,
            "return": [
                "int",
                "str",
                "List[str]",
                "Callable"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Diag": {
            "name": "Diag",
            "location": 197,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "FillTriangular": {
            "name": "FillTriangular",
            "location": 201,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "bool",
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "fill_upper": [
                    "bool",
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "fill_lower": [
                    "bool",
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "bool",
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Permute": {
            "name": "Permute",
            "location": 205,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]",
                    "int"
                ],
                "rearrange": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]",
                    "int"
                ]
            }
        },
        "Reshape": {
            "name": "Reshape",
            "location": 209,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "proposed_shape": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "label": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ]
            }
        },
        "Slice": {
            "name": "Slice",
            "location": 213,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "dimension": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "index": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "label": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ]
            }
        },
        "StridedSlice": {
            "name": "StridedSlice",
            "location": 224,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "start": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "end": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "stride": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "ellipsis": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "upper_bound_stop": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "drop_dimension": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ],
                "label": [
                    "Collection[int]",
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "int",
                    "bool"
                ]
            }
        },
        "Take": {
            "name": "Take",
            "location": 228,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]",
                    "int"
                ],
                "index": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]",
                    "int"
                ]
            }
        },
        "TriLower": {
            "name": "TriLower",
            "location": 232,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "int",
                    "Optional[str]",
                    "Collection[int]",
                    "bool"
                ],
                "k": [
                    "base.vertex_constructor_param_types",
                    "int",
                    "Optional[str]",
                    "Collection[int]",
                    "bool"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "int",
                    "Optional[str]",
                    "Collection[int]",
                    "bool"
                ]
            }
        },
        "TriUpper": {
            "name": "TriUpper",
            "location": 236,
            "return": [
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int",
                    "float"
                ],
                "k": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int",
                    "float"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int",
                    "float"
                ]
            }
        },
        "TrianglePart": {
            "name": "TrianglePart",
            "location": 240,
            "return": [
                "int",
                "str",
                "List[str]",
                "Callable"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "bool",
                    "Optional[str]"
                ],
                "upper_part": [
                    "base.vertex_constructor_param_types",
                    "bool",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Where": {
            "name": "Where",
            "location": 244,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "predicate": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "thn": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "els": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ]
            }
        },
        "BooleanProxy": {
            "name": "BooleanProxy",
            "location": 248,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "shape": [
                    "str",
                    "Collection[int]",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[str]"
                ],
                "label": [
                    "str",
                    "Collection[int]",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[str]"
                ]
            }
        },
        "CastNumberToBoolean": {
            "name": "CastNumberToBoolean",
            "location": 252,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "CastToBoolean": {
            "name": "CastToBoolean",
            "location": 256,
            "return": [
                "str",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "ConstantBoolean": {
            "name": "ConstantBoolean",
            "location": 260,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "constant": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "AndBinary": {
            "name": "AndBinary",
            "location": 264,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "OrBinary": {
            "name": "OrBinary",
            "location": 268,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "XorBinary": {
            "name": "XorBinary",
            "location": 272,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Equals": {
            "name": "Equals",
            "location": 276,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "GreaterThanOrEqual": {
            "name": "GreaterThanOrEqual",
            "location": 280,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "GreaterThan": {
            "name": "GreaterThan",
            "location": 284,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "LessThanOrEqual": {
            "name": "LessThanOrEqual",
            "location": 288,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "LessThan": {
            "name": "LessThan",
            "location": 292,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "NotEquals": {
            "name": "NotEquals",
            "location": 296,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "NumericalEquals": {
            "name": "NumericalEquals",
            "location": 300,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ],
                "b": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ],
                "epsilon": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ]
            }
        },
        "BooleanConcatenation": {
            "name": "BooleanConcatenation",
            "location": 304,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "dimension": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "input": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "BooleanToDoubleMask": {
            "name": "BooleanToDoubleMask",
            "location": 308,
            "return": [
                "str",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "BooleanToIntegerMask": {
            "name": "BooleanToIntegerMask",
            "location": 312,
            "return": [
                "str",
                "Dict[str, int]",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "AllFalse": {
            "name": "AllFalse",
            "location": 316,
            "return": [
                "bool",
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "AllTrue": {
            "name": "AllTrue",
            "location": 320,
            "return": [
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "AnyFalse": {
            "name": "AnyFalse",
            "location": 324,
            "return": [
                "float",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "AnyTrue": {
            "name": "AnyTrue",
            "location": 328,
            "return": [
                "bytearray",
                "Dict[str, int]",
                "float",
                "bool",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "IsFinite": {
            "name": "IsFinite",
            "location": 332,
            "return": [
                "Optional[int]",
                "bool"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "IsInfinite": {
            "name": "IsInfinite",
            "location": 336,
            "return": [
                "Optional[int]",
                "bool"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "IsNaN": {
            "name": "IsNaN",
            "location": 340,
            "return": [
                "str",
                "Optional[int]",
                "Callable",
                "Optional[str]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "IsNegativeInfinity": {
            "name": "IsNegativeInfinity",
            "location": 344,
            "return": [
                "Optional[int]",
                "bool"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "IsPositiveInfinity": {
            "name": "IsPositiveInfinity",
            "location": 348,
            "return": [
                "Optional[int]",
                "bool"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "NotBinary": {
            "name": "NotBinary",
            "location": 352,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "NotNaN": {
            "name": "NotNaN",
            "location": 356,
            "return": [
                "str",
                "IO",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Bernoulli": {
            "name": "Bernoulli",
            "location": 360,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "prob_true": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Print": {
            "name": "Print",
            "location": 370,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "parent": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "base.vertex_constructor_param_types"
                ],
                "message": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "base.vertex_constructor_param_types"
                ],
                "print_data": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "CastNumberToInteger": {
            "name": "CastNumberToInteger",
            "location": 374,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "ConstantInteger": {
            "name": "ConstantInteger",
            "location": 378,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "constant": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "IntegerProxy": {
            "name": "IntegerProxy",
            "location": 382,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "shape": [
                    "str",
                    "Collection[int]",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[str]"
                ],
                "label": [
                    "str",
                    "Collection[int]",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[str]"
                ]
            }
        },
        "IntegerConcatenation": {
            "name": "IntegerConcatenation",
            "location": 386,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "dimension": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "input": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArgMax": {
            "name": "ArgMax",
            "location": 390,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "axis": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArgMin": {
            "name": "ArgMin",
            "location": 394,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "axis": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "NaNArgMax": {
            "name": "NaNArgMax",
            "location": 398,
            "return": [
                "str",
                "List[str]",
                "float",
                "Callable"
            ],
            "arguments": {
                "input_vertex": [
                    "int",
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "axis": [
                    "int",
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "int",
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "NaNArgMin": {
            "name": "NaNArgMin",
            "location": 402,
            "return": [
                "str",
                "List[str]",
                "float",
                "Callable"
            ],
            "arguments": {
                "input_vertex": [
                    "int",
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "axis": [
                    "int",
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "int",
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Binomial": {
            "name": "Binomial",
            "location": 406,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "p": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "n": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Geometric": {
            "name": "Geometric",
            "location": 410,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "p": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "Multinomial": {
            "name": "Multinomial",
            "location": 414,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "n": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "bool"
                ],
                "p": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "bool"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "Poisson": {
            "name": "Poisson",
            "location": 418,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "mu": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "UniformInt": {
            "name": "UniformInt",
            "location": 428,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "min": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "max": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Mod": {
            "name": "Mod",
            "location": 432,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "right": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "CastNumberToDouble": {
            "name": "CastNumberToDouble",
            "location": 436,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "ConstantDouble": {
            "name": "ConstantDouble",
            "location": 440,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "constant": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "DoubleProxy": {
            "name": "DoubleProxy",
            "location": 444,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "shape": [
                    "str",
                    "Collection[int]",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[str]"
                ],
                "label": [
                    "str",
                    "Collection[int]",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[str]"
                ]
            }
        },
        "Concatenation": {
            "name": "Concatenation",
            "location": 448,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "dimension": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "operands": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Beta": {
            "name": "Beta",
            "location": 459,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "alpha": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "beta": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Cauchy": {
            "name": "Cauchy",
            "location": 470,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "location": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "scale": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "ChiSquared": {
            "name": "ChiSquared",
            "location": 474,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "k": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "str"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "str"
                ]
            }
        },
        "Dirichlet": {
            "name": "Dirichlet",
            "location": 484,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "concentration": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "Exponential": {
            "name": "Exponential",
            "location": 493,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "rate": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types",
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "Gamma": {
            "name": "Gamma",
            "location": 502,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "theta": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "k": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Gaussian": {
            "name": "Gaussian",
            "location": 512,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "mu": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "sigma": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "HalfCauchy": {
            "name": "HalfCauchy",
            "location": 516,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "scale": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "HalfGaussian": {
            "name": "HalfGaussian",
            "location": 520,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "sigma": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "InverseGamma": {
            "name": "InverseGamma",
            "location": 524,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "alpha": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "beta": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "KDE": {
            "name": "KDE",
            "location": 535,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "samples": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "bandwidth": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Laplace": {
            "name": "Laplace",
            "location": 539,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "mu": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "beta": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "LogNormal": {
            "name": "LogNormal",
            "location": 550,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "mu": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "sigma": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Logistic": {
            "name": "Logistic",
            "location": 554,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "mu": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "s": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "MultivariateGaussian": {
            "name": "MultivariateGaussian",
            "location": 558,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "mu": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "covariance": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Pareto": {
            "name": "Pareto",
            "location": 572,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "location": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "scale": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "StudentT": {
            "name": "StudentT",
            "location": 576,
            "return": [],
            "arguments": {
                "v": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Triangular": {
            "name": "Triangular",
            "location": 580,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "x_min": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "x_max": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "c": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Uniform": {
            "name": "Uniform",
            "location": 591,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "x_min": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ],
                "x_max": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float"
                ]
            }
        },
        "ArcTan2": {
            "name": "ArcTan2",
            "location": 602,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Optional[int]",
                    "Tuple[Any, int]"
                ],
                "y": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Optional[int]",
                    "Tuple[Any, int]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Optional[int]",
                    "Tuple[Any, int]"
                ]
            }
        },
        "LogAddExp2": {
            "name": "LogAddExp2",
            "location": 612,
            "return": [
                "bool",
                "Dict[int, Set[int]]",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "LogAddExp": {
            "name": "LogAddExp",
            "location": 616,
            "return": [
                "bool",
                "Dict[int, Set[int]]",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "SafeLogTimes": {
            "name": "SafeLogTimes",
            "location": 620,
            "return": [
                "Dict[str, int]",
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "x": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "List[str]"
                ],
                "y": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "List[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "List[str]"
                ]
            }
        },
        "ArcCos": {
            "name": "ArcCos",
            "location": 624,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArcCosh": {
            "name": "ArcCosh",
            "location": 633,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArcSin": {
            "name": "ArcSin",
            "location": 642,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArcSinh": {
            "name": "ArcSinh",
            "location": 651,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArcTan": {
            "name": "ArcTan",
            "location": 660,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "ArcTanh": {
            "name": "ArcTanh",
            "location": 669,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Ceil": {
            "name": "Ceil",
            "location": 678,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "CholeskyDecomposition": {
            "name": "CholeskyDecomposition",
            "location": 688,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "CholeskyInverse": {
            "name": "CholeskyInverse",
            "location": 697,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Cos": {
            "name": "Cos",
            "location": 706,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Cosh": {
            "name": "Cosh",
            "location": 715,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Digamma": {
            "name": "Digamma",
            "location": 724,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Exp2": {
            "name": "Exp2",
            "location": 733,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "ExpM1": {
            "name": "ExpM1",
            "location": 742,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Exp": {
            "name": "Exp",
            "location": 751,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Floor": {
            "name": "Floor",
            "location": 760,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Log10": {
            "name": "Log10",
            "location": 770,
            "return": [
                "Callable",
                "Dict[str, Any]",
                "float",
                "List[dict]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ]
            }
        },
        "Log1p": {
            "name": "Log1p",
            "location": 779,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Log2": {
            "name": "Log2",
            "location": 788,
            "return": [
                "Callable",
                "Dict[str, Any]",
                "float",
                "List[dict]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ]
            }
        },
        "LogGamma": {
            "name": "LogGamma",
            "location": 797,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Log": {
            "name": "Log",
            "location": 806,
            "return": [
                "Callable",
                "Dict[str, Any]",
                "float",
                "List[dict]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "Collection[int]"
                ]
            }
        },
        "MatrixDeterminant": {
            "name": "MatrixDeterminant",
            "location": 815,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "vertex": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "keanu.vartypes.tensor_arg_types",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "MatrixInverse": {
            "name": "MatrixInverse",
            "location": 819,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Mean": {
            "name": "Mean",
            "location": 823,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "over_dimensions": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "label": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ]
            }
        },
        "ReplaceNaN": {
            "name": "ReplaceNaN",
            "location": 833,
            "return": [
                "str",
                "IO",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float",
                    "int"
                ],
                "replace_with_value": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "float",
                    "int"
                ]
            }
        },
        "Round": {
            "name": "Round",
            "location": 837,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Sigmoid": {
            "name": "Sigmoid",
            "location": 847,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Sin": {
            "name": "Sin",
            "location": 857,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Sinh": {
            "name": "Sinh",
            "location": 866,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "StandardDeviation": {
            "name": "StandardDeviation",
            "location": 875,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Standardize": {
            "name": "Standardize",
            "location": 884,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Tan": {
            "name": "Tan",
            "location": 888,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Tanh": {
            "name": "Tanh",
            "location": 897,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Trigamma": {
            "name": "Trigamma",
            "location": 906,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Addition": {
            "name": "Addition",
            "location": 915,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "right": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Difference": {
            "name": "Difference",
            "location": 925,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "right": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Division": {
            "name": "Division",
            "location": 929,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "right": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "GreaterThanMask": {
            "name": "GreaterThanMask",
            "location": 939,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "GreaterThanOrEqualToMask": {
            "name": "GreaterThanOrEqualToMask",
            "location": 943,
            "return": [
                "float",
                "str",
                "Tuple[int]"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "LessThanMask": {
            "name": "LessThanMask",
            "location": 947,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "LessThanOrEqualToMask": {
            "name": "LessThanOrEqualToMask",
            "location": 951,
            "return": [
                "float",
                "str",
                "Tuple[int]"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "MatrixMultiplication": {
            "name": "MatrixMultiplication",
            "location": 955,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "transpose_left": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "transpose_right": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Max": {
            "name": "Max",
            "location": 967,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Min": {
            "name": "Min",
            "location": 977,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "right": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Multiplication": {
            "name": "Multiplication",
            "location": 987,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "left": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "right": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Power": {
            "name": "Power",
            "location": 997,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "base": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "exponent": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "TensorMultiplication": {
            "name": "TensorMultiplication",
            "location": 1007,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "left": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "right": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "dims_left": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "dims_right": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "SetWithMask": {
            "name": "SetWithMask",
            "location": 1021,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "operand": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "mask": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "set_value": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "Abs": {
            "name": "Abs",
            "location": 1025,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "CumProd": {
            "name": "CumProd",
            "location": 1034,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "requested_dimension": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "CumSum": {
            "name": "CumSum",
            "location": 1038,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "requested_dimension": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "MaxUnary": {
            "name": "MaxUnary",
            "location": 1042,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]"
                ]
            }
        },
        "MinUnary": {
            "name": "MinUnary",
            "location": 1046,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Product": {
            "name": "Product",
            "location": 1050,
            "return": [
                "dict",
                "Dict[str, Any]",
                "Sequence[str]",
                "int",
                "Iterable[str]"
            ],
            "arguments": {
                "input_vertex": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "Optional[str]",
                    "int"
                ],
                "over_dimensions": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "Optional[str]",
                    "int"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Collection[int]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Sign": {
            "name": "Sign",
            "location": 1054,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ],
                "label": [
                    "Optional[str]",
                    "base.vertex_constructor_param_types"
                ]
            }
        },
        "Sum": {
            "name": "Sum",
            "location": 1063,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "input_vertex": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "over_dimensions": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ],
                "label": [
                    "Optional[str]",
                    "Collection[int]",
                    "base.vertex_constructor_param_types",
                    "int"
                ]
            }
        },
        "Assert": {
            "name": "Assert",
            "location": 1073,
            "return": [
                "bytearray",
                "str"
            ],
            "arguments": {
                "predicate": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "str"
                ],
                "error_message": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "str"
                ],
                "label": [
                    "base.vertex_constructor_param_types",
                    "Optional[str]",
                    "str"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vertex/iff.py": {
        "If": {
            "name": "If",
            "location": 12,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "List[str]",
                "Optional[List[Callable]]"
            ],
            "arguments": {
                "predicate": [
                    "Union[keanu.vartypes.tensor_arg_types, base.Vertex]",
                    "Optional[str]",
                    "str",
                    "Optional[bool]"
                ],
                "thn": [
                    "Optional[int]"
                ],
                "els": [
                    "Optional[dict]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vertex/label.py": {
        "_VertexLabel.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[str]",
                    "Callable[[float], bool]"
                ]
            }
        },
        "_VertexLabel.get_name": {
            "name": "get_name",
            "location": 28,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_VertexLabel.__repr__": {
            "name": "__repr__",
            "location": 31,
            "return": [
                "str",
                "Callable",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_VertexLabel.create_from_list": {
            "name": "create_from_list",
            "location": 35,
            "return": [
                "str"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/keanu/vertex/lambda_model.py": {
        "LambdaModel.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "Optional[str]",
                    "dict",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "executor": [
                    "str",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "bool",
                    "Optional[str]",
                    "dict",
                    "Optional[Dict[str, Any]]",
                    "Optional[int]"
                ],
                "update_values": [
                    "dict",
                    "int",
                    "Dict[str, Any]",
                    "List[Dict]"
                ],
                "label": [
                    "bool",
                    "str",
                    "Dict[str, Any]",
                    "Optional[int]"
                ]
            }
        },
        "LambdaModel.__execute": {
            "name": "__execute",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices_unwrapped": [
                    "Tuple[int, int]",
                    "str"
                ]
            }
        },
        "LambdaModel.__update_value": {
            "name": "__update_value",
            "location": 36,
            "return": [
                "float",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LambdaModel.__to_java_map": {
            "name": "__to_java_map",
            "location": 41,
            "return": [
                "eth.chains.base.MiningChain",
                "Dict[str, Any]",
                "float"
            ],
            "arguments": {
                "inputs": [
                    "dict",
                    "str",
                    "Pattern[str]",
                    "Dict[str, List[Any]]"
                ]
            }
        },
        "LambdaModel.__wrap": {
            "name": "__wrap",
            "location": 46,
            "return": [
                "bool",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "vertices": [
                    "py4j.java_JavaMap",
                    "Dict[str, str]",
                    "dict"
                ]
            }
        },
        "LambdaModel.__update_unwrapped_vertices": {
            "name": "__update_unwrapped_vertices",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "vertices_wrapped": [
                    "Dict[str, keanu.vertex.base.Vertex]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, int]"
                ],
                "vertices_unwrapped": [
                    "py4j.java_JavaMap",
                    "bytes",
                    "Callable",
                    "Dict[str, float]"
                ]
            }
        },
        "LambdaModel.get_double_model_output_vertex": {
            "name": "get_double_model_output_vertex",
            "location": 54,
            "return": [
                "int",
                "List[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "Optional[Sequence[str]]",
                    "List[str]",
                    "int",
                    "ByteString"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vertex/vertex_casting.py": {
        "do_vertex_cast": {
            "name": "do_vertex_cast",
            "location": 13,
            "return": [
                "str",
                "int",
                "dict",
                "float",
                "tuple"
            ],
            "arguments": {
                "vertex_ctor": [
                    "Callable",
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "Optional['ModelOrDc']",
                    "float"
                ],
                "value": [
                    "Callable",
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "Optional['ModelOrDc']",
                    "float"
                ]
            }
        },
        "do_inferred_vertex_cast": {
            "name": "do_inferred_vertex_cast",
            "location": 17,
            "return": [
                "Optional[str]",
                "str",
                "bool",
                "Hashable"
            ],
            "arguments": {
                "ctors": [
                    "Union[str, int, float]",
                    "str",
                    "T",
                    "list"
                ],
                "value": [
                    "str",
                    "T",
                    "int",
                    "type",
                    "Tuple[float, float, float]"
                ]
            }
        },
        "cast_to_double_tensor": {
            "name": "cast_to_double_tensor",
            "location": 28,
            "return": [
                "str",
                "int",
                "dict",
                "Union[int, Tuple[int, ...]]"
            ],
            "arguments": {
                "value": [
                    "keanu.vartypes.tensor_arg_types",
                    "float",
                    "torch.Tensor",
                    "T",
                    "bool",
                    "str"
                ]
            }
        },
        "cast_to_integer_tensor": {
            "name": "cast_to_integer_tensor",
            "location": 32,
            "return": [
                "str",
                "int",
                "dict",
                "Union[int, Tuple[int, ...]]"
            ],
            "arguments": {
                "value": [
                    "keanu.vartypes.tensor_arg_types",
                    "float",
                    "torch.Tensor",
                    "T",
                    "bool",
                    "str"
                ]
            }
        },
        "cast_to_boolean_tensor": {
            "name": "cast_to_boolean_tensor",
            "location": 36,
            "return": [
                "str",
                "int",
                "dict",
                "Union[int, Tuple[int, ...]]"
            ],
            "arguments": {
                "value": [
                    "keanu.vartypes.tensor_arg_types",
                    "float",
                    "torch.Tensor",
                    "T",
                    "bool",
                    "str"
                ]
            }
        },
        "cast_to_double": {
            "name": "cast_to_double",
            "location": 40,
            "return": [
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_integer": {
            "name": "cast_to_integer",
            "location": 44,
            "return": [
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_boolean": {
            "name": "cast_to_boolean",
            "location": 48,
            "return": [
                "bool"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_long_array": {
            "name": "cast_to_long_array",
            "location": 52,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_int_array": {
            "name": "cast_to_int_array",
            "location": 56,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_boolean_array": {
            "name": "cast_to_boolean_array",
            "location": 60,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "cast_to_vertex_array": {
            "name": "cast_to_vertex_array",
            "location": 64,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "input": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        }
    },
    "keanu-master/keanu-python/keanu/vertex/__init__.py": {},
    "keanu-master/keanu-python/nd4j/setup.py": {},
    "keanu-master/keanu-python/nd4j/nd4j/__init__.py": {
        "get_classpath": {
            "name": "get_classpath",
            "location": 6,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/nd4j/nd4j/__version__.py": {},
    "keanu-master/keanu-python/tests/conftest.py": {
        "make_tests_deterministic": {
            "name": "make_tests_deterministic",
            "location": 7,
            "return": [
                ""
            ],
            "arguments": {
                "request": [
                    "int"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_base.py": {
        "java_list_wrapper": {
            "name": "java_list_wrapper",
            "location": 8,
            "return": [
                "str",
                "List[Dict]",
                "List[int]",
                "List[List[Any]]",
                "list"
            ],
            "arguments": {}
        },
        "test_you_can_call_a_java_method_on_the_unwrapped_object": {
            "name": "test_you_can_call_a_java_method_on_the_unwrapped_object",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "java_list_wrapper": [
                    "str",
                    "list",
                    "Optional[List[str]]",
                    "bytes",
                    "int",
                    "float"
                ]
            }
        },
        "test_you_cannot_call_a_java_method_with_snake_case_on_the_unwrapped_object": {
            "name": "test_you_cannot_call_a_java_method_with_snake_case_on_the_unwrapped_object",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "java_list_wrapper": [
                    "str",
                    "list",
                    "Optional[List[str]]",
                    "bytes",
                    "int",
                    "float"
                ]
            }
        },
        "test_you_cannot_call_a_java_method_with_snake_case_on_the_wrapped_object": {
            "name": "test_you_cannot_call_a_java_method_with_snake_case_on_the_wrapped_object",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "java_list_wrapper": [
                    "str",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_you_can_overload_a_java_method_in_python": {
            "name": "test_you_can_overload_a_java_method_in_python",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "java_list_wrapper": [
                    "str",
                    "bool",
                    "list",
                    "Iterable[str]"
                ]
            }
        },
        "test_you_cannot_call_a_java_method_that_hasnt_been_overloaded": {
            "name": "test_you_cannot_call_a_java_method_that_hasnt_been_overloaded",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "java_list_wrapper": [
                    "str"
                ]
            }
        },
        "test_throws_if_not_unwrapped_and_passed_to_java_object": {
            "name": "test_throws_if_not_unwrapped_and_passed_to_java_object",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "java_list_wrapper": [
                    "str",
                    "Union[None, dict]",
                    "dict"
                ]
            }
        },
        "java_list_wrapper.JavaListWrapper.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "numbers": [
                    "int",
                    "Dict[str, Any]",
                    "Union[str, int]",
                    "bool"
                ]
            }
        },
        "java_list_wrapper.JavaListWrapper.get": {
            "name": "get",
            "location": 19,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_cast.py": {
        "test_scalar_cast": {
            "name": "test_scalar_cast",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "type",
                    "Callable",
                    "keanu.vartypes.primitive_types",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ],
                "cast_fn": [
                    "type",
                    "Callable",
                    "keanu.vartypes.primitive_types",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ],
                "expected_type": [
                    "type",
                    "Callable",
                    "keanu.vartypes.primitive_types",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ]
            }
        },
        "test_nonscalar_tensor_cast": {
            "name": "test_nonscalar_tensor_cast",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "type",
                    "Callable",
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ],
                "cast_fn": [
                    "type",
                    "Callable",
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ],
                "expected_type": [
                    "type",
                    "Callable",
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "test_nonscalar_vertex_cast": {
            "name": "test_nonscalar_vertex_cast",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "type",
                    "Callable",
                    "keanu.vartypes.primitive_types",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ],
                "cast_fn": [
                    "type",
                    "Callable",
                    "keanu.vartypes.primitive_types",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ],
                "expected_type": [
                    "type",
                    "Callable",
                    "keanu.vartypes.primitive_types",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ]
            }
        },
        "test_cant_pass_vertex_to_cast_tensor_arg": {
            "name": "test_cant_pass_vertex_to_cast_tensor_arg",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "cast_fn": [
                    "Callable",
                    "str"
                ],
                "cast_to_type": [
                    "type",
                    "Type[Any]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_coal_mining.py": {
        "test_coalmining": {
            "name": "test_coalmining",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_const.py": {
        "generic": {
            "name": "generic",
            "location": 13,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_const_takes_ndarray": {
            "name": "test_const_takes_ndarray",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "arr": [
                    "int",
                    "Iterable[str]",
                    "List[List[keanu.vartypes.primitive_types]]",
                    "Iterable[int]",
                    "T",
                    "float",
                    "AbstractSet[Any]"
                ],
                "expected_java_class": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "test_const_takes_panda_series": {
            "name": "test_const_takes_panda_series",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "data": [
                    "str",
                    "List[List[int]]",
                    "Dict[str, str]",
                    "Type[Dict[str, Any]]",
                    "Union[Dict, List]"
                ],
                "expected_java_class": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "test_const_takes_panda_dataframe": {
            "name": "test_const_takes_panda_dataframe",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "data": [
                    "Dict[str, Any]",
                    "dict",
                    "Optional[Dict[str, Any]]"
                ],
                "expected_java_class": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "test_const_takes_num": {
            "name": "test_const_takes_num",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "num": [
                    "bool",
                    "list",
                    "int",
                    "float"
                ],
                "expected_java_class": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_const_does_not_take_generic_ndarray": {
            "name": "test_const_does_not_take_generic_ndarray",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "generic": [
                    "List[numpy.ndarray]",
                    "numpy.ndarray",
                    "keanu.vartypes.primitive_types",
                    "str",
                    "int"
                ]
            }
        },
        "test_const_does_not_take_generic": {
            "name": "test_const_does_not_take_generic",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "generic": [
                    "str"
                ]
            }
        },
        "test_const_does_not_take_empty_ndarray": {
            "name": "test_const_does_not_take_empty_ndarray",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_const_takes_ndarray_of_rank_one": {
            "name": "test_const_takes_ndarray_of_rank_one",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_const_takes_label": {
            "name": "test_const_takes_label",
            "location": 105,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_const_takes_none_label": {
            "name": "test_const_takes_none_label",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "assert_java_class": {
            "name": "assert_java_class",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "java_object_wrapper": [
                    "str"
                ],
                "java_class_str": [
                    "str"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_context.py": {
        "test_the_context_is_a_singleton": {
            "name": "test_the_context_is_a_singleton",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_there_is_only_one_jvm_view": {
            "name": "test_there_is_only_one_jvm_view",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_convert_a_numpy_array_to_a_java_array": {
            "name": "test_you_can_convert_a_numpy_array_to_a_java_array",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_create_vertex_array_from_different_types": {
            "name": "test_you_can_create_vertex_array_from_different_types",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_descriptions.py": {
        "test_simple_if_vertex_description_created_correctly": {
            "name": "test_simple_if_vertex_description_created_correctly",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_simple_binary_op_description": {
            "name": "test_simple_binary_op_description",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_gradient_optimization.py": {
        "model": {
            "name": "model",
            "location": 10,
            "return": [
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "test_gradient_op_bayes_net": {
            "name": "test_gradient_op_bayes_net",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "model": []
            }
        },
        "test_gradient_op_vertex": {
            "name": "test_gradient_op_vertex",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "TestModule.Model",
                    "bool"
                ]
            }
        },
        "test_gradient_op_throws_with_invalid_net_param": {
            "name": "test_gradient_op_throws_with_invalid_net_param",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_gradient_can_set_max_eval_builder_properties_for_conjugate_gradient": {
            "name": "test_gradient_can_set_max_eval_builder_properties_for_conjugate_gradient",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "TestModule.Model",
                    "int"
                ]
            }
        },
        "test_thermometers_map_gradient_with_conjugate_gradient": {
            "name": "test_thermometers_map_gradient_with_conjugate_gradient",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "TestModule.Model",
                    "bool"
                ]
            }
        },
        "test_thermometers_map_gradient_with_adam": {
            "name": "test_thermometers_map_gradient_with_adam",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "TestModule.Model",
                    "bool"
                ]
            }
        },
        "thermometers_map_gradient": {
            "name": "thermometers_map_gradient",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "int",
                    "str",
                    "dict",
                    "Set[int]"
                ],
                "algorithm": [
                    "Union['Contributor', 'Coverage']",
                    "rflx.model.Model",
                    "Optional[float]",
                    "allennlp.models.model.Model"
                ]
            }
        },
        "test_thermometers_likelihood_gradient_for_conjugate_gradient": {
            "name": "test_thermometers_likelihood_gradient_for_conjugate_gradient",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "TestModule.Model",
                    "bool"
                ]
            }
        },
        "test_thermometers_likelihood_gradient_for_adam": {
            "name": "test_thermometers_likelihood_gradient_for_adam",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "TestModule.Model",
                    "bool"
                ]
            }
        },
        "thermometers_max_likelihood_gradient": {
            "name": "thermometers_max_likelihood_gradient",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "int",
                    "str",
                    "dict",
                    "Set[int]"
                ],
                "algorithm": [
                    "Union['Contributor', 'Coverage']",
                    "rflx.model.Model",
                    "Optional[float]",
                    "allennlp.models.model.Model"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_if.py": {
        "test_you_can_create_a_double_valued_if": {
            "name": "test_you_can_create_a_double_valued_if",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "predicate": [
                    "str",
                    "bool",
                    "Union[List, Dict]",
                    "List[str]",
                    "float"
                ],
                "data": [
                    "Union[keanu.vartypes.tensor_arg_types, keanu.vertex.Vertex]"
                ]
            }
        },
        "test_you_can_create_an_integer_valued_if": {
            "name": "test_you_can_create_an_integer_valued_if",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "predicate": [
                    "str",
                    "Union[List, Dict]",
                    "List[str]",
                    "float",
                    "bool"
                ],
                "data": [
                    "Union[keanu.vartypes.tensor_arg_types, keanu.vertex.Vertex]"
                ]
            }
        },
        "test_you_can_create_a_boolean_valued_if": {
            "name": "test_you_can_create_a_boolean_valued_if",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "predicate": [
                    "str",
                    "bool",
                    "Union[List, Dict]",
                    "List[str]",
                    "float"
                ],
                "data": [
                    "Union[keanu.vartypes.tensor_arg_types, keanu.vertex.Vertex]"
                ]
            }
        },
        "test_if_thn_or_els_is_not_float_it_gets_coerced": {
            "name": "test_if_thn_or_els_is_not_float_it_gets_coerced",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "thn": [
                    "Optional[\"Game\"]",
                    "Optional[int]",
                    "Callable[[int], Tuple]"
                ],
                "els": [
                    "Optional[\"Game\"]",
                    "Optional[int]",
                    "Callable[[int], Tuple]"
                ]
            }
        },
        "test_if_thn_or_els_is_not_int_it_gets_coerced": {
            "name": "test_if_thn_or_els_is_not_int_it_gets_coerced",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "thn": [
                    "Optional[\"Game\"]",
                    "Optional[int]",
                    "Callable[[int], Tuple]"
                ],
                "els": [
                    "Optional[\"Game\"]",
                    "Optional[int]",
                    "Callable[[int], Tuple]"
                ]
            }
        },
        "test_if_predicate_is_not_bool_it_gets_coerced": {
            "name": "test_if_predicate_is_not_bool_it_gets_coerced",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "pred": [
                    "bool"
                ]
            }
        },
        "test_you_get_a_useful_error_message_when_you_use_a_boolean_vertex_in_a_python_if_clause": {
            "name": "test_you_get_a_useful_error_message_when_you_use_a_boolean_vertex_in_a_python_if_clause",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_init.py": {
        "test_version_is_correctly_formatted": {
            "name": "test_version_is_correctly_formatted",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_iterator.py": {
        "test_it_tells_you_when_it_is_finished": {
            "name": "test_it_tells_you_when_it_is_finished",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_it_throws_if_you_pass_the_end": {
            "name": "test_it_throws_if_you_pass_the_end",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_an_empty_python_iterator_yields_an_empty_java_iterator": {
            "name": "test_an_empty_python_iterator_yields_an_empty_java_iterator",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_java_exception.py": {
        "test_you_can_get_info_from_a_java_exception": {
            "name": "test_you_can_get_info_from_a_java_exception",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_throw_a_java_exception": {
            "name": "test_you_can_throw_a_java_exception",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_its_repr_method_gives_you_the_stack_trace": {
            "name": "test_its_repr_method_gives_you_the_stack_trace",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_keanu_random.py": {
        "test_default_keanu_random": {
            "name": "test_default_keanu_random",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_seeded_keanu_random": {
            "name": "test_seeded_keanu_random",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_labels.py": {
        "test_you_can_create_a_label_with_a_name": {
            "name": "test_you_can_create_a_label_with_a_name",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_create_a_label_from_a_dot_separated_string": {
            "name": "test_you_can_create_a_label_from_a_dot_separated_string",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_there_is_a_helper_method_to_build_the_string_from_a_list": {
            "name": "test_there_is_a_helper_method_to_build_the_string_from_a_list",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_cannot_build_it_with_an_empty_list": {
            "name": "test_you_cannot_build_it_with_an_empty_list",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_the_repr_method_makes_it_clear_what_the_namespace_is": {
            "name": "test_the_repr_method_makes_it_clear_what_the_namespace_is",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_lambdas.py": {
        "plus_one": {
            "name": "plus_one",
            "location": 6,
            "return": [
                ""
            ],
            "arguments": {
                "vertices": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_you_can_create_a_lambda_model_vertex": {
            "name": "test_you_can_create_a_lambda_model_vertex",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_create_a_process_model_vertex": {
            "name": "test_you_can_create_a_process_model_vertex",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": []
            }
        },
        "evaluate_and_check_for_increment": {
            "name": "evaluate_and_check_for_increment",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "str",
                    "bool"
                ],
                "v_in": [
                    "keanu.vertex.Vertex",
                    "bool",
                    "int",
                    "tuple",
                    "float"
                ]
            }
        },
        "BlackBoxProcess.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dir": [
                    "IO[str]",
                    "str",
                    "int"
                ]
            }
        },
        "BlackBoxProcess.run": {
            "name": "run",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "str",
                    "list"
                ]
            }
        },
        "BlackBoxProcess.extract_values": {
            "name": "extract_values",
            "location": 19,
            "return": [
                "str",
                "dict",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "keanu-master/keanu-python/tests/test_lorenz.py": {
        "test_lorenz": {
            "name": "test_lorenz",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "add_time": {
            "name": "add_time",
            "location": 54,
            "return": [
                "List[int]",
                "int",
                "bool"
            ],
            "arguments": {
                "current": [
                    "Tuple[keanu.vertex.Vertex, keanu.vertex.Vertex, keanu.vertex.Vertex]",
                    "str",
                    "Union[str, int]",
                    "numpy.ndarray"
                ]
            }
        },
        "build_graph": {
            "name": "build_graph",
            "location": 64,
            "return": [
                "typing.Generator[typing.Tuple[keanu.vertex.Vertex, keanu.vertex.Vertex, keanu.vertex.Vertex], None, None]"
            ],
            "arguments": {
                "initial": [
                    "Tuple[keanu.vertex.Vertex, keanu.vertex.Vertex, keanu.vertex.Vertex]",
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "apply_observations": {
            "name": "apply_observations",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "graph_time_steps": [
                    "float",
                    "int",
                    "Optional[str]"
                ],
                "window": [
                    "Optional[int]",
                    "Tuple[int, int]",
                    "numpy.ndarray",
                    "Callable[[str, str], float]",
                    "int"
                ],
                "observed": [
                    "int",
                    "bool",
                    "float",
                    "bytes"
                ]
            }
        },
        "get_time_slice_values": {
            "name": "get_time_slice_values",
            "location": 81,
            "return": [
                "List[str]",
                "list"
            ],
            "arguments": {
                "time_steps": [
                    "float",
                    "str",
                    "int",
                    "bool"
                ],
                "time": [
                    "float",
                    "str",
                    "int",
                    "bool"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_model.py": {
        "test_to_bayes_net": {
            "name": "test_to_bayes_net",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_to_bayes_net_excludes_non_vertices": {
            "name": "test_to_bayes_net_excludes_non_vertices",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_net.py": {
        "test_construct_bayes_net": {
            "name": "test_construct_bayes_net",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_get_vertices_from_bayes_net": {
            "name": "test_can_get_vertices_from_bayes_net",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "get_method": [
                    "str",
                    "Callable[[], str]",
                    "Dict[str, Any]",
                    "bool",
                    "Optional[bytes]"
                ],
                "latent": [
                    "List[str]",
                    "Dict[str, Any]",
                    "Callable",
                    "Dict[str, List['WantedGallery']]",
                    "T",
                    "int",
                    "float"
                ],
                "observed": [
                    "int",
                    "Callable",
                    "List[str]"
                ],
                "continuous": [
                    "List[str]",
                    "Dict[str, Any]",
                    "Callable",
                    "Dict[str, List['WantedGallery']]",
                    "T",
                    "int",
                    "float"
                ],
                "discrete": [
                    "int",
                    "Callable",
                    "List[str]"
                ],
                "deterministic": [
                    "str",
                    "int",
                    "List[str]"
                ]
            }
        },
        "test_probe_for_non_zero_probability_from_bayes_net": {
            "name": "test_probe_for_non_zero_probability_from_bayes_net",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "check_loaded_net": {
            "name": "check_loaded_net",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "int",
                    "bool"
                ]
            }
        },
        "check_dot_file": {
            "name": "check_dot_file",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "dot_file_name": [
                    "str"
                ]
            }
        },
        "test_can_save_and_load": {
            "name": "test_can_save_and_load",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": []
            }
        },
        "test_can_dot_save_list_of_vertices": {
            "name": "test_can_dot_save_list_of_vertices",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": []
            }
        },
        "test_dot_save_only_takes_bayes_net_or_list": {
            "name": "test_dot_save_only_takes_bayes_net_or_list",
            "location": 125,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str"
                ]
            }
        },
        "test_get_vertex_by_label": {
            "name": "test_get_vertex_by_label",
            "location": 131,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_non_gradient_optimization.py": {
        "model": {
            "name": "model",
            "location": 10,
            "return": [
                "Callable",
                "Optional[str]",
                "Type"
            ],
            "arguments": {}
        },
        "test_non_gradient_op_bayes_net": {
            "name": "test_non_gradient_op_bayes_net",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "model": []
            }
        },
        "test_non_gradient_op_vertex": {
            "name": "test_non_gradient_op_vertex",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "bool",
                    "TestModule.Model"
                ]
            }
        },
        "test_non_gradient_op_throws_with_invalid_net_param": {
            "name": "test_non_gradient_op_throws_with_invalid_net_param",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_non_gradient_can_set_max_eval_builder_properties": {
            "name": "test_non_gradient_can_set_max_eval_builder_properties",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "int",
                    "TestModule.Model"
                ]
            }
        },
        "test_non_gradient_can_set_bounds_range_builder_properties": {
            "name": "test_non_gradient_can_set_bounds_range_builder_properties",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "TestModule.Model",
                    "int",
                    "Tuple[int, int]"
                ]
            }
        },
        "test_map_non_gradient": {
            "name": "test_map_non_gradient",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "int",
                    "TestModule.Model"
                ]
            }
        },
        "test_max_likelihood_non_gradient": {
            "name": "test_max_likelihood_non_gradient",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "int",
                    "TestModule.Model"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_proposal_distributions.py": {
        "net": {
            "name": "net",
            "location": 11,
            "return": [],
            "arguments": {}
        },
        "test_you_can_create_a_prior_proposal_distribution": {
            "name": "test_you_can_create_a_prior_proposal_distribution",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet",
                    "keanu.vartypes.tensor_arg_types",
                    "int",
                    "Dict[type, Any]"
                ]
            }
        },
        "test_you_can_create_a_gaussian_proposal_distribution": {
            "name": "test_you_can_create_a_gaussian_proposal_distribution",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "sigma": [
                    "keanu.BayesNet",
                    "keanu.vartypes.tensor_arg_types",
                    "int",
                    "Dict[type, Any]"
                ],
                "net": [
                    "keanu.BayesNet",
                    "keanu.vartypes.tensor_arg_types",
                    "int",
                    "Dict[type, Any]"
                ]
            }
        },
        "test_it_throws_if_you_specify_gaussian_without_a_value_for_sigma": {
            "name": "test_it_throws_if_you_specify_gaussian_without_a_value_for_sigma",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet",
                    "keanu.vartypes.tensor_arg_types",
                    "Optional[List[str]]",
                    "Dict[type, Any]"
                ]
            }
        },
        "test_it_throws_if_you_specify_gaussian_with_not_enough_sigmas_for_each_latent": {
            "name": "test_it_throws_if_you_specify_gaussian_with_not_enough_sigmas_for_each_latent",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet",
                    "keanu.vartypes.tensor_arg_types",
                    "int",
                    "Dict[type, Any]"
                ]
            }
        },
        "test_it_throws_if_you_specify_gaussian_without_values_for_latents": {
            "name": "test_it_throws_if_you_specify_gaussian_without_values_for_latents",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_it_throws_if_you_specify_gaussian_with_empty_list_of_latents": {
            "name": "test_it_throws_if_you_specify_gaussian_with_empty_list_of_latents",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet"
                ]
            }
        },
        "test_it_throws_if_you_specify_sigma_but_the_type_isnt_gaussian": {
            "name": "test_it_throws_if_you_specify_sigma_but_the_type_isnt_gaussian",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_it_throws_if_it_doesnt_recognise_the_type": {
            "name": "test_it_throws_if_it_doesnt_recognise_the_type",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_sampling.py": {
        "net": {
            "name": "net",
            "location": 17,
            "return": [],
            "arguments": {}
        },
        "tensor_net": {
            "name": "tensor_net",
            "location": 27,
            "return": [],
            "arguments": {}
        },
        "test_sampling_returns_dict_of_list_of_ndarrays_for_vertices_in_sample_from": {
            "name": "test_sampling_returns_dict_of_list_of_ndarrays_for_vertices_in_sample_from",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "algo": [
                    "Callable"
                ],
                "net": [
                    "int",
                    "pandas.DataFrame",
                    "keanu.BayesNet"
                ]
            }
        },
        "test_sampling_returns_multi_indexed_dict_of_list_of_scalars_for_tensor_in_sample_from": {
            "name": "test_sampling_returns_multi_indexed_dict_of_list_of_scalars_for_tensor_in_sample_from",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "algo": [
                    "dict"
                ],
                "tensor_net": [
                    "keanu.BayesNet",
                    "int",
                    "pandas.DataFrame",
                    "keanu.vartypes.tensor_arg_types"
                ]
            }
        },
        "test_sampling_returns_multi_indexed_dict_of_list_of_scalars_for_mixed_net": {
            "name": "test_sampling_returns_multi_indexed_dict_of_list_of_scalars_for_mixed_net",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "algo": [
                    "dict"
                ]
            }
        },
        "test_sample_dict_can_be_loaded_in_to_dataframe": {
            "name": "test_sample_dict_can_be_loaded_in_to_dataframe",
            "location": 109,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "int",
                    "keanu.BayesNet",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_multi_indexed_sample_dict_can_be_loaded_in_to_dataframe": {
            "name": "test_multi_indexed_sample_dict_can_be_loaded_in_to_dataframe",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor_net": [
                    "keanu.BayesNet",
                    "int",
                    "pandas.DataFrame",
                    "Optional[List[str]]"
                ]
            }
        },
        "test_dropping_samples": {
            "name": "test_dropping_samples",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "str"
                ]
            }
        },
        "test_down_sample_interval": {
            "name": "test_down_sample_interval",
            "location": 150,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "str"
                ]
            }
        },
        "test_sample_with_plot": {
            "name": "test_sample_with_plot",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet",
                    "str"
                ]
            }
        },
        "test_can_specify_a_gaussian_proposal_distribution": {
            "name": "test_can_specify_a_gaussian_proposal_distribution",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet"
                ]
            }
        },
        "test_can_specify_a_gaussian_proposal_distribution_with_multiple_sigmas": {
            "name": "test_can_specify_a_gaussian_proposal_distribution_with_multiple_sigmas",
            "location": 179,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet"
                ]
            }
        },
        "test_can_iter_through_samples": {
            "name": "test_can_iter_through_samples",
            "location": 188,
            "return": [
                "None"
            ],
            "arguments": {
                "algo": [
                    "bool",
                    "int"
                ],
                "net": [
                    "bool",
                    "int"
                ]
            }
        },
        "test_can_iter_through_tensor_samples": {
            "name": "test_can_iter_through_tensor_samples",
            "location": 202,
            "return": [
                "None"
            ],
            "arguments": {
                "algo": [
                    "str",
                    "Callable[[keanu.BayesNet], keanu.algorithm.PosteriorSamplingAlgorithm]",
                    "keanu.BayesNet",
                    "Dict[str, Any]"
                ],
                "tensor_net": [
                    "str",
                    "Callable[[keanu.BayesNet], keanu.algorithm.PosteriorSamplingAlgorithm]",
                    "keanu.BayesNet",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_iter_returns_same_result_as_sample": {
            "name": "test_iter_returns_same_result_as_sample",
            "location": 220,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_iter_with_live_plot": {
            "name": "test_iter_with_live_plot",
            "location": 239,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "int"
                ]
            }
        },
        "test_can_get_acceptance_rates": {
            "name": "test_can_get_acceptance_rates",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "pandas.DataFrame"
                ]
            }
        },
        "test_can_track_acceptance_rate_when_iterating": {
            "name": "test_can_track_acceptance_rate_when_iterating",
            "location": 266,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "pandas.DataFrame",
                    "keanu.BayesNet"
                ]
            }
        },
        "test_can_specify_nuts_params": {
            "name": "test_can_specify_nuts_params",
            "location": 281,
            "return": [
                "None"
            ],
            "arguments": {
                "net": [
                    "keanu.BayesNet",
                    "keanu.vartypes.tensor_arg_types",
                    "int",
                    "Dict[type, Any]"
                ]
            }
        },
        "test_sample_throws_if_vertices_in_sample_from_are_missing_labels": {
            "name": "test_sample_throws_if_vertices_in_sample_from_are_missing_labels",
            "location": 293,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_generate_samples_throws_if_vertices_in_sample_from_are_missing_labels": {
            "name": "test_generate_samples_throws_if_vertices_in_sample_from_are_missing_labels",
            "location": 304,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "set_starting_state": {
            "name": "set_starting_state",
            "location": 315,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "reorder_subplots": {
            "name": "reorder_subplots",
            "location": 322,
            "return": [
                "None"
            ],
            "arguments": {
                "ax": [
                    "str",
                    "int"
                ]
            }
        },
        "__assert_valid_samples": {
            "name": "__assert_valid_samples",
            "location": 333,
            "return": [
                "None"
            ],
            "arguments": {
                "draws": [
                    "int",
                    "str",
                    "Dict[str, str]",
                    "bytes",
                    "Sequence[Tuple[float, float]]"
                ],
                "samples": [
                    "dict",
                    "Mapping[str, Any]",
                    "Dict[str, Dict[str, str]]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_sequence.py": {
        "test_you_can_iterate_over_the_sequence": {
            "name": "test_you_can_iterate_over_the_sequence",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_build_a_sequence_with_fixed_count": {
            "name": "test_you_can_build_a_sequence_with_fixed_count",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_build_a_sequence_from_data": {
            "name": "test_you_can_build_a_sequence_from_data",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_must_pass_count_or_data_generator": {
            "name": "test_you_must_pass_count_or_data_generator",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_cannot_pass_both_count_and_data_generator": {
            "name": "test_you_cannot_pass_both_count_and_data_generator",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_build_a_time_series": {
            "name": "test_you_can_build_a_time_series",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "__check_sequence_output_links_to_input": {
            "name": "__check_sequence_output_links_to_input",
            "location": 105,
            "return": [
                "None"
            ],
            "arguments": {
                "item": [
                    "Dict[str, Dict[str, str]]",
                    "bool",
                    "dict",
                    "Dict[str, Type[Any]]",
                    "Dict[str, int]",
                    "Dict[str, Any]",
                    "str"
                ],
                "previous_output_label": [
                    "Dict[str, Dict[str, str]]",
                    "bool",
                    "dict",
                    "Dict[str, Type[Any]]",
                    "Dict[str, int]",
                    "Dict[str, Any]",
                    "str"
                ],
                "current_input_label": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "dict"
                ]
            }
        },
        "__check_output_equals": {
            "name": "__check_output_equals",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "sequence": [
                    "Iterable[float]",
                    "List[T]",
                    "int",
                    "str"
                ],
                "label": [
                    "str",
                    "bool",
                    "float",
                    "Callable[[bytes], bytes]"
                ],
                "desired_output": [
                    "float",
                    "List[int]",
                    "int",
                    "bool"
                ]
            }
        },
        "test_you_can_use_multiple_factories_to_build_sequences": {
            "name": "test_you_can_use_multiple_factories_to_build_sequences",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_last_item_retrieved_correctly": {
            "name": "test_last_item_retrieved_correctly",
            "location": 192,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_name_a_sequence": {
            "name": "test_you_can_name_a_sequence",
            "location": 216,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_get_a_bayes_net_from_a_sequence": {
            "name": "test_you_can_get_a_bayes_net_from_a_sequence",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_proxy_vertices_are_correctly_typed": {
            "name": "test_proxy_vertices_are_correctly_typed",
            "location": 266,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_build_a_sequence_with_fixed_count.create_vertex": {
            "name": "create_vertex",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "item": [
                    "keanu.sequence.SequenceItem",
                    "T",
                    "Mapping",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_you_can_build_a_sequence_from_data.create_vertices": {
            "name": "create_vertices",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "item": [
                    "Dict[str, Any]",
                    "keanu.sequence.SequenceItem",
                    "list",
                    "dict"
                ],
                "point": [
                    "Dict[str, Any]",
                    "keanu.sequence.SequenceItem",
                    "list",
                    "dict"
                ]
            }
        },
        "test_you_can_build_a_time_series.create_time_step": {
            "name": "create_time_step",
            "location": 79,
            "return": [
                ""
            ],
            "arguments": {
                "sequence_item": [
                    "Optional[TextIO]"
                ]
            }
        },
        "test_you_can_use_multiple_factories_to_build_sequences.factory1": {
            "name": "factory1",
            "location": 139,
            "return": [
                ""
            ],
            "arguments": {
                "sequence_item": [
                    "int"
                ]
            }
        },
        "test_you_can_use_multiple_factories_to_build_sequences.factory2": {
            "name": "factory2",
            "location": 151,
            "return": [
                ""
            ],
            "arguments": {
                "sequence_item": [
                    "int"
                ]
            }
        },
        "test_last_item_retrieved_correctly.factory": {
            "name": "factory",
            "location": 195,
            "return": [],
            "arguments": {
                "sequence_item": []
            }
        },
        "test_you_can_name_a_sequence.factory": {
            "name": "factory",
            "location": 219,
            "return": [],
            "arguments": {
                "sequence_item": []
            }
        },
        "test_you_can_get_a_bayes_net_from_a_sequence.factory": {
            "name": "factory",
            "location": 248,
            "return": [],
            "arguments": {
                "sequence_item": []
            }
        },
        "test_proxy_vertices_are_correctly_typed.factory": {
            "name": "factory",
            "location": 274,
            "return": [
                ""
            ],
            "arguments": {
                "sequence_item": [
                    "Dict[str, Any]",
                    "float"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_shape_validation.py": {
        "test_doesnt_throw_on_valid_index": {
            "name": "test_doesnt_throw_on_valid_index",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_throws_on_index_longer_than_shape": {
            "name": "test_throws_on_index_longer_than_shape",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_throws_on_index_shorter_than_shape": {
            "name": "test_throws_on_index_shorter_than_shape",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_throws_on_index_out_of_bounds": {
            "name": "test_throws_on_index_out_of_bounds",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_doesnt_throw_on_matching_shapes": {
            "name": "test_doesnt_throw_on_matching_shapes",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_throws_on_non_mathcing_shapes": {
            "name": "test_throws_on_non_mathcing_shapes",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_throws_on_empty_list_of_shapes": {
            "name": "test_throws_on_empty_list_of_shapes",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_stats.py": {
        "test_can_get_correct_autocorrelation": {
            "name": "test_can_get_correct_autocorrelation",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_autocorr_returns_ndarray_of_correct_dtype": {
            "name": "test_autocorr_returns_ndarray_of_correct_dtype",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_cant_get_autocorrelation_of_np_bools": {
            "name": "test_cant_get_autocorrelation_of_np_bools",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_cant_get_autocorrelation_of_np_ints": {
            "name": "test_cant_get_autocorrelation_of_np_ints",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_autocorrelation_same_for_streaming_as_batch": {
            "name": "test_autocorrelation_same_for_streaming_as_batch",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "set_starting_state": {
            "name": "set_starting_state",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "keanu.Model",
                    "str",
                    "tensorflow.keras.Model",
                    "keanu.vertex.base.Vertex",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_tensor.py": {
        "generic": {
            "name": "generic",
            "location": 14,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_num_passed_to_Tensor_creates_scalar_tensor": {
            "name": "test_num_passed_to_Tensor_creates_scalar_tensor",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "num": [
                    "int",
                    "str"
                ]
            }
        },
        "test_dataframe_passed_to_Tensor_creates_tensor": {
            "name": "test_dataframe_passed_to_Tensor_creates_tensor",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "pandas.core.groupby.DataFrameGroupBy"
                ]
            }
        },
        "test_series_passed_to_Tensor_creates_tensor": {
            "name": "test_series_passed_to_Tensor_creates_tensor",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "torch.Tensor",
                    "bytes",
                    "str"
                ]
            }
        },
        "test_cannot_pass_generic_to_Tensor": {
            "name": "test_cannot_pass_generic_to_Tensor",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "generic": [
                    "str"
                ]
            }
        },
        "test_ndarray_passed_to_Tensor_creates_nonscalar_tensor": {
            "name": "test_ndarray_passed_to_Tensor_creates_nonscalar_tensor",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "arr": [
                    "float",
                    "numpy.ndarray",
                    "List[numpy.ndarray]",
                    "keanu.vartypes.primitive_types"
                ]
            }
        },
        "test_cannot_pass_generic_ndarray_to_Tensor": {
            "name": "test_cannot_pass_generic_ndarray_to_Tensor",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "generic": [
                    "numpy.ndarray",
                    "List[numpy.ndarray]",
                    "str",
                    "keanu.vartypes.primitive_types"
                ]
            }
        },
        "test_can_pass_empty_ndarray_to_Tensor": {
            "name": "test_can_pass_empty_ndarray_to_Tensor",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_convert_java_tensor_to_ndarray": {
            "name": "test_convert_java_tensor_to_ndarray",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "keanu.vartypes.numpy_types",
                    "str"
                ]
            }
        },
        "test_you_can_apply_a_function_to_a_tensor": {
            "name": "test_you_can_apply_a_function_to_a_tensor",
            "location": 89,
            "return": [
                ""
            ],
            "arguments": {
                "value": [
                    "bool",
                    "int",
                    "str"
                ],
                "expected_result": [
                    "int",
                    "float",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "test_you_can_create_tensors": {
            "name": "test_you_can_create_tensors",
            "location": 97,
            "return": [
                ""
            ],
            "arguments": {
                "dtype": []
            }
        },
        "test_you_can_create_boolean_tensor": {
            "name": "test_you_can_create_boolean_tensor",
            "location": 106,
            "return": [
                ""
            ],
            "arguments": {
                "value": [
                    "float",
                    "List[float]"
                ]
            }
        },
        "test_fails_when_long_is_too_long": {
            "name": "test_fails_when_long_is_too_long",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "keanu-master/keanu-python/tests/test_traceplot.py": {
        "trace": {
            "name": "trace",
            "location": 11,
            "return": [
                "Dict[str, Any]",
                "dict",
                "Dict[str, Dict[str, str]]"
            ],
            "arguments": {}
        },
        "test_traceplot_returns_axesplot_with_correct_data": {
            "name": "test_traceplot_returns_axesplot_with_correct_data",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "trace": []
            }
        }
    },
    "keanu-master/keanu-python/tests/test_vertex.py": {
        "jvm_view": {
            "name": "jvm_view",
            "location": 16,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "assert_vertex_value_equals_scalar": {
            "name": "assert_vertex_value_equals_scalar",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "vertex": [
                    "keanu.vertex.base.Vertex",
                    "str",
                    "bool"
                ],
                "expected_type": [
                    "Type",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Tuple[List[str], List[str]]",
                    "Tuple[str]"
                ],
                "scalar": [
                    "keanu.vartypes.primitive_types",
                    "Type",
                    "Tuple[keanu.vertex.Vertex, keanu.vertex.Vertex, keanu.vertex.Vertex]",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "assert_vertex_value_equals_ndarray": {
            "name": "assert_vertex_value_equals_ndarray",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "vertex": [
                    "keanu.vertex.base.Vertex",
                    "str",
                    "bool"
                ],
                "expected_type": [
                    "str",
                    "T"
                ],
                "ndarray": [
                    "str",
                    "int",
                    "bytes",
                    "Iterable[Iterable[str]]"
                ]
            }
        },
        "assert_vertex_value_equals_pandas": {
            "name": "assert_vertex_value_equals_pandas",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "vertex": [
                    "keanu.vertex.base.Vertex",
                    "str",
                    "bool"
                ],
                "expected_type": [
                    "dict",
                    "int"
                ],
                "pandas": [
                    "bool",
                    "float",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "dict"
                ]
            }
        },
        "test_can_pass_scalar_to_vertex": {
            "name": "test_can_pass_scalar_to_vertex",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_pass_ndarray_to_vertex": {
            "name": "test_can_pass_ndarray_to_vertex",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_pass_pandas_dataframe_to_vertex": {
            "name": "test_can_pass_pandas_dataframe_to_vertex",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_pass_pandas_series_to_vertex": {
            "name": "test_can_pass_pandas_series_to_vertex",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_pass_vertex_to_vertex": {
            "name": "test_can_pass_vertex_to_vertex",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "jvm_view": [
                    "int"
                ]
            }
        },
        "test_can_pass_array_to_vertex": {
            "name": "test_can_pass_array_to_vertex",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "jvm_view": [
                    "int"
                ]
            }
        },
        "test_cannot_pass_generic_to_vertex": {
            "name": "test_cannot_pass_generic_to_vertex",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "jvm_view": [
                    "py4j.java_gateway.JVMView",
                    "int"
                ]
            }
        },
        "test_int_vertex_value_is_a_numpy_array": {
            "name": "test_int_vertex_value_is_a_numpy_array",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_float_vertex_value_is_a_numpy_array": {
            "name": "test_float_vertex_value_is_a_numpy_array",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_boolean_vertex_value_is_a_numpy_array": {
            "name": "test_boolean_vertex_value_is_a_numpy_array",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_scalar_vertex_value_is_a_numpy_array": {
            "name": "test_scalar_vertex_value_is_a_numpy_array",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_vertex_sample_is_a_numpy_array": {
            "name": "test_vertex_sample_is_a_numpy_array",
            "location": 139,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_get_connected_graph": {
            "name": "test_get_connected_graph",
            "location": 149,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_id_str_of_downstream_vertex_is_higher_than_upstream": {
            "name": "test_id_str_of_downstream_vertex_is_higher_than_upstream",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_construct_vertex_with_java_vertex": {
            "name": "test_construct_vertex_with_java_vertex",
            "location": 169,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_java_collections_to_generator": {
            "name": "test_java_collections_to_generator",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_get_vertex_id": {
            "name": "test_get_vertex_id",
            "location": 188,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_ids_are_reset": {
            "name": "test_ids_are_reset",
            "location": 197,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_set_value": {
            "name": "test_you_can_set_value",
            "location": 224,
            "return": [
                "None"
            ],
            "arguments": {
                "vertex": [
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex",
                    "Callable",
                    "Type",
                    "AbstractSet[T]",
                    "Set[VT]",
                    "bool"
                ],
                "expected_type": [
                    "Type",
                    "Callable",
                    "int"
                ],
                "value": [
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex",
                    "Callable",
                    "Type",
                    "AbstractSet[T]",
                    "Set[VT]",
                    "bool"
                ],
                "assert_vertex_value_equals": [
                    "Type",
                    "Callable",
                    "int"
                ]
            }
        },
        "test_you_can_set_scalar_value": {
            "name": "test_you_can_set_scalar_value",
            "location": 232,
            "return": [
                ""
            ],
            "arguments": {
                "vertex": [
                    "str",
                    "Optional[Iterable[str]]"
                ],
                "expected_type": [
                    "Callable",
                    "str",
                    "bool",
                    "Type[Any]"
                ],
                "value": [
                    "str",
                    "Optional[Iterable[str]]"
                ]
            }
        },
        "test_you_can_set_and_cascade": {
            "name": "test_you_can_set_and_cascade",
            "location": 257,
            "return": [
                "None"
            ],
            "arguments": {
                "ctor": [
                    "bool",
                    "dict",
                    "Union[str, int, float]",
                    "Optional[Dict]"
                ],
                "args": [],
                "expected_type": [
                    "Callable",
                    "Type",
                    "List[int]",
                    "bytes",
                    "dict"
                ],
                "value": [
                    "keanu.vartypes.tensor_arg_types",
                    "dict",
                    "float",
                    "bool",
                    "str"
                ],
                "assert_vertex_value_equals": [
                    "Callable",
                    "Type",
                    "List[int]",
                    "bytes",
                    "dict"
                ]
            }
        },
        "test_you_can_set_and_cascade_scalar": {
            "name": "test_you_can_set_and_cascade_scalar",
            "location": 289,
            "return": [
                "None"
            ],
            "arguments": {
                "ctor": [
                    "Callable",
                    "Optional[Iterable[str]]"
                ],
                "args": [],
                "expected_type": [
                    "Callable",
                    "Optional[Iterable[str]]"
                ],
                "value": [
                    "Callable",
                    "Optional[Iterable[str]]"
                ]
            }
        },
        "test_you_can_observe": {
            "name": "test_you_can_observe",
            "location": 313,
            "return": [
                "None"
            ],
            "arguments": {
                "ctor": [
                    "Callable",
                    "bool",
                    "str",
                    "Callable[[Any], bool]",
                    "int"
                ],
                "args": [],
                "expected_type": [
                    "Type",
                    "Callable",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ],
                "value": [
                    "keanu.vartypes.tensor_arg_types",
                    "int",
                    "str"
                ],
                "assert_vertex_value_equals": [
                    "Type",
                    "Callable",
                    "keanu.vartypes.tensor_arg_types",
                    "keanu.vertex.base.Vertex"
                ]
            }
        },
        "test_unobserve": {
            "name": "test_unobserve",
            "location": 323,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_you_can_observe_scalar": {
            "name": "test_you_can_observe_scalar",
            "location": 335,
            "return": [
                "None"
            ],
            "arguments": {
                "ctor": [
                    "Optional[Iterable[str]]"
                ],
                "args": [],
                "expected_type": [
                    "Optional[Iterable[str]]"
                ],
                "value": [
                    "Optional[Iterable[str]]"
                ]
            }
        },
        "test_pass_label_as_an_optional_param": {
            "name": "test_pass_label_as_an_optional_param",
            "location": 339,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_pass_none_label": {
            "name": "test_can_pass_none_label",
            "location": 345,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_pass_namespaced_label": {
            "name": "test_can_pass_namespaced_label",
            "location": 350,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_set_label": {
            "name": "test_set_label",
            "location": 356,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_cannot_set_none_label": {
            "name": "test_cannot_set_none_label",
            "location": 363,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_label_is_required_param_for_proxy_vertices": {
            "name": "test_label_is_required_param_for_proxy_vertices",
            "location": 369,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_proxy_vertex_takes_string_as_required_param": {
            "name": "test_proxy_vertex_takes_string_as_required_param",
            "location": 374,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_java_vertex_to_python_vertex_persists_label": {
            "name": "test_java_vertex_to_python_vertex_persists_label",
            "location": 380,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_get_parents_and_children": {
            "name": "test_can_get_parents_and_children",
            "location": 387,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_get_parents_and_children.labels_match": {
            "name": "labels_match",
            "location": 389,
            "return": [
                "List[List[str]]",
                "object",
                "dict",
                "List[T]",
                "Set[int]",
                "List[str]"
            ],
            "arguments": {
                "lhs": [
                    "str",
                    "int"
                ],
                "rhs": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "keanu-master/keanu-python/tests/test_vertex_operations.py": {
        "test_can_do_equal_to": {
            "name": "test_can_do_equal_to",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "keanu.vertex.base.Vertex",
                    "bool",
                    "str",
                    "int",
                    "Iterable[Iterable[Any]]"
                ],
                "rhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "keanu.vertex.base.Vertex",
                    "bool",
                    "str",
                    "int",
                    "Iterable[Iterable[Any]]"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_not_equal_to": {
            "name": "test_can_do_not_equal_to",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "keanu.vertex.base.Vertex",
                    "bool",
                    "str",
                    "int"
                ],
                "rhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "keanu.vertex.base.Vertex",
                    "bool",
                    "str",
                    "int"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_greater_than": {
            "name": "test_can_do_greater_than",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "bool",
                    "int",
                    "str"
                ],
                "rhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "bool",
                    "int",
                    "str"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_less_than": {
            "name": "test_can_do_less_than",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "bool",
                    "int",
                    "str"
                ],
                "rhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "bool",
                    "int",
                    "str"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_greater_than_or_equal_to": {
            "name": "test_can_do_greater_than_or_equal_to",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "rhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Iterable[Iterable[Any]]",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_greater_than_or_equal_to_with_vertex_on_rhs": {
            "name": "test_can_do_greater_than_or_equal_to_with_vertex_on_rhs",
            "location": 105,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "rhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Iterable[Iterable[Any]]",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_less_than_or_equal_to": {
            "name": "test_can_do_less_than_or_equal_to",
            "location": 119,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "rhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Iterable[Iterable[Any]]",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "test_can_do_less_than_or_equal_to_with_vertex_on_rhs": {
            "name": "test_can_do_less_than_or_equal_to_with_vertex_on_rhs",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "rhs": [
                    "keanu.vertex.base.Vertex",
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Union[int, slice]"
                ],
                "expected_result": [
                    "keanu.vartypes.numpy_types",
                    "Iterable[Iterable[Any]]",
                    "Union[keanu.vartypes.numpy_types, float]"
                ]
            }
        },
        "infer_result_type": {
            "name": "infer_result_type",
            "location": 147,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "lhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, int]",
                    "str"
                ],
                "rhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, int]",
                    "str"
                ]
            }
        },
        "result_should_be_vertex": {
            "name": "result_should_be_vertex",
            "location": 154,
            "return": [
                "bool"
            ],
            "arguments": {
                "lhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Callable"
                ],
                "rhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, float]",
                    "Callable"
                ]
            }
        },
        "assert_is_correct_vertex_type_and_expected_value": {
            "name": "assert_is_correct_vertex_type_and_expected_value",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, int]",
                    "bool",
                    "Dict[str, Any]",
                    "type"
                ],
                "rhs": [
                    "Union[keanu.vertex.base.Vertex, keanu.vartypes.numpy_types, int]",
                    "bool",
                    "Dict[str, Any]",
                    "type"
                ],
                "result": [
                    "int",
                    "bool",
                    "dict"
                ],
                "expected_result": [
                    "numpy.ndarray",
                    "dict",
                    "Optional[numpy.ndarray]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "test_can_do_addition": {
            "name": "test_can_do_addition",
            "location": 179,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs_constructor": [
                    "str"
                ],
                "rhs_constructor": [
                    "str"
                ],
                "lhs": [
                    "str"
                ],
                "rhs": [
                    "str"
                ],
                "expected_result": []
            }
        },
        "test_can_do_subtraction": {
            "name": "test_can_do_subtraction",
            "location": 202,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs_constructor": [
                    "str"
                ],
                "rhs_constructor": [
                    "str"
                ],
                "lhs": [
                    "str"
                ],
                "rhs": [
                    "str"
                ],
                "expected_result": []
            }
        },
        "test_can_do_multiplication": {
            "name": "test_can_do_multiplication",
            "location": 225,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs_constructor": [
                    "str"
                ],
                "rhs_constructor": [
                    "str"
                ],
                "lhs": [
                    "str"
                ],
                "rhs": [
                    "str"
                ],
                "expected_result": []
            }
        },
        "test_can_do_division": {
            "name": "test_can_do_division",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs_constructor": [
                    "str"
                ],
                "rhs_constructor": [
                    "str"
                ],
                "lhs": [
                    "str"
                ],
                "rhs": [
                    "str"
                ],
                "expected_result": [
                    "Union[keanu.vartypes.numpy_types, float]",
                    "keanu.vartypes.numpy_types"
                ]
            }
        },
        "test_can_do_integer_division": {
            "name": "test_can_do_integer_division",
            "location": 275,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs_constructor": [
                    "str"
                ],
                "rhs_constructor": [
                    "str"
                ],
                "lhs": [
                    "str"
                ],
                "rhs": [
                    "str"
                ],
                "expected_result": [
                    "Dict[str, Any]"
                ]
            }
        },
        "test_can_do_pow": {
            "name": "test_can_do_pow",
            "location": 295,
            "return": [
                "None"
            ],
            "arguments": {
                "lhs_constructor": [
                    "str"
                ],
                "rhs_constructor": [
                    "str"
                ],
                "lhs": [
                    "str"
                ],
                "rhs": [
                    "str"
                ],
                "expected_result": [
                    "Dict[str, Any]"
                ]
            }
        },
        "test_can_do_compound_operations": {
            "name": "test_can_do_compound_operations",
            "location": 305,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_do_abs": {
            "name": "test_can_do_abs",
            "location": 317,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_do_round": {
            "name": "test_can_do_round",
            "location": 327,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_rounding_is_only_supported_to_zero_digits": {
            "name": "test_rounding_is_only_supported_to_zero_digits",
            "location": 340,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_do_floor": {
            "name": "test_can_do_floor",
            "location": 346,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_can_do_ceil": {
            "name": "test_can_do_ceil",
            "location": 358,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    }
}
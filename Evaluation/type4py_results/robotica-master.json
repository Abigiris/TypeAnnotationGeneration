{
    "robotica-master/setup.py": {},
    "robotica-master/click/__init__.py": {
        "command": {
            "name": "command",
            "location": 5,
            "return": [],
            "arguments": {}
        },
        "option": {
            "name": "option",
            "location": 6,
            "return": [],
            "arguments": {
                "name": [],
                "default": [],
                "help": []
            }
        }
    },
    "robotica-master/click_log/__init__.py": {
        "simple_verbosity_option": {
            "name": "simple_verbosity_option",
            "location": 6,
            "return": [],
            "arguments": {
                "logger": []
            }
        },
        "basic_config": {
            "name": "basic_config",
            "location": 8,
            "return": [],
            "arguments": {
                "logger": []
            }
        }
    },
    "robotica-master/docs/conf.py": {},
    "robotica-master/robotica/cli.py": {
        "_load_class": {
            "name": "_load_class",
            "location": 23,
            "return": [
                "bool",
                "Union[str, List[str]]",
                "str"
            ],
            "arguments": {
                "class_name": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "config": [
                    "str",
                    "List[str]",
                    "Dict[str, Any]"
                ],
                "schedule": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        }
    },
    "robotica-master/robotica/executor.py": {
        "Executor.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "loop": [
                    "dict",
                    "str",
                    "list"
                ],
                "config": [
                    "dict"
                ]
            }
        },
        "Executor.start": {
            "name": "start",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Executor.stop": {
            "name": "stop",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Executor.set_scheduler": {
            "name": "set_scheduler",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scheduler": [
                    "bool",
                    "float"
                ]
            }
        },
        "Executor.add_output": {
            "name": "add_output",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output": [
                    "str",
                    "Container"
                ]
            }
        },
        "Executor.action_required_for_locations": {
            "name": "action_required_for_locations",
            "location": 48,
            "return": [
                "bool",
                "str",
                "Optional[Any]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "locations": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "action": [
                    "str",
                    "List[str]",
                    "bool"
                ]
            }
        }
    },
    "robotica-master/robotica/schedule.py": {
        "TimeEntry.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "time": [
                    "int",
                    "float"
                ],
                "locations": [
                    "bool",
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "actions": [
                    "int",
                    "float"
                ]
            }
        },
        "TimeEntry.to_json": {
            "name": "to_json",
            "location": 40,
            "return": [
                "datetime.datetime",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TimeEntry.__str__": {
            "name": "__str__",
            "location": 47,
            "return": [
                "str",
                "bytes",
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "TimeEntry.__repr__": {
            "name": "__repr__",
            "location": 50,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Timer.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Timer.is_running": {
            "name": "is_running",
            "location": 74,
            "return": [
                "Sequence[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Timer.cancel": {
            "name": "cancel",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Timer.set_minutes": {
            "name": "set_minutes",
            "location": 147,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "total_minutes": [
                    "int",
                    "slice",
                    "float"
                ]
            }
        },
        "Timer.set_end_time": {
            "name": "set_end_time",
            "location": 152,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "time_str": [
                    "str",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        },
        "Scheduler.__init__": {
            "name": "__init__",
            "location": 274,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scheduler.save_schedule": {
            "name": "save_schedule",
            "location": 290,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scheduler.start": {
            "name": "start",
            "location": 294,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scheduler.stop": {
            "name": "stop",
            "location": 300,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scheduler._parse_entry": {
            "name": "_parse_entry",
            "location": 303,
            "return": [
                "bool",
                "str",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scheduler._expand_template": {
            "name": "_expand_template",
            "location": 377,
            "return": [
                "str",
                "Callable[[list], None]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "date": [
                    "datetime.date",
                    "str",
                    "int",
                    "Set[str]",
                    "list",
                    "Optional[str]",
                    "Tuple[str, str]"
                ],
                "time": [
                    "datetime.date",
                    "str",
                    "int",
                    "Set[str]",
                    "list",
                    "Optional[str]",
                    "Tuple[str, str]"
                ],
                "locations": [
                    "datetime.date",
                    "str",
                    "int",
                    "Set[str]",
                    "list",
                    "Optional[str]",
                    "Tuple[str, str]"
                ],
                "template_name": [
                    "str",
                    "bool"
                ]
            }
        },
        "Scheduler.get_days_for_date": {
            "name": "get_days_for_date",
            "location": 417,
            "return": [
                "List[Tuple[str, str]]",
                "Dict[str, Tuple[int, int]]",
                "list"
            ],
            "arguments": {
                "self": [],
                "date": [
                    "datetime.date",
                    "str",
                    "datetime.datetime",
                    "Optional[str]"
                ]
            }
        },
        "Scheduler.get_schedule_for_date": {
            "name": "get_schedule_for_date",
            "location": 517,
            "return": [
                "Dict[str, Tuple[int, int]]",
                "Type",
                "Optional[int]",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "date": [
                    "datetime.date",
                    "Optional[datetime.date]",
                    "datetime.datetime",
                    "List[int]",
                    "hypothesis.strategies.SearchStrategy[datetime.date.time]"
                ]
            }
        },
        "Scheduler._add_list_to_scheduler": {
            "name": "_add_list_to_scheduler",
            "location": 558,
            "return": [
                "str",
                "Iterable[Mapping[str, Any]]",
                "Optional[bool]",
                "Iterator[Any]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "schedule": [
                    "Iterable[str]",
                    "dbadapters.base.relation.BaseRelation",
                    "List[str]",
                    "Callable",
                    "Dict[str, List[str]]",
                    "List[dict]",
                    "str"
                ]
            }
        },
        "Scheduler.add_tasks_to_scheduler": {
            "name": "add_tasks_to_scheduler",
            "location": 573,
            "return": [
                "Iterable[Mapping[str, Any]]",
                "Optional[bool]",
                "str",
                "Iterator[Any]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "robotica-master/robotica/types.py": {},
    "robotica-master/robotica/__init__.py": {},
    "robotica-master/robotica/__main__.py": {},
    "robotica-master/robotica/plugins/__init__.py": {
        "Plugin.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Plugin.start": {
            "name": "start",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Plugin.stop": {
            "name": "stop",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "robotica-master/robotica/plugins/inputs/http.py": {
        "HttpInput.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "HttpInput._get_version": {
            "name": "_get_version",
            "location": 42,
            "return": [
                "str"
            ],
            "arguments": {
                "request": [
                    "aiohttp.web.Request",
                    "aiohttp.web_requesRequest",
                    "Dict[str, Any]"
                ]
            }
        },
        "HttpInput._get_schedule": {
            "name": "_get_schedule",
            "location": 59,
            "return": [
                "dict",
                "bool",
                "int",
                "List[str]",
                "Dict[str, List[Any]]",
                "Dict[str, Dict[str, str]]"
            ],
            "arguments": {
                "self": [],
                "request": [
                    "aiohttp.web.Request",
                    "Callable"
                ]
            }
        },
        "HttpInput._get_application": {
            "name": "_get_application",
            "location": 72,
            "return": [
                "app.executor.Application",
                "aiohttp.web.Application"
            ],
            "arguments": {
                "self": []
            }
        },
        "HttpInput.start": {
            "name": "start",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "HttpInput.stop": {
            "name": "stop",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "robotica-master/robotica/plugins/inputs/mqtt.py": {
        "MqttInput.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MqttInput.start": {
            "name": "start",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MqttInput.stop": {
            "name": "stop",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MqttInput._get_topics": {
            "name": "_get_topics",
            "location": 55,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "robotica-master/robotica/plugins/inputs/__init__.py": {
        "Input.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "robotica-master/robotica/plugins/outputs/audio.py": {
        "AudioOutput.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AudioOutput.start": {
            "name": "start",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AudioOutput.stop": {
            "name": "stop",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AudioOutput.is_action_required_for_location": {
            "name": "is_action_required_for_location",
            "location": 34,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "str",
                    "mypy.types.Type",
                    "Type"
                ],
                "action": [
                    "robotica.types.Action",
                    "str",
                    "Action",
                    "Type",
                    "T"
                ]
            }
        }
    },
    "robotica-master/robotica/plugins/outputs/lifx.py": {
        "LifxOutput.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LifxOutput.start": {
            "name": "start",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LifxOutput.stop": {
            "name": "stop",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LifxOutput._get_labels_for_location": {
            "name": "_get_labels_for_location",
            "location": 36,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "str",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "LifxOutput.is_action_required_for_location": {
            "name": "is_action_required_for_location",
            "location": 40,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "bool"
                ],
                "action": [
                    "robotica.types.Action",
                    "str",
                    "Action",
                    "Type",
                    "T"
                ]
            }
        },
        "LifxOutput._get_lights_from_location": {
            "name": "_get_lights_from_location",
            "location": 81,
            "return": [
                "int",
                "str",
                "Iterator[travelfootprininsta.types.FeedItem]",
                "types.ModuleType",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "bool",
                    "Set[str]",
                    "Callable"
                ]
            }
        }
    },
    "robotica-master/robotica/plugins/outputs/mqtt.py": {
        "MqttOutput.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MqttOutput.start": {
            "name": "start",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MqttOutput.stop": {
            "name": "stop",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MqttOutput.is_action_required_for_location": {
            "name": "is_action_required_for_location",
            "location": 41,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "str",
                    "mypy.types.Type",
                    "Type"
                ],
                "action": [
                    "robotica.types.Action",
                    "str",
                    "Action",
                    "Type",
                    "T"
                ]
            }
        }
    },
    "robotica-master/robotica/plugins/outputs/__init__.py": {
        "Output.is_action_required_for_location": {
            "name": "is_action_required_for_location",
            "location": 6,
            "return": [
                "builtins.bool"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "robotica.types.Action",
                    "str",
                    "Action",
                    "Type",
                    "T"
                ],
                "action": [
                    "robotica.types.Action",
                    "str",
                    "Action",
                    "Type",
                    "T"
                ]
            }
        }
    },
    "robotica-master/tests/test_robotica.py": {
        "test_dummy": {
            "name": "test_dummy",
            "location": 7,
            "return": [],
            "arguments": {}
        }
    },
    "robotica-master/tests/__init__.py": {},
    "robotica-master/yaml/__init__.py": {
        "safe_load": {
            "name": "safe_load",
            "location": 3,
            "return": [],
            "arguments": {
                "stream": []
            }
        },
        "dump": {
            "name": "dump",
            "location": 4,
            "return": [],
            "arguments": {
                "data": [],
                "stream": []
            }
        }
    }
}
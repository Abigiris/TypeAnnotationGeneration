{
    "CategoryLearning-master/wandb_logger.py": {
        "log_results": {
            "name": "log_results",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "cache": [
                    "Tuple[Hashable]",
                    "Tuple[str, int, str]",
                    "Dict[int, List[Any]]"
                ],
                "matched": [
                    "Dict[int, Set[int]]",
                    "float",
                    "Dict[str, Any]"
                ]
            }
        },
        "save_params": {
            "name": "save_params",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "catlearn.categorical_model.TrainableDecisionCatModel"
                ]
            }
        },
        "save_file": {
            "name": "save_file",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/algebra_models.py": {
        "Algebra.flatdim": {
            "name": "flatdim",
            "location": 23,
            "return": [
                "builtins.int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Algebra.dim": {
            "name": "dim",
            "location": 32,
            "return": [
                "builtins.int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Algebra.unit": {
            "name": "unit",
            "location": 40,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "data_tuple": [
                    "int",
                    "bool",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "Algebra.comp": {
            "name": "comp",
            "location": 50,
            "return": [
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "data1": [
                    "int",
                    "bytes",
                    "Optional[Sequence[T]]"
                ],
                "data2": [
                    "bytes",
                    "int",
                    "str"
                ]
            }
        },
        "Algebra.__repr__": {
            "name": "__repr__",
            "location": 61,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Algebra.equals": {
            "name": "equals",
            "location": 64,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "left": [
                    "torch.Tensor",
                    "Callable[[int], None]",
                    "Sequence[T]",
                    "float",
                    "str"
                ],
                "right": [
                    "torch.Tensor",
                    "Callable[[int], None]",
                    "Sequence[T]",
                    "float",
                    "str"
                ],
                "epsilon": [
                    "float"
                ]
            }
        },
        "VectAlgebra.__init__": {
            "name": "__init__",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ]
            }
        },
        "VectAlgebra.dim": {
            "name": "dim",
            "location": 94,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "VectAlgebra.flatdim": {
            "name": "flatdim",
            "location": 101,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "VectAlgebra.unit": {
            "name": "unit",
            "location": 107,
            "return": [
                "int",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data_tuple": [
                    "int",
                    "bool",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "VectAlgebra.comp": {
            "name": "comp",
            "location": 116,
            "return": [
                "Dict[str, Any]",
                "Dict[str, str]",
                "dict",
                "torch.LongTensor"
            ],
            "arguments": {
                "self": [],
                "data1": [
                    "bool",
                    "int",
                    "torch.Tensor",
                    "bytes"
                ],
                "data2": [
                    "bool",
                    "int"
                ]
            }
        },
        "VectMultAlgebra.__init__": {
            "name": "__init__",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ]
            }
        },
        "VectMultAlgebra.dim": {
            "name": "dim",
            "location": 147,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "VectMultAlgebra.flatdim": {
            "name": "flatdim",
            "location": 154,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "VectMultAlgebra.unit": {
            "name": "unit",
            "location": 160,
            "return": [
                "int",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data_tuple": [
                    "int",
                    "bool",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "VectMultAlgebra.comp": {
            "name": "comp",
            "location": 169,
            "return": [
                "Dict[str, Any]",
                "Dict[str, str]",
                "dict",
                "torch.LongTensor"
            ],
            "arguments": {
                "self": [],
                "data1": [
                    "bool",
                    "int",
                    "torch.Tensor",
                    "bytes"
                ],
                "data2": [
                    "bool",
                    "int"
                ]
            }
        },
        "MatrixAlgebra.__init__": {
            "name": "__init__",
            "location": 189,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ]
            }
        },
        "MatrixAlgebra.dim": {
            "name": "dim",
            "location": 198,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MatrixAlgebra.flatdim": {
            "name": "flatdim",
            "location": 205,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MatrixAlgebra.viewmat": {
            "name": "viewmat",
            "location": 211,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "vect": [
                    "torch.Tensor"
                ]
            }
        },
        "MatrixAlgebra.unit": {
            "name": "unit",
            "location": 224,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "data_tuple": [
                    "int",
                    "torch.Tensor",
                    "bytes",
                    "str"
                ]
            }
        },
        "MatrixAlgebra.comp": {
            "name": "comp",
            "location": 247,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "data1": [
                    "int",
                    "str",
                    "bytes"
                ],
                "data2": [
                    "int",
                    "float",
                    "bytes"
                ]
            }
        },
        "AffineAlgebra.__init__": {
            "name": "__init__",
            "location": 283,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ]
            }
        },
        "AffineAlgebra.dim": {
            "name": "dim",
            "location": 293,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "AffineAlgebra.flatdim": {
            "name": "flatdim",
            "location": 300,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "AffineAlgebra.viewmat": {
            "name": "viewmat",
            "location": 307,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "aff": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AffineAlgebra.viewvect": {
            "name": "viewvect",
            "location": 323,
            "return": [
                "str",
                "list",
                "Optional[BaseException]",
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "aff": [
                    "str",
                    "int"
                ]
            }
        },
        "AffineAlgebra.unit": {
            "name": "unit",
            "location": 334,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "data_tuple": [
                    "int",
                    "bool",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "AffineAlgebra.comp": {
            "name": "comp",
            "location": 361,
            "return": [
                "str",
                "Dict[bytes, int]",
                "Tuple[bytes, int]",
                "Tuple[int, List[int]]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data1": [
                    "Any",
                    "int",
                    "Mapping",
                    "Optional[Mapping]"
                ],
                "data2": [
                    "int",
                    "float",
                    "bytes"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/categorical_model.py": {
        "RelationModel.__call__": {
            "name": "__call__",
            "location": 27,
            "return": [
                "catlearn.tensor_utils.Tsor",
                "None"
            ],
            "arguments": {
                "self": [],
                "src": [
                    "bool",
                    "catlearn.tensor_utils.Tsor",
                    "typing.Iterable[int]",
                    "int",
                    "Iterable[int]"
                ],
                "dst": [
                    "bool",
                    "catlearn.tensor_utils.Tsor",
                    "typing.Iterable[int]",
                    "int",
                    "Iterable[int]"
                ],
                "rel": [
                    "ArrowType"
                ]
            }
        },
        "ScoringModel.__call__": {
            "name": "__call__",
            "location": 34,
            "return": [
                "catlearn.tensor_utils.Tsor",
                "None"
            ],
            "arguments": {
                "self": [],
                "src": [
                    "bool",
                    "catlearn.tensor_utils.Tsor",
                    "typing.Iterable[int]",
                    "int",
                    "Iterable[int]"
                ],
                "dst": [
                    "bool",
                    "catlearn.tensor_utils.Tsor",
                    "typing.Iterable[int]",
                    "int",
                    "Iterable[int]"
                ],
                "rel": [
                    "bool",
                    "catlearn.tensor_utils.Tsor",
                    "typing.Iterable[int]",
                    "int",
                    "Iterable[int]"
                ]
            }
        },
        "DecisionCatModel.__init__": {
            "name": "__init__",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "relation_model": [
                    "RelationModel"
                ],
                "label_universe": [
                    "Mapping[(ArrowType, Any)]"
                ],
                "scoring_model": [
                    "ScoringModel"
                ],
                "algebra_model": [
                    "catlearn.algebra_models.Algebra"
                ],
                "epsilon": [
                    "float"
                ]
            }
        },
        "DecisionCatModel.algebra": {
            "name": "algebra",
            "location": 92,
            "return": [
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "DecisionCatModel.label_universe": {
            "name": "label_universe",
            "location": 99,
            "return": [
                "MappingProxyType",
                "str",
                "Type[Any]",
                "mypy.types.Type"
            ],
            "arguments": {
                "self": []
            }
        },
        "DecisionCatModel.score": {
            "name": "score",
            "location": 105,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "source": [
                    "str",
                    "typing.Type",
                    "type",
                    "catlearn.tensor_utils.Tsor"
                ],
                "target": [
                    "str",
                    "bool",
                    "int"
                ],
                "relation": [
                    "str",
                    "bytearray",
                    "IO[bytes]",
                    "typing.IO",
                    "MutableMapping[str, str]",
                    "typing.MutableMapping"
                ]
            }
        },
        "DecisionCatModel.generate_cache": {
            "name": "generate_cache",
            "location": 121,
            "return": [
                "RelationCache",
                "str",
                "Optional[bool]",
                "Optional[int]",
                "torch.FloatTensor",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "Mapping[(NodeType, Any)]"
                ],
                "relations": [
                    "Iterable"
                ],
                "max_arrow_number": [
                    "Optional[int]"
                ]
            }
        },
        "DecisionCatModel.cost": {
            "name": "cost",
            "location": 133,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "Mapping[(NodeType, Any)]"
                ],
                "relations": [
                    "Iterable"
                ],
                "labels": [
                    "bool",
                    "str",
                    "dict",
                    "dict[, ]"
                ],
                "match_negatives": [
                    "bool"
                ],
                "max_arrow_number": [
                    "Optional[int]"
                ]
            }
        },
        "DecisionCatModel.save": {
            "name": "save",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        },
        "DecisionCatModel.load": {
            "name": "load",
            "location": 170,
            "return": [
                "DecisionCatModel"
            ],
            "arguments": {
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        },
        "TrainableDecisionCatModel.__init__": {
            "name": "__init__",
            "location": 201,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "relation_model": [
                    "RelationModel"
                ],
                "label_universe": [
                    "Mapping[(ArrowType, Any)]"
                ],
                "scoring_model": [
                    "ScoringModel"
                ],
                "algebra_model": [
                    "catlearn.algebra_models.Algebra"
                ],
                "optimizer": [
                    "dict[, ]",
                    "torch.Tensor",
                    "None",
                    "bool",
                    "torch.optim.Optimizer",
                    "typing.Type",
                    "Optional[dict]",
                    "dict",
                    "Type"
                ],
                "epsilon": [
                    "float"
                ]
            }
        },
        "TrainableDecisionCatModel.relation_dim": {
            "name": "relation_dim",
            "location": 224,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainableDecisionCatModel.named_parameters": {
            "name": "named_parameters",
            "location": 231,
            "return": [
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "recurse": [
                    "bool"
                ]
            }
        },
        "TrainableDecisionCatModel.freeze": {
            "name": "freeze",
            "location": 246,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainableDecisionCatModel.unfreeze": {
            "name": "unfreeze",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainableDecisionCatModel.total_cost": {
            "name": "total_cost",
            "location": 261,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainableDecisionCatModel.reset": {
            "name": "reset",
            "location": 267,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainableDecisionCatModel.train": {
            "name": "train",
            "location": 274,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "data_points": [
                    "Mapping[(NodeType, Any)]"
                ],
                "relations": [
                    "Iterable"
                ],
                "labels": [
                    "int",
                    "float",
                    "Union[Tuple[int, int], int]",
                    "tuple[typing.Union[int,int]]"
                ],
                "step": [
                    "bool"
                ],
                "match_negatives": [
                    "bool"
                ],
                "max_arrow_number": [
                    "Optional[int]"
                ]
            }
        },
        "TrainableDecisionCatModel.save": {
            "name": "save",
            "location": 305,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        },
        "TrainableDecisionCatModel.load": {
            "name": "load",
            "location": 312,
            "return": [
                "TrainableDecisionCatModel"
            ],
            "arguments": {
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/composition_graph.py": {
        "CompositeArrow.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nodes": [
                    "set[str]",
                    "Set[str]",
                    "list[int]",
                    "List[int]",
                    "int"
                ],
                "arrows": [
                    "int",
                    "None",
                    "str",
                    "list",
                    "list[typing.Union[str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str,str]]",
                    "bool"
                ]
            }
        },
        "CompositeArrow.derive": {
            "name": "derive",
            "location": 56,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositeArrow.suspend": {
            "name": "suspend",
            "location": 63,
            "return": [],
            "arguments": {
                "self": [],
                "source": [
                    "str"
                ],
                "target": [
                    "str"
                ]
            }
        },
        "CompositeArrow.nodes": {
            "name": "nodes",
            "location": 74,
            "return": [
                "int",
                "Iterable[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositeArrow.arrows": {
            "name": "arrows",
            "location": 81,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositeArrow.__getitem__": {
            "name": "__getitem__",
            "location": 87,
            "return": [
                "int",
                "str",
                "CompositeArrow",
                "bytes",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "Union[int, slice]",
                    "list[list[str]]",
                    "list[]",
                    "List[List[str]]",
                    "list"
                ]
            }
        },
        "CompositeArrow.__len__": {
            "name": "__len__",
            "location": 135,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositeArrow.__eq__": {
            "name": "__eq__",
            "location": 142,
            "return": [
                "bool",
                "float",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "List[int]",
                    "str",
                    "list[int]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "CompositeArrow.op": {
            "name": "op",
            "location": 151,
            "return": [
                "CompositeArrow",
                "int",
                "bytearray",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositeArrow.comp": {
            "name": "comp",
            "location": 157,
            "return": [
                "Optional[str]",
                "CompositeArrow"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "Callable",
                    "int",
                    "Union[\"RangeSet[T]\", Iterable[Any]]"
                ],
                "overlap": [
                    "bool",
                    "int",
                    "Callable"
                ]
            }
        },
        "CompositeArrow.__add__": {
            "name": "__add__",
            "location": 180,
            "return": [
                "CompositeArrow",
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "int",
                    "bool"
                ]
            }
        },
        "CompositeArrow.__matmul__": {
            "name": "__matmul__",
            "location": 196,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "CompositeArrow.__hash__": {
            "name": "__hash__",
            "location": 206,
            "return": [
                "int",
                "Tuple[int, int]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositeArrow.__repr__": {
            "name": "__repr__",
            "location": 213,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositionGraph.__init__": {
            "name": "__init__",
            "location": 231,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "comp": [
                    "int",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "str",
                    "Union[str, int]",
                    "bool"
                ],
                "arrows": [
                    "dict[str, typing.Any]",
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "Union[str, int]",
                    "bool"
                ]
            }
        },
        "CompositionGraph.graph": {
            "name": "graph",
            "location": 258,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositionGraph.add": {
            "name": "add",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "str",
                    "list"
                ]
            }
        },
        "CompositionGraph.flush": {
            "name": "flush",
            "location": 301,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositionGraph.arrows": {
            "name": "arrows",
            "location": 307,
            "return": [
                "typing.Generator[]",
                "List[str]",
                "str",
                "Tuple[int, int]",
                "List[Dict[str, str]]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "src": [
                    "str",
                    "None",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "tar": [
                    "str",
                    "None",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "arrow_length_range": [
                    "tuple[typing.Optional[int]]",
                    "int",
                    "str",
                    "float",
                    "Optional[str]"
                ]
            }
        },
        "CompositionGraph.__iter__": {
            "name": "__iter__",
            "location": 352,
            "return": [
                "int",
                "bool",
                "tuple",
                "List[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositionGraph.__len__": {
            "name": "__len__",
            "location": 358,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositionGraph.__getitem__": {
            "name": "__getitem__",
            "location": 364,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "CompositionGraph.__delitem__": {
            "name": "__delitem__",
            "location": 371,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "Dict[str, Any]"
                ]
            }
        },
        "CompositionGraph.__repr__": {
            "name": "__repr__",
            "location": 402,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompositionGraph.__init__._comp": {
            "name": "_comp",
            "location": 246,
            "return": [],
            "arguments": {
                "arrow": []
            }
        }
    },
    "CategoryLearning-master/catlearn/device_utils.py": {
        "to_device": {
            "name": "to_device",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "str"
                ],
                "model": [
                    "str",
                    "torch.nn.Module",
                    "IO[str]",
                    "int",
                    "bool"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/full_layer_models.py": {
        "couple_layered_models": {
            "name": "couple_layered_models",
            "location": 165,
            "return": [
                "LayeredModel"
            ],
            "arguments": {}
        },
        "reduce_model": {
            "name": "reduce_model",
            "location": 189,
            "return": [
                "LayeredModel"
            ],
            "arguments": {
                "model": [
                    "LayeredModel"
                ]
            }
        },
        "ConstantModel.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "func": [
                    "Callable"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "ConstantModel.__repr__": {
            "name": "__repr__",
            "location": 26,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstantModel.forward": {
            "name": "forward",
            "location": 35,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstantModel.named_parameters": {
            "name": "named_parameters",
            "location": 40,
            "return": [
                "Iterable[Tuple[(str, Any)]]"
            ],
            "arguments": {
                "self": [],
                "recurse": [
                    "bool"
                ]
            }
        },
        "ConstantModel.freeze": {
            "name": "freeze",
            "location": 45,
            "return": [
                "catlearn.tensor_utils.Tsor",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConstantModel.unfreeze": {
            "name": "unfreeze",
            "location": 48,
            "return": [
                "catlearn.tensor_utils.Tsor",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Sequence[int]"
                ],
                "output_shape": [
                    "Sequence[int]"
                ],
                "layers": [
                    "Iterable[Callable]"
                ]
            }
        },
        "LayeredModel.input_shape": {
            "name": "input_shape",
            "location": 75,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.input_ndim": {
            "name": "input_ndim",
            "location": 82,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.input_numel": {
            "name": "input_numel",
            "location": 89,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.output_shape": {
            "name": "output_shape",
            "location": 96,
            "return": [
                "int",
                "bytes",
                "torch.Tensor",
                "IO[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.output_ndim": {
            "name": "output_ndim",
            "location": 103,
            "return": [
                "int",
                "str",
                "List[int]",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.output_numel": {
            "name": "output_numel",
            "location": 110,
            "return": [
                "str",
                "int",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.children": {
            "name": "children",
            "location": 118,
            "return": [
                "typing.Callable[, ]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.named_parameters": {
            "name": "named_parameters",
            "location": 125,
            "return": [
                "Callable[([], Iterable)]"
            ],
            "arguments": {
                "self": [],
                "recurse": [
                    "bool"
                ]
            }
        },
        "LayeredModel.forward": {
            "name": "forward",
            "location": 132,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel._set_requires_grad_flag": {
            "name": "_set_requires_grad_flag",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "bool"
                ]
            }
        },
        "LayeredModel.freeze": {
            "name": "freeze",
            "location": 147,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayeredModel.unfreeze": {
            "name": "unfreeze",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FullPerceptron.__init__": {
            "name": "__init__",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Sequence[int]"
                ],
                "output_shape": [
                    "Sequence[int]"
                ],
                "num_units": [
                    "Sequence[int]"
                ],
                "activation_factory": [
                    "Callable[([], Any)]"
                ]
            }
        },
        "FullPerceptron._get_layer_sequence": {
            "name": "_get_layer_sequence",
            "location": 234,
            "return": [
                "Iterable"
            ],
            "arguments": {
                "self": [],
                "num_units": [
                    "Sequence[int]"
                ],
                "activation_factory": [
                    "Callable[([], Any)]"
                ]
            }
        },
        "FullPerceptron._view_input": {
            "name": "_view_input",
            "location": 251,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch_input": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "FullPerceptron._view_output": {
            "name": "_view_output",
            "location": 267,
            "return": [
                "str",
                "List[int]",
                "bytes",
                "torch.Tensor"
            ],
            "arguments": {
                "self": [],
                "batch_output": [
                    "memoryview",
                    "bytes",
                    "torch.Tensor",
                    "torch.FloatTensor",
                    "catlearn.tensor_utils.Tsor"
                ]
            }
        },
        "FullPerceptron.save": {
            "name": "save",
            "location": 282,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        },
        "FullPerceptron.load": {
            "name": "load",
            "location": 289,
            "return": [
                "FullPerceptron"
            ],
            "arguments": {
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        },
        "FullPerceptronWithRandomState.__init__": {
            "name": "__init__",
            "location": 308,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Sequence[int]"
                ],
                "output_shape": [
                    "Sequence[int]"
                ],
                "num_units": [
                    "Sequence[int]"
                ],
                "num_random": [
                    "int"
                ],
                "activation_factory": [
                    "Callable[([], Any)]"
                ],
                "random_generator": [
                    "Callable"
                ]
            }
        },
        "FullPerceptronWithRandomState.draw_state": {
            "name": "draw_state",
            "location": 340,
            "return": [
                "str",
                "float",
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "batch_shape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "FullPerceptronWithRandomState.augment_input": {
            "name": "augment_input",
            "location": 349,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "batch_input": [
                    "str",
                    "float"
                ]
            }
        },
        "FullPerceptronWithRandomState.save": {
            "name": "save",
            "location": 362,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        },
        "FullPerceptronWithRandomState.load": {
            "name": "load",
            "location": 369,
            "return": [
                "FullPerceptronWithRandomState"
            ],
            "arguments": {
                "flike": [
                    "Union[(str, IO)]"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/graph_utils.py": {
        "mapping_product": {
            "name": "mapping_product",
            "location": 28,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "mapping0": [
                    "Mapping"
                ],
                "mapping1": [
                    "Mapping"
                ]
            }
        },
        "generate_random_graph": {
            "name": "generate_random_graph",
            "location": 527,
            "return": [
                "float",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "nb_steps": [
                    "int"
                ],
                "random_generator": [
                    "random.Random"
                ]
            }
        },
        "pagerank_sample": {
            "name": "pagerank_sample",
            "location": 554,
            "return": [
                "Callable",
                "str",
                "Tuple[Any, Any, Any]",
                "trezor.utils.Writer"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ],
                "sample_vertices_size": [
                    "int"
                ],
                "rng": [
                    "random.Random"
                ]
            }
        },
        "hubs_sample": {
            "name": "hubs_sample",
            "location": 571,
            "return": [
                "Callable",
                "str",
                "Tuple[Any, Any, Any]",
                "trezor.utils.Writer"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ],
                "sample_vertices_size": [
                    "int"
                ],
                "rng": [
                    "random.Random"
                ]
            }
        },
        "authorities_sample": {
            "name": "authorities_sample",
            "location": 587,
            "return": [
                "Callable",
                "str",
                "Tuple[Any, Any, Any]",
                "trezor.utils.Writer"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ],
                "sample_vertices_size": [
                    "int"
                ],
                "rng": [
                    "random.Random"
                ]
            }
        },
        "sample": {
            "name": "sample",
            "location": 603,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "graph": [
                    "List[str]",
                    "Union[numpy.dtype, numpy.ndarray]",
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Dict[int, Set[int]]"
                ],
                "sample_vertices_size": [
                    "int"
                ],
                "ranking": [
                    "Callable[([Any], Mapping[(NodeType, float)])]"
                ],
                "rng": [
                    "random.Random"
                ],
                "with_edges": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "dict"
                ]
            }
        },
        "uniform_sample": {
            "name": "uniform_sample",
            "location": 653,
            "return": [
                "Callable",
                "str",
                "Tuple[Any, Any, Any]",
                "trezor.utils.Writer"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "Sequence",
                    "numpy.ndarray",
                    "float"
                ],
                "sample_vertices_size": [
                    "int"
                ],
                "rng": [
                    "random.Random"
                ],
                "with_edges": [
                    "bool"
                ]
            }
        },
        "random_walk_vertex_sample": {
            "name": "random_walk_vertex_sample",
            "location": 669,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "bool",
                    "List[List[bool]]"
                ],
                "rng": [
                    "random.Random"
                ],
                "n_iter": [
                    "int"
                ],
                "seeds": [
                    "Optional[Iterable[NodeType]]"
                ],
                "n_seeds": [
                    "int"
                ],
                "use_opposite": [
                    "bool"
                ]
            }
        },
        "random_walk_edge_sample": {
            "name": "random_walk_edge_sample",
            "location": 709,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "graph": [
                    "bool",
                    "List[str]"
                ],
                "rng": [
                    "random.Random"
                ],
                "n_iter": [
                    "int"
                ],
                "seeds": [
                    "Optional[Iterable[ArrowType]]"
                ],
                "n_seeds": [
                    "int"
                ],
                "use_opposite": [
                    "bool"
                ],
                "use_both_ends": [
                    "bool"
                ],
                "max_in_degree": [
                    "int"
                ],
                "max_out_degree": [
                    "int"
                ]
            }
        },
        "n_hop_sample": {
            "name": "n_hop_sample",
            "location": 799,
            "return": [
                "float",
                "numpy.ndarray",
                "str",
                "T",
                "int"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "List[List[bool]]"
                ],
                "n_hops": [
                    "int"
                ],
                "seeds": [
                    "Optional[str]",
                    "Optional[numpy.ndarray]",
                    "Optional[int]",
                    "bool",
                    "Optional[float]"
                ],
                "n_seeds": [
                    "int"
                ],
                "rng": [
                    "random.Random"
                ],
                "search_branching": [
                    "int"
                ],
                "max_degree_greedy": [
                    "int"
                ]
            }
        },
        "clean_selfloops": {
            "name": "clean_selfloops",
            "location": 865,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "Iterable[T]",
                    "int",
                    "set",
                    "networkx.Graph",
                    "float"
                ],
                "clean_edges": [
                    "bool"
                ],
                "clean_isolate_nodes": [
                    "bool"
                ]
            }
        },
        "clean_isolates": {
            "name": "clean_isolates",
            "location": 883,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [],
                "clean": [
                    "bool"
                ]
            }
        },
        "init_relation_vectors": {
            "name": "init_relation_vectors",
            "location": 894,
            "return": [
                "dict"
            ],
            "arguments": {
                "relation2id": [
                    "dict"
                ]
            }
        },
        "augment_graph": {
            "name": "augment_graph",
            "location": 904,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "Callable"
                ],
                "revers_rels": [
                    "dict"
                ]
            }
        },
        "create_revers_rels": {
            "name": "create_revers_rels",
            "location": 926,
            "return": [
                "List[dict]"
            ],
            "arguments": {
                "revers_rels_str": [
                    "dict"
                ],
                "relation2id": [
                    "dict"
                ]
            }
        },
        "DirectedGraph.__delitem__": {
            "name": "__delitem__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "node": []
            }
        },
        "DirectedGraph.__setitem__": {
            "name": "__setitem__",
            "location": 57,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "NodeType"
                ],
                "children": [
                    "Iterable[NodeType]"
                ]
            }
        },
        "DirectedGraph.op": {
            "name": "op",
            "location": 74,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedGraph.dualize_relations": {
            "name": "dualize_relations",
            "location": 80,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedGraph.under": {
            "name": "under",
            "location": 100,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "Sized"
                ]
            }
        },
        "DirectedGraph._under": {
            "name": "_under",
            "location": 111,
            "return": [
                "bool",
                "int",
                "Mapping[str, Any]",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "roots": [
                    "str",
                    "int",
                    "Union[str, IO[bytes]]",
                    "Optional[Callable[[None], None]]"
                ]
            }
        },
        "DirectedGraph.over": {
            "name": "over",
            "location": 126,
            "return": [
                "SendCh[trio.abc.Stream]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "str",
                    "bytes",
                    "Tuple[numpy.array, numpy.array]",
                    "int"
                ]
            }
        },
        "DirectedGraph.subgraph_nodes": {
            "name": "subgraph_nodes",
            "location": 133,
            "return": [
                "Mapping[str, Any]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "nodes": []
            }
        },
        "DirectedGraph.prune": {
            "name": "prune",
            "location": 141,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "Sequence[object]"
                ]
            }
        },
        "DirectedGraph.__repr__": {
            "name": "__repr__",
            "location": 161,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedGraph.__or__": {
            "name": "__or__",
            "location": 172,
            "return": [
                "int",
                "Type[Any]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "other_graph": [
                    "Union[int, float]",
                    "type",
                    "Iterable[Any]",
                    "AbstractSet[\"TemplateObjectVariable\"]",
                    "AbstractSet[\"TemplateActionTypeVariable\"]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "DirectedGraph.__and__": {
            "name": "__and__",
            "location": 191,
            "return": [
                "dict",
                "Dict[str, Any]",
                "numpy.ndarray",
                "bool"
            ],
            "arguments": {
                "self": [],
                "other_graph": [
                    "str",
                    "Exception",
                    "Iterable[str]"
                ]
            }
        },
        "DirectedGraph.__add__": {
            "name": "__add__",
            "location": 205,
            "return": [
                "int",
                "Type[Any]",
                "type",
                "dict"
            ],
            "arguments": {
                "self": [],
                "other_graph": [
                    "type",
                    "bool"
                ]
            }
        },
        "DirectedGraph.__matmul__": {
            "name": "__matmul__",
            "location": 230,
            "return": [
                "Dict[str, Any]",
                "Set[str]",
                "int",
                "Type"
            ],
            "arguments": {
                "self": [],
                "other_graph": [
                    "str",
                    "dict"
                ]
            }
        },
        "DirectedGraph.__mul__": {
            "name": "__mul__",
            "location": 256,
            "return": [
                "bool",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "other_graph": [
                    "float",
                    "Dict[str, Any]",
                    "T",
                    "MutableMapping[str, Any]",
                    "str"
                ]
            }
        },
        "DirectedGraph.remap_names": {
            "name": "remap_names",
            "location": 275,
            "return": [
                "dict",
                "List[Tuple[str, str]]",
                "Set[int]",
                "Callable[..., Awaitable[None]]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "key_func": [
                    "Tuple[Type[Any]]",
                    "type",
                    "Type",
                    "Sequence[str]",
                    "str",
                    "int"
                ]
            }
        },
        "DirectedGraph.integerify": {
            "name": "integerify",
            "location": 290,
            "return": [
                "str",
                "bool",
                "Optional[Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedGraph.stringify": {
            "name": "stringify",
            "location": 300,
            "return": [
                "bool",
                "bytes",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedGraph.rand_prune": {
            "name": "rand_prune",
            "location": 307,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "pruning_factor": [
                    "str",
                    "float",
                    "bool",
                    "int",
                    "Sequence[int]"
                ],
                "random_generator": [
                    "Optional[str]",
                    "str",
                    "bool",
                    "Optional[int]",
                    "Optional[\"Outcome\"]",
                    "Optional[bool]"
                ]
            }
        },
        "DirectedAcyclicGraph.__init__": {
            "name": "__init__",
            "location": 342,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedAcyclicGraph.ins": {
            "name": "ins",
            "location": 355,
            "return": [
                "List[int]",
                "List[List[int]]",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedAcyclicGraph.outs": {
            "name": "outs",
            "location": 362,
            "return": [
                "int",
                "str",
                "Mapping[str, object]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "DirectedAcyclicGraph.__setitem__": {
            "name": "__setitem__",
            "location": 368,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "NodeType"
                ],
                "children": [
                    "Iterable[NodeType]"
                ]
            }
        },
        "GraphRandomFactory.__init_subclass__": {
            "name": "__init_subclass__",
            "location": 405,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "type"
                ]
            }
        },
        "GraphRandomFactory.__init__": {
            "name": "__init__",
            "location": 414,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weights": [
                    "Sequence[float]"
                ],
                "nb_graphs": [
                    "int"
                ],
                "pruning_factor": [
                    "float"
                ],
                "random_generator": [
                    "random.Random"
                ]
            }
        },
        "GraphRandomFactory.erode": {
            "name": "erode",
            "location": 447,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "graph": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "GraphRandomFactory.nb_graphs": {
            "name": "nb_graphs",
            "location": 458,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphRandomFactory.graphs": {
            "name": "graphs",
            "location": 465,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphRandomFactory.weights": {
            "name": "weights",
            "location": 472,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphRandomFactory.ops": {
            "name": "ops",
            "location": 479,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphRandomFactory.ops_nargs": {
            "name": "ops_nargs",
            "location": 486,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GraphRandomFactory.__next__": {
            "name": "__next__",
            "location": 492,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": []
            }
        },
        "random_walk_edge_sample.get_degree_safe": {
            "name": "get_degree_safe",
            "location": 754,
            "return": [
                "str",
                "Optional[str]",
                "int",
                "list"
            ],
            "arguments": {
                "graph": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Hashable",
                    "T"
                ],
                "node": [
                    "bool",
                    "dict",
                    "Dict[str, Any]",
                    "Union[int, float, complex]",
                    "Union[Sequence[str], str]"
                ],
                "use_in_degree": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Hashable",
                    "T"
                ]
            }
        },
        "random_walk_edge_sample.can_add_edge": {
            "name": "can_add_edge",
            "location": 758,
            "return": [
                "Optional[int]",
                "Type",
                "Optional[str]",
                "Optional[Iterable[str]]",
                "List[str]",
                "Optional[Iterable[Any]]"
            ],
            "arguments": {
                "graph": [
                    "bool",
                    "int"
                ],
                "node": [
                    "bool",
                    "int"
                ],
                "use_in_degree": [
                    "bool",
                    "int"
                ],
                "allowed_degree": [
                    "bool",
                    "int"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/relation_cache.py": {
        "kl_match": {
            "name": "kl_match",
            "location": 22,
            "return": [
                "str",
                "torch.LongTensor",
                "torch.BoolTensor",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "score": [
                    "str",
                    "catlearn.tensor_utils.Tsor",
                    "bytes",
                    "int"
                ],
                "label": [
                    "None",
                    "catlearn.tensor_utils.Tsor",
                    "torch.Tensor"
                ],
                "against_negative": [
                    "bool"
                ]
            }
        },
        "NegativeMatch.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "abc.Hashable"
                ]
            }
        },
        "NegativeMatch.value": {
            "name": "value",
            "location": 54,
            "return": [
                "str",
                "int",
                "Type[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NegativeMatch.__hash__": {
            "name": "__hash__",
            "location": 60,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "NegativeMatch.__eq__": {
            "name": "__eq__",
            "location": 66,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other_object": [
                    "abc.Hashable"
                ]
            }
        },
        "NegativeMatch.__repr__": {
            "name": "__repr__",
            "location": 74,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache._graph_comp": {
            "name": "_graph_comp",
            "location": 88,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.__init__": {
            "name": "__init__",
            "location": 146,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rel_embed": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "label_universe": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "scorer": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "comp": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "datas": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "List[Dict[\"str\", Any]]",
                    "list[dict[\"str\", typing.Any]]",
                    "Dict[str, Dict[str, str]]",
                    "dict[str, dict[str, str]]"
                ],
                "arrows": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "Optional[bool]"
                ],
                "max_arrow_number": [
                    "int",
                    "float",
                    "bool",
                    "Set[Tuple[str, ...]]"
                ],
                "epsilon": [
                    "str",
                    "Sequence[str]",
                    "List[List[Any]]"
                ]
            }
        },
        "RelationCache.arrows": {
            "name": "arrows",
            "location": 208,
            "return": [
                "typing.Generator[]",
                "int",
                "list",
                "List[Dict]",
                "List[Tuple[int, float]]",
                "List[dict]",
                "List[str]",
                "Iterator[str]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "src": [
                    "int",
                    "str",
                    "None"
                ],
                "tar": [
                    "int",
                    "str",
                    "None"
                ],
                "arrow_length_range": [
                    "tuple[typing.Optional[int]]",
                    "int",
                    "str"
                ],
                "include_non_causal": [
                    "bool",
                    "str",
                    "int",
                    "Dict[str, str]"
                ]
            }
        },
        "RelationCache.causality_cost": {
            "name": "causality_cost",
            "location": 232,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.data": {
            "name": "data",
            "location": 238,
            "return": [
                "bool",
                "int",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "bool",
                    "int",
                    "Optional[Mapping[str, Any]]",
                    "BinaryIO"
                ]
            }
        },
        "RelationCache.label_universe": {
            "name": "label_universe",
            "location": 254,
            "return": [
                "MappingProxyType",
                "str",
                "Type[Any]",
                "mypy.types.Type"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.__getitem__": {
            "name": "__getitem__",
            "location": 260,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "RelationCache.__iter__": {
            "name": "__iter__",
            "location": 273,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.__len__": {
            "name": "__len__",
            "location": 279,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.__setitem__": {
            "name": "__setitem__",
            "location": 285,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "str",
                    "dict",
                    "dict[, ]"
                ],
                "data_point": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "RelationCache.__delitem__": {
            "name": "__delitem__",
            "location": 293,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "arrow": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "RelationCache.__repr__": {
            "name": "__repr__",
            "location": 299,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.flush": {
            "name": "flush",
            "location": 310,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache._get_worst_relation": {
            "name": "_get_worst_relation",
            "location": 319,
            "return": [
                "int",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationCache.prune_relations": {
            "name": "prune_relations",
            "location": 353,
            "return": [
                "set[]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "nb_to_keep": [
                    "int",
                    "Optional[int]",
                    "Optional[List[str]]",
                    "Optional[bool]"
                ]
            }
        },
        "RelationCache.build_composites": {
            "name": "build_composites",
            "location": 374,
            "return": [
                "tuple[set[]]",
                "bytes",
                "Callable[[bytes], bytes]",
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "max_arrow_number": [
                    "int",
                    "float"
                ]
            }
        },
        "RelationCache.match": {
            "name": "match",
            "location": 422,
            "return": [
                "bool",
                "Dict[str, Tuple[int, int]]",
                "str"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "Dict[str, Any]",
                    "int",
                    "dict[str, typing.Any]",
                    "IO[bytes]",
                    "typing.IO",
                    "list",
                    "list[]"
                ],
                "match_negatives": [
                    "bool",
                    "int",
                    "str",
                    "float",
                    "List[float]"
                ]
            }
        },
        "RelationCache._graph_comp.graph_comp": {
            "name": "graph_comp",
            "location": 97,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "graph": [],
                "arrow": []
            }
        }
    },
    "CategoryLearning-master/catlearn/tensor_utils.py": {
        "repeat_tensor": {
            "name": "repeat_tensor",
            "location": 19,
            "return": [
                "int",
                "List[str]",
                "str",
                "dict",
                "Sequence[str]"
            ],
            "arguments": {
                "to_repeat": [
                    "str",
                    "Match[Any]",
                    "bytes"
                ],
                "nb_repeats": [
                    "int"
                ],
                "axis": [
                    "int"
                ],
                "copy": [
                    "bool"
                ]
            }
        },
        "is_shape_broadcastable": {
            "name": "is_shape_broadcastable",
            "location": 50,
            "return": [
                "bool"
            ],
            "arguments": {
                "first_shape": [
                    "Sequence"
                ],
                "last_shape": [
                    "Sequence"
                ]
            }
        },
        "sorted_weighted_sum": {
            "name": "sorted_weighted_sum",
            "location": 63,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "to_sum": [
                    "list",
                    "Optional[str]",
                    "int",
                    "Union[Callable, str]"
                ],
                "weights": [
                    "Dict[str, float]",
                    "int",
                    "str"
                ],
                "axis": [
                    "int"
                ],
                "keepdim": [
                    "bool"
                ],
                "largest": [
                    "bool"
                ]
            }
        },
        "tensor_equals": {
            "name": "tensor_equals",
            "location": 106,
            "return": [
                "bool"
            ],
            "arguments": {
                "left": [
                    "float",
                    "int",
                    "torch.Tensor"
                ],
                "right": [
                    "float",
                    "int",
                    "torch.Tensor"
                ],
                "precision": [
                    "float"
                ]
            }
        },
        "full_like": {
            "name": "full_like",
            "location": 115,
            "return": [
                "int",
                "str",
                "List[int]",
                "Dict[str, Any]",
                "tuple"
            ],
            "arguments": {
                "value": [
                    "str",
                    "float",
                    "int",
                    "bool"
                ],
                "tensor": [
                    "int",
                    "str",
                    "bool"
                ],
                "shape": [
                    "Optional[Sequence[int]]"
                ]
            }
        },
        "zeros_like": {
            "name": "zeros_like",
            "location": 130,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "shape": [
                    "Optional[Sequence[int]]"
                ]
            }
        },
        "ones_like": {
            "name": "ones_like",
            "location": 140,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "shape": [
                    "Optional[Sequence[int]]"
                ]
            }
        },
        "clip_proba": {
            "name": "clip_proba",
            "location": 150,
            "return": [
                "float",
                "int",
                "bytearray",
                "bytes"
            ],
            "arguments": {
                "proba_vector": [
                    "Union[bool, str, int]",
                    "int",
                    "float",
                    "str"
                ],
                "dim": [
                    "int"
                ],
                "epsilon": [
                    "float"
                ]
            }
        },
        "subproba_kl_div": {
            "name": "subproba_kl_div",
            "location": 170,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predicted": [
                    "str",
                    "bool",
                    "torch.Tensor"
                ],
                "labels": [
                    "str",
                    "torch.nn.utils.rnn.PackedSequence",
                    "torch.Tensor"
                ],
                "epsilon": [
                    "float"
                ],
                "dim": [
                    "int"
                ],
                "keepdim": [
                    "bool"
                ]
            }
        },
        "remap_subproba": {
            "name": "remap_subproba",
            "location": 195,
            "return": [
                "int",
                "str",
                "float",
                "torch.nn.Module"
            ],
            "arguments": {
                "to_remap": [
                    "str",
                    "dict",
                    "Tuple[Dict, int]"
                ],
                "reference": [
                    "str",
                    "dict",
                    "Tuple[Dict, int]"
                ],
                "dim": [
                    "int"
                ]
            }
        },
        "AbstractModel.parameters": {
            "name": "parameters",
            "location": 243,
            "return": [
                "Iterable"
            ],
            "arguments": {
                "self": [],
                "recurse": [
                    "bool"
                ]
            }
        },
        "AbstractModel.named_parameters": {
            "name": "named_parameters",
            "location": 246,
            "return": [
                "Iterable[Tuple[(str, Any)]]"
            ],
            "arguments": {
                "self": [],
                "recurse": [
                    "bool"
                ]
            }
        },
        "AbstractModel.freeze": {
            "name": "freeze",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AbstractModel.unfreeze": {
            "name": "unfreeze",
            "location": 254,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "CategoryLearning-master/catlearn/utils.py": {
        "init_logger": {
            "name": "init_logger",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "str_color": {
            "name": "str_color",
            "location": 20,
            "return": [
                "str"
            ],
            "arguments": {
                "color_type": [
                    "str"
                ],
                "string": [
                    "str"
                ]
            }
        },
        "one_hot": {
            "name": "one_hot",
            "location": 38,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "sample_id": [
                    "int"
                ],
                "nb_samples": [
                    "int"
                ]
            }
        }
    },
    "CategoryLearning-master/catlearn/__init__.py": {},
    "CategoryLearning-master/data/config.py": {},
    "CategoryLearning-master/data/dataset.py": {
        "Dataset.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ],
                "ds_name": [
                    "str"
                ],
                "node_vec_dim": [
                    "int"
                ],
                "ds_pat": [
                    "dict"
                ],
                "prep_pat": [
                    "dict"
                ],
                "node2vec_path": [
                    "str"
                ]
            }
        },
        "Dataset.from_file": {
            "name": "from_file",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.check_path": {
            "name": "check_path",
            "location": 77,
            "return": [
                "str"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "Dataset.read_file": {
            "name": "read_file",
            "location": 83,
            "return": [
                "generator"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        },
        "Dataset.format_dataset": {
            "name": "format_dataset",
            "location": 98,
            "return": [
                "generator"
            ],
            "arguments": {
                "self": [],
                "raw_dataset": [
                    "generator"
                ]
            }
        },
        "Dataset._format_id_map": {
            "name": "_format_id_map",
            "location": 123,
            "return": [
                "Dict[(str, int)]"
            ],
            "arguments": {
                "self": [],
                "id_map": [
                    "generator"
                ],
                "ds_name": [
                    "str"
                ]
            }
        },
        "Dataset.preproc_dataset": {
            "name": "preproc_dataset",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.read_id_maps": {
            "name": "read_id_maps",
            "location": 136,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.init_entity_vectors": {
            "name": "init_entity_vectors",
            "location": 155,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.init_relation_vectors": {
            "name": "init_relation_vectors",
            "location": 170,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.load": {
            "name": "load",
            "location": 180,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "CategoryLearning-master/data/utils.py": {
        "read_file": {
            "name": "read_file",
            "location": 20,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "write_file": {
            "name": "write_file",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "to_file": [
                    "Union[(dict, list, set)]"
                ],
                "force": [
                    "bool"
                ]
            }
        },
        "get_entities_relations": {
            "name": "get_entities_relations",
            "location": 60,
            "return": [
                "Tuple[(List[str], List[str])]"
            ],
            "arguments": {
                "ds_list": [
                    "List[str]"
                ]
            }
        },
        "_update_set_with_missing": {
            "name": "_update_set_with_missing",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "entities_or_rels": [],
                "set_to_update": [
                    "set"
                ],
                "set_type": [
                    "str"
                ],
                "set_purpose": [
                    "str"
                ]
            }
        },
        "preprocess": {
            "name": "preprocess",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "preprocess_word2vec": {
            "name": "preprocess_word2vec",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "path_word2vec": [
                    "str"
                ],
                "path_dir_wordset": [
                    "str"
                ]
            }
        },
        "parse_args": {
            "name": "parse_args",
            "location": 163,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {}
        }
    },
    "CategoryLearning-master/data/__init__.py": {},
    "CategoryLearning-master/tests/test_algebramodels.py": {
        "ndim": {
            "name": "ndim",
            "location": 32,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "algebra": {
            "name": "algebra",
            "location": 38,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ],
                "ndim": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "batch_ndim": {
            "name": "batch_ndim",
            "location": 44,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "batch_shape": {
            "name": "batch_shape",
            "location": 50,
            "return": [
                "tuple[]",
                "torch.FloatTensor",
                "str",
                "List[int]",
                "int"
            ],
            "arguments": {
                "request": [
                    "int",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "batch_ndim": [
                    "int",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "data_point": {
            "name": "data_point",
            "location": 58,
            "return": [
                "torch.Tensor",
                "str",
                "Optional[torch.Tensor]",
                "int"
            ],
            "arguments": {
                "request": [
                    "Tuple[int]",
                    "tuple[int]",
                    "dict",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "batch_shape": [
                    "tuple[int]",
                    "Tuple[int]",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "sample_elem": {
            "name": "sample_elem",
            "location": 63,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "algebra": [
                    "algebra_models.Algebra"
                ],
                "batch_shape": [
                    "Tuple[(int, ...)]"
                ]
            }
        },
        "TestAlgebra.test_unit_shape": {
            "name": "test_unit_shape",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "algebra": [
                    "algebra_models.Algebra"
                ],
                "data_point": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "catlearn.algebra_models.Algebra",
                    "dict[str, typing.Any]",
                    "Union[str, Dict[str, Any]]",
                    "dict[, ]",
                    "Optional[Dict]",
                    "None"
                ],
                "batch_shape": [
                    "torch.Tensor",
                    "catlearn.algebra_models.Algebra",
                    "Union[str, Dict[str, Any]]",
                    "int",
                    "Optional[Dict]"
                ]
            }
        },
        "TestAlgebra.test_comp_shape": {
            "name": "test_comp_shape",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "algebra": [
                    "algebra_models.Algebra"
                ],
                "batch_shape": [
                    "tests.basilisp.helpers.CompileFn",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ]
            }
        },
        "TestAlgebra.test_unit_left": {
            "name": "test_unit_left",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {
                "algebra": [
                    "algebra_models.Algebra"
                ],
                "data_point": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "catlearn.algebra_models.Algebra",
                    "dict[str, typing.Any]",
                    "Union[str, Dict[str, Any]]",
                    "dict[, ]",
                    "Optional[Dict]",
                    "None"
                ],
                "batch_shape": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "catlearn.algebra_models.Algebra",
                    "dict[str, typing.Any]",
                    "Union[str, Dict[str, Any]]",
                    "dict[, ]",
                    "Optional[Dict]",
                    "None"
                ]
            }
        },
        "TestAlgebra.test_unit_right": {
            "name": "test_unit_right",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "algebra": [
                    "algebra_models.Algebra"
                ],
                "data_point": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "catlearn.algebra_models.Algebra",
                    "dict[str, typing.Any]",
                    "Union[str, Dict[str, Any]]",
                    "dict[, ]",
                    "Optional[Dict]",
                    "None"
                ],
                "batch_shape": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "catlearn.algebra_models.Algebra",
                    "dict[str, typing.Any]",
                    "Union[str, Dict[str, Any]]",
                    "dict[, ]",
                    "Optional[Dict]",
                    "None"
                ]
            }
        },
        "TestAlgebra.test_associativity": {
            "name": "test_associativity",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "algebra": [
                    "algebra_models.Algebra"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/test_categorical_model.py": {
        "nb_features": {
            "name": "nb_features",
            "location": 50,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "nb_scores": {
            "name": "nb_scores",
            "location": 56,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "nb_labels": {
            "name": "nb_labels",
            "location": 61,
            "return": [
                "int",
                "float",
                "bool"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "dim_rels": {
            "name": "dim_rels",
            "location": 66,
            "return": [
                "str",
                "bytes",
                "int"
            ],
            "arguments": {
                "request": []
            }
        },
        "algebra": {
            "name": "algebra",
            "location": 72,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ],
                "dim_rels": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "reload": {
            "name": "reload",
            "location": 78,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "relation": {
            "name": "relation",
            "location": 98,
            "return": [
                "CustomRelation",
                "str",
                "Dict[str, Any]",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "nb_labels": [
                    "int",
                    "str",
                    "catlearn.algebra_models.Algebra",
                    "dict[, ]",
                    "dict"
                ],
                "nb_features": [
                    "int",
                    "str",
                    "catlearn.algebra_models.Algebra",
                    "dict[, ]",
                    "dict"
                ],
                "algebra": [
                    "int",
                    "str",
                    "catlearn.algebra_models.Algebra",
                    "dict[, ]",
                    "dict"
                ]
            }
        },
        "label_universe": {
            "name": "label_universe",
            "location": 105,
            "return": [
                "int",
                "dict[, ]"
            ],
            "arguments": {
                "nb_labels": [
                    "int",
                    "str",
                    "float",
                    "List[Dict[str, float]]",
                    "list[dict[str, float]]",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "scoring": {
            "name": "scoring",
            "location": 133,
            "return": [
                "CustomScore",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "nb_features": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "nb_scores": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "algebra": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "arrow": {
            "name": "arrow",
            "location": 140,
            "return": [
                "CompositeArrow",
                "float",
                "Dict[str, int]",
                "Dict[str, float]",
                "Dict[str, Dict[str, int]]",
                "str",
                "bool"
            ],
            "arguments": {
                "request": [
                    "Mapping[int, catlearn.tensor_utils.Tsor]",
                    "int",
                    "typing.Mapping"
                ],
                "label_universe": [
                    "Mapping[int, catlearn.tensor_utils.Tsor]",
                    "int"
                ]
            }
        },
        "match_negatives": {
            "name": "match_negatives",
            "location": 147,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "request": [
                    "Set[str]",
                    "set[str]",
                    "str",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "get_labels": {
            "name": "get_labels",
            "location": 151,
            "return": [
                "str",
                "float",
                "tuple[typing.Union[int,str]]",
                "bool",
                "int",
                "tuple[typing.Union[int,int]]",
                "bytes"
            ],
            "arguments": {
                "nodes": [
                    "Iterable[int]"
                ],
                "nb_scores": [
                    "int"
                ],
                "nb_labels": [
                    "int"
                ]
            }
        },
        "get_trainable_model": {
            "name": "get_trainable_model",
            "location": 171,
            "return": [
                "catlearn.categorical_model.TrainableDecisionCatModel"
            ],
            "arguments": {
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ]
            }
        },
        "CustomRelation.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nb_features": [
                    "int"
                ],
                "nb_labels": [
                    "int"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ]
            }
        },
        "CustomRelation.named_parameters": {
            "name": "named_parameters",
            "location": 89,
            "return": [
                "str",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "CustomRelation.__call__": {
            "name": "__call__",
            "location": 92,
            "return": [
                "Tuple[float, float]",
                "float",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int",
                    "torch.Tensor"
                ],
                "y": [
                    "float",
                    "int",
                    "torch.Tensor"
                ],
                "l": [
                    "float",
                    "int",
                    "torch.Tensor"
                ]
            }
        },
        "label_universe.one_hot": {
            "name": "one_hot",
            "location": 107,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "label": [
                    "str",
                    "int",
                    "List[int]"
                ]
            }
        },
        "CustomScore.__init__": {
            "name": "__init__",
            "location": 115,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nb_features": [
                    "int"
                ],
                "nb_scores": [
                    "int"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ]
            }
        },
        "CustomScore.named_parameters": {
            "name": "named_parameters",
            "location": 123,
            "return": [
                "str",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "CustomScore.__call__": {
            "name": "__call__",
            "location": 126,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "src": [
                    "int",
                    "str",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "torch.device"
                ],
                "dst": [
                    "int",
                    "str",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "torch.device"
                ],
                "rel": [
                    "int",
                    "str",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "torch.device"
                ]
            }
        },
        "TestRelationCache.get_cache": {
            "name": "get_cache",
            "location": 204,
            "return": [
                "dict",
                "Dict[str, Any]",
                "torch.Tensor",
                "Optional[torch.Tensor]",
                "float",
                "int"
            ],
            "arguments": {
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "data_dim": [
                    "int"
                ],
                "datas": [
                    "Optional[Mapping[(int, Any)]]"
                ]
            }
        },
        "TestRelationCache.test_relation": {
            "name": "test_relation",
            "location": 226,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_features": [
                    "int"
                ],
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "arrow": [
                    "str"
                ]
            }
        },
        "TestRelationCache.test_score": {
            "name": "test_score",
            "location": 252,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_features": [
                    "int"
                ],
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "arrow": [
                    "Dict[str, Any]",
                    "List[str]",
                    "str",
                    "int"
                ]
            }
        },
        "TestRelationCache.test_matching": {
            "name": "test_matching",
            "location": 288,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_features": [
                    "int"
                ],
                "nb_labels": [
                    "int"
                ],
                "nb_scores": [
                    "int"
                ],
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "arrow": [
                    "str",
                    "int"
                ],
                "match_negatives": [
                    "bool"
                ]
            }
        },
        "TestRelationCache.test_prune": {
            "name": "test_prune",
            "location": 370,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_features": [
                    "int"
                ],
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "arrow": [
                    "str",
                    "int"
                ],
                "nb_to_prune": [
                    "int"
                ]
            }
        },
        "TestRelationCache.test_build_composites": {
            "name": "test_build_composites",
            "location": 410,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_labels": [
                    "int"
                ],
                "arrow": [
                    "int",
                    "bytes",
                    "str",
                    "dict",
                    "Dict[str, Any]",
                    "Callable"
                ],
                "max_arrow_length": [
                    "int"
                ],
                "max_arrow_number": [
                    "int"
                ]
            }
        },
        "TestDecisionCatModel.test_cost": {
            "name": "test_cost",
            "location": 460,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "str",
                    "int"
                ],
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "nb_features": [
                    "int"
                ],
                "nb_labels": [
                    "int"
                ],
                "nb_scores": [
                    "int"
                ],
                "match_negatives": [
                    "bool"
                ]
            }
        },
        "TestTrainableDecisionCatModel.test_train_without_update": {
            "name": "test_train_without_update",
            "location": 516,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "str",
                    "Callable",
                    "list[]",
                    "int",
                    "list"
                ],
                "relation": [
                    "catlearn.categorical_model.RelationModel"
                ],
                "label_universe": [
                    "Mapping[(int, Any)]"
                ],
                "scoring": [
                    "catlearn.categorical_model.ScoringModel"
                ],
                "algebra": [
                    "catlearn.algebra_models.Algebra"
                ],
                "nb_features": [
                    "int"
                ],
                "nb_labels": [
                    "int"
                ],
                "nb_scores": [
                    "int"
                ],
                "reload": [
                    "bool"
                ],
                "match_negatives": [
                    "bool"
                ]
            }
        },
        "TestTrainableDecisionCatModel.test_train_with_update": {
            "name": "test_train_with_update",
            "location": 570,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "str",
                    "Callable"
                ],
                "relation": [
                    "typing.Mapping",
                    "int",
                    "catlearn.categorical_model.ScoringModel",
                    "str",
                    "Mapping[int, catlearn.tensor_utils.Tsor]",
                    "catlearn.categorical_model.RelationModel",
                    "catlearn.algebra_models.Algebra"
                ],
                "label_universe": [
                    "typing.Mapping",
                    "int",
                    "catlearn.categorical_model.ScoringModel",
                    "str",
                    "Mapping[int, catlearn.tensor_utils.Tsor]",
                    "catlearn.categorical_model.RelationModel",
                    "catlearn.algebra_models.Algebra"
                ],
                "scoring": [
                    "typing.Mapping",
                    "int",
                    "catlearn.categorical_model.ScoringModel",
                    "str",
                    "Mapping[int, catlearn.tensor_utils.Tsor]",
                    "catlearn.categorical_model.RelationModel",
                    "catlearn.algebra_models.Algebra"
                ],
                "algebra": [
                    "typing.Mapping",
                    "int",
                    "catlearn.categorical_model.ScoringModel",
                    "str",
                    "Mapping[int, catlearn.tensor_utils.Tsor]",
                    "catlearn.categorical_model.RelationModel",
                    "catlearn.algebra_models.Algebra"
                ],
                "nb_features": [
                    "int",
                    "float"
                ],
                "nb_labels": [
                    "Callable",
                    "bool",
                    "typing.Callable[, ]",
                    "float"
                ],
                "nb_steps": [
                    "int",
                    "list[str]",
                    "str",
                    "catlearn.categorical_model.ScoringModel",
                    "torch.LongTensor",
                    "List[str]"
                ],
                "nb_scores": [
                    "Callable",
                    "bool",
                    "typing.Callable[, ]",
                    "float"
                ],
                "match_negatives": [
                    "bool",
                    "str",
                    "typing.Callable[, ]",
                    "Callable",
                    "int"
                ]
            }
        },
        "TestRelationCache.test_build_composites.relation": {
            "name": "relation",
            "location": 420,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "_": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "__": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "___": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestRelationCache.test_build_composites.scoring": {
            "name": "scoring",
            "location": 426,
            "return": [
                "bytes",
                "str",
                "bool"
            ],
            "arguments": {
                "src": [
                    "str",
                    "int"
                ],
                "dst": [
                    "str",
                    "int"
                ],
                "rel": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/test_composition_graph.py": {
        "to_add": {
            "name": "to_add",
            "location": 22,
            "return": [
                "str",
                "Tuple[str, str]",
                "int",
                "dict"
            ],
            "arguments": {
                "request": []
            }
        },
        "repr_comp": {
            "name": "repr_comp",
            "location": 29,
            "return": [
                "str"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "arrow": [
                    "Sequence[T]",
                    "str",
                    "Dict[str, Any]",
                    "catlearn.composition_graph.CompositeArrow[str, str]",
                    "List[str]",
                    "List[int]",
                    "list"
                ]
            }
        },
        "hex_arrow": {
            "name": "hex_arrow",
            "location": 43,
            "return": [
                "CompositeArrow",
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "length": [
                    "int"
                ]
            }
        },
        "TestCompositeArrow.test_getitem": {
            "name": "test_getitem",
            "location": 170,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "Union[int, slice]",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]"
                ],
                "index": [
                    "Union[(int, slice)]"
                ],
                "expected_result": [
                    "bool",
                    "dict[, ]",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "dict"
                ]
            }
        },
        "TestCompositeArrow.test_derive": {
            "name": "test_derive",
            "location": 184,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "str",
                    "Callable[..., Awaitable]",
                    "Union[int, slice]"
                ],
                "expected_result": [
                    "bool",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "str",
                    "typing.Mapping",
                    "Mapping[str, Any]",
                    "dict[str, typing.Any]",
                    "None",
                    "Optional[Dict[str, Any]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "TestCompositeArrow.test_suspend": {
            "name": "test_suspend",
            "location": 194,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "str",
                    "Iterable[Tuple[int, int]]"
                ]
            }
        },
        "TestCompositeArrow.test_op": {
            "name": "test_op",
            "location": 207,
            "return": [
                "None"
            ],
            "arguments": {
                "arrow": [
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]"
                ],
                "expected_result": [
                    "bool",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "str",
                    "typing.Mapping",
                    "Mapping[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ]
            }
        },
        "TestCompositeArrow.test_binary_op": {
            "name": "test_binary_op",
            "location": 217,
            "return": [
                "None"
            ],
            "arguments": {
                "binary_op": [
                    "Callable[([Any, Any], Any)]"
                ],
                "first_operand": [
                    "typing.Callable[A, typing.Any]",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "dict[typing.Any, int]",
                    "str",
                    "Callable[[Any, Any], Any]",
                    "list[str]",
                    "Dict[Any, int]",
                    "List[str]"
                ],
                "second_operand": [
                    "typing.Callable[A, typing.Any]",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "dict[typing.Any, int]",
                    "str",
                    "Callable[[Any, Any], Any]",
                    "list[str]",
                    "Dict[Any, int]",
                    "List[str]"
                ],
                "expected_result": [
                    "dict",
                    "str",
                    "dict[, ]",
                    "Optional[List]",
                    "list[]",
                    "Tuple[int, int]",
                    "None",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "TestCompositionGraph.test_getitem": {
            "name": "test_getitem",
            "location": 239,
            "return": [
                "None"
            ],
            "arguments": {
                "to_add": [
                    "catlearn.composition_graph.CompositeArrow[str, str]",
                    "list",
                    "dict",
                    "set",
                    "Set[frozenset[int]]"
                ]
            }
        },
        "TestCompositionGraph.test_add": {
            "name": "test_add",
            "location": 252,
            "return": [
                "None"
            ],
            "arguments": {
                "to_add": [
                    "catlearn.composition_graph.CompositeArrow[str, str]",
                    "list",
                    "dict",
                    "int",
                    "set"
                ]
            }
        },
        "TestCompositionGraph.test_del": {
            "name": "test_del",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "to_add": [
                    "catlearn.composition_graph.CompositeArrow[str, str]",
                    "List[str]",
                    "List[Dict[str, Any]]",
                    "list"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/test_data.py": {
        "TestDataset.test_dataset": {
            "name": "test_dataset",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "initializer_dict": [
                    "dict"
                ],
                "expected_graph": [
                    "int",
                    "bytes",
                    "gluonts.datasecommon.Dataset"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/test_fulllayermodels.py": {
        "batch_shape": {
            "name": "batch_shape",
            "location": 32,
            "return": [
                "tuple[]",
                "str",
                "torch.Tensor",
                "Optional[torch.Tensor]",
                "dict",
                "torch.FloatTensor",
                "Dict[str, Any]"
            ],
            "arguments": {
                "request": [
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "input_shape": {
            "name": "input_shape",
            "location": 38,
            "return": [
                "tuple[]",
                "str",
                "torch.Tensor",
                "Optional[torch.Tensor]",
                "dict",
                "torch.FloatTensor",
                "Dict[str, Any]"
            ],
            "arguments": {
                "request": [
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "output_shape": {
            "name": "output_shape",
            "location": 44,
            "return": [
                "tuple[]",
                "str",
                "bytes"
            ],
            "arguments": {
                "request": []
            }
        },
        "num_units": {
            "name": "num_units",
            "location": 50,
            "return": [
                "list[]",
                "List[str]",
                "str",
                "List[Dict]",
                "List[List[Any]]",
                "Union[str, List[Any]]",
                "list"
            ],
            "arguments": {
                "request": [
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "num_random": {
            "name": "num_random",
            "location": 56,
            "return": [
                "int",
                "str",
                "Optional[Dict]",
                "List[str]"
            ],
            "arguments": {
                "request": []
            }
        },
        "reload": {
            "name": "reload",
            "location": 62,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "test_constant_model": {
            "name": "test_constant_model",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "TestLayeredModel.get_layered_model": {
            "name": "get_layered_model",
            "location": 80,
            "return": [
                "catlearn.full_layer_models.LayeredModel"
            ],
            "arguments": {
                "nlayer": [
                    "int",
                    "bytearray",
                    "Tuple[int]",
                    "tuple[int]"
                ]
            }
        },
        "TestLayeredModel.test_creation": {
            "name": "test_creation",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLayeredModel.test_reduce_model": {
            "name": "test_reduce_model",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLayeredModel.test_couple_models": {
            "name": "test_couple_models",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFullPerceptron.get_model": {
            "name": "get_model",
            "location": 134,
            "return": [
                "catlearn.full_layer_models.FullPerceptron"
            ],
            "arguments": {
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptron.test_output_shape": {
            "name": "test_output_shape",
            "location": 147,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "batch_shape": [
                    "Tuple[(int, ...)]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptron.test_params_list": {
            "name": "test_params_list",
            "location": 164,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptron.test_children_list": {
            "name": "test_children_list",
            "location": 178,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptronWithRandomState.get_model": {
            "name": "get_model",
            "location": 208,
            "return": [
                "catlearn.full_layer_models.FullPerceptronWithRandomState"
            ],
            "arguments": {
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "num_random": [
                    "int"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptronWithRandomState.test_draw_state": {
            "name": "test_draw_state",
            "location": 223,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "num_random": [
                    "int"
                ],
                "batch_shape": [
                    "Tuple[(int, ...)]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptronWithRandomState.test_input_augment": {
            "name": "test_input_augment",
            "location": 240,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "num_random": [
                    "int"
                ],
                "batch_shape": [
                    "Tuple[(int, ...)]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptronWithRandomState.test_output_shape": {
            "name": "test_output_shape",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "num_random": [
                    "int"
                ],
                "batch_shape": [
                    "Tuple[(int, ...)]"
                ],
                "reload": [
                    "bool"
                ]
            }
        },
        "TestFullPerceptronWithRandomState.test_params_list": {
            "name": "test_params_list",
            "location": 283,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "num_random": [
                    "int"
                ],
                "reload": [
                    "int",
                    "float",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "None",
                    "Sequence[int]",
                    "Dict[str, torch.LongTensor]",
                    "typing.Sequence[int]",
                    "dict[str, torch.LongTensor]"
                ]
            }
        },
        "TestFullPerceptronWithRandomState.test_children_list": {
            "name": "test_children_list",
            "location": 298,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[(int, ...)]"
                ],
                "output_shape": [
                    "Tuple[(int, ...)]"
                ],
                "num_units": [
                    "List[int]"
                ],
                "num_random": [
                    "int"
                ],
                "reload": [
                    "bool"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/test_graph_utils.py": {
        "seed": {
            "name": "seed",
            "location": 30,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "pruning_factor": {
            "name": "pruning_factor",
            "location": 38,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "nb_steps": {
            "name": "nb_steps",
            "location": 453,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "weights": {
            "name": "weights",
            "location": 464,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestDirectedGraph.test_init": {
            "name": "test_init",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "initializer_dict": [
                    "Dict[(Hashable, Iterable[Hashable])]"
                ],
                "expected_dict": [
                    "Optional[Dict[(Hashable, FrozenSet[Hashable])]]"
                ]
            }
        },
        "TestDirectedGraph.test_op": {
            "name": "test_op",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "initializer_dict": [
                    "Dict[(Hashable, Iterable[Hashable])]"
                ],
                "expected_op": [
                    "int",
                    "catlearn.graph_utils.DirectedGraph"
                ]
            }
        },
        "TestDirectedGraph.test_delitem": {
            "name": "test_delitem",
            "location": 259,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "Callable"
                ],
                "node_to_remove": [
                    "Hashable"
                ],
                "expected_graph": [
                    "int",
                    "catlearn.graph_utils.DirectedGraph"
                ]
            }
        },
        "TestDirectedGraph.test_setitem": {
            "name": "test_setitem",
            "location": 281,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "catlearn.graph_utils.DirectedGraph",
                    "list[str]",
                    "Optional[List[str]]",
                    "None"
                ],
                "node_to_add": [
                    "Hashable"
                ],
                "children": [
                    "Iterable[Hashable]"
                ],
                "expected_graph": [
                    "typing.Callable[, ]",
                    "int",
                    "catlearn.graph_utils.DirectedGraph",
                    "Callable"
                ]
            }
        },
        "TestDirectedGraph.test_len": {
            "name": "test_len",
            "location": 298,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "str",
                    "catlearn.graph_utils.DirectedGraph"
                ],
                "expected_length": [
                    "int"
                ]
            }
        },
        "TestDirectedGraph.test_iter": {
            "name": "test_iter",
            "location": 306,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "set[]",
                    "str",
                    "set",
                    "catlearn.graph_utils.DirectedGraph"
                ],
                "nodes_set": [
                    "set"
                ]
            }
        },
        "TestDirectedGraph.test_under": {
            "name": "test_under",
            "location": 314,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "set[typing.Hashable]",
                    "Set[Hashable]",
                    "typing.Hashable",
                    "catlearn.graph_utils.DirectedGraph",
                    "typing.Callable[, ]",
                    "Hashable",
                    "list[]",
                    "Callable",
                    "list"
                ],
                "node": [
                    "Hashable"
                ],
                "nodes_set": [
                    "Set[Hashable]"
                ]
            }
        },
        "TestDirectedGraph.test_over": {
            "name": "test_over",
            "location": 322,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "set[typing.Hashable]",
                    "Set[Hashable]",
                    "typing.Hashable",
                    "catlearn.graph_utils.DirectedGraph",
                    "typing.Callable[, ]",
                    "Hashable",
                    "list[]",
                    "Callable",
                    "list"
                ],
                "node": [
                    "Hashable"
                ],
                "nodes_set": [
                    "Set[Hashable]"
                ]
            }
        },
        "TestDirectedGraph.test_subgraph": {
            "name": "test_subgraph",
            "location": 330,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "catlearn.graph_utils.DirectedGraph",
                    "set[typing.Hashable]",
                    "int",
                    "Set[Hashable]",
                    "list[]",
                    "list",
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "nodes_set": [
                    "Set[Hashable]"
                ],
                "expected_graph": [
                    "catlearn.graph_utils.DirectedGraph",
                    "set[typing.Hashable]",
                    "int",
                    "Set[Hashable]",
                    "list[]",
                    "list",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "TestDirectedGraph.test_binary_operator": {
            "name": "test_binary_operator",
            "location": 338,
            "return": [
                "None"
            ],
            "arguments": {
                "binary_op": [
                    "Callable[([Any, Any], Any)]"
                ],
                "first_graph": [
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "second_graph": [
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "expected_graph": [
                    "typing.Callable[A, typing.Any]",
                    "str",
                    "catlearn.composition_graph.CompositeArrow[Hashable, Hashable]",
                    "Callable[[Any, Any], Any]"
                ]
            }
        },
        "TestDirectedGraph.test_prune": {
            "name": "test_prune",
            "location": 353,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "Callable",
                    "set",
                    "catlearn.graph_utils.DirectedGraph",
                    "bool"
                ],
                "node_to_prune": [
                    "Hashable"
                ],
                "expected_graph": [
                    "int",
                    "catlearn.graph_utils.DirectedGraph"
                ]
            }
        },
        "TestDirectedGraph.test_integerify": {
            "name": "test_integerify",
            "location": 364,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "str",
                    "Dict[str, Any]"
                ],
                "expected_graph": [
                    "str",
                    "catlearn.graph_utils.DirectedGraph",
                    "int",
                    "bytearray",
                    "list[tuple[typing.Union[str,typing.Any]]]",
                    "list[str]",
                    "List[Tuple[str, Any]]",
                    "List[str]"
                ]
            }
        },
        "TestDirectedGraph.test_stringify": {
            "name": "test_stringify",
            "location": 377,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "str",
                    "Dict[str, Any]"
                ],
                "expected_graph": [
                    "str",
                    "catlearn.graph_utils.DirectedGraph",
                    "int",
                    "bytearray",
                    "list[tuple[typing.Union[str,typing.Any]]]",
                    "list[str]",
                    "List[Tuple[str, Any]]",
                    "List[str]"
                ]
            }
        },
        "TestDirectedGraph.test_rand_prune": {
            "name": "test_rand_prune",
            "location": 391,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "pruning_factor": [
                    "float"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "TestDirectedGraph.test_dualize_relations": {
            "name": "test_dualize_relations",
            "location": 412,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "bool",
                    "List[str]",
                    "int",
                    "Dict[str, int]",
                    "Union[List[str], List[Any]]"
                ],
                "expected_graph": [
                    "str",
                    "catlearn.graph_utils.DirectedGraph",
                    "dict[, ]",
                    "dict"
                ]
            }
        },
        "TestAcyclicDirectedGraph.test_init": {
            "name": "test_init",
            "location": 435,
            "return": [
                "None"
            ],
            "arguments": {
                "initializer_dict": [
                    "Dict[(Hashable, Iterable[Hashable])]"
                ],
                "has_loops": [
                    "bool"
                ]
            }
        },
        "TestGraphRandomFactory.test_result_equality": {
            "name": "test_result_equality",
            "location": 487,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_graphs": [
                    "int"
                ],
                "initial_graphs": [
                    "List[catlearn.graph_utils.DirectedAcyclicGraph]"
                ],
                "nb_steps": [
                    "int"
                ],
                "weights": [
                    "Tuple[(float, float, float, float, float)]"
                ],
                "pruning_factor": [
                    "float"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "TestSubgraphSampling.rng": {
            "name": "rng",
            "location": 523,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "TestSubgraphSampling.nb_steps": {
            "name": "nb_steps",
            "location": 529,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubgraphSampling.graph": {
            "name": "graph",
            "location": 537,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "nb_steps": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "rng": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubgraphSampling.n_seeds": {
            "name": "n_seeds",
            "location": 545,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubgraphSampling.n_iter": {
            "name": "n_iter",
            "location": 551,
            "return": [
                "int"
            ],
            "arguments": {
                "request": [
                    "str",
                    "Set[str]",
                    "set[str]",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "TestSubgraphSampling.max_degree": {
            "name": "max_degree",
            "location": 557,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubgraphSampling.test_sample": {
            "name": "test_sample",
            "location": 562,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "tests.basilisp.helpers.CompileFn"
                ],
                "rng": [
                    "str",
                    "int"
                ]
            }
        },
        "TestSubgraphSampling.test_uniform": {
            "name": "test_uniform",
            "location": 571,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "int"
                ],
                "rng": [
                    "str",
                    "float",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "TestSubgraphSampling.test_pagerank": {
            "name": "test_pagerank",
            "location": 581,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "graph": [
                    "str",
                    "int"
                ],
                "rng": [
                    "str",
                    "float",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "TestSubgraphSampling.test_hubs": {
            "name": "test_hubs",
            "location": 590,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "graph": [
                    "str",
                    "int"
                ],
                "rng": [
                    "str",
                    "float",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "TestSubgraphSampling.test_authorities": {
            "name": "test_authorities",
            "location": 599,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "graph": [
                    "str",
                    "int"
                ],
                "rng": [
                    "str",
                    "float",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_vertex": {
            "name": "test_random_walk_vertex",
            "location": 606,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "float",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "None",
                    "random.Random"
                ],
                "rng": [
                    "int",
                    "float",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "None",
                    "random.Random"
                ],
                "n_iter": [
                    "int",
                    "List[int]",
                    "list[int]"
                ],
                "n_seeds": [
                    "int",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_vertex_specified_root": {
            "name": "test_random_walk_vertex_specified_root",
            "location": 615,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "list[int]",
                    "bool",
                    "List[int]",
                    "Iterable[T]"
                ],
                "rng": [
                    "bool",
                    "List[int]",
                    "Iterable[T]"
                ],
                "n_iter": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_vertex_with_dual": {
            "name": "test_random_walk_vertex_with_dual",
            "location": 623,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "bool",
                    "Iterable[Any]",
                    "typing.Iterable[typing.Any]"
                ],
                "rng": [
                    "bool",
                    "Iterable[Any]",
                    "typing.Iterable[typing.Any]"
                ],
                "n_iter": [
                    "int"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_edge": {
            "name": "test_random_walk_edge",
            "location": 629,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]",
                    "Optional[int]",
                    "None"
                ],
                "rng": [
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]",
                    "Optional[int]",
                    "None"
                ],
                "n_iter": [
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]",
                    "Optional[int]",
                    "None"
                ],
                "n_seeds": [
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]",
                    "Optional[int]",
                    "None"
                ],
                "max_degree": [
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_edge_use_all": {
            "name": "test_random_walk_edge_use_all",
            "location": 640,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "int",
                    "str"
                ],
                "rng": [
                    "int",
                    "str"
                ],
                "n_iter": [
                    "int",
                    "str"
                ],
                "n_seeds": [
                    "int",
                    "str"
                ],
                "max_degree": [
                    "int",
                    "str"
                ]
            }
        },
        "TestSubgraphSampling.n_hops": {
            "name": "n_hops",
            "location": 650,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubgraphSampling.test_n_hop_sampler": {
            "name": "test_n_hop_sampler",
            "location": 655,
            "return": [
                "None"
            ],
            "arguments": {
                "graph": [
                    "int"
                ],
                "rng": [
                    "float",
                    "int",
                    "bytes"
                ],
                "n_hops": [
                    "float",
                    "int",
                    "bytes"
                ],
                "n_seeds": [
                    "float",
                    "int",
                    "bytes"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_edge_star_pattern": {
            "name": "test_random_walk_edge_star_pattern",
            "location": 661,
            "return": [
                "None"
            ],
            "arguments": {
                "rng": [
                    "bool"
                ],
                "max_degree": [
                    "int",
                    "str"
                ]
            }
        },
        "TestSubgraphSampling.chain_length": {
            "name": "chain_length",
            "location": 691,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_edge_chain_pattern": {
            "name": "test_random_walk_edge_chain_pattern",
            "location": 696,
            "return": [
                "None"
            ],
            "arguments": {
                "rng": [
                    "bool"
                ],
                "chain_length": [
                    "str"
                ]
            }
        },
        "TestSubgraphSampling.test_random_walk_edge_functional_pattern": {
            "name": "test_random_walk_edge_functional_pattern",
            "location": 724,
            "return": [
                "None"
            ],
            "arguments": {
                "rng": [
                    "bool"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/test_tools.py": {
        "pytest_generate_tests": {
            "name": "pytest_generate_tests",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "metafunc": [
                    "dict",
                    "Dict[str, Any]",
                    "type"
                ]
            }
        },
        "random_int_list": {
            "name": "random_int_list",
            "location": 44,
            "return": [
                "Callable[([], Iterator[int])]"
            ],
            "arguments": {
                "min_length": [
                    "int"
                ],
                "max_length": [
                    "int"
                ],
                "min_member": [
                    "int"
                ],
                "max_member": [
                    "int"
                ]
            }
        }
    },
    "CategoryLearning-master/tests/__init__.py": {}
}
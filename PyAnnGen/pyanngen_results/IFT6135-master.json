{
    "IFT6135-master/Assignment1/download.py": {},
    "IFT6135-master/Assignment1/nn.py": {
        "NN.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dims": [
                    "tuple[int]"
                ],
                "n_hidden": [
                    "int"
                ],
                "mode": [
                    "typing.Text"
                ],
                "datapath": [
                    "None"
                ],
                "model_path": [
                    "None"
                ]
            }
        },
        "NN.initialize_weights": {
            "name": "initialize_weights",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_hidden": [],
                "dims": []
            }
        },
        "NN.forward": {
            "name": "forward",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input": [],
                "labels": []
            }
        },
        "NN.activation": {
            "name": "activation",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input": []
            }
        },
        "NN.loss": {
            "name": "loss",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "prediction": []
            }
        },
        "NN.softmax": {
            "name": "softmax",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input": []
            }
        },
        "NN.backward": {
            "name": "backward",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cache": [],
                "labels": []
            }
        },
        "NN.update": {
            "name": "update",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "grads": []
            }
        },
        "NN.train": {
            "name": "train",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "NN.test": {
            "name": "test",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "IFT6135-master/Assignment2/models.py": {
        "glorot_init": {
            "name": "glorot_init",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "weight": [
                    "torch.Tensor",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "one_hot_encoding": {
            "name": "one_hot_encoding",
            "location": 55,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "torch.Tensor"
                ],
                "vocab_size": [
                    "int"
                ]
            }
        },
        "num_trainable_params": {
            "name": "num_trainable_params",
            "location": 74,
            "return": [
                "bool",
                "list",
                "List[Dict[str, Any]]",
                "frozenset",
                "str"
            ],
            "arguments": {
                "model": [
                    "torch.nn.Module",
                    "Type[T]",
                    "str"
                ]
            }
        },
        "clones": {
            "name": "clones",
            "location": 382,
            "return": [
                "bool"
            ],
            "arguments": {
                "module": [
                    "int",
                    "List[int]",
                    "Sequence[T]",
                    "Sized"
                ],
                "N": [
                    "int",
                    "List[int]",
                    "Sequence[T]",
                    "Sized"
                ]
            }
        },
        "make_model": {
            "name": "make_model",
            "location": 648,
            "return": [
                "FullTransformer"
            ],
            "arguments": {
                "vocab_size": [
                    "int",
                    "list",
                    "float"
                ],
                "n_blocks": [
                    "int",
                    "list",
                    "float"
                ],
                "n_units": [
                    "int",
                    "bool",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, torch.LongTensor]"
                ],
                "n_heads": [
                    "int",
                    "str",
                    "Dict[str, Dict[str, Any]]",
                    "defaultdict"
                ],
                "dropout": [
                    "bool",
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "subsequent_mask": {
            "name": "subsequent_mask",
            "location": 672,
            "return": [
                "dict",
                "bytes",
                "int"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ]
            }
        },
        "BaseRNNCell.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int",
                    "bool",
                    "Tuple[int, int, int]",
                    "float"
                ],
                "hidden_size": [
                    "int",
                    "bool",
                    "Tuple[int, int, int]",
                    "float"
                ],
                "dropout_keep_prob": [
                    "int",
                    "float",
                    "bool",
                    "bytes"
                ]
            }
        },
        "BaseRNNCell.forward": {
            "name": "forward",
            "location": 100,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "str"
                ],
                "hidden_state": [
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "VanillaRNNCell.__init__": {
            "name": "__init__",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VanillaRNNCell.forward": {
            "name": "forward",
            "location": 121,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "int"
                ],
                "hidden_state": [
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "GRURNNCell.__init__": {
            "name": "__init__",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GRURNNCell.forward": {
            "name": "forward",
            "location": 139,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x_t": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "float"
                ],
                "h_t": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "RNNBase.__init__": {
            "name": "__init__",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "emb_size": [
                    "int",
                    "Sized",
                    "List[Tuple[int, int]]",
                    "numpy.ndarray"
                ],
                "hidden_size": [
                    "Container[int]",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int]"
                ],
                "seq_len": [
                    "Optional[List[int]]",
                    "Optional[str]",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "bool"
                ],
                "vocab_size": [
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "num_layers": [
                    "str",
                    "int",
                    "Tuple[int]",
                    "dict",
                    "numpy.ndarray",
                    "list"
                ],
                "dp_keep_prob": [
                    "float",
                    "torch.nn.Module",
                    "Optional[Iterable]",
                    "bool",
                    "List[str]"
                ],
                "cell_type": [
                    "bool",
                    "List[List[int]]",
                    "List[str]",
                    "torch.LongTensor",
                    "torch.nn.Module",
                    "Dict[str, str]"
                ]
            }
        },
        "RNNBase.init_weights": {
            "name": "init_weights",
            "location": 222,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNBase.init_hidden": {
            "name": "init_hidden",
            "location": 233,
            "return": [
                "bool",
                "str",
                "int",
                "Optional[float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "RNNBase.forward": {
            "name": "forward",
            "location": 242,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "bool",
                    "float",
                    "List[List[str]]",
                    "torch.Tensor",
                    "int"
                ],
                "hidden": [
                    "bool",
                    "dict",
                    "Dict[str, torch.Tensor]"
                ]
            }
        },
        "RNNBase.generate": {
            "name": "generate",
            "location": 301,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "int",
                    "Callable",
                    "str"
                ],
                "hidden": [
                    "bool",
                    "dict",
                    "Dict[str, torch.Tensor]"
                ],
                "generated_seq_len": [
                    "str",
                    "list",
                    "List[str]",
                    "Sequence[int]"
                ]
            }
        },
        "RNN.__init__": {
            "name": "__init__",
            "location": 370,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GRU.__init__": {
            "name": "__init__",
            "location": 377,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AttentionHead.__init__": {
            "name": "__init__",
            "location": 457,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "d_model": [
                    "numpy.ndarray",
                    "Optional[int]",
                    "str"
                ],
                "d_k": [
                    "int",
                    "numpy.ndarray"
                ],
                "d_v": [
                    "int",
                    "str",
                    "bool",
                    "Optional[float]",
                    "Dict[str, Any]"
                ],
                "drop_prob": [
                    "float",
                    "List[str]",
                    "Optional[dict]"
                ]
            }
        },
        "AttentionHead.forward": {
            "name": "forward",
            "location": 469,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "Q": [
                    "torch.Tensor",
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "K": [
                    "torch.Tensor",
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "V": [
                    "torch.Tensor",
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "mask": [
                    "Dict[str, torch.LongTensor]",
                    "Dict[str, int]",
                    "numpy.ndarray",
                    "Optional[float]",
                    "bool",
                    "float",
                    "Optional[Any]",
                    "Sequence[float]"
                ]
            }
        },
        "MultiHeadedAttention.__init__": {
            "name": "__init__",
            "location": 492,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_heads": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str",
                    "float"
                ],
                "n_units": [
                    "int"
                ],
                "dropout": [
                    "int",
                    "str"
                ]
            }
        },
        "MultiHeadedAttention.init_weights": {
            "name": "init_weights",
            "location": 530,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadedAttention.forward": {
            "name": "forward",
            "location": 544,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "Hashable",
                    "Union[int, str]",
                    "Callable",
                    "Type",
                    "Dict[str, torch.Tensor]"
                ],
                "key": [
                    "str",
                    "Type[T]",
                    "type",
                    "Sequence[str]",
                    "\"Account\""
                ],
                "value": [
                    "str",
                    "Type[T]",
                    "type",
                    "Sequence[str]",
                    "\"Account\""
                ],
                "mask": [
                    "str",
                    "Type[T]",
                    "type",
                    "Sequence[str]",
                    "\"Account\""
                ]
            }
        },
        "WordEmbedding.__init__": {
            "name": "__init__",
            "location": 572,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_units": [
                    "int"
                ],
                "vocab": [
                    "int"
                ]
            }
        },
        "WordEmbedding.forward": {
            "name": "forward",
            "location": 577,
            "return": [
                "str",
                "bool",
                "Callable",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bool",
                    "int"
                ]
            }
        },
        "PositionalEncoding.__init__": {
            "name": "__init__",
            "location": 583,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_units": [
                    "int"
                ],
                "dropout": [
                    "int"
                ],
                "max_len": [
                    "int",
                    "float"
                ]
            }
        },
        "PositionalEncoding.forward": {
            "name": "forward",
            "location": 597,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "torch.Tensor",
                    "Tuple[int]",
                    "Union[int, float]"
                ]
            }
        },
        "TransformerBlock.__init__": {
            "name": "__init__",
            "location": 609,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "size": [
                    "int",
                    "numpy.ndarray",
                    "dict",
                    "bool",
                    "bytes",
                    "str"
                ],
                "self_attn": [
                    "int",
                    "bytes"
                ],
                "feed_forward": [
                    "int",
                    "bytes"
                ],
                "dropout": [
                    "int",
                    "bool",
                    "List[float]",
                    "List[int]"
                ]
            }
        },
        "TransformerBlock.forward": {
            "name": "forward",
            "location": 616,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "Variable",
                    "float"
                ],
                "mask": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "Variable"
                ]
            }
        },
        "TransformerStack.__init__": {
            "name": "__init__",
            "location": 625,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "layer": [
                    "int",
                    "str",
                    "Pattern[str]",
                    "bool"
                ],
                "n_blocks": [
                    "int",
                    "str",
                    "float",
                    "Set[str]"
                ]
            }
        },
        "TransformerStack.forward": {
            "name": "forward",
            "location": 630,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "mask": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "FullTransformer.__init__": {
            "name": "__init__",
            "location": 637,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transformer_stack": [],
                "embedding": [],
                "n_units": [
                    "Optional[str]",
                    "float",
                    "str",
                    "bool"
                ],
                "vocab_size": [
                    "Optional[str]",
                    "float",
                    "str",
                    "bool"
                ]
            }
        },
        "FullTransformer.forward": {
            "name": "forward",
            "location": 643,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "input_sequence": [
                    "int",
                    "Callable",
                    "str"
                ],
                "mask": [
                    "str",
                    "int"
                ]
            }
        },
        "Batch.__init__": {
            "name": "__init__",
            "location": 680,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "int"
                ],
                "pad": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "Batch.make_mask": {
            "name": "make_mask",
            "location": 685,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "data": [
                    "bytes",
                    "Optional[List[Dict]]"
                ],
                "pad": [
                    "str",
                    "bytes",
                    "List[str]",
                    "T",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        },
        "LayerNorm.__init__": {
            "name": "__init__",
            "location": 698,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "features": [
                    "int",
                    "float",
                    "List['Node']",
                    "bool"
                ],
                "eps": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LayerNorm.forward": {
            "name": "forward",
            "location": 704,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "float"
                ]
            }
        },
        "ResidualSkipConnectionWithLayerNorm.__init__": {
            "name": "__init__",
            "location": 715,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "size": [
                    "int",
                    "bytes"
                ],
                "dropout": [
                    "int",
                    "bytes"
                ]
            }
        },
        "ResidualSkipConnectionWithLayerNorm.forward": {
            "name": "forward",
            "location": 720,
            "return": [
                "int",
                "List[int]",
                "str",
                "bool",
                "Union[str, bool, None]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ],
                "sublayer": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "MLP.__init__": {
            "name": "__init__",
            "location": 729,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_units": [
                    "int"
                ],
                "dropout": [
                    "int"
                ]
            }
        },
        "MLP.forward": {
            "name": "forward",
            "location": 735,
            "return": [
                "Callable",
                "str",
                "Tuple[int, int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "T",
                    "int",
                    "bool",
                    "Iterable[T]"
                ]
            }
        }
    },
    "IFT6135-master/Assignment2/ptb-lm.py": {
        "_read_words": {
            "name": "_read_words",
            "location": 203,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "_build_vocab": {
            "name": "_build_vocab",
            "location": 207,
            "return": [
                "Tuple[(dict, dict)]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "_file_to_word_ids": {
            "name": "_file_to_word_ids",
            "location": 219,
            "return": [
                "list"
            ],
            "arguments": {
                "filename": [
                    "str",
                    "MutableMapping",
                    "list",
                    "annofabapi.models.TaskPhase",
                    "int",
                    "bytes"
                ],
                "word_to_id": [
                    "int",
                    "str",
                    "DefaultDict[Any, dict]",
                    "bytes"
                ]
            }
        },
        "ptb_raw_data": {
            "name": "ptb_raw_data",
            "location": 224,
            "return": [
                "Tuple[(Any, Any, Any, dict, dict)]"
            ],
            "arguments": {
                "data_path": [
                    "str"
                ],
                "prefix": [
                    "str"
                ]
            }
        },
        "ptb_iterator": {
            "name": "ptb_iterator",
            "location": 236,
            "return": [
                "Generator[(Tuple[(Any, Any)], Any, None)]"
            ],
            "arguments": {
                "raw_data": [
                    "int",
                    "Tuple[int, int]",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "num_steps": [
                    "int",
                    "torch.LongTensor",
                    "Union[Tuple[int, int], int]",
                    "bytearray"
                ]
            }
        },
        "repackage_hidden": {
            "name": "repackage_hidden",
            "location": 343,
            "return": [
                "numpy.ndarray",
                "Optional[int]",
                "Tuple[Tuple[int, Any]]"
            ],
            "arguments": {
                "h": []
            }
        },
        "run_epoch": {
            "name": "run_epoch",
            "location": 361,
            "return": [
                "Tuple[(Any, list)]"
            ],
            "arguments": {
                "model": [
                    "models.Surface"
                ],
                "data": [
                    "Dict[str, Any]",
                    "Dict[str, str]",
                    "Type[analytics.models.BaseCount]"
                ],
                "is_train": [
                    "dict"
                ],
                "lr": [
                    "dict",
                    "str",
                    "int"
                ]
            }
        },
        "Batch.__init__": {
            "name": "__init__",
            "location": 258,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "int"
                ],
                "pad": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "Batch.make_mask": {
            "name": "make_mask",
            "location": 263,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "data": [
                    "bytes",
                    "Optional[List[Dict]]",
                    "core.models.GroupingKey"
                ],
                "pad": [
                    "str",
                    "bytes",
                    "List[str]",
                    "T",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        },
        "Batch.make_mask.subsequent_mask": {
            "name": "subsequent_mask",
            "location": 266,
            "return": [
                "dict",
                "bytes",
                "int"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "IFT6135-master/Assignment2/q5-1.py": {},
    "IFT6135-master/Assignment2/q5-2.py": {
        "run_batch": {
            "name": "run_batch",
            "location": 9,
            "return": [
                "str",
                "int",
                "bool",
                "list"
            ],
            "arguments": {
                "model": [
                    "core.models.DepositClaim",
                    "str"
                ],
                "data": [
                    "bool",
                    "str"
                ]
            }
        },
        "run_batch.register_grad_hook": {
            "name": "register_grad_hook",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "run_batch.register_grad_hook.hook": {
            "name": "hook",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "grad": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        }
    },
    "IFT6135-master/Assignment2/q5-3.py": {
        "generate_sequences": {
            "name": "generate_sequences",
            "location": 8,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "model_type": [
                    "str",
                    "Exception"
                ],
                "generated_seq_len": [
                    "int",
                    "List[str]",
                    "float"
                ],
                "batch_size_used": [
                    "int",
                    "Optional[int]",
                    "str",
                    "Optional[float]",
                    "zam_repondeur.models.Lecture"
                ],
                "starting_word": [
                    "Text",
                    "int",
                    "List[str]",
                    "str"
                ]
            }
        }
    },
    "IFT6135-master/Assignment2/q5.py": {
        "_read_words": {
            "name": "_read_words",
            "location": 25,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "_build_vocab": {
            "name": "_build_vocab",
            "location": 29,
            "return": [
                "Tuple[(dict, dict)]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "_file_to_word_ids": {
            "name": "_file_to_word_ids",
            "location": 41,
            "return": [
                "list"
            ],
            "arguments": {
                "filename": [
                    "str",
                    "MutableMapping",
                    "List",
                    "int",
                    "bytes",
                    "annofabapi.models.TaskPhase"
                ],
                "word_to_id": [
                    "str",
                    "bytes",
                    "int",
                    "DefaultDict[Any,dict]"
                ]
            }
        },
        "ptb_raw_data": {
            "name": "ptb_raw_data",
            "location": 46,
            "return": [
                "Tuple[(Any, Any, Any, dict, dict)]"
            ],
            "arguments": {
                "data_path": [
                    "str",
                    "None"
                ],
                "prefix": [
                    "str",
                    "Text"
                ]
            }
        },
        "ptb_iterator": {
            "name": "ptb_iterator",
            "location": 59,
            "return": [
                "Generator[(Tuple[(Any, Any)], Any, None)]"
            ],
            "arguments": {
                "raw_data": [
                    "int",
                    "float",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "num_steps": [
                    "int",
                    "torch.LongTensor",
                    "Union[Tuple[int,int],int]",
                    "bytearray"
                ]
            }
        },
        "repackage_hidden": {
            "name": "repackage_hidden",
            "location": 106,
            "return": [
                "Tuple",
                "numpy.ndarray",
                "Optional[int]",
                "Tuple[Tuple[int,Any]]"
            ],
            "arguments": {
                "h": []
            }
        },
        "run_epoch": {
            "name": "run_epoch",
            "location": 123,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "model": [],
                "data": [
                    "Dict[str, Any]",
                    "Dict[str, str]",
                    "Type[analytics.models.BaseCount]"
                ],
                "is_train": [
                    "Dict",
                    "bool"
                ],
                "lr": [
                    "Dict",
                    "float"
                ]
            }
        },
        "get_best_model": {
            "name": "get_best_model",
            "location": 168,
            "return": [
                "Optional[Union[(models.FullTransformer, models.GRU, models.RNN)]]"
            ],
            "arguments": {
                "model_type": [
                    "str",
                    "Type",
                    "None",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "Optional[type]"
                ]
            }
        },
        "Batch.__init__": {
            "name": "__init__",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "bytes",
                    "int",
                    "numpy.ndarray"
                ],
                "pad": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "Batch.make_mask": {
            "name": "make_mask",
            "location": 86,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "data": [
                    "bytes",
                    "Optional[List[Dict]]",
                    "core.models.GroupingKey"
                ],
                "pad": [
                    "str",
                    "bytes",
                    "List[str]",
                    "Dict",
                    "Dict[str,str]",
                    "T"
                ]
            }
        },
        "Batch.make_mask.subsequent_mask": {
            "name": "subsequent_mask",
            "location": 89,
            "return": [
                "bool",
                "Dict",
                "bytes",
                "int"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/classify_svhn.py": {
        "get_data_loader": {
            "name": "get_data_loader",
            "location": 21,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "dataset_location": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[float]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "bool",
                    "Tuple[Union[float,float,float]]",
                    "Tuple[float,float,float]"
                ]
            }
        },
        "get_data_loaderNoNormalize": {
            "name": "get_data_loaderNoNormalize",
            "location": 57,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "dataset_location": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None"
                ],
                "batch_size": [
                    "bool",
                    "float",
                    "str",
                    "int",
                    "Tuple[Union[float,float,float]]",
                    "Tuple[float,float,float]"
                ]
            }
        },
        "evaluate": {
            "name": "evaluate",
            "location": 141,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "classify": [
                    "torch.Tensor",
                    "Tuple[float, float, float]"
                ],
                "dataset": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Classifier.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classifier.forward": {
            "name": "forward",
            "location": 134,
            "return": [
                "float",
                "utils.Node",
                "trezor.utils.Writer",
                "torch.FloatTensor",
                "cmk.utils.type_defs.ServiceName",
                "cmk.utils.type_defs.HostName"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "Classifier.extract_features": {
            "name": "extract_features",
            "location": 137,
            "return": [
                "bool",
                "utils.Node"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/density_estimation.py": {
        "estimate_density": {
            "name": "estimate_density",
            "location": 55,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "xx": [
                    "List",
                    "bool"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/mnist_loader.py": {
        "get_data_loader": {
            "name": "get_data_loader",
            "location": 11,
            "return": [
                "list"
            ],
            "arguments": {
                "dataset_location": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "Tuple[int]",
                    "float",
                    "Union[float,str]",
                    "str",
                    "Tuple[int,int]",
                    "numpy.random.RandomState"
                ]
            }
        },
        "get_data_loader.lines_to_np_array": {
            "name": "lines_to_np_array",
            "location": 14,
            "return": [
                "str",
                "int",
                "Optional[numpy.ndarray]",
                "Tuple[int]",
                "List[str]"
            ],
            "arguments": {
                "lines": [
                    "bytes",
                    "VT",
                    "str",
                    "int",
                    "Optional[str]",
                    "List[str]",
                    "list",
                    "Tuple[str]"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/q1.py": {
        "jensen_shannon_divergence": {
            "name": "jensen_shannon_divergence",
            "location": 18,
            "return": [
                "str",
                "List[List[int]]"
            ],
            "arguments": {
                "network": [
                    "int",
                    "torch.nn.Module",
                    "Iterable[T]",
                    "torch.Tensor"
                ],
                "x": [
                    "int"
                ],
                "y": [
                    "int",
                    "numpy.array",
                    "List[str]",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "wasserstein_distance": {
            "name": "wasserstein_distance",
            "location": 27,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "network": [
                    "float",
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "x": [
                    "numpy.ndarray",
                    "float"
                ],
                "y": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "gradient_pernalty": {
            "name": "gradient_pernalty",
            "location": 38,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "Union[tensorflow.Tensor, numpy.ndarray]",
                    "str",
                    "int"
                ],
                "x": [
                    "int"
                ],
                "y": [
                    "int"
                ]
            }
        },
        "maximize_objective": {
            "name": "maximize_objective",
            "location": 64,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "objective": [
                    "str",
                    "AbstractSet[str]",
                    "List[str]"
                ],
                "p": [
                    "torch.Tensor",
                    "Union[str, Dict[str, Any]]",
                    "int",
                    "Optional[List[str]]"
                ],
                "q": [
                    "torch.Tensor",
                    "Union[str, Dict[str, Any]]",
                    "int",
                    "Optional[List[str]]"
                ],
                "network": [
                    "float",
                    "str",
                    "int"
                ],
                "maxsteps": [
                    "bool",
                    "str",
                    "int"
                ],
                "threshold": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "gaussian_distribution": {
            "name": "gaussian_distribution",
            "location": 169,
            "return": [
                "generator"
            ],
            "arguments": {
                "mean": [
                    "int",
                    "Tuple[int, int]",
                    "float",
                    "Optional[int]",
                    "list"
                ],
                "std": [
                    "int",
                    "Tuple[int, int]",
                    "float",
                    "Optional[int]",
                    "list"
                ],
                "mini_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "float",
                    "Optional[int]",
                    "list"
                ]
            }
        },
        "to_tensors": {
            "name": "to_tensors",
            "location": 179,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "generator": [
                    "dict",
                    "IO",
                    "Iterable[numpy.ndarray]",
                    "List[str]",
                    "int",
                    "Iterator[Dict[str, str]]",
                    "torch.device"
                ]
            }
        },
        "get_optimal_discriminator": {
            "name": "get_optimal_discriminator",
            "location": 187,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "f_0": [
                    "numpy.ndarray",
                    "str",
                    "Type[Exception]",
                    "Dict[str, object]",
                    "List[object]"
                ],
                "f_1": [
                    "numpy.ndarray",
                    "str",
                    "Type[Exception]",
                    "Dict[str, object]",
                    "List[object]"
                ]
            }
        },
        "q1": {
            "name": "q1",
            "location": 225,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "p": [
                    "int",
                    "Callable",
                    "str"
                ],
                "q": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "q2": {
            "name": "q2",
            "location": 229,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "p": [
                    "int",
                    "Callable",
                    "str"
                ],
                "q": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "q3": {
            "name": "q3",
            "location": 232,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "q4": {
            "name": "q4",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "gradient_pernalty.random_interpolation": {
            "name": "random_interpolation",
            "location": 42,
            "return": [
                "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                "List[int]",
                "int",
                "Iterable[str]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "List[float]"
                ],
                "y": [
                    "float",
                    "List[float]"
                ]
            }
        },
        "NumpyBuffer.__init__": {
            "name": "__init__",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "capacity": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "NumpyBuffer.put": {
            "name": "put",
            "location": 119,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "new_value": [
                    "str",
                    "List[str]",
                    "Tuple[int, int]",
                    "bool",
                    "FrozenSet[int]"
                ]
            }
        },
        "StopIfConverged.__init__": {
            "name": "__init__",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "patience": [
                    "int",
                    "Callable",
                    "bool"
                ],
                "threshold": [
                    "int",
                    "bool",
                    "float"
                ],
                "maximizing": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "StopIfConverged.__call__": {
            "name": "__call__",
            "location": 144,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "numpy.ndarray",
                    "Union[str, type]",
                    "int",
                    "str",
                    "List[str]"
                ]
            }
        },
        "get_optimal_discriminator.discriminator_value_fn": {
            "name": "discriminator_value_fn",
            "location": 188,
            "return": [
                "int",
                "str",
                "Optional[int]",
                "bool",
                "Optional[Tuple[int, int]]",
                "float"
            ],
            "arguments": {
                "network": [
                    "float",
                    "int"
                ],
                "x": [
                    "int",
                    "float",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "numpy.ndarray"
                ],
                "y": [
                    "int",
                    "T"
                ]
            }
        },
        "get_optimal_discriminator.disc_numpy": {
            "name": "disc_numpy",
            "location": 210,
            "return": [
                "dict",
                "str",
                "Dict[str, Any]",
                "List[Dict[str, Any]]",
                "OrderedDict[str, Any]"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ]
            }
        },
        "q3.get_samples": {
            "name": "get_samples",
            "location": 236,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "phi": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/q2.py": {
        "ELBO": {
            "name": "ELBO",
            "location": 71,
            "return": [
                "bytes",
                "str"
            ],
            "arguments": {
                "output": [
                    "int",
                    "dict",
                    "T",
                    "bool"
                ],
                "target": [
                    "str",
                    "Dict",
                    "List[str]",
                    "bool",
                    "T"
                ],
                "mu": [
                    "str",
                    "bool"
                ],
                "logvar": [
                    "bool",
                    "str"
                ]
            }
        },
        "validate": {
            "name": "validate",
            "location": 76,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "str",
                    "Dict[str, Any]",
                    "List[T]",
                    "int"
                ],
                "valid": [
                    "bool",
                    "list",
                    "MutableMapping[Any, Any]",
                    "str",
                    "dict",
                    "Hashable",
                    "bytes",
                    "List[str]"
                ],
                "device": [
                    "int",
                    "float",
                    "str"
                ],
                "method": [
                    "Text",
                    "str",
                    "List[str]"
                ]
            }
        },
        "part1": {
            "name": "part1",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "int",
                    "bool"
                ]
            }
        },
        "importance_sample_vae": {
            "name": "importance_sample_vae",
            "location": 127,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "vae": [
                    "float",
                    "int",
                    "Union[int,float]"
                ],
                "x": [
                    "numpy.ndarray"
                ],
                "z": [
                    "numpy.ndarray",
                    "Callable",
                    "Union[int, float]",
                    "int",
                    "torch.Tensor"
                ],
                "device": [
                    "Sequence[T]"
                ]
            }
        },
        "part2": {
            "name": "part2",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "Dict",
                    "str",
                    "IO",
                    "bool"
                ]
            }
        },
        "Encoder.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_size": [
                    "int",
                    "torch.LongTensor",
                    "bool",
                    "Iterable[int]"
                ]
            }
        },
        "Encoder.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "Decoder.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Decoder.forward": {
            "name": "forward",
            "location": 53,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "VAE.__init__": {
            "name": "__init__",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VAE.forward": {
            "name": "forward",
            "location": 65,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/q3_gan.py": {
        "gradient_penalty": {
            "name": "gradient_penalty",
            "location": 67,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "reals": [
                    "int",
                    "float",
                    "torch.Tensor"
                ],
                "fakes": [
                    "int",
                    "float",
                    "torch.Tensor"
                ],
                "gan": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "random_interpolation": {
            "name": "random_interpolation",
            "location": 89,
            "return": [
                "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                "List[int]",
                "int",
                "Iterable[str]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "torch.Tensor"
                ],
                "y": [
                    "float",
                    "List[float]"
                ]
            }
        },
        "visual_samples": {
            "name": "visual_samples",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "gan": [
                    "int",
                    "Callable",
                    "str"
                ],
                "dimensions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "device": [
                    "int",
                    "Callable",
                    "str"
                ],
                "svhn_loader": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "step": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "disentangled_representation": {
            "name": "disentangled_representation",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "gan": [
                    "int",
                    "Callable",
                    "str"
                ],
                "dimensions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "device": [
                    "int",
                    "Callable",
                    "str"
                ],
                "epsilon": [
                    "int",
                    "torch.Tensor",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "interpolation": {
            "name": "interpolation",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "gan": [
                    "Dict[str,tuple[Union[int,int]]]",
                    "Dict[str,Tuple[int,int]]",
                    "int",
                    "List",
                    "float",
                    "Iterable[Any]"
                ],
                "dimensions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "device": [
                    "int"
                ]
            }
        },
        "save_1000_images": {
            "name": "save_1000_images",
            "location": 149,
            "return": [
                "None"
            ],
            "arguments": {
                "img_dir": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "Discriminator.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Discriminator.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "str",
                "int",
                "List",
                "Dict[str,int]"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "str",
                    "torch.Tensor",
                    "int",
                    "float"
                ]
            }
        },
        "Generator.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Generator.forward": {
            "name": "forward",
            "location": 52,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor"
                ]
            }
        },
        "GAN.__init__": {
            "name": "__init__",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "IFT6135-master/Assignment3/q3_vae.py": {
        "ELBO": {
            "name": "ELBO",
            "location": 56,
            "return": [
                "float",
                "bytes",
                "str"
            ],
            "arguments": {
                "output": [
                    "str",
                    "Optional[bytes]",
                    "bytes"
                ],
                "target": [
                    "str"
                ],
                "mu": [
                    "str",
                    "bool"
                ],
                "logvar": [
                    "bool",
                    "str"
                ]
            }
        },
        "visual_samples": {
            "name": "visual_samples",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "vae": [
                    "str",
                    "bool",
                    "float",
                    "List[list[str]]",
                    "List[List[str]]",
                    "torch.Tensor",
                    "int"
                ],
                "dimensions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "device": [
                    "str",
                    "numpy.ndarray"
                ],
                "svhn_loader": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "disentangled_representation": {
            "name": "disentangled_representation",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "vae": [
                    "int",
                    "Callable",
                    "str"
                ],
                "dimensions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "device": [
                    "int",
                    "Callable",
                    "str"
                ],
                "epsilon": [
                    "int",
                    "torch.Tensor",
                    "List[int]",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "make_tensor": {
            "name": "make_tensor",
            "location": 97,
            "return": [
                "int",
                "Tuple[Union[str,str]]",
                "str",
                "Callable",
                "None"
            ],
            "arguments": {
                "tens_list": [
                    "List[tuple[Union[str,str]]]",
                    "List",
                    "List[Tuple[str,str]]",
                    "List[str]",
                    "Sequence[dict]",
                    "Iterator[tuple]",
                    "bool"
                ]
            }
        },
        "interpolation": {
            "name": "interpolation",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "vae": [
                    "Dict[str,tuple[Union[int,int]]]",
                    "Dict[str,Tuple[int,int]]",
                    "int",
                    "List",
                    "float",
                    "Iterable[Any]"
                ],
                "dimensions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "device": [
                    "int"
                ]
            }
        },
        "save_1000_images": {
            "name": "save_1000_images",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "img_dir": [
                    "str"
                ]
            }
        },
        "Encoder.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_size": [
                    "int",
                    "torch.LongTensor",
                    "bool",
                    "Iterable[int]"
                ]
            }
        },
        "Encoder.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "Decoder.forward": {
            "name": "forward",
            "location": 36,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ]
            }
        },
        "VAE.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VAE.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/samplers.py": {
        "distribution1": {
            "name": "distribution1",
            "location": 5,
            "return": [
                "Generator[(np.ndarray, Any, Any)]"
            ],
            "arguments": {
                "x": [
                    "int",
                    "bool",
                    "numpy.ndarray"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "distribution2": {
            "name": "distribution2",
            "location": 11,
            "return": [
                "generator"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "bool"
                ]
            }
        },
        "distribution3": {
            "name": "distribution3",
            "location": 17,
            "return": [
                "generator"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "bool"
                ]
            }
        },
        "distribution4": {
            "name": "distribution4",
            "location": 24,
            "return": [
                "generator"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[int,int]"
                ]
            }
        }
    },
    "IFT6135-master/Assignment3/score_fid.py": {
        "get_sample_loader": {
            "name": "get_sample_loader",
            "location": 15,
            "return": [
                "str",
                "bytes",
                "int",
                "Dict[str,Any]",
                "Dict",
                "Callable",
                "range",
                "Optional[str]",
                "Callable[[str],T]"
            ],
            "arguments": {
                "path": [
                    "str",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "bytes",
                    "List[float]"
                ]
            }
        },
        "get_test_loader": {
            "name": "get_test_loader",
            "location": 44,
            "return": [
                "str",
                "int",
                "Callable",
                "List[float]",
                "List[List[int]]",
                "List[int]"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "extract_features": {
            "name": "extract_features",
            "location": 64,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "classifier": [
                    "bytes",
                    "numpy.ndarray"
                ],
                "data_loader": [
                    "str",
                    "bool"
                ]
            }
        },
        "calculate_fid_score": {
            "name": "calculate_fid_score",
            "location": 75,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "sample_feature_iterator": [
                    "int",
                    "Callable",
                    "str"
                ],
                "testset_feature_iterator": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "calculate_fid_score.take": {
            "name": "take",
            "location": 79,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "n": [
                    "int"
                ],
                "iterable": [
                    "int"
                ]
            }
        }
    }
}
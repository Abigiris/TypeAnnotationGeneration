{
    "MedTagger-master/.travis/run_tests_if_subproject_changed.py": {
        "get_root_dir": {
            "name": "get_root_dir",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "run": {
            "name": "run",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "command": [
                    "List[str]",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "do_not_run": {
            "name": "do_not_run",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/env.py": {
        "run_migrations_offline": {
            "name": "run_migrations_offline",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "run_migrations_online": {
            "name": "run_migrations_online",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/01dc85c25335_add_skip_count_column_to_scan_model.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/0707294d0a96_add_disabled_flags.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/14898bcabb8a_add_comment_column_to_label_model.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/39c660178412_change_columns_names.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/3f2c98c1710b_add_tools_to_tag.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/4e7789e84f5d_add_point_label_element.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/4e93b463a357_initial_revision.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/569a3b109b71_rename_scan_category_to_dataset.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/5e3f98d24b75_add_description_and_label_examples_for_.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/61737c4342bc_add_label_tag.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/617bf951f6a2_add_chain_label_element.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/6d69756a1476_add_user_settings.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/729cd1e8cde1_add_width_and_height_to_slices.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/75a3481c4d0c_change_scans_and_slices_to_use_enums.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/7995a5e4f811_add_label_tools.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/89c593744804_remove_all_binary_mask_related_things_.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/9a6cd75ba23f_add_brush_label_element_to_postgresql_.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/9c615d167588_add_tasks.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/9f2eafdf821e_add_cascade_delete_to_scans.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/ab732474a829_add_owners_to_labels_and_scans.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/c075df75ca43_add_support_for_predefined_labels.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/ddd21c46f46d_add_slices_to_cassandra.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/e1d0a4fcf63c_add_tables_for_actions_like_surveys.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/e4721c7f3521_added_labeling_time_column.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/alembic/versions/f49f6dc9b600_add__created_and__modified_fields_to_.py": {
        "upgrade": {
            "name": "upgrade",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "downgrade": {
            "name": "downgrade",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/config.py": {
        "AppConfiguration.get": {
            "name": "get",
            "location": 10,
            "return": [
                "Union[(str, _T2)]"
            ],
            "arguments": {
                "namespace": [
                    "str",
                    "bytes",
                    "Optional[int]",
                    "int"
                ],
                "key": [
                    "str",
                    "bytes",
                    "Optional[int]",
                    "int"
                ],
                "fallback": [
                    "str",
                    "int",
                    "None"
                ]
            }
        },
        "AppConfiguration.getint": {
            "name": "getint",
            "location": 22,
            "return": [
                "int"
            ],
            "arguments": {
                "namespace": [
                    "str",
                    "int"
                ],
                "key": [
                    "str",
                    "int"
                ],
                "fallback": [
                    "int",
                    "str"
                ]
            }
        },
        "AppConfiguration.getboolean": {
            "name": "getboolean",
            "location": 27,
            "return": [
                "bool"
            ],
            "arguments": {
                "namespace": [
                    "str",
                    "bytes",
                    "Hashable",
                    "List"
                ],
                "key": [
                    "str",
                    "bytes",
                    "Hashable",
                    "List"
                ],
                "fallback": [
                    "bool",
                    "str",
                    "bytes",
                    "Hashable",
                    "List"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/conversion.py": {
        "convert_slice_to_normalized_8bit_array": {
            "name": "convert_slice_to_normalized_8bit_array",
            "location": 12,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "List[int]"
            ],
            "arguments": {
                "dicom_file": [
                    "str",
                    "int",
                    "float",
                    "None",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "convert_scan_to_normalized_8bit_array": {
            "name": "convert_scan_to_normalized_8bit_array",
            "location": 25,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "List[int]"
            ],
            "arguments": {
                "dicom_files": [
                    "str",
                    "bool",
                    "numpy.ndarray",
                    "int"
                ],
                "output_x_size": [
                    "int",
                    "str",
                    "None"
                ]
            }
        },
        "_get_scan_slice_thickness": {
            "name": "_get_scan_slice_thickness",
            "location": 54,
            "return": [
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "dicom_files": [
                    "str",
                    "List[str]",
                    "TextIO"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/definitions.py": {},
    "MedTagger-master/backend/medtagger/dicoms.py": {
        "read_int": {
            "name": "read_int",
            "location": 9,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "dicom": [
                    "Dict",
                    "medtagger.definitions.DicomTag",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]"
                ],
                "tag": [
                    "Dict",
                    "medtagger.definitions.DicomTag",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]"
                ]
            }
        },
        "read_float": {
            "name": "read_float",
            "location": 22,
            "return": [
                "Optional[float]"
            ],
            "arguments": {
                "dicom": [
                    "Dict",
                    "medtagger.definitions.DicomTag",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]"
                ],
                "tag": [
                    "Dict",
                    "medtagger.definitions.DicomTag",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]"
                ]
            }
        },
        "read_string": {
            "name": "read_string",
            "location": 35,
            "return": [
                "None",
                "Optional[str]",
                "Optional[float]",
                "str",
                "Optional[List[str]]",
                "Optional[Any]"
            ],
            "arguments": {
                "dicom": [
                    "Dict",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]",
                    "medtagger.definitions.DicomTag"
                ],
                "tag": [
                    "Dict",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]",
                    "medtagger.definitions.DicomTag"
                ]
            }
        },
        "read_list": {
            "name": "read_list",
            "location": 48,
            "return": [
                "None",
                "str",
                "List[str]",
                "Set[str]",
                "Dict[str,Any]"
            ],
            "arguments": {
                "dicom": [
                    "Dict",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]",
                    "medtagger.definitions.DicomTag"
                ],
                "tag": [
                    "Dict",
                    "Union[SimpleITK.Image,SimpleITK.ImageFileReader]",
                    "medtagger.definitions.DicomTag"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/exceptions.py": {},
    "MedTagger-master/backend/medtagger/types.py": {},
    "MedTagger-master/backend/medtagger/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/exceptions.py": {},
    "MedTagger-master/backend/medtagger/api/pagination.py": {},
    "MedTagger-master/backend/medtagger/api/rest.py": {
        "shutdown_session": {
            "name": "shutdown_session",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "exception": [
                    "List[dict]",
                    "List[str]",
                    "None",
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/security.py": {
        "auth_error_handler": {
            "name": "auth_error_handler",
            "location": 17,
            "return": [
                "NoReturn"
            ],
            "arguments": {}
        },
        "role_required": {
            "name": "role_required",
            "location": 30,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {}
        },
        "require_one_of_roles": {
            "name": "require_one_of_roles",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "required_roles": [
                    "Set[str]",
                    "List",
                    "Set",
                    "List[str]",
                    "Pattern",
                    "Pattern[str]",
                    "Pattern[bytes]"
                ]
            }
        },
        "hash_password": {
            "name": "hash_password",
            "location": 51,
            "return": [
                "str",
                "Optional[Sequence[str]]",
                "Dict[str, str]",
                "Sequence[str]"
            ],
            "arguments": {
                "password": [
                    "str",
                    "medtagger.database.models.User"
                ]
            }
        },
        "verify_user_password": {
            "name": "verify_user_password",
            "location": 56,
            "return": [
                "str",
                "bool",
                "Callable"
            ],
            "arguments": {
                "user": [
                    "str",
                    "medtagger.database.models.User",
                    "tracim.models.data.Content"
                ],
                "password": [
                    "str",
                    "medtagger.database.models.User",
                    "tracim.models.data.Content"
                ]
            }
        },
        "generate_auth_token": {
            "name": "generate_auth_token",
            "location": 61,
            "return": [
                "str"
            ],
            "arguments": {
                "user": [
                    "str",
                    "bytes",
                    "Sequence[int]",
                    "zerver.models.UserProfile",
                    "None",
                    "Optional[str]"
                ],
                "expiration": [
                    "int",
                    "zerver.models.UserProfile",
                    "Optional[str]",
                    "str",
                    "Dict[str,Any]",
                    "zerver.models.Stream",
                    "Dict"
                ]
            }
        },
        "get_user_by_token": {
            "name": "get_user_by_token",
            "location": 73,
            "return": [
                "None",
                "Optional[str]",
                "str",
                "Optional[Dict]"
            ],
            "arguments": {
                "token": [
                    "str",
                    "int",
                    "List[list[int]]",
                    "List[List[int]]",
                    "T"
                ]
            }
        },
        "verify_token": {
            "name": "verify_token",
            "location": 90,
            "return": [
                "bool"
            ],
            "arguments": {
                "token": [
                    "str",
                    "Sequence[str]",
                    "Optional[Mapping[str,Any]]",
                    "Mapping",
                    "None"
                ]
            }
        },
        "role_required.wrapper": {
            "name": "wrapper",
            "location": 32,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "wrapped_method": [
                    "str",
                    "Callable",
                    "List[str]"
                ]
            }
        },
        "role_required.wrapper.decorated": {
            "name": "decorated",
            "location": 35,
            "return": [
                "bool",
                "str",
                "List[Dict[str, Any]]"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/utils.py": {
        "get_current_user": {
            "name": "get_current_user",
            "location": 7,
            "return": [
                "str",
                "zerver.models.Realm",
                "bool"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/websocket.py": {
        "shutdown_session": {
            "name": "shutdown_session",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "exception": [
                    "List[dict]",
                    "List[str]",
                    "None",
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/__init__.py": {
        "setup_connection_to_sql_and_storage": {
            "name": "setup_connection_to_sql_and_storage",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "rest_default_error_handler": {
            "name": "rest_default_error_handler",
            "location": 54,
            "return": [
                "Tuple[Union[dict[Text,Text],int]]",
                "int",
                "Dict[str,Any]",
                "str",
                "Container[str]"
            ],
            "arguments": {
                "exception": [
                    "Exception",
                    "Iterable[Any]"
                ]
            }
        },
        "rest_unauthorized_error_handler": {
            "name": "rest_unauthorized_error_handler",
            "location": 65,
            "return": [
                "Tuple[Union[dict[Text,Text],int]]",
                "Callable",
                "Iterable[str]"
            ],
            "arguments": {
                "exception": [
                    "Exception",
                    "str",
                    "Type"
                ]
            }
        },
        "rest_not_found_error_handler": {
            "name": "rest_not_found_error_handler",
            "location": 77,
            "return": [
                "Tuple[Union[dict[Text,Text],int]]",
                "Dict[str,Any]",
                "Dict",
                "Dict[str,str]",
                "int"
            ],
            "arguments": {
                "exception": [
                    "Exception",
                    "str",
                    "int"
                ]
            }
        },
        "rest_invalid_arguments_error_handler": {
            "name": "rest_invalid_arguments_error_handler",
            "location": 89,
            "return": [
                "Tuple[Union[dict[Text,Text],int]]",
                "int",
                "Sequence",
                "pymongo.database.Database",
                "str"
            ],
            "arguments": {
                "exception": [
                    "Exception",
                    "str",
                    "Type"
                ]
            }
        },
        "rest_access_forbidden_error_handel": {
            "name": "rest_access_forbidden_error_handel",
            "location": 101,
            "return": [
                "Tuple[Union[dict[Text,Text],int]]",
                "str",
                "Tuple",
                "bool",
                "Dict[str,Any]"
            ],
            "arguments": {
                "exception": [
                    "Exception",
                    "int",
                    "str",
                    "Union[int,float,str]",
                    "float"
                ]
            }
        },
        "web_socket_default_error_handler": {
            "name": "web_socket_default_error_handler",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {
                "exception": [
                    "Exception",
                    "BaseException"
                ]
            }
        },
        "setup_connection_to_sql_and_storage.connect_to_db_and_storage": {
            "name": "connect_to_db_and_storage",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/auth/business.py": {
        "create_user": {
            "name": "create_user",
            "location": 9,
            "return": [
                "Tuple[(Any, str)]"
            ],
            "arguments": {
                "email": [
                    "str"
                ],
                "password": [
                    "str",
                    "int"
                ],
                "first_name": [
                    "str"
                ],
                "last_name": [
                    "str"
                ]
            }
        },
        "sign_in_user": {
            "name": "sign_in_user",
            "location": 33,
            "return": [
                "str"
            ],
            "arguments": {
                "email": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "password": [
                    "str",
                    "Dict[str,object]",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/auth/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/auth/service.py": {
        "Register.post": {
            "name": "post",
            "location": 21,
            "return": [
                "Tuple[Union[dict[Text,],int]]",
                "Dict",
                "int"
            ],
            "arguments": {}
        },
        "SignIn.post": {
            "name": "post",
            "location": 35,
            "return": [
                "Tuple[Union[dict[Text,],int]]",
                "str",
                "Callable",
                "List",
                "List[str]"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/auth/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/core/business.py": {
        "success": {
            "name": "success",
            "location": 5,
            "return": [
                "bool",
                "Dict[Text,bool]"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/core/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/core/service.py": {
        "Status.get": {
            "name": "get",
            "location": 21,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "CheckAuthentication.get": {
            "name": "get",
            "location": 35,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "CheckAuthorization.get": {
            "name": "get",
            "location": 50,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/core/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/datasets/business.py": {
        "get_available_datasets": {
            "name": "get_available_datasets",
            "location": 10,
            "return": [
                "bool",
                "str",
                "bytes",
                "int"
            ],
            "arguments": {}
        },
        "create_dataset": {
            "name": "create_dataset",
            "location": 18,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {
                "key": [
                    "str"
                ],
                "name": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/datasets/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/datasets/service_rest.py": {
        "Datasets.get": {
            "name": "get",
            "location": 24,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {}
        },
        "Datasets.post": {
            "name": "post",
            "location": 36,
            "return": [
                "Tuple[int]",
                "str",
                "Callable",
                "List[str]",
                "int"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/api/datasets/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/labels/business.py": {
        "get_label": {
            "name": "get_label",
            "location": 14,
            "return": [
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "label_id": [
                    "str",
                    "medtagger.types.LabelID",
                    "None",
                    "Optional[str]"
                ]
            }
        },
        "change_label_status": {
            "name": "change_label_status",
            "location": 25,
            "return": [
                "bool",
                "Iterable[str]",
                "List[str]",
                "str"
            ],
            "arguments": {
                "label_id": [
                    "str",
                    "int",
                    "float",
                    "Optional[str]",
                    "None"
                ],
                "status": [
                    "int",
                    "medtagger.definitions.LabelVerificationStatus",
                    "str",
                    "Set[int]"
                ]
            }
        },
        "get_random_label": {
            "name": "get_random_label",
            "location": 40,
            "return": [
                "int",
                "bool",
                "django.contrib.auth.models.AbstractBaseUser",
                "Callable[[], T]",
                "zerver.models.Realm",
                "sqlalchemy.orm.Session"
            ],
            "arguments": {}
        },
        "get_action_details": {
            "name": "get_action_details",
            "location": 51,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[List[str]]",
                "Optional[str]",
                "limbic.emotion.models.LexiconLimbicModel",
                "int",
                "Callable"
            ],
            "arguments": {
                "action_id": [
                    "str",
                    "int",
                    "medtagger.types.ActionID"
                ]
            }
        },
        "add_action_response": {
            "name": "add_action_response",
            "location": 63,
            "return": [
                "Iterable[str]"
            ],
            "arguments": {
                "action_id": [
                    "int",
                    "medtagger.types.ActionID",
                    "str",
                    "Dict",
                    "None",
                    "Optional[str]"
                ],
                "response": [
                    "Dict",
                    "int",
                    "str",
                    "Optional[bytes]",
                    "bytes",
                    "None"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/labels/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/labels/service.py": {
        "Label.get": {
            "name": "get",
            "location": 29,
            "return": [
                "str",
                "bytes",
                "int",
                "tuple"
            ],
            "arguments": {
                "label_id": [
                    "str",
                    "int",
                    "medtagger.types.LabelID"
                ]
            }
        },
        "RandomLabel.get": {
            "name": "get",
            "location": 45,
            "return": [
                "str",
                "List[str]",
                "bool",
                "int"
            ],
            "arguments": {}
        },
        "ChangeLabelStatus.put": {
            "name": "put",
            "location": 67,
            "return": [
                "str",
                "dict",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "label_id": [
                    "int",
                    "medtagger.types.LabelID"
                ]
            }
        },
        "ActionDetails.get": {
            "name": "get",
            "location": 89,
            "return": [
                "Optional[str]",
                "Optional[List[str]]",
                "exporwiki.types.PrimalEngramEntry",
                "int"
            ],
            "arguments": {
                "action_id": [
                    "int",
                    "str",
                    "medtagger.types.ActionID"
                ]
            }
        },
        "ActionDetails.post": {
            "name": "post",
            "location": 100,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "action_id": [
                    "str",
                    "medtagger.types.ActionID",
                    "None",
                    "int",
                    "Optional[str]",
                    "opentrons.types.Mount"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/labels/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/scans/business.py": {
        "dataset_is_valid": {
            "name": "dataset_is_valid",
            "location": 33,
            "return": [
                "bool"
            ],
            "arguments": {
                "dataset_key": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "create_empty_scan": {
            "name": "create_empty_scan",
            "location": 46,
            "return": [
                "bool",
                "str",
                "recidiviz.persistence.database.database_entity.DatabaseEntity",
                "int",
                "Iterable[str]",
                "Callable"
            ],
            "arguments": {
                "dataset_key": [
                    "str",
                    "int",
                    "List[int]",
                    "Union[int,str]",
                    "Union[str,int]"
                ],
                "declared_number_of_slices": [
                    "str",
                    "List[str]",
                    "Optional[bool]",
                    "bool",
                    "None"
                ]
            }
        },
        "get_random_scan": {
            "name": "get_random_scan",
            "location": 58,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "task_key": [
                    "str",
                    "werkzeug.exceptions.HTTPException"
                ]
            }
        },
        "get_slices_for_scan": {
            "name": "get_slices_for_scan",
            "location": 80,
            "return": [
                "Iterable[Tuple[medtagger.database.models.Slice,bytes]]",
                "Generator[tuple]"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "medtagger.types.ActionID"
                ],
                "begin": [
                    "int",
                    "Set[str]"
                ],
                "count": [
                    "int",
                    "Set[str]"
                ],
                "orientation": [
                    "int",
                    "str",
                    "medtagger.types.ActionID"
                ]
            }
        },
        "get_predefined_brush_label_elements": {
            "name": "get_predefined_brush_label_elements",
            "location": 96,
            "return": [
                "Iterable[Tuple[medtagger.database.models.BrushLabelElement,bytes]]",
                "Generator[tuple]"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "None",
                    "transfer.models.SnippetID",
                    "Optional[str]",
                    "medtagger.types.LabelID"
                ],
                "task_id": [
                    "str",
                    "None",
                    "transfer.models.SnippetID",
                    "Optional[str]",
                    "medtagger.types.LabelID"
                ],
                "begin": [
                    "str",
                    "None",
                    "transfer.models.SnippetID",
                    "Optional[str]",
                    "medtagger.types.LabelID"
                ],
                "count": [
                    "str",
                    "None",
                    "transfer.models.SnippetID",
                    "Optional[str]",
                    "medtagger.types.LabelID"
                ]
            }
        },
        "validate_label_payload": {
            "name": "validate_label_payload",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "label": [
                    "str",
                    "bool"
                ],
                "task_key": [
                    "str"
                ],
                "files": [
                    "str"
                ]
            }
        },
        "_validate_tool": {
            "name": "_validate_tool",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "label": [
                    "str",
                    "Set[str]",
                    "raiden.utils.SecretHash",
                    "int",
                    "Iterable[models.Course]"
                ]
            }
        },
        "_validate_files": {
            "name": "_validate_files",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "files": [
                    "Dict[str,str]",
                    "Dict",
                    "Dict[int,dict[int,Any]]",
                    "Dict[str,Any]",
                    "Union[Dict,List]",
                    "Dict[int,Dict[int,Any]]",
                    "str"
                ]
            }
        },
        "_validate_label_elements": {
            "name": "_validate_label_elements",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "label": [
                    "str",
                    "types.ModuleType",
                    "Dict",
                    "Set"
                ],
                "task_key": [
                    "str",
                    "services.ticketing.models.ticket_evenTicketEvent"
                ],
                "files": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "add_label": {
            "name": "add_label",
            "location": 161,
            "return": [
                "Union[zerver.models.UserProfile, zilencer.models.RemoteZulipServer]",
                "str",
                "float"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "List[str]",
                    "Union[str,int]",
                    "None",
                    "List[I]",
                    "Optional[int]",
                    "bool",
                    "Optional[List[CustomLineItemDraft]]"
                ],
                "task_key": [
                    "int",
                    "str",
                    "List[str]",
                    "Union[str,int]",
                    "None",
                    "List[I]",
                    "Optional[int]",
                    "bool",
                    "Optional[List[CustomLineItemDraft]]"
                ],
                "elements": [
                    "List[str]",
                    "bool",
                    "int",
                    "Optional[List[str]]"
                ],
                "files": [
                    "str",
                    "Callable",
                    "Optional[str]",
                    "None",
                    "Optional[Any]",
                    "Any"
                ],
                "labeling_time": [
                    "int",
                    "str",
                    "List[str]",
                    "Union[str,int]",
                    "None",
                    "List[I]",
                    "Optional[int]",
                    "bool",
                    "Optional[List[CustomLineItemDraft]]"
                ],
                "comment": [
                    "int",
                    "None",
                    "List[str]",
                    "str",
                    "Union[str,int]",
                    "List[I]",
                    "Optional[int]",
                    "bool",
                    "Optional[List[CustomLineItemDraft]]"
                ],
                "is_predefined": [
                    "bool",
                    "int",
                    "Union[str,int]",
                    "List[str]",
                    "Optional[int]",
                    "str",
                    "Optional[List[CustomLineItemDraft]]"
                ]
            }
        },
        "add_label_element": {
            "name": "add_label_element",
            "location": 185,
            "return": [
                "None"
            ],
            "arguments": {
                "element": [
                    "str",
                    "bytes",
                    "Sequence[str]",
                    "Dict[str,str]"
                ],
                "label_id": [
                    "Sequence[str]",
                    "str",
                    "List[str]",
                    "bool",
                    "Dict[str,str]"
                ],
                "files": [
                    "Sequence[str]",
                    "str",
                    "List[str]",
                    "bool",
                    "Dict[str,str]"
                ]
            }
        },
        "_add_rectangle_element": {
            "name": "_add_rectangle_element",
            "location": 203,
            "return": [
                "None"
            ],
            "arguments": {
                "element": [
                    "bytes",
                    "int"
                ],
                "label_id": [
                    "int",
                    "str",
                    "Type",
                    "Type[models.taxonomies.T]",
                    "raiden_contracts.utils.type_aliases.ChainID"
                ]
            }
        },
        "_add_brush_element": {
            "name": "_add_brush_element",
            "location": 215,
            "return": [
                "None"
            ],
            "arguments": {
                "element": [
                    "str",
                    "int",
                    "Collection"
                ],
                "label_id": [
                    "str",
                    "int"
                ],
                "files": [
                    "str"
                ]
            }
        },
        "_add_point_element": {
            "name": "_add_point_element",
            "location": 230,
            "return": [
                "None"
            ],
            "arguments": {
                "element": [
                    "bytes",
                    "int"
                ],
                "label_id": [
                    "int",
                    "str",
                    "Type",
                    "Type[models.taxonomies.T]",
                    "raiden_contracts.utils.type_aliases.ChainID"
                ]
            }
        },
        "_add_chain_element": {
            "name": "_add_chain_element",
            "location": 241,
            "return": [
                "None"
            ],
            "arguments": {
                "element": [
                    "List[set[str]]",
                    "Tuple[Union[float,float]]",
                    "List[Set[str]]",
                    "Union[AsyncIterable[Any],Iterable[Any]]",
                    "Tuple[float,float]",
                    "bool",
                    "Optional[object]"
                ],
                "label_id": [
                    "str",
                    "Type",
                    "int",
                    "Type[models.taxonomies.T]",
                    "Mapping",
                    "Mapping[str,Any]",
                    "sqlalchemy.Table"
                ]
            }
        },
        "_get_label_tag": {
            "name": "_get_label_tag",
            "location": 254,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "tag_key": [
                    "str",
                    "Dict[str,str]",
                    "Dict[str,list[bytes]]",
                    "sqlalchemy.orm.session.Session",
                    "Dict[str,List[bytes]]"
                ]
            }
        },
        "add_new_slice": {
            "name": "add_new_slice",
            "location": 262,
            "return": [
                "str"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "None",
                    "transfer.models.ShopID",
                    "tracim.models.data.Content",
                    "Optional[str]"
                ],
                "image": [
                    "int",
                    "str",
                    "bytes",
                    "List[libkol.types.ItemQuantity]",
                    "List[I]"
                ]
            }
        },
        "get_paginated_scans": {
            "name": "get_paginated_scans",
            "location": 280,
            "return": [
                "str",
                "supersemodels.slice.Slice",
                "Optional[Dict[str, Any]]",
                "Optional[List[str]]",
                "Optional[str]"
            ],
            "arguments": {
                "dataset_key": [
                    "str",
                    "None",
                    "bytes",
                    "int",
                    "Optional[str]"
                ],
                "page": [
                    "int",
                    "str",
                    "bytes",
                    "Optional[str]"
                ],
                "per_page": [
                    "int",
                    "str",
                    "bytes",
                    "Optional[str]"
                ]
            }
        },
        "get_scan": {
            "name": "get_scan",
            "location": 291,
            "return": [
                "str",
                "zerver.models.Realm",
                "Optional[List[str]]",
                "Optional[str]",
                "limbic.emotion.models.LexiconLimbicModel",
                "int",
                "Callable"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int",
                    "medtagger.types.ActionID"
                ]
            }
        },
        "skip_scan": {
            "name": "skip_scan",
            "location": 303,
            "return": [
                "bool"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/scans/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/scans/service_rest.py": {
        "Scans.get": {
            "name": "get",
            "location": 32,
            "return": [
                "Dict[Text,dict[Text,]]",
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "Scans.post": {
            "name": "post",
            "location": 61,
            "return": [
                "Tuple[int]",
                "Optional[Type]",
                "Dict"
            ],
            "arguments": {}
        },
        "Random.get": {
            "name": "get",
            "location": 84,
            "return": [
                "str",
                "Optional[str]",
                "Optional[Dict[str, Any]]",
                "bool"
            ],
            "arguments": {}
        },
        "Label.post": {
            "name": "post",
            "location": 104,
            "return": [
                "Tuple[int]",
                "str",
                "float",
                "Callable"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int",
                    "medtagger.types.ScanID",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "task_key": [
                    "str",
                    "bytes",
                    "List[Tuple[str,int]]",
                    "List[tuple[Union[str,int]]]"
                ]
            }
        },
        "Scan.get": {
            "name": "get",
            "location": 156,
            "return": [
                "str",
                "int",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "List[str]",
                    "medtagger.types.ScanID"
                ]
            }
        },
        "SkipScan.post": {
            "name": "post",
            "location": 171,
            "return": [
                "Tuple[Union[Text,int]]",
                "Optional[Type]",
                "Dict"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "medtagger.types.ScanID"
                ]
            }
        },
        "ScanSlices.post": {
            "name": "post",
            "location": 189,
            "return": [
                "Tuple[int]",
                "int",
                "Set",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int",
                    "medtagger.types.ScanID"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/scans/service_web_socket.py": {
        "Slices.on_request_slices": {
            "name": "on_request_slices",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "request": [
                    "Dict[str, Any]"
                ]
            }
        },
        "Slices._send_slices": {
            "name": "_send_slices",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "Optional[float]",
                    "float",
                    "Optional[int]",
                    "None",
                    "bool",
                    "int"
                ],
                "begin": [
                    "int",
                    "str",
                    "bytes",
                    "bool"
                ],
                "count": [
                    "str",
                    "int",
                    "bool"
                ],
                "orientation": [
                    "str",
                    "int",
                    "bool"
                ],
                "reversed_order": [
                    "bool",
                    "Set",
                    "List[str]",
                    "Optional[str]",
                    "bytes",
                    "List[int]",
                    "str",
                    "List"
                ]
            }
        },
        "Slices._send_predefined_labels": {
            "name": "_send_predefined_labels",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None",
                    "Optional[Dict]",
                    "Dict"
                ],
                "begin": [
                    "str",
                    "Optional[str]",
                    "int",
                    "None",
                    "List[dict]",
                    "List[list[fonduer.candidates.models.Candidate]]",
                    "List[List[fonduer.candidates.models.Candidate]]",
                    "Optional[int]",
                    "Optional[bool]"
                ],
                "count": [
                    "str",
                    "Optional[str]",
                    "int",
                    "None",
                    "List[dict]",
                    "List[list[fonduer.candidates.models.Candidate]]",
                    "List[List[fonduer.candidates.models.Candidate]]",
                    "Optional[int]",
                    "Optional[bool]"
                ],
                "task_key": [
                    "str",
                    "List[int]"
                ],
                "reversed_order": [
                    "bool",
                    "str",
                    "Optional[bool]",
                    "bytes",
                    "int",
                    "List[int]"
                ]
            }
        },
        "Slices._raise_on_invalid_request_slices": {
            "name": "_raise_on_invalid_request_slices",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "count": [
                    "int",
                    "float",
                    "str"
                ],
                "orientation": [
                    "Set[str]",
                    "str",
                    "Optional[List[str]]",
                    "List[str]",
                    "Tuple[str]",
                    "Dict[str,Any]",
                    "Union[int,float]",
                    "None",
                    "int",
                    "float"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/scans/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/tasks/business.py": {
        "get_tasks": {
            "name": "get_tasks",
            "location": 13,
            "return": [
                "str",
                "Dict[str, Any]",
                "bool",
                "models.User"
            ],
            "arguments": {}
        },
        "get_task_for_key": {
            "name": "get_task_for_key",
            "location": 21,
            "return": [
                "str",
                "Iterator[dep_check.models.SourceFile]",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {
                "task_key": [
                    "str"
                ]
            }
        },
        "create_task": {
            "name": "create_task",
            "location": 33,
            "return": [
                "str",
                "Dict[str, Any]",
                "Optional[IO[str]]",
                "dict"
            ],
            "arguments": {
                "key": [
                    "str",
                    "List[str]"
                ],
                "name": [
                    "str",
                    "List[str]"
                ],
                "image_path": [
                    "str",
                    "List[str]"
                ],
                "datasets_keys": [
                    "str",
                    "List[str]"
                ],
                "description": [
                    "str",
                    "List[str]"
                ],
                "label_examples": [
                    "str",
                    "List[str]"
                ],
                "tags": [
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/tasks/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/tasks/service_rest.py": {
        "Tasks.get": {
            "name": "get",
            "location": 25,
            "return": [
                "str",
                "bool",
                "daylighdb.models.Photo",
                "Iterable[str]",
                "zerver.models.UserProfile",
                "app.models.Tweet",
                "app.models.Position"
            ],
            "arguments": {}
        },
        "Tasks.post": {
            "name": "post",
            "location": 37,
            "return": [
                "Tuple[int]",
                "Dict[str,str]",
                "str"
            ],
            "arguments": {}
        },
        "Task.get": {
            "name": "get",
            "location": 61,
            "return": [
                "str",
                "Optional[int]",
                "Optional[List[Any]]"
            ],
            "arguments": {
                "task_key": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/tasks/__init__.py": {},
    "MedTagger-master/backend/medtagger/api/users/business.py": {
        "get_all_users": {
            "name": "get_all_users",
            "location": 12,
            "return": [
                "app.models.User",
                "str",
                "Optional[str]",
                "Sequence[str]",
                "abilian.core.models.subjects.User"
            ],
            "arguments": {}
        },
        "set_user_role": {
            "name": "set_user_role",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "user_id": [
                    "str",
                    "int",
                    "salon.models.Stylist"
                ],
                "role_name": [
                    "str",
                    "int",
                    "salon.models.Stylist"
                ]
            }
        },
        "set_user_info": {
            "name": "set_user_info",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "user_id": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ],
                "firstName": [
                    "str",
                    "Set[str]"
                ],
                "lastName": [
                    "str",
                    "Set[str]"
                ]
            }
        },
        "set_user_settings": {
            "name": "set_user_settings",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "value": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/users/serializers.py": {},
    "MedTagger-master/backend/medtagger/api/users/service.py": {
        "GetUsers.get": {
            "name": "get",
            "location": 26,
            "return": [
                "Tuple[Union[dict[Text,Union[str,dict[str,Union[int,str]],dict[str,str],int]],int]]",
                "str",
                "Dict[str,str]"
            ],
            "arguments": {}
        },
        "SetRole.put": {
            "name": "put",
            "location": 40,
            "return": [
                "bool",
                "Tuple[Union[dict[Text,bool],int]]"
            ],
            "arguments": {
                "user_id": [
                    "int",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "GetUserInfo.get": {
            "name": "get",
            "location": 55,
            "return": [
                "Tuple[Union[str,dict[str,Union[int,str]],dict[str,str],int]]",
                "Set",
                "bool",
                "Iterable[str]",
                "bob_emploi.frontend.api.user_pb2.User",
                "Dict[str,Any]"
            ],
            "arguments": {}
        },
        "SetUserSettings.post": {
            "name": "post",
            "location": 68,
            "return": [
                "bool",
                "Tuple[Union[dict[Text,bool],int]]"
            ],
            "arguments": {
                "user_id": [
                    "int",
                    "Sequence[int]",
                    "List[int]"
                ]
            }
        },
        "SetUserInfo.put": {
            "name": "put",
            "location": 85,
            "return": [
                "bool",
                "Tuple[Union[dict[Text,bool],int]]"
            ],
            "arguments": {
                "user_id": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/api/users/__init__.py": {},
    "MedTagger-master/backend/medtagger/database/fixtures.py": {
        "insert_user_roles": {
            "name": "insert_user_roles",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "apply_all_fixtures": {
            "name": "apply_all_fixtures",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/database/models.py": {
        "delete_brush_element_from_storage": {
            "name": "delete_brush_element_from_storage",
            "location": 828,
            "return": [
                "None"
            ],
            "arguments": {
                "mapper": [
                    "bytes",
                    "sqlalchemy.engine.Connection",
                    "sqlalchemy.orm.mapper.Mapper"
                ],
                "connection": [
                    "bytes",
                    "sqlalchemy.engine.Connection",
                    "sqlalchemy.orm.mapper.Mapper"
                ],
                "target": [
                    "bytes",
                    "Dict[str,Any]",
                    "models.Membership",
                    "viewer.models.Gallery",
                    "deeplearning.ml4pl.models.classifier_base.ClassifierBase"
                ]
            }
        },
        "delete_original_and_processed_slice_from_storage": {
            "name": "delete_original_and_processed_slice_from_storage",
            "location": 836,
            "return": [
                "None"
            ],
            "arguments": {
                "mapper": [
                    "bytes",
                    "bool",
                    "sqlalchemy.orm.mapper.Mapper",
                    "sqlalchemy.engine.Connection",
                    "rouver.types.StartResponse",
                    "rouver.types.WSGIEnvironment"
                ],
                "connection": [
                    "bytes",
                    "bool",
                    "sqlalchemy.orm.mapper.Mapper",
                    "sqlalchemy.engine.Connection",
                    "rouver.types.StartResponse",
                    "rouver.types.WSGIEnvironment"
                ],
                "target": [
                    "str",
                    "Dict",
                    "Dict[str,Any]",
                    "zam_repondeur.models.Dossier"
                ]
            }
        },
        "Role.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Dict[str,Any]",
                    "List[str]",
                    "Dict"
                ]
            }
        },
        "User.__init__": {
            "name": "__init__",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "email": [
                    "str",
                    "Optional[str]",
                    "None",
                    "int",
                    "List[dict[str,Any]]",
                    "airflow.models.TaskInstance",
                    "Optional[int]",
                    "List[Dict[str,Any]]"
                ],
                "password_hash": [
                    "str",
                    "Optional[str]",
                    "None",
                    "int",
                    "List[dict[str,Any]]",
                    "airflow.models.TaskInstance",
                    "Optional[int]",
                    "List[Dict[str,Any]]"
                ],
                "first_name": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "last_name": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "User.__repr__": {
            "name": "__repr__",
            "location": 69,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "User.role": {
            "name": "role",
            "location": 74,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "UserSettings.__init__": {
            "name": "__init__",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.__init__": {
            "name": "__init__",
            "location": 113,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "None",
                    "Dict",
                    "Optional[str]",
                    "Any",
                    "Optional[Union[Any,str]]",
                    "T"
                ],
                "name": [
                    "str",
                    "List[str]",
                    "Dict[str,Any]",
                    "Dict"
                ]
            }
        },
        "Dataset.__repr__": {
            "name": "__repr__",
            "location": 122,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Task.__init__": {
            "name": "__init__",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "Dict[str,Any]",
                    "Callable[[str],str]",
                    "Callable[str,str]"
                ],
                "name": [
                    "str",
                    "List[str]"
                ],
                "image_path": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "Task.__repr__": {
            "name": "__repr__",
            "location": 154,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Task.available_tags": {
            "name": "available_tags",
            "location": 164,
            "return": [
                "None",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "new_tags": [
                    "bool"
                ]
            }
        },
        "Task.number_of_available_scans": {
            "name": "number_of_available_scans",
            "location": 169,
            "return": [
                "int",
                "mypy.types.Type",
                "str",
                "types.Resolver",
                "Tuple[str]",
                "Dict[str,Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scan.__init__": {
            "name": "__init__",
            "location": 198,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "str",
                    "int",
                    "Callable",
                    "Callable[...,None]"
                ],
                "declared_number_of_slices": [
                    "str",
                    "int",
                    "Callable",
                    "Callable[...,None]"
                ],
                "user": [
                    "bool",
                    "List[str]",
                    "Type",
                    "sqlalchemy.orm.session.Session",
                    "None",
                    "django.contrib.auth.models.AbstractBaseUser",
                    "zerver.models.UserProfile",
                    "Type[models.User]",
                    "Optional[services.user.transfer.models.User]"
                ]
            }
        },
        "Scan.__repr__": {
            "name": "__repr__",
            "location": 210,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scan.width": {
            "name": "width",
            "location": 215,
            "return": [
                "None",
                "bool",
                "str",
                "Union[str,int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scan.height": {
            "name": "height",
            "location": 225,
            "return": [
                "None",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scan.add_slice": {
            "name": "add_slice",
            "location": 234,
            "return": [
                "Slice"
            ],
            "arguments": {
                "self": [],
                "orientation": [
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "Scan.update_status": {
            "name": "update_status",
            "location": 245,
            "return": [
                "Scan"
            ],
            "arguments": {
                "self": [
                    "_TScan@@Scan@@"
                ],
                "status": [
                    "str",
                    "int"
                ]
            }
        },
        "Slice.__init__": {
            "name": "__init__",
            "location": 273,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "orientation": [
                    "List[Dict[str,Any]]",
                    "bytes",
                    "List[dict[str,Any]]",
                    "str",
                    "List",
                    "Dict",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ],
                "location": [
                    "bool",
                    "None",
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "position": [
                    "bool",
                    "None",
                    "List[int]",
                    "int",
                    "str"
                ]
            }
        },
        "Slice.__repr__": {
            "name": "__repr__",
            "location": 290,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Slice.update_location": {
            "name": "update_location",
            "location": 294,
            "return": [
                "Slice"
            ],
            "arguments": {
                "self": [
                    "_TSlice@@Slice@@"
                ],
                "new_location": [
                    "str",
                    "int",
                    "Optional[types.RootValue]",
                    "None"
                ]
            }
        },
        "Slice.update_position": {
            "name": "update_position",
            "location": 300,
            "return": [
                "Slice"
            ],
            "arguments": {
                "self": [
                    "_TSlice@@Slice@@"
                ],
                "new_position": [
                    "float",
                    "Tuple",
                    "int"
                ]
            }
        },
        "Slice.update_size": {
            "name": "update_size",
            "location": 308,
            "return": [
                "Slice"
            ],
            "arguments": {
                "self": [
                    "_TSlice@@Slice@@"
                ],
                "height": [
                    "int",
                    "str",
                    "Tuple[str,str,str]",
                    "Tuple[Union[str,str,str]]",
                    "Tuple[List[str],Optional[str]]",
                    "Tuple[Union[list[str],str,None]]"
                ],
                "width": [
                    "int",
                    "str",
                    "Tuple[str,str,str]",
                    "Tuple[Union[str,str,str]]",
                    "Tuple[List[str],Optional[str]]",
                    "Tuple[Union[list[str],str,None]]"
                ]
            }
        },
        "Slice.update_status": {
            "name": "update_status",
            "location": 315,
            "return": [
                "Slice"
            ],
            "arguments": {
                "self": [
                    "_TSlice@@Slice@@"
                ],
                "status": [
                    "str",
                    "int"
                ]
            }
        },
        "Label.__init__": {
            "name": "__init__",
            "location": 354,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "user": [
                    "Dict[str,str]",
                    "str",
                    "Callable[,Any]",
                    "myaku.datastore.database.ArticleIndexDb",
                    "None",
                    "Optional[str]"
                ],
                "labeling_time": [
                    "medtagger.types.LabelingTime",
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "float",
                    "None"
                ],
                "comment": [
                    "bool",
                    "None",
                    "Tuple[Union[int,int]]",
                    "users.models.JustfixUser",
                    "reader_server.types.User",
                    "Tuple[int,int]",
                    "utils.Vote"
                ],
                "is_predefined": [
                    "bool",
                    "users.models.JustfixUser",
                    "reader_server.types.User",
                    "Tuple[int,int]",
                    "utils.Vote"
                ]
            }
        },
        "Label.__repr__": {
            "name": "__repr__",
            "location": 372,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Label.update_status": {
            "name": "update_status",
            "location": 377,
            "return": [
                "Label"
            ],
            "arguments": {
                "self": [
                    "_TLabel@@Label@@"
                ],
                "status": [
                    "str",
                    "int"
                ]
            }
        },
        "LabelTag.__init__": {
            "name": "__init__",
            "location": 403,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "kombu.Connection",
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "name": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "tools": [
                    "str",
                    "bool",
                    "None",
                    "sqlalchemy.orm.state.InstanceState",
                    "Callable[,bool]",
                    "Optional[str]",
                    "MutableMapping",
                    "Optional[Callable[,bool]]",
                    "MutableMapping[str,Any]"
                ],
                "actions": [
                    "str",
                    "None",
                    "bool",
                    "sqlalchemy.orm.state.InstanceState",
                    "Callable[,bool]",
                    "Optional[str]",
                    "MutableMapping",
                    "Optional[Callable[,bool]]",
                    "MutableMapping[str,Any]"
                ]
            }
        },
        "LabelTag.__repr__": {
            "name": "__repr__",
            "location": 416,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelElement.__init__": {
            "name": "__init__",
            "location": 445,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "Dict",
                    "bytes",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "LabelElement.__repr__": {
            "name": "__repr__",
            "location": 454,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelElement.update_status": {
            "name": "update_status",
            "location": 458,
            "return": [
                "LabelElement"
            ],
            "arguments": {
                "self": [
                    "_TLabelElement@@LabelElement@@"
                ],
                "status": [
                    "str",
                    "int"
                ]
            }
        },
        "RectangularLabelElement.__init__": {
            "name": "__init__",
            "location": 484,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "position": [
                    "int",
                    "Optional[dict]",
                    "Dict",
                    "bool",
                    "None"
                ],
                "shape": [
                    "int",
                    "Tuple[Union[int,int]]",
                    "Tuple[int,int]",
                    "bool"
                ],
                "tag": [
                    "bool",
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "None",
                    "Optional[Dict[str,str]]",
                    "Dict[str,str]"
                ]
            }
        },
        "RectangularLabelElement.__repr__": {
            "name": "__repr__",
            "location": 498,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BrushLabelElement.__init__": {
            "name": "__init__",
            "location": 516,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "slice_index": [
                    "Optional[str]",
                    "str",
                    "float",
                    "None",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "List[Any]",
                    "Optional[List[str]]",
                    "bool",
                    "Container[str]",
                    "List[str]",
                    "int",
                    "Container"
                ],
                "width": [
                    "Optional[str]",
                    "str",
                    "float",
                    "None",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "List[Any]",
                    "Optional[List[str]]",
                    "bool",
                    "Container[str]",
                    "List[str]",
                    "int",
                    "Container"
                ],
                "height": [
                    "Optional[str]",
                    "str",
                    "float",
                    "None",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "List[Any]",
                    "Optional[List[str]]",
                    "bool",
                    "Container[str]",
                    "List[str]",
                    "int",
                    "Container"
                ],
                "tag": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "Dict",
                    "None"
                ]
            }
        },
        "BrushLabelElement.__repr__": {
            "name": "__repr__",
            "location": 529,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PointLabelElement.__init__": {
            "name": "__init__",
            "location": 547,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "position": [
                    "Dict[str,Any]",
                    "str",
                    "float",
                    "medtagger.types.LabelPosition"
                ],
                "tag": [
                    "bytes"
                ]
            }
        },
        "PointLabelElement.__repr__": {
            "name": "__repr__",
            "location": 558,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChainLabelElement.__init__": {
            "name": "__init__",
            "location": 578,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "slice_index": [
                    "int",
                    "str",
                    "bool",
                    "List[list[str]]",
                    "List[List[str]]"
                ],
                "tag": [
                    "bytes"
                ],
                "loop": [
                    "int",
                    "str",
                    "bool",
                    "List[list[str]]",
                    "List[List[str]]"
                ]
            }
        },
        "ChainLabelElement.__repr__": {
            "name": "__repr__",
            "location": 589,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChainLabelElementPoint.__init__": {
            "name": "__init__",
            "location": 607,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "int",
                    "Dict"
                ],
                "y": [
                    "bytes",
                    "float",
                    "int",
                    "Union[float,int]",
                    "Optional[str]",
                    "str",
                    "Optional[int]",
                    "None"
                ],
                "label_element_id": [
                    "int",
                    "str",
                    "bool"
                ],
                "order": [
                    "str",
                    "int",
                    "Dict"
                ]
            }
        },
        "ChainLabelElementPoint.__repr__": {
            "name": "__repr__",
            "location": 622,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Action.__init__": {
            "name": "__init__",
            "location": 651,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Dict[str,Any]",
                    "List[str]",
                    "Dict"
                ]
            }
        },
        "Action.__repr__": {
            "name": "__repr__",
            "location": 658,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Survey.__init__": {
            "name": "__init__",
            "location": 677,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "initial_element_key": [
                    "str",
                    "Optional[int]",
                    "int",
                    "None"
                ]
            }
        },
        "Survey.get_details": {
            "name": "get_details",
            "location": 686,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Survey.validate_response": {
            "name": "validate_response",
            "location": 694,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "response": [
                    "List[str]",
                    "Dict",
                    "List[int]",
                    "raiden.utils.Dict"
                ]
            }
        },
        "SurveyElement.__init__": {
            "name": "__init__",
            "location": 718,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "Dict",
                    "Optional[str]",
                    "None"
                ],
                "instant_next_element": [
                    "bool",
                    "None",
                    "str",
                    "Sequence[str]",
                    "Optional[List[Any]]",
                    "Tuple[int,int]",
                    "List[Any]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "SurveyElement.get_details": {
            "name": "get_details",
            "location": 727,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SurveySingleChoiceQuestion.__init__": {
            "name": "__init__",
            "location": 748,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "Dict[Tuple[int,int],int]",
                    "bool",
                    "Dict[tuple[Union[int,int]],int]",
                    "str"
                ],
                "title": [
                    "bool",
                    "str",
                    "bytes"
                ],
                "possible_answers": [
                    "bool",
                    "str",
                    "bytes"
                ],
                "instant_next_element": [
                    "Dict[Tuple[int,int],int]",
                    "bool",
                    "None",
                    "str",
                    "Dict[tuple[Union[int,int]],int]"
                ]
            }
        },
        "SurveySingleChoiceQuestion.__repr__": {
            "name": "__repr__",
            "location": 761,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SurveySingleChoiceQuestion.get_details": {
            "name": "get_details",
            "location": 765,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ActionResponse.get_details": {
            "name": "get_details",
            "location": 790,
            "return": [
                "Dict[(nothing, nothing)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SurveyResponse.__init__": {
            "name": "__init__",
            "location": 811,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "survey_id": [
                    "str",
                    "Dict[str,str]",
                    "Dict",
                    "bytes",
                    "Dict[str,Any]",
                    "Tuple[Union[int,int]]",
                    "Tuple[int,int]"
                ],
                "data": [
                    "str",
                    "Dict",
                    "Dict[str,str]",
                    "bytes",
                    "None",
                    "Optional[dict]",
                    "Optional[Dict[str,Any]]"
                ]
            }
        },
        "SurveyResponse.get_details": {
            "name": "get_details",
            "location": 821,
            "return": [
                "bytes",
                "Dict[str, Any]",
                "str",
                "Callable",
                "Optional[str]",
                "Callable[[str], T]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "MedTagger-master/backend/medtagger/database/utils.py": {
        "ArrayOfEnum.bind_expression": {
            "name": "bind_expression",
            "location": 14,
            "return": [
                "str",
                "sqlalchemy.engine.base.Engine"
            ],
            "arguments": {
                "self": [],
                "bindvalue": [
                    "str",
                    "sqlalchemy.engine.base.Engine"
                ]
            }
        },
        "ArrayOfEnum.result_processor": {
            "name": "result_processor",
            "location": 18,
            "return": [
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "dialect": [
                    "str",
                    "Sequence[str]",
                    "Iterator[Tuple[str,Any,Any]]",
                    "Iterator"
                ],
                "coltype": [
                    "str",
                    "Sequence[str]",
                    "Iterator[Tuple[str,Any,Any]]",
                    "Iterator"
                ]
            }
        },
        "ArrayOfEnum.result_processor.handle_raw_string": {
            "name": "handle_raw_string",
            "location": 22,
            "return": [
                "List",
                "bool",
                "str",
                "List[Dict[str,str]]"
            ],
            "arguments": {
                "value": [
                    "str"
                ]
            }
        },
        "ArrayOfEnum.result_processor.process": {
            "name": "process",
            "location": 31,
            "return": [
                "str"
            ],
            "arguments": {
                "value": [
                    "str",
                    "Type",
                    "int",
                    "bool"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/database/__init__.py": {
        "connect": {
            "name": "connect",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "dbapi_connection": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "connection_record": [
                    "str",
                    "Dict"
                ]
            }
        },
        "checkout": {
            "name": "checkout",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "dbapi_connection": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "connection_record": [
                    "Callable[Mapping,collections.abc.Awaitable]",
                    "bool",
                    "Callable[[Mapping],Awaitable]",
                    "Callable[,Awaitable[Mapping]]"
                ],
                "connection_proxy": [
                    "Optional[BaseException]",
                    "str",
                    "BaseException",
                    "None"
                ]
            }
        },
        "is_alive": {
            "name": "is_alive",
            "location": 76,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "db_connection_session": {
            "name": "db_connection_session",
            "location": 86,
            "return": [
                "Generator[sqlalchemy.orm.Session,None,None]",
                "Generator"
            ],
            "arguments": {}
        },
        "db_transaction_session": {
            "name": "db_transaction_session",
            "location": 93,
            "return": [
                "Generator[sqlalchemy.orm.Session,None,None]",
                "Generator"
            ],
            "arguments": {}
        },
        "MedTaggerBase.__repr__": {
            "name": "__repr__",
            "location": 21,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MedTaggerBase.save": {
            "name": "save",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/generator.py": {
        "DataSetGenerator.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "algorithm": [
                    "int",
                    "float",
                    "bool",
                    "apistar.types.RouteConfig"
                ]
            }
        },
        "DataSetGenerator.generate": {
            "name": "generate",
            "location": 24,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "label_elements": [
                    "str",
                    "List[str]",
                    "int",
                    "float",
                    "bool"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/__init__.py": {},
    "MedTagger-master/backend/medtagger/ground_truth/algorithms/base.py": {
        "GeneratorAlgorithm.get_ground_truth": {
            "name": "get_ground_truth",
            "location": 12,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Dict[str,Any]",
                    "bytes",
                    "Mapping",
                    "List",
                    "numpy.ndarray",
                    "int",
                    "Mapping[str,Any]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/algorithms/dbscan.py": {
        "DBSCANAlgorithm.get_ground_truth": {
            "name": "get_ground_truth",
            "location": 20,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/algorithms/gaussian_mixture_models.py": {
        "GaussianMixtureModelsAlgorithm.get_ground_truth": {
            "name": "get_ground_truth",
            "location": 18,
            "return": [
                "str",
                "base.Model"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Dict[str,Any]",
                    "bool",
                    "Dict",
                    "str"
                ]
            }
        },
        "GaussianMixtureModelsAlgorithm._choose_number_of_components": {
            "name": "_choose_number_of_components",
            "location": 31,
            "return": [
                "int",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/algorithms/k_means.py": {
        "KMeansAlgorithm.get_ground_truth": {
            "name": "get_ground_truth",
            "location": 16,
            "return": [
                "str",
                "base.Model"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Dict[str,Any]",
                    "bool",
                    "Dict",
                    "str"
                ]
            }
        },
        "KMeansAlgorithm._choose_number_of_clusters": {
            "name": "_choose_number_of_clusters",
            "location": 28,
            "return": [
                "List[List[str]]",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "int",
                    "str",
                    "bytes",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/algorithms/majority_voting.py": {
        "MajorityVotingAlgorithm.get_ground_truth": {
            "name": "get_ground_truth",
            "location": 14,
            "return": [
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Dict",
                    "bytes",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/algorithms/__init__.py": {},
    "MedTagger-master/backend/medtagger/ground_truth/parsers/base.py": {
        "LabelElementParser.convert_to_numpy": {
            "name": "convert_to_numpy",
            "location": 13,
            "return": [
                "numpy.ndarray",
                "None"
            ],
            "arguments": {
                "self": [],
                "label_elements": [
                    "bool",
                    "List[medtagger.database.models.LabelElement]",
                    "str",
                    "None",
                    "Optional[str]",
                    "int",
                    "Iterable[str]"
                ],
                "resize_image": [
                    "bool",
                    "List[medtagger.database.models.LabelElement]",
                    "Optional[str]",
                    "int",
                    "str",
                    "Iterable[str]"
                ]
            }
        },
        "LabelElementParser.compute_intersection_over_union": {
            "name": "compute_intersection_over_union",
            "location": 22,
            "return": [
                "float",
                "None"
            ],
            "arguments": {
                "self": [],
                "first_label_element": [
                    "bool",
                    "numpy.ndarray",
                    "Set[str]",
                    "None",
                    "Optional[Set[str]]",
                    "Iterable[Any]",
                    "Iterable[float]"
                ],
                "second_label_element": [
                    "bool",
                    "numpy.ndarray",
                    "Set[str]",
                    "None",
                    "Optional[Set[str]]",
                    "Iterable[Any]",
                    "Iterable[float]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/parsers/chain.py": {
        "ChainLabelElementParser.convert_to_numpy": {
            "name": "convert_to_numpy",
            "location": 19,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "base.ConfigOptions",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "label_elements": [
                    "List[medtagger.database.models.LabelElement]",
                    "str",
                    "bool",
                    "Optional[str]",
                    "int",
                    "Iterable[str]"
                ],
                "resize_image": [
                    "bool",
                    "List[medtagger.database.models.LabelElement]",
                    "Optional[str]",
                    "int",
                    "str",
                    "Iterable[str]"
                ]
            }
        },
        "ChainLabelElementParser.compute_intersection_over_union": {
            "name": "compute_intersection_over_union",
            "location": 50,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "first_label_element": [
                    "int",
                    "Callable"
                ],
                "second_label_element": [
                    "int",
                    "Callable"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/parsers/rectangle.py": {
        "RectangleLabelElementParser.convert_to_numpy": {
            "name": "convert_to_numpy",
            "location": 13,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "label_elements": [
                    "Tuple[Union[int,int]]",
                    "bytes",
                    "bool",
                    "List[str]",
                    "Tuple[int,int]",
                    "medtagger.types.LabelPosition"
                ],
                "resize_image": [
                    "bool",
                    "List[medtagger.database.models.LabelElement]",
                    "Optional[str]",
                    "int",
                    "str",
                    "Iterable[str]"
                ]
            }
        },
        "RectangleLabelElementParser.compute_intersection_over_union": {
            "name": "compute_intersection_over_union",
            "location": 23,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "first_label_element": [
                    "str",
                    "bool",
                    "django.db.models.Model"
                ],
                "second_label_element": [
                    "str",
                    "bool",
                    "django.db.models.Model"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/parsers/__init__.py": {
        "get_parser": {
            "name": "get_parser",
            "location": 8,
            "return": [
                "dict",
                "bool",
                "videoarchiver.tvasahi.models.Episode",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "label_element_type": [
                    "str",
                    "Dict",
                    "Dict[str,Any]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/quality/figures.py": {
        "specificity_vs_sensitivity": {
            "name": "specificity_vs_sensitivity",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "users_specificity": [
                    "Dict[medtagger.types.UserID,float]",
                    "zerver.models.UserProfile",
                    "zerver.models.UserGroup",
                    "List[zerver.models.UserProfile]",
                    "models.User",
                    "abilian.core.models.subjects.User"
                ],
                "users_sensitivity": [
                    "Dict[medtagger.types.UserID,float]",
                    "zerver.models.UserProfile",
                    "zerver.models.UserGroup",
                    "List[zerver.models.UserProfile]",
                    "models.User",
                    "abilian.core.models.subjects.User"
                ]
            }
        },
        "mean_labeling_time_vs_score": {
            "name": "mean_labeling_time_vs_score",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "label_elements": [
                    "str",
                    "Dict[str,str]",
                    "bool",
                    "zerver.models.Client",
                    "raiden_libs.types.Address"
                ],
                "users_scores": [
                    "Dict[str,dict[str,Any]]",
                    "correios.models.posting.ShippingLabel",
                    "metaswitch_tinder.database.models.Request",
                    "Dict[str,Dict[str,Any]]",
                    "Callable[[Type,str],bool]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/quality/user_specificity_sensitivity.py": {
        "compute_specificity_and_sensitivity_for_users": {
            "name": "compute_specificity_and_sensitivity_for_users",
            "location": 27,
            "return": [
                "Tuple[(collections.defaultdict, collections.defaultdict, collections.defaultdict)]"
            ],
            "arguments": {
                "algorithm": [
                    "str",
                    "authentication.session.models.current_user.CurrentUser",
                    "lms.lmsdb.models.User",
                    "lms.lmsdb.models.Solution",
                    "zerver.models.Stream",
                    "zerver.models.Recipient"
                ],
                "users": [
                    "List[str]",
                    "str",
                    "django.contrib.auth.models.AbstractBaseUser",
                    "Type[models.User]",
                    "Optional[services.user.transfer.models.User]",
                    "users.models.JustfixUser"
                ],
                "label_elements": [
                    "str",
                    "bool",
                    "core.models.Groups",
                    "int"
                ],
                "ground_truth": [
                    "Mapping[str, Any]",
                    "dict"
                ]
            }
        },
        "_analyse_user_label_elements": {
            "name": "_analyse_user_label_elements",
            "location": 77,
            "return": [
                "Statistics"
            ],
            "arguments": {
                "algorithm": [
                    "Callable",
                    "Optional[Callable]",
                    "None",
                    "str",
                    "bool",
                    "Callable[,str]",
                    "Optional[str]",
                    "Dict[str,Any]",
                    "Optional[Dict[str,Any]]"
                ],
                "user_label_elements_for_this_slice": [
                    "str",
                    "bool",
                    "tracim.models.User",
                    "Optional[int]",
                    "Optional[Sequence[str]]",
                    "Optional[str]"
                ],
                "all_label_elements_for_this_slice": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "int"
                ],
                "ground_truth_annotation": [
                    "bool",
                    "str",
                    "Dict[str,Any]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/ground_truth/quality/__init__.py": {},
    "MedTagger-master/backend/medtagger/repositories/actions.py": {
        "get_action_by_id": {
            "name": "get_action_by_id",
            "location": 10,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "action_id": [
                    "int",
                    "medtagger.types.ActionID",
                    "medtagger.types.ScanID",
                    "shop.transfer.models.ShopID"
                ]
            }
        },
        "add_action_response": {
            "name": "add_action_response",
            "location": 15,
            "return": [
                "medtagger.database.models.SurveyResponse"
            ],
            "arguments": {
                "action_id": [
                    "int",
                    "str",
                    "medtagger.types.ActionID"
                ],
                "response": [
                    "int",
                    "str",
                    "Dict",
                    "Dict[str,str]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/datasets.py": {
        "get_all_datasets": {
            "name": "get_all_datasets",
            "location": 9,
            "return": [
                "str",
                "bool",
                "Mapping",
                "Dict[str, str]",
                "games.models.Game",
                "int"
            ],
            "arguments": {
                "include_disabled": [
                    "bool",
                    "str",
                    "Set[str]"
                ]
            }
        },
        "get_dataset_by_key": {
            "name": "get_dataset_by_key",
            "location": 17,
            "return": [
                "str",
                "int",
                "List",
                "Dict[str,Union[Any,Any]]",
                "Dict[str,str]",
                "List[str]",
                "None"
            ],
            "arguments": {
                "key": [
                    "str",
                    "core.models.User.Key"
                ]
            }
        },
        "add_new_dataset": {
            "name": "add_new_dataset",
            "location": 28,
            "return": [
                "medtagger.database.models.Dataset"
            ],
            "arguments": {
                "key": [
                    "str",
                    "bytes"
                ],
                "name": [
                    "str",
                    "bytes"
                ]
            }
        },
        "update": {
            "name": "update",
            "location": 41,
            "return": [
                "float",
                "zam_repondeur.models.Amendement",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "key": [
                    "str"
                ],
                "name": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "disable": {
            "name": "disable",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "key": [
                    "str",
                    "bytes",
                    "Dict"
                ]
            }
        },
        "enable": {
            "name": "enable",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "key": [
                    "str",
                    "bytes",
                    "Dict"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/labels.py": {
        "get_all_labels": {
            "name": "get_all_labels",
            "location": 14,
            "return": [
                "dict",
                "Dict[str, str]",
                "tracim.models.auth.User",
                "Dict[str, Dict[str, Any]]",
                "Dict[str, models.DeviceRow]"
            ],
            "arguments": {}
        },
        "get_label_by_id": {
            "name": "get_label_by_id",
            "location": 19,
            "return": [
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "label_id": [
                    "int",
                    "Iterable[int]",
                    "medtagger.types.LabelID",
                    "medtagger.types.ActionID",
                    "medtagger.types.ScanID"
                ]
            }
        },
        "get_random_label": {
            "name": "get_random_label",
            "location": 24,
            "return": [
                "str",
                "bool",
                "db.models.Taxon"
            ],
            "arguments": {
                "status": [
                    "medtagger.definitions.LabelVerificationStatus",
                    "str",
                    "None",
                    "int",
                    "Callable[[str],int]",
                    "Callable[str,int]"
                ]
            }
        },
        "get_predefined_label_for_scan_in_task": {
            "name": "get_predefined_label_for_scan_in_task",
            "location": 38,
            "return": [
                "dict",
                "list",
                "str",
                "Iterable[Tuple[str, str]]"
            ],
            "arguments": {
                "scan": [
                    "str",
                    "medtagger.database.models.Scan",
                    "Any",
                    "Dict",
                    "None",
                    "medtagger.database.models.Task",
                    "Optional[Any]",
                    "Task"
                ],
                "task": [
                    "Callable[str,str,None]",
                    "medtagger.database.models.Task",
                    "medtagger.database.models.Scan",
                    "pc.data.Task",
                    "Callable[[str,str],None]",
                    "nufb.task.Task"
                ]
            }
        },
        "get_predefined_brush_label_elements": {
            "name": "get_predefined_brush_label_elements",
            "location": 52,
            "return": [
                "dict",
                "Dict[str, Any]",
                "Dict[str, models.DeviceRow]",
                "Dict[str, float]"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int",
                    "medtagger.types.ScanID",
                    "None",
                    "List[str]",
                    "transfer.models.RoleID",
                    "transfer.models.TopicID",
                    "Optional[str]"
                ],
                "task_id": [
                    "int",
                    "str",
                    "shop.transfer.models.ShopID",
                    "transfer.models.TopicID",
                    "transfer.models.BoardID",
                    "transfer.models.CategoryID"
                ],
                "begin": [
                    "int",
                    "str",
                    "medtagger.definitions.SliceOrientation"
                ],
                "count": [
                    "int",
                    "str"
                ]
            }
        },
        "add_new_label": {
            "name": "add_new_label",
            "location": 73,
            "return": [
                "medtagger.database.models.Label"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "medtagger.types.ScanID"
                ],
                "task_key": [
                    "str",
                    "bool",
                    "int"
                ],
                "user": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ],
                "labeling_time": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ],
                "comment": [
                    "str",
                    "None",
                    "List[str]",
                    "Optional[str]"
                ],
                "is_predefined": [
                    "bool",
                    "str",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "add_new_rectangular_label_element": {
            "name": "add_new_rectangular_label_element",
            "location": 94,
            "return": [
                "Union[(medtagger.types.LabelElementID, sqlalchemy.sql.schema.Column)]"
            ],
            "arguments": {
                "label_id": [
                    "medtagger.types.LabelID",
                    "str",
                    "int",
                    "Optional[str]",
                    "None",
                    "Sequence[str]",
                    "Optional[Dict[str,str]]",
                    "Dict[str,str]"
                ],
                "position": [
                    "str",
                    "bytes",
                    "Optional[list]",
                    "List[str]",
                    "List",
                    "int",
                    "None"
                ],
                "shape": [
                    "str",
                    "bytes",
                    "Optional[list]",
                    "List[str]",
                    "List",
                    "int",
                    "None"
                ],
                "label_tag": [
                    "str",
                    "bytes",
                    "Optional[list]",
                    "List[str]",
                    "List",
                    "int",
                    "None"
                ]
            }
        },
        "add_new_brush_label_element": {
            "name": "add_new_brush_label_element",
            "location": 112,
            "return": [
                "Union[(medtagger.types.LabelElementID, sqlalchemy.sql.schema.Column)]"
            ],
            "arguments": {
                "label_id": [
                    "str",
                    "int",
                    "medtagger.types.LabelID",
                    "None",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "slice_index": [
                    "int",
                    "str",
                    "Callable[[None],None]",
                    "Callable[None,None]",
                    "Optional[Union[float,int]]",
                    "float",
                    "None"
                ],
                "width": [
                    "int",
                    "str",
                    "Callable[[None],None]",
                    "Callable[None,None]",
                    "Optional[Union[float,int]]",
                    "float",
                    "None"
                ],
                "height": [
                    "int",
                    "str",
                    "Callable[[None],None]",
                    "Callable[None,None]",
                    "Optional[Union[float,int]]",
                    "float",
                    "None"
                ],
                "image": [
                    "bytes",
                    "int",
                    "Iterable[Sequence[str]]",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "label_tag": [
                    "int",
                    "str",
                    "Callable[[None],None]",
                    "Callable[None,None]",
                    "Optional[Union[float,int]]",
                    "float",
                    "None"
                ]
            }
        },
        "add_new_point_label_element": {
            "name": "add_new_point_label_element",
            "location": 133,
            "return": [
                "Union[(medtagger.types.LabelElementID, sqlalchemy.sql.schema.Column)]"
            ],
            "arguments": {
                "label_id": [
                    "int",
                    "medtagger.types.LabelID",
                    "Dict",
                    "str",
                    "Optional[str]",
                    "Sequence[str]",
                    "None",
                    "Optional[Dict[str,str]]",
                    "Dict[str,str]"
                ],
                "position": [
                    "str",
                    "List",
                    "bytes",
                    "List[str]",
                    "int",
                    "Iterable[Sequence[str]]",
                    "None",
                    "Optional[List[str]]"
                ],
                "label_tag": [
                    "str",
                    "List",
                    "bytes",
                    "List[str]",
                    "int",
                    "Iterable[Sequence[str]]",
                    "None",
                    "Optional[List[str]]"
                ]
            }
        },
        "add_new_chain_label_element": {
            "name": "add_new_chain_label_element",
            "location": 149,
            "return": [
                "Union[(medtagger.types.LabelElementID, sqlalchemy.sql.schema.Column)]"
            ],
            "arguments": {
                "label_id": [
                    "medtagger.types.LabelID",
                    "str",
                    "int",
                    "Optional[str]",
                    "None",
                    "Sequence[str]",
                    "Optional[Dict[str,str]]",
                    "Dict[str,str]"
                ],
                "slice_index": [
                    "bool",
                    "str",
                    "float",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "Optional[str]",
                    "None"
                ],
                "label_tag": [
                    "bool",
                    "str",
                    "float",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "Optional[str]",
                    "None"
                ],
                "points": [
                    "str",
                    "bytes",
                    "Callable",
                    "int",
                    "bool"
                ],
                "loop": [
                    "bool",
                    "str",
                    "float",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/label_tags.py": {
        "get_all_tags": {
            "name": "get_all_tags",
            "location": 11,
            "return": [
                "str",
                "Optional[str]",
                "dict",
                "int",
                "Optional[dict]"
            ],
            "arguments": {
                "include_disabled": [
                    "bool",
                    "int",
                    "List[str]",
                    "Dict",
                    "str"
                ]
            }
        },
        "get_label_tag_by_key": {
            "name": "get_label_tag_by_key",
            "location": 19,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "label_tag_key": [
                    "str",
                    "bool",
                    "List[str]",
                    "bytes",
                    "Dict[str,str]",
                    "Optional[str]",
                    "None",
                    "Dict[int,Set[str]]",
                    "Dict[int,set[str]]"
                ]
            }
        },
        "add_new_tag": {
            "name": "add_new_tag",
            "location": 24,
            "return": [
                "medtagger.database.models.LabelTag"
            ],
            "arguments": {
                "key": [
                    "str",
                    "bool",
                    "List[str]",
                    "List[medtagger.definitions.LabelTool]"
                ],
                "name": [
                    "str",
                    "bool",
                    "List[str]",
                    "List[medtagger.definitions.LabelTool]"
                ],
                "tools": [
                    "str",
                    "bool",
                    "List[str]",
                    "List[medtagger.definitions.LabelTool]"
                ],
                "task_id": [
                    "str",
                    "medtagger.types.TaskID"
                ]
            }
        },
        "delete_tag_by_key": {
            "name": "delete_tag_by_key",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "key": [
                    "str",
                    "int"
                ]
            }
        },
        "update": {
            "name": "update",
            "location": 46,
            "return": [
                "str",
                "Dict[int,str]",
                "int",
                "bool"
            ],
            "arguments": {
                "key": [
                    "str"
                ],
                "name": [
                    "str",
                    "None",
                    "int",
                    "List[str]",
                    "Optional[Union[str,int]]"
                ],
                "tools": [
                    "List[medtagger.definitions.LabelTool]",
                    "None",
                    "str",
                    "bool",
                    "Optional[int]",
                    "Any",
                    "Optional[Union[str,Any]]",
                    "Optional[str]"
                ],
                "task_id": [
                    "medtagger.types.TaskID",
                    "str",
                    "None"
                ]
            }
        },
        "disable": {
            "name": "disable",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "label_tag_key": [
                    "str",
                    "Dict",
                    "bool",
                    "List[str]",
                    "daylighdb.models.User"
                ]
            }
        },
        "enable": {
            "name": "enable",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "label_tag_key": [
                    "str",
                    "Dict",
                    "bool",
                    "List[str]",
                    "daylighdb.models.User"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/roles.py": {
        "get_all_roles": {
            "name": "get_all_roles",
            "location": 13,
            "return": [
                "str",
                "Dict[str, float]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "get_role_with_name": {
            "name": "get_role_with_name",
            "location": 18,
            "return": [
                "str",
                "Dict[str,Any]",
                "int",
                "Tuple[Union[Any,Any]]",
                "Dict"
            ],
            "arguments": {
                "role_name": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "set_user_role": {
            "name": "set_user_role",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "user_id": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ],
                "role_name": [
                    "str"
                ]
            }
        },
        "role_exists": {
            "name": "role_exists",
            "location": 39,
            "return": [
                "Dict[str, bool]",
                "dict",
                "str",
                "int",
                "sqlalchemy.MetaData",
                "Dict[str, Any]"
            ],
            "arguments": {
                "role_name": [
                    "str"
                ]
            }
        },
        "add_role": {
            "name": "add_role",
            "location": 45,
            "return": [
                "medtagger.database.models.Role"
            ],
            "arguments": {
                "role_name": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/scans.py": {
        "get_paginated_scans": {
            "name": "get_paginated_scans",
            "location": 12,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "dataset_key": [
                    "str",
                    "None"
                ],
                "page": [
                    "int",
                    "bytes",
                    "core.models.GroupingKey",
                    "Type[models.taxonomies.T]",
                    "List[str]",
                    "mypy.types.Any"
                ],
                "per_page": [
                    "int",
                    "bytes",
                    "core.models.GroupingKey",
                    "Type[models.taxonomies.T]",
                    "List[str]",
                    "mypy.types.Any"
                ]
            }
        },
        "get_all_scans": {
            "name": "get_all_scans",
            "location": 31,
            "return": [
                "str",
                "Dict[str, float]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "get_scan_by_id": {
            "name": "get_scan_by_id",
            "location": 36,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "medtagger.types.ScanID",
                    "medtagger.types.ActionID",
                    "medtagger.types.LabelID"
                ]
            }
        },
        "get_random_scan": {
            "name": "get_random_scan",
            "location": 41,
            "return": [
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "task": [
                    "None",
                    "bool",
                    "medtagger.database.models.Task",
                    "django.contrib.auth.models.AbstractUser",
                    "bob_emploi.frontend.api.user_pb2.User",
                    "users.models.JustfixUser",
                    "user.User",
                    "zerver.models.UserProfile",
                    "util.freefocus.sql.Task",
                    "viewer.models.Archive"
                ],
                "user": [
                    "None",
                    "Dict",
                    "medtagger.database.models.User",
                    "medtagger.database.models.Task",
                    "zerver.models.UserProfile",
                    "transfer.models.User",
                    "bob_emploi.frontend.api.user_pb2.User"
                ]
            }
        },
        "delete_scan_by_id": {
            "name": "delete_scan_by_id",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "transfer.models.OrgaTeamID",
                    "transfer.models.StorefronID",
                    "transfer.models.ShopID",
                    "transfer.models.Badge.ID",
                    "transfer.models.ArticleID",
                    "transfer.models.Member.shipID",
                    "transfer.models.OrderNumber.SequenceID",
                    "transfer.models.ArticleNumberSequenceID",
                    "medtagger.types.ScanID"
                ]
            }
        },
        "add_new_scan": {
            "name": "add_new_scan",
            "location": 72,
            "return": [
                "medtagger.database.models.Scan"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "Tuple[Union[str,str,str]]",
                    "bytes",
                    "medtagger.database.models.Dataset",
                    "medtagger.database.models.User",
                    "Tuple[str,str,str]"
                ],
                "number_of_slices": [
                    "int",
                    "Tuple[Union[str,str,str]]",
                    "bytes",
                    "medtagger.database.models.Dataset",
                    "medtagger.database.models.User",
                    "Tuple[str,str,str]"
                ],
                "user": [
                    "int",
                    "None",
                    "bytes",
                    "medtagger.database.models.Dataset",
                    "Tuple[Union[str,str,str]]",
                    "medtagger.database.models.User",
                    "Tuple[str,str,str]"
                ]
            }
        },
        "try_to_mark_scan_as_stored": {
            "name": "try_to_mark_scan_as_stored",
            "location": 86,
            "return": [
                "bool"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "medtagger.types.ScanID",
                    "sqlalchemy.orm.Session",
                    "transfer.models.ItemID"
                ]
            }
        },
        "increase_skip_count_of_a_scan": {
            "name": "increase_skip_count_of_a_scan",
            "location": 106,
            "return": [
                "bool"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "bytes",
                    "medtagger.types.ScanID"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/slices.py": {
        "get_slice_by_id": {
            "name": "get_slice_by_id",
            "location": 10,
            "return": [
                "str",
                "Dict[str, Any]",
                "int",
                "Exception",
                "tartare.core.models.Job",
                "dict"
            ],
            "arguments": {
                "slice_id": [
                    "medtagger.types.SliceID",
                    "int",
                    "transfer.models.OrderNumber.SequenceID",
                    "transfer.models.ArticleNumberSequenceID",
                    "List[int]",
                    "transfer.models.OrgaTeamID"
                ]
            }
        },
        "get_slices_by_scan_id": {
            "name": "get_slices_by_scan_id",
            "location": 16,
            "return": [
                "str",
                "bytes",
                "float"
            ],
            "arguments": {
                "scan_id": [
                    "medtagger.types.ScanID",
                    "str",
                    "shop.transfer.models.ShopID"
                ],
                "orientation": [
                    "medtagger.definitions.SliceOrientation",
                    "str",
                    "transfer.models.ListID",
                    "dict",
                    "int"
                ]
            }
        },
        "get_slices_ids_for_labeled_scans": {
            "name": "get_slices_ids_for_labeled_scans",
            "location": 29,
            "return": [
                "set"
            ],
            "arguments": {
                "label_elements": [
                    "str",
                    "abilian.core.models.subjects.User"
                ]
            }
        },
        "delete_slice": {
            "name": "delete_slice",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "_slice": [
                    "medtagger.database.models.Slice",
                    "str",
                    "int"
                ]
            }
        },
        "get_slice_original_image": {
            "name": "get_slice_original_image",
            "location": 57,
            "return": [
                "Optional[str]",
                "Callable",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "slice_id": [
                    "medtagger.types.SliceID",
                    "int"
                ]
            }
        },
        "get_slice_converted_image": {
            "name": "get_slice_converted_image",
            "location": 63,
            "return": [
                "Optional[str]",
                "Dict[Optional[str], Set[abilian.services.security.models.Role]]",
                "abilian.core.models.subjects.Principal",
                "Callable",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "slice_id": [
                    "medtagger.types.SliceID",
                    "int"
                ]
            }
        },
        "store_original_image": {
            "name": "store_original_image",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "slice_id": [
                    "bytes",
                    "medtagger.types.SliceID",
                    "List[str]",
                    "int",
                    "str",
                    "raiden.storage.sqlite.SQLiteStorage"
                ],
                "image": [
                    "bytes",
                    "medtagger.types.SliceID",
                    "List[str]",
                    "int",
                    "str",
                    "raiden.storage.sqlite.SQLiteStorage"
                ]
            }
        },
        "store_converted_image": {
            "name": "store_converted_image",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "slice_id": [
                    "bytes",
                    "medtagger.types.SliceID",
                    "str",
                    "raiden.storage.sqlite.SQLiteStorage"
                ],
                "image": [
                    "bytes",
                    "medtagger.types.SliceID",
                    "str",
                    "raiden.storage.sqlite.SQLiteStorage"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/tasks.py": {
        "get_all_tasks": {
            "name": "get_all_tasks",
            "location": 9,
            "return": [
                "int",
                "dict",
                "Dict[str, str]",
                "games.models.Game"
            ],
            "arguments": {
                "include_disabled": [
                    "bool",
                    "Mapping[str,Any]",
                    "T",
                    "Dict[str,Any]",
                    "List[Dict[str,Any]]",
                    "str",
                    "List[str]",
                    "Sequence[int]"
                ]
            }
        },
        "get_task_by_key": {
            "name": "get_task_by_key",
            "location": 17,
            "return": [
                "Dict[str,Any]",
                "str",
                "Dict",
                "bytes"
            ],
            "arguments": {
                "key": [
                    "str",
                    "bytes",
                    "int"
                ]
            }
        },
        "add_task": {
            "name": "add_task",
            "location": 28,
            "return": [
                "medtagger.database.models.Task"
            ],
            "arguments": {
                "key": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "name": [
                    "str"
                ],
                "image_path": [
                    "str"
                ],
                "datasets_keys": [
                    "str",
                    "Optional[str]",
                    "int",
                    "None",
                    "Optional[List[str]]",
                    "List[str]",
                    "recidiviz.persistence.database.session.Session"
                ],
                "description": [
                    "str",
                    "Dict[str,str]",
                    "Optional[str]",
                    "None"
                ],
                "label_examples": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "None"
                ],
                "tags": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "Dict[str,str]",
                    "None"
                ]
            }
        },
        "assign_label_tag": {
            "name": "assign_label_tag",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "tag": [
                    "Mapping[str,str]",
                    "Dict[str,Any]",
                    "Mapping",
                    "bytes",
                    "str",
                    "Set[str]"
                ],
                "task_key": [
                    "str",
                    "bool",
                    "services.ticketing.models.ticket_evenTicketEvent"
                ]
            }
        },
        "unassign_label_tag": {
            "name": "unassign_label_tag",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "tag": [
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str,str]]",
                    "bool",
                    "None",
                    "Dict[str,str]"
                ],
                "task_key": [
                    "str",
                    "bool",
                    "services.ticketing.models.ticket_evenTicketEvent"
                ]
            }
        },
        "update": {
            "name": "update",
            "location": 76,
            "return": [
                "Dict",
                "bytes",
                "List[str]",
                "Pattern",
                "str",
                "excars.models.profiles.Profile",
                "app.models.Tweet",
                "app.models.Position"
            ],
            "arguments": {
                "task_key": [
                    "str",
                    "Dict[str,str]",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "name": [
                    "str",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "image_path": [
                    "str",
                    "None",
                    "List[str]",
                    "Optional[str]",
                    "Sequence[str]"
                ],
                "datasets_keys": [
                    "str",
                    "None",
                    "int",
                    "recidiviz.persistence.database.session.Session",
                    "List[str]",
                    "Optional[str]",
                    "Optional[List[str]]"
                ],
                "description": [
                    "str",
                    "None",
                    "int",
                    "Optional[int]",
                    "Sequence[str]"
                ],
                "label_examples": [
                    "str",
                    "None",
                    "int",
                    "Optional[int]",
                    "Sequence[str]"
                ]
            }
        },
        "update_parameter_if_needed": {
            "name": "update_parameter_if_needed",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "task": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "value": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "None",
                    "Optional[Iterable[str]]",
                    "Iterable[str]"
                ]
            }
        },
        "disable": {
            "name": "disable",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "task_key": [
                    "str",
                    "List[int]",
                    "celery.Task",
                    "transfer.models.TicketCode"
                ]
            }
        },
        "enable": {
            "name": "enable",
            "location": 115,
            "return": [
                "None"
            ],
            "arguments": {
                "task_key": [
                    "str",
                    "List[int]",
                    "celery.Task",
                    "transfer.models.TicketCode"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/users.py": {
        "add_new_user": {
            "name": "add_new_user",
            "location": 8,
            "return": [
                "str",
                "float",
                "Optional[str]"
            ],
            "arguments": {
                "new_user": [
                    "int",
                    "str",
                    "medtagger.database.models.User",
                    "app.models.models.User",
                    "Union[server.models.User,int]",
                    "daylighdb.models.User",
                    "zerver.models.Recipient"
                ]
            }
        },
        "get_all_users": {
            "name": "get_all_users",
            "location": 18,
            "return": [
                "zerver.models.Realm",
                "bytes",
                "str",
                "Dict[str, Dict[str, Any]]",
                "user_models.User"
            ],
            "arguments": {}
        },
        "get_user_by_email": {
            "name": "get_user_by_email",
            "location": 23,
            "return": [
                "models.User",
                "core.models.UserPreferences",
                "app.models.GameMember",
                "app.models.course.Course"
            ],
            "arguments": {
                "user_email": [
                    "str",
                    "users.models.User"
                ]
            }
        },
        "get_user_by_id": {
            "name": "get_user_by_id",
            "location": 31,
            "return": [
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "user_id": [
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "set_user_info": {
            "name": "set_user_info",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "user": [
                    "str",
                    "medtagger.database.models.User",
                    "None",
                    "int",
                    "Optional[str]",
                    "Optional[Union[str,int]]"
                ],
                "first_name": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ],
                "last_name": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "set_user_settings": {
            "name": "set_user_settings",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "user": [
                    "str",
                    "List[str]",
                    "medtagger.database.models.User"
                ],
                "name": [
                    "str",
                    "int"
                ],
                "value": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/repositories/__init__.py": {},
    "MedTagger-master/backend/medtagger/storage/models.py": {},
    "MedTagger-master/backend/medtagger/storage/__init__.py": {
        "create_session": {
            "name": "create_session",
            "location": 20,
            "return": [
                "str",
                "int",
                "Dict[str,Any]",
                "bytearray",
                "Exception",
                "Dict",
                "List"
            ],
            "arguments": {
                "use_gevent": [
                    "bool",
                    "Optional[Callable]",
                    "Dict[str,List[str]]"
                ]
            }
        },
        "create_connection": {
            "name": "create_connection",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "use_gevent": [
                    "bool",
                    "Callable[,int]",
                    "float"
                ]
            }
        },
        "is_alive": {
            "name": "is_alive",
            "location": 39,
            "return": [
                "bool"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/workers/celery_configuration.py": {
        "get_all_modules_with_tasks": {
            "name": "get_all_modules_with_tasks",
            "location": 13,
            "return": [
                "List[str]"
            ],
            "arguments": {}
        },
        "setup_logging_handler": {
            "name": "setup_logging_handler",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "process_initialization": {
            "name": "process_initialization",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/medtagger/workers/conversion.py": {
        "convert_scan_to_png": {
            "name": "convert_scan_to_png",
            "location": 26,
            "return": [
                "None",
                "str",
                "int",
                "Set[str]",
                "Iterable[Hashable]",
                "Dict"
            ],
            "arguments": {
                "scan_id": [
                    "int",
                    "str",
                    "transfer.models.ShopID",
                    "transfer.models.StorefronID",
                    "transfer.models.ArticleID"
                ]
            }
        },
        "_convert_scan_in_all_axes": {
            "name": "_convert_scan_in_all_axes",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "dicom_images": [
                    "int",
                    "bytes",
                    "Tuple[Union[int,int]]",
                    "numpy.ndarray",
                    "Tuple[int,int]",
                    "bool"
                ],
                "slices": [
                    "int",
                    "float"
                ],
                "scan": [
                    "str",
                    "medtagger.database.models.Scan",
                    "List[S]",
                    "int",
                    "torch.utils.data.DataLoader",
                    "List[recidiviz.persistence.database.schema.state.schema.StateIncarcerationPeriod]"
                ]
            }
        },
        "_prepare_slices_in_y_orientation": {
            "name": "_prepare_slices_in_y_orientation",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "normalized_scan": [
                    "List[cirq.Qid]",
                    "List[tuple[Union[int,int]]]",
                    "float",
                    "int",
                    "Union[int,float]",
                    "List[Tuple[int,int]]"
                ],
                "scan": [
                    "int",
                    "Set[int]"
                ]
            }
        },
        "_prepare_slices_in_x_orientation": {
            "name": "_prepare_slices_in_x_orientation",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "normalized_scan": [
                    "List",
                    "Tuple",
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "float",
                    "Tuple[float,float]",
                    "numpy.array"
                ],
                "scan": [
                    "Dict",
                    "int"
                ]
            }
        },
        "_convert_to_png_and_store": {
            "name": "_convert_to_png_and_store",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "_slice": [
                    "str",
                    "bool",
                    "medtagger.database.models.Slice",
                    "None",
                    "Optional[int]",
                    "Union[int,str]"
                ],
                "slice_pixels": [
                    "int",
                    "numpy.ndarray",
                    "trezor.utils.Writer",
                    "app.models.move.Coordinate",
                    "multinedb.models.workspace.Workspace"
                ]
            }
        },
        "_convert_slice_pixels_to_png": {
            "name": "_convert_slice_pixels_to_png",
            "location": 138,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "slice_pixels": [
                    "float",
                    "numpy.ndarray",
                    "str",
                    "Tuple[Union[int,int]]",
                    "Tuple[int,int]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/workers/storage.py": {
        "parse_dicom_and_update_slice": {
            "name": "parse_dicom_and_update_slice",
            "location": 19,
            "return": [
                "str",
                "None"
            ],
            "arguments": {
                "slice_id": [
                    "str",
                    "int",
                    "bytes",
                    "bool"
                ]
            }
        },
        "trigger_scan_conversion_if_needed": {
            "name": "trigger_scan_conversion_if_needed",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "scan_id": [
                    "str",
                    "int",
                    "medtagger.types.ScanID",
                    "None",
                    "bool",
                    "Optional[bool]"
                ]
            }
        }
    },
    "MedTagger-master/backend/medtagger/workers/__init__.py": {},
    "MedTagger-master/backend/scripts/convert_dicoms_to_png.py": {},
    "MedTagger-master/backend/scripts/dev__add_default_accounts.py": {
        "insert_admin_account": {
            "name": "insert_admin_account",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/scripts/import_data.py": {},
    "MedTagger-master/backend/scripts/sync_configuration.py": {
        "sync_configuration": {
            "name": "sync_configuration",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "configuration": [
                    "Dict",
                    "int",
                    "Generator",
                    "str",
                    "None",
                    "Optional[bool]",
                    "Optional[int]"
                ]
            }
        },
        "_sync_datasets": {
            "name": "_sync_datasets",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "configuration": [
                    "Dict",
                    "str"
                ]
            }
        },
        "_sync_tasks": {
            "name": "_sync_tasks",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "configuration": [
                    "Dict[str,Any]",
                    "Dict",
                    "str"
                ]
            }
        },
        "_sync_label_tags_in_task": {
            "name": "_sync_label_tags_in_task",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "configuration": [
                    "str",
                    "int",
                    "annofabapi.models.TaskPhase"
                ],
                "task_key": [
                    "str",
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "_add_label_tag": {
            "name": "_add_label_tag",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "tag": [
                    "dict",
                    "Type[T]",
                    "int",
                    "Awaitable"
                ],
                "db_task_id": [
                    "str",
                    "medtagger.types.TaskID",
                    "bool",
                    "List[str]",
                    "None",
                    "Optional[int]",
                    "Dict",
                    "Union[str,dict]"
                ]
            }
        },
        "run": {
            "name": "run",
            "location": 184,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/scripts/utils.py": {
        "user_agrees": {
            "name": "user_agrees",
            "location": 4,
            "return": [
                "bool",
                "Callable[[List,bool],None]",
                "Callable",
                "str"
            ],
            "arguments": {
                "prompt_message": [
                    "str",
                    "int",
                    "Dict"
                ]
            }
        }
    },
    "MedTagger-master/backend/scripts/__init__.py": {},
    "MedTagger-master/backend/tests/__init__.py": {},
    "MedTagger-master/backend/tests/functional_tests/conftest.py": {
        "prepare_environment": {
            "name": "prepare_environment",
            "location": 22,
            "return": [
                "Any",
                "Generator"
            ],
            "arguments": {}
        },
        "synchronous_celery": {
            "name": "synchronous_celery",
            "location": 35,
            "return": [
                "Any",
                "None"
            ],
            "arguments": {
                "mocker": [
                    "bool",
                    "int",
                    "Optional[bool]"
                ]
            }
        },
        "pytest_keyboard_interrupt": {
            "name": "pytest_keyboard_interrupt",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "excinfo": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "get_token_for_logged_in_user": {
            "name": "get_token_for_logged_in_user",
            "location": 47,
            "return": [
                "str"
            ],
            "arguments": {
                "role": [
                    "Dict[str,Any]",
                    "int",
                    "Optional[str]",
                    "str",
                    "None",
                    "bool"
                ]
            }
        },
        "_clear_databases": {
            "name": "_clear_databases",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/tests/functional_tests/helpers.py": {
        "create_tag_and_assign_to_task": {
            "name": "create_tag_and_assign_to_task",
            "location": 16,
            "return": [
                "models.LabelTag"
            ],
            "arguments": {
                "key": [
                    "str",
                    "Dict[str,str]",
                    "bytes",
                    "Dict[str,List[bytes]]",
                    "Dict[str,list[bytes]]"
                ],
                "name": [
                    "str",
                    "Dict[str,str]",
                    "bytes",
                    "Dict[str,List[bytes]]",
                    "Dict[str,list[bytes]]"
                ],
                "task_key": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "tools": [
                    "str",
                    "Dict[str,str]",
                    "bytes",
                    "Dict[str,List[bytes]]",
                    "Dict[str,list[bytes]]"
                ]
            }
        },
        "prepare_scan_and_tag_for_labeling": {
            "name": "prepare_scan_and_tag_for_labeling",
            "location": 30,
            "return": [
                "Tuple[(models.Scan, models.LabelTag)]"
            ],
            "arguments": {}
        },
        "prepare_empty_label": {
            "name": "prepare_empty_label",
            "location": 41,
            "return": [
                "models.Label"
            ],
            "arguments": {
                "scan": [
                    "str",
                    "Dict",
                    "int",
                    "models.UserAuth",
                    "abilian.core.models.subjects.User",
                    "zerver.models.Stream"
                ],
                "user": [
                    "str",
                    "Dict",
                    "int",
                    "models.UserAuth",
                    "abilian.core.models.subjects.User",
                    "zerver.models.Stream"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_adding_new_label.py": {
        "test_add_brush_label": {
            "name": "test_add_brush_label",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ],
                "synchronous_celery": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "test_add_point_label": {
            "name": "test_add_point_label",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ],
                "synchronous_celery": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "test_add_chain_label": {
            "name": "test_add_chain_label",
            "location": 123,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ],
                "synchronous_celery": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "test_add_chain_label_not_enough_points": {
            "name": "test_add_chain_label_not_enough_points",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ],
                "synchronous_celery": [
                    "str",
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "test_add_label_with_tag_from_other_task": {
            "name": "test_add_label_with_tag_from_other_task",
            "location": 228,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "Callable",
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ],
                "synchronous_celery": [
                    "Callable",
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_alembic_migrations.py": {
        "test_if_developer_commited_migrations": {
            "name": "test_if_developer_commited_migrations",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_basic_flow.py": {
        "test_basic_flow": {
            "name": "test_basic_flow",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn",
                    "cli_ui.tests.MessageRecorder"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn",
                    "cli_ui.tests.MessageRecorder"
                ]
            }
        },
        "test_basic_flow_with_predefined_label": {
            "name": "test_basic_flow_with_predefined_label",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn",
                    "cli_ui.tests.MessageRecorder"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn",
                    "cli_ui.tests.MessageRecorder"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_deleting_scan.py": {
        "test_delete_scan_without_slices": {
            "name": "test_delete_scan_without_slices",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "tests.basilisp.helpers.CompileFn",
                    "jsonlog.tests.capture.Capture"
                ],
                "synchronous_celery": [
                    "str",
                    "tests.basilisp.helpers.CompileFn",
                    "jsonlog.tests.capture.Capture"
                ]
            }
        },
        "test_delete_scan_with_slices": {
            "name": "test_delete_scan_with_slices",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "tests.basilisp.helpers.CompileFn",
                    "jsonlog.tests.capture.Capture"
                ],
                "synchronous_celery": [
                    "str",
                    "tests.basilisp.helpers.CompileFn",
                    "jsonlog.tests.capture.Capture"
                ]
            }
        },
        "test_delete_scan_with_labels": {
            "name": "test_delete_scan_with_labels",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_labels_repository.py": {
        "test_get_predefined_label_for_scan_in_task__no_predefined_label": {
            "name": "test_get_predefined_label_for_scan_in_task__no_predefined_label",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_get_predefined_label_for_scan_in_task__label_that_is_not_predefined": {
            "name": "test_get_predefined_label_for_scan_in_task__label_that_is_not_predefined",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "Callable"
                ]
            }
        },
        "test_get_predefined_label_for_scan_in_task__predefined_label": {
            "name": "test_get_predefined_label_for_scan_in_task__predefined_label",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "bool",
                    "str",
                    "Callable"
                ]
            }
        },
        "test_get_predefined_label_for_scan_in_task__predefined_label_for_given_task": {
            "name": "test_get_predefined_label_for_scan_in_task__predefined_label_for_given_task",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "bool",
                    "str",
                    "Callable"
                ]
            }
        },
        "test_get_predefined_brush_label_elements": {
            "name": "test_get_predefined_brush_label_elements",
            "location": 91,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_scan_upload.py": {
        "test_scan_upload_and_conversion": {
            "name": "test_scan_upload_and_conversion",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest"
                ]
            }
        },
        "fixture_problems_with_storage": {
            "name": "fixture_problems_with_storage",
            "location": 70,
            "return": [
                "str",
                "Dict[str, Any]",
                "int",
                "List[dict]",
                "app.models.move.Coordinate"
            ],
            "arguments": {
                "mocker": [
                    "int",
                    "float",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "test_scan_upload_with_retrying": {
            "name": "test_scan_upload_with_retrying",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "fixture_problems_with_storage": [
                    "int"
                ],
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_settings.py": {
        "test_do_not_show_tutorial_again": {
            "name": "test_do_not_show_tutorial_again",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "List[str]"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_skipping_a_scan.py": {
        "test_skipping_a_scan": {
            "name": "test_skipping_a_scan",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest",
                    "cli_ui.tests.MessageRecorder"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest",
                    "cli_ui.tests.MessageRecorder"
                ]
            }
        },
        "test_skipping_a_scan_that_doesnt_exist": {
            "name": "test_skipping_a_scan_that_doesnt_exist",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest",
                    "cli_ui.tests.MessageRecorder"
                ],
                "synchronous_celery": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest",
                    "cli_ui.tests.MessageRecorder"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_status.py": {
        "test_status_endpoint": {
            "name": "test_status_endpoint",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "int",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_survey.py": {
        "test_adding_new_survey": {
            "name": "test_adding_new_survey",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "bool",
                    "str",
                    "jsonlog.tests.capture.Capture",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_adding_new_response_for_survey": {
            "name": "test_adding_new_response_for_survey",
            "location": 119,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_tasks.py": {
        "test_add_task": {
            "name": "test_add_task",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Callable",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.MagicMock"
                ],
                "synchronous_celery": [
                    "str",
                    "Callable",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.MagicMock"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_tools_and_tags.py": {
        "test_add_label_non_existing_tag": {
            "name": "test_add_label_non_existing_tag",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "bool",
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_add_label_non_supported_tool": {
            "name": "test_add_label_non_supported_tool",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool",
                    "Callable"
                ]
            }
        },
        "test_add_label_missing_tag": {
            "name": "test_add_label_missing_tag",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "bool",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "test_add_label_missing_tool": {
            "name": "test_add_label_missing_tool",
            "location": 136,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool",
                    "tests.async_mock.MagicMock",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_add_label_wrong_tool_for_tag": {
            "name": "test_add_label_wrong_tool_for_tag",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "bool",
                    "str",
                    "jsonlog.tests.capture.Capture",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/test_users.py": {
        "test_basic_user_flow": {
            "name": "test_basic_user_flow",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "Type",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_upgrade_to_doctor_role": {
            "name": "test_upgrade_to_doctor_role",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_ownership": {
            "name": "test_ownership",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.MagicMock",
                    "tests.async_mock.Mock",
                    "Mapping[str,Any]"
                ],
                "synchronous_celery": [
                    "str",
                    "Mapping",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.MagicMock",
                    "tests.async_mock.Mock",
                    "Mapping[str,Any]"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/__init__.py": {
        "get_api_client": {
            "name": "get_api_client",
            "location": 7,
            "return": [],
            "arguments": {}
        },
        "get_web_socket_client": {
            "name": "get_web_socket_client",
            "location": 14,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "namespace": [
                    "str",
                    "Callable",
                    "None",
                    "Dict"
                ]
            }
        },
        "get_headers": {
            "name": "get_headers",
            "location": 21,
            "return": [
                "Dict[Text,Text]",
                "str",
                "Dict[str,Union[str,int]]"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/tests/functional_tests/api/__init__.py": {},
    "MedTagger-master/backend/tests/functional_tests/api/scans/test_fetching_scans.py": {
        "test_get_paginated_scans": {
            "name": "test_get_paginated_scans",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_get_paginated_scans_by_volunteer": {
            "name": "test_get_paginated_scans_by_volunteer",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_get_paginated_scans_with_invalid_arguments": {
            "name": "test_get_paginated_scans_with_invalid_arguments",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/api/scans/__init__.py": {},
    "MedTagger-master/backend/tests/functional_tests/ground_truth/test_generator.py": {
        "test_data_set_generator": {
            "name": "test_data_set_generator",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/__init__.py": {},
    "MedTagger-master/backend/tests/functional_tests/ground_truth/algorithms/test_dbscan.py": {
        "test_dbscan_algorithm": {
            "name": "test_dbscan_algorithm",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/algorithms/test_gaussian_mixture_models.py": {
        "test_gaussian_mixture_models_algorithm": {
            "name": "test_gaussian_mixture_models_algorithm",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/algorithms/test_k_means.py": {
        "test_k_means_algorithm": {
            "name": "test_k_means_algorithm",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/algorithms/test_majority_voting.py": {
        "test_majority_voting_algorithm": {
            "name": "test_majority_voting_algorithm",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/algorithms/__init__.py": {},
    "MedTagger-master/backend/tests/functional_tests/ground_truth/parsers/test_chain.py": {
        "test_parsing_chain_label_elements": {
            "name": "test_parsing_chain_label_elements",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_chain_intersection_over_union": {
            "name": "test_chain_intersection_over_union",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.MagicMock",
                    "tests.async_mock.Mock",
                    "Mapping[str,Any]"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/parsers/test_rectangle.py": {
        "test_parsing_rectangle_label_elements": {
            "name": "test_parsing_rectangle_label_elements",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_rectangle_intersection_over_union": {
            "name": "test_rectangle_intersection_over_union",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.MagicMock",
                    "tests.async_mock.Mock",
                    "Mapping[str,Any]"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/ground_truth/parsers/__init__.py": {},
    "MedTagger-master/backend/tests/functional_tests/scripts/test_sync_configuration.py": {
        "test_sync_with_empty_database": {
            "name": "test_sync_with_empty_database",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        },
        "test_sync_with_updated_names": {
            "name": "test_sync_with_updated_names",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_sync_with_changed_tools_in_tag": {
            "name": "test_sync_with_changed_tools_in_tag",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "Type"
                ]
            }
        },
        "test_sync_with_changed_tags_in_task": {
            "name": "test_sync_with_changed_tags_in_task",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_sync_with_changed_task_in_dataset": {
            "name": "test_sync_with_changed_task_in_dataset",
            "location": 294,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "int"
                ],
                "prepare_environment": []
            }
        },
        "test_sync_with_changed_dataset_and_reused_task": {
            "name": "test_sync_with_changed_dataset_and_reused_task",
            "location": 458,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": [
                    "Type"
                ]
            }
        },
        "test_sync_with_changed_description": {
            "name": "test_sync_with_changed_description",
            "location": 524,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_sync_with_changed_label_examples": {
            "name": "test_sync_with_changed_label_examples",
            "location": 592,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_sync_with_missing_label_examples": {
            "name": "test_sync_with_missing_label_examples",
            "location": 660,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        },
        "test_sync_with_missing_description": {
            "name": "test_sync_with_missing_description",
            "location": 694,
            "return": [
                "None"
            ],
            "arguments": {
                "prepare_environment": []
            }
        }
    },
    "MedTagger-master/backend/tests/functional_tests/scripts/__init__.py": {},
    "MedTagger-master/backend/tests/unit_tests/test_config.py": {
        "test_get_default_values_for_api": {
            "name": "test_get_default_values_for_api",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/tests/unit_tests/__init__.py": {},
    "MedTagger-master/backend/tests/unit_tests/api/__init__.py": {
        "get_test_application": {
            "name": "get_test_application",
            "location": 7,
            "return": [
                "Tuple[Callable, Callable]",
                "flask.Flask"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "Callable",
                    "List[List[int]]"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/unit_tests/api/auth/test_business.py": {
        "get_user_by_email_success_fixture": {
            "name": "get_user_by_email_success_fixture",
            "location": 14,
            "return": [
                "str",
                "Dict[str,str]",
                "Mapping[str,Any]",
                "List[dict[str,str]]"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "bytes",
                    "zerver.models.Realm"
                ]
            }
        },
        "get_user_by_email_failure_fixture": {
            "name": "get_user_by_email_failure_fixture",
            "location": 22,
            "return": [
                "str",
                "Dict[str,str]",
                "Mapping[str,Any]",
                "List[dict[str,str]]"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "bytes",
                    "zerver.models.Realm"
                ]
            }
        },
        "get_role_fixture": {
            "name": "get_role_fixture",
            "location": 30,
            "return": [
                "str",
                "bytes",
                "None",
                "Dict[str,Union[Any,Any,Any]]",
                "List[Union[Any,Any,Any]]"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "int",
                    "salon.models.Stylist"
                ]
            }
        },
        "wrong_password_fixture": {
            "name": "wrong_password_fixture",
            "location": 38,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "dict"
                ]
            }
        },
        "test_create_user_user_exists": {
            "name": "test_create_user_user_exists",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "bool",
                    "pathfinding_service.api.PFSApi"
                ],
                "get_user_by_email_success_fixture": [
                    "str",
                    "bool",
                    "pathfinding_service.api.PFSApi"
                ]
            }
        },
        "test_create_user_missing_role": {
            "name": "test_create_user_missing_role",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "bool",
                    "str",
                    "Callable[...,None]",
                    "None",
                    "Optional[str]",
                    "Literal",
                    "int"
                ],
                "get_user_by_email_failure_fixture": [
                    "bool",
                    "str",
                    "Callable[...,None]",
                    "None",
                    "Optional[str]",
                    "Literal",
                    "int"
                ],
                "get_role_fixture": [
                    "bool",
                    "str",
                    "Callable[...,None]",
                    "None",
                    "Optional[str]",
                    "Literal",
                    "int"
                ]
            }
        },
        "test_sign_in_user_user_does_not_exists": {
            "name": "test_sign_in_user_user_does_not_exists",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "bool",
                    "pathfinding_service.api.PFSApi"
                ],
                "get_user_by_email_failure_fixture": [
                    "str",
                    "bool",
                    "pathfinding_service.api.PFSApi"
                ]
            }
        },
        "test_sign_in_user_wrong_password": {
            "name": "test_sign_in_user_wrong_password",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "Union[str,int]",
                    "int"
                ],
                "get_user_by_email_success_fixture": [
                    "str",
                    "Union[str,int]",
                    "int"
                ],
                "wrong_password_fixture": [
                    "str",
                    "Union[str,int]",
                    "int"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/unit_tests/api/auth/test_service.py": {
        "create_user_exception_fixture": {
            "name": "create_user_exception_fixture",
            "location": 12,
            "return": [
                "str"
            ],
            "arguments": {
                "mocker": [
                    "List[str]",
                    "str"
                ]
            }
        },
        "sign_in_wrong_password_fixture": {
            "name": "sign_in_wrong_password_fixture",
            "location": 20,
            "return": [
                "List[str]",
                "Dict[str, Any]",
                "neuromation.api.RemoteImage",
                "str"
            ],
            "arguments": {
                "mocker": [
                    "flask.Flask",
                    "str"
                ]
            }
        },
        "test_create_user_user_already_exist": {
            "name": "test_create_user_user_already_exist",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "flask.testing.FlaskClient"
                ],
                "create_user_exception_fixture": [
                    "int",
                    "ultron8.api.db_models.user.User"
                ]
            }
        },
        "test_create_user_password_too_short": {
            "name": "test_create_user_password_too_short",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "int",
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_create_user_email_missing": {
            "name": "test_create_user_email_missing",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "int",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_sign_in_wrong_password": {
            "name": "test_sign_in_wrong_password",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "bool",
                    "Optional[List[str]]",
                    "List[str]",
                    "None"
                ],
                "sign_in_wrong_password_fixture": [
                    "str"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/unit_tests/api/auth/__init__.py": {},
    "MedTagger-master/backend/tests/unit_tests/api/core/test_business.py": {
        "test_success": {
            "name": "test_success",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "MedTagger-master/backend/tests/unit_tests/api/core/test_service.py": {
        "success_fixture": {
            "name": "success_fixture",
            "location": 11,
            "return": [
                "tests.basilisp.helpers.CompileFn"
            ],
            "arguments": {
                "mocker": [
                    "Callable",
                    "Mapping[str, Any]",
                    "str",
                    "dict"
                ]
            }
        },
        "test_status_endpoint": {
            "name": "test_status_endpoint",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "mocker": [
                    "str",
                    "tests.basilisp.helpers.CompileFn"
                ],
                "success_fixture": [
                    "str",
                    "int",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        }
    },
    "MedTagger-master/backend/tests/unit_tests/api/core/__init__.py": {}
}
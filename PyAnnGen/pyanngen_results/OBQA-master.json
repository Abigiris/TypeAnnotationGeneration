{
    "OBQA-master/rule.py": {
        "is_aux": {
            "name": "is_aux",
            "location": 26,
            "return": [
                "bool",
                "Type",
                "Set[Type]",
                "List[str]"
            ],
            "arguments": {
                "tok": [
                    "str"
                ]
            }
        },
        "is_verb": {
            "name": "is_verb",
            "location": 29,
            "return": [
                "List[str]",
                "bool"
            ],
            "arguments": {
                "tok": [
                    "str"
                ]
            }
        },
        "add_affix": {
            "name": "add_affix",
            "location": 33,
            "return": [
                "list[]",
                "str",
                "Iterable[Any]",
                "int"
            ],
            "arguments": {
                "candidates": [
                    "str"
                ],
                "afxs": [
                    "str"
                ],
                "postag": [
                    "dict[, ]",
                    "int",
                    "T",
                    "dict",
                    "bool"
                ],
                "pos": [
                    "typing.Text",
                    "T",
                    "dict",
                    "int",
                    "bool"
                ]
            }
        },
        "lower": {
            "name": "lower",
            "location": 43,
            "return": [
                "str"
            ],
            "arguments": {
                "sent": [
                    "str",
                    "Set[str]",
                    "set[str]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "Question.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "Question._preprocess": {
            "name": "_preprocess",
            "location": 107,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "list",
                    "List[int]",
                    "List[List[str]]",
                    "List[Tuple[int, int]]",
                    "int",
                    "float"
                ]
            }
        },
        "Question._get_node": {
            "name": "_get_node",
            "location": 117,
            "return": [
                "None",
                "Optional[str]",
                "bool",
                "Optional[Dict]",
                "Optional[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "rel": [
                    "str",
                    "Optional[str]",
                    "None",
                    "Tuple[Tuple[int, ...]]",
                    "tuple[tuple[typing.Union[int,...]]]"
                ]
            }
        },
        "Question._get_children": {
            "name": "_get_children",
            "location": 123,
            "return": [
                "list[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "str",
                    "int",
                    "Dict[str, Any]"
                ],
                "rels": [
                    "int",
                    "bytes"
                ],
                "loc": [
                    "typing.Text",
                    "int",
                    "list"
                ]
            }
        },
        "Question._get_nth_child": {
            "name": "_get_nth_child",
            "location": 138,
            "return": [
                "str",
                "Optional[int]",
                "int",
                "Dict[str, Any]",
                "list[]",
                "list[dict[str, typing.Any]]"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "str",
                    "int",
                    "list",
                    "list[]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ],
                "loc": [
                    "typing.Text",
                    "bool",
                    "Type",
                    "float"
                ],
                "n": [
                    "int",
                    "str",
                    "Collection[int]"
                ]
            }
        },
        "Question._get_wh": {
            "name": "_get_wh",
            "location": 146,
            "return": [
                "None",
                "Optional[int]",
                "Optional[str]",
                "bool",
                "str",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._get_wh_pos": {
            "name": "_get_wh_pos",
            "location": 166,
            "return": [
                "tuple[str]",
                "Callable",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._is_valid": {
            "name": "_is_valid",
            "location": 202,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._lastword_idx": {
            "name": "_lastword_idx",
            "location": 214,
            "return": [
                "int",
                "List[str]",
                "Optional[int]",
                "Iterable[T]",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._dangling_prep": {
            "name": "_dangling_prep",
            "location": 221,
            "return": [
                "None",
                "str",
                "list",
                "Optional[BaseException]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._is_descendant": {
            "name": "_is_descendant",
            "location": 235,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "child": [
                    "str",
                    "int"
                ],
                "head": [
                    "str",
                    "int"
                ]
            }
        },
        "Question._get_dobj_pos": {
            "name": "_get_dobj_pos",
            "location": 249,
            "return": [
                "int",
                "str",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._wh_is_time": {
            "name": "_wh_is_time",
            "location": 275,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._wh_is_quantity": {
            "name": "_wh_is_quantity",
            "location": 283,
            "return": [
                "bool",
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._wh_is_happened": {
            "name": "_wh_is_happened",
            "location": 290,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._aux_precedes_verb": {
            "name": "_aux_precedes_verb",
            "location": 300,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._wh_is_compl": {
            "name": "_wh_is_compl",
            "location": 318,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question.get_answer_pos": {
            "name": "get_answer_pos",
            "location": 339,
            "return": [
                "str",
                "int",
                "typing.Final",
                "dict[, ]",
                "typing.Counter",
                "list[str]",
                "dict[str, int]",
                "typing.Callable[[], str]",
                "float"
            ],
            "arguments": {
                "self": [],
                "a": [
                    "IO[bytes]",
                    "List[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Question.set_answer_pos": {
            "name": "set_answer_pos",
            "location": 394,
            "return": [
                "None",
                "Iterator[object]",
                "Union[tuple, list]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "pos": [
                    "int",
                    "str",
                    "list",
                    "list[]"
                ]
            }
        },
        "Question.remove_tok": {
            "name": "remove_tok",
            "location": 400,
            "return": [
                "Iterator[Tuple[str, str]]",
                "None"
            ],
            "arguments": {
                "self": [],
                "tok": [
                    "str",
                    "bool",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "Question.set_aux_pos": {
            "name": "set_aux_pos",
            "location": 405,
            "return": [
                "None",
                "Union[tuple, list]",
                "Dict[str, Any]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "pos": [
                    "bool",
                    "float"
                ]
            }
        },
        "Question._get_new_aux_pos": {
            "name": "_get_new_aux_pos",
            "location": 409,
            "return": [
                "str",
                "Union[Literal, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question._get_new_cop_pos": {
            "name": "_get_new_cop_pos",
            "location": 438,
            "return": [
                "str",
                "typing.Literal",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question.swap_aux": {
            "name": "swap_aux",
            "location": 459,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question.change_tense": {
            "name": "change_tense",
            "location": 484,
            "return": [
                "Iterator",
                "None"
            ],
            "arguments": {
                "self": [],
                "past": [
                    "bool",
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict"
                ],
                "pres_3sg": [
                    "bool",
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict"
                ]
            }
        },
        "Question.format_declr": {
            "name": "format_declr",
            "location": 506,
            "return": [
                "str",
                "int",
                "List[List[str]]",
                "tuple"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question.insert_answer": {
            "name": "insert_answer",
            "location": 515,
            "return": [
                "None",
                "str",
                "Optional[str]",
                "bool",
                "Optional[float]"
            ],
            "arguments": {
                "self": [],
                "a": [
                    "float",
                    "int"
                ]
            }
        },
        "Question.is_do_neg": {
            "name": "is_do_neg",
            "location": 540,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Question.insert_answer_default": {
            "name": "insert_answer_default",
            "location": 548,
            "return": [
                "None",
                "Union[tuple, list]",
                "Dict[str, Any]",
                "str",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "a": [
                    "int",
                    "list",
                    "float"
                ]
            }
        },
        "AnswerSpan.__init__": {
            "name": "__init__",
            "location": 595,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "answer": [
                    "str"
                ]
            }
        },
        "AnswerSpan._isvalid": {
            "name": "_isvalid",
            "location": 602,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnswerSpan._type": {
            "name": "_type",
            "location": 605,
            "return": [
                "None",
                "Optional[str]",
                "Tuple[List[str], Optional[str]]",
                "Optional[int]",
                "Optional[bool]",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnswerSpan._get_rel": {
            "name": "_get_rel",
            "location": 611,
            "return": [
                "None",
                "Optional[str]",
                "str",
                "Optional[Dict[str, Any]]",
                "Optional[Dict]"
            ],
            "arguments": {
                "self": [],
                "rel": [
                    "str",
                    "bool"
                ]
            }
        },
        "AnswerSpan._preprocess": {
            "name": "_preprocess",
            "location": 618,
            "return": [
                "str",
                "List[str]",
                "list"
            ],
            "arguments": {
                "self": [],
                "answer": [
                    "str",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "AnswerSpan.add_affix": {
            "name": "add_affix",
            "location": 632,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "afx_node": [
                    "dict",
                    "Dict[str, Any]",
                    "Type"
                ],
                "pos": [
                    "typing.Text",
                    "List[str]",
                    "str",
                    "List[int]"
                ]
            }
        },
        "AnswerSpan.change_tense": {
            "name": "change_tense",
            "location": 639,
            "return": [
                "Iterator",
                "None"
            ],
            "arguments": {
                "self": [],
                "past": [
                    "bool",
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict"
                ],
                "pres_3sg": [
                    "bool",
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict"
                ]
            }
        }
    },
    "OBQA-master/rule_based_qa.py": {
        "qa2d": {
            "name": "qa2d",
            "location": 13,
            "return": [
                "typing.Text",
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "idx": [
                    "str",
                    "int"
                ]
            }
        },
        "print_sentence": {
            "name": "print_sentence",
            "location": 26,
            "return": [
                "dict",
                "str",
                "float",
                "Optional[bool]"
            ],
            "arguments": {
                "idx": [
                    "Union[str, List[str]]",
                    "str",
                    "bytes",
                    "list",
                    "float",
                    "list[str]",
                    "list[]",
                    "Optional[List[float]]",
                    "List[int]",
                    "Set[str]",
                    "list[float]",
                    "None",
                    "list[int]",
                    "set[str]"
                ]
            }
        },
        "writeToFile": {
            "name": "writeToFile",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "outputfile": [
                    "str"
                ],
                "examples": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "OBQA-master/bagofwords/run_classifier.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 331,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "list[typing.Any]",
                    "numpy.ndarray",
                    "Optional[List[Any]]",
                    "IO",
                    "int"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 413,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 429,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 433,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "get_dataloader": {
            "name": "get_dataloader",
            "location": 438,
            "return": [
                "DataLoader",
                "str",
                "bool"
            ],
            "arguments": {
                "train_features": [
                    "str",
                    "list[]",
                    "list",
                    "sideeye.data.region.Region",
                    "int"
                ],
                "train_batch_size": [
                    "int",
                    "float"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 448,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "input_mask": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "segment_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "label_id": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 88,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 93,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "BoWProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 105,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "BoWProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 111,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "BoWProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 116,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "BoWProcessor.get_labels": {
            "name": "get_labels",
            "location": 121,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "BoWProcessor._create_examples": {
            "name": "_create_examples",
            "location": 125,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "OBQAProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 141,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 147,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_labels": {
            "name": "get_labels",
            "location": 152,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "OBQAProcessor._create_examples": {
            "name": "_create_examples",
            "location": 156,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MrpcProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 171,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 177,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_labels": {
            "name": "get_labels",
            "location": 182,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MrpcProcessor._create_examples": {
            "name": "_create_examples",
            "location": 186,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        },
        "MnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 204,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 209,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 215,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 219,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "QnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 236,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "QnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 241,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "QnliProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 246,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "QnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 252,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "QnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 256,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "SnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 273,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 278,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 284,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 288,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "ColaProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 305,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 310,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_labels": {
            "name": "get_labels",
            "location": 315,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ColaProcessor._create_examples": {
            "name": "_create_examples",
            "location": 319,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "Optional[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/bagofwords/run_scorer.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 128,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 234,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 250,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 254,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "get_dataloader": {
            "name": "get_dataloader",
            "location": 259,
            "return": [
                "DataLoader",
                "str",
                "bool"
            ],
            "arguments": {
                "train_features": [
                    "str",
                    "list[]",
                    "list",
                    "sideeye.data.region.Region",
                    "int"
                ],
                "train_batch_size": [
                    "int",
                    "float"
                ]
            }
        },
        "softmax": {
            "name": "softmax",
            "location": 270,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 275,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 89,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 94,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "BoWProcessor.get_score_examples": {
            "name": "get_score_examples",
            "location": 106,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ],
                "fname": [
                    "str"
                ]
            }
        },
        "BoWProcessor.get_labels": {
            "name": "get_labels",
            "location": 111,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "BoWProcessor._create_examples": {
            "name": "_create_examples",
            "location": 115,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/bert/run_trainqa.py": {
        "read_ranked": {
            "name": "read_ranked",
            "location": 14,
            "return": [
                "dict[, ]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "Union[str, IO[bytes]]"
                ],
                "topk": [
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "read_knowledge": {
            "name": "read_knowledge",
            "location": 23,
            "return": [
                "tuple[typing.Union[dict[typing.Union[str,set[str],dict[int, str],None], ],list[typing.Union[str,set[str],dict[int, str],None]]]]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "get_train_facts": {
            "name": "get_train_facts",
            "location": 34,
            "return": [
                "list[]",
                "str",
                "bool"
            ],
            "arguments": {
                "fact1": [
                    "str",
                    "Exception",
                    "bool"
                ],
                "topk": [
                    "str",
                    "bool"
                ],
                "ranked": [
                    "str",
                    "list[int]",
                    "tuple[typing.Any]",
                    "List[int]",
                    "Union[int, str]",
                    "int",
                    "Union[str, Tuple[Any]]"
                ],
                "knowlegde": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "T",
                    "dict"
                ],
                "knowledgemap": [
                    "str",
                    "list[int]",
                    "tuple[typing.Any]",
                    "List[int]",
                    "Union[int, str]",
                    "int",
                    "Union[str, Tuple[Any]]"
                ]
            }
        },
        "read_data_to_train": {
            "name": "read_data_to_train",
            "location": 52,
            "return": [
                "dict[int, Input]",
                "IO[bytes]",
                "Optional[Dict[str, Any]]",
                "bytes",
                "Dict[str, Any]",
                "Optional[float]",
                "str",
                "dict"
            ],
            "arguments": {
                "topk": [
                    "str",
                    "int",
                    "typing.Callable[, ]",
                    "Callable",
                    "None",
                    "bool",
                    "Optional[bool]"
                ],
                "ranked": [
                    "tuple[]",
                    "int",
                    "tuple",
                    "dict[int, dict[, ]]",
                    "Iterable",
                    "transfer.models.Order",
                    "Dict[int, dict]"
                ],
                "knowledge": [
                    "tuple[]",
                    "int",
                    "tuple",
                    "dict[int, dict[, ]]",
                    "Iterable",
                    "transfer.models.Order",
                    "Dict[int, dict]"
                ],
                "knowledgemap": [
                    "tuple[]",
                    "int",
                    "tuple",
                    "dict[int, dict[, ]]",
                    "Iterable",
                    "transfer.models.Order",
                    "Dict[int, dict]"
                ],
                "use_gold_f2": [
                    "bool",
                    "int",
                    "Union[str, Iterable[str]]",
                    "str",
                    "Optional[Tuple[int, int]]",
                    "float"
                ]
            }
        },
        "read_data_to_test": {
            "name": "read_data_to_test",
            "location": 88,
            "return": [
                "dict[str, Input]",
                "dict",
                "bytes",
                "str",
                "IO[bytes]",
                "Optional[float]"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "topk": [
                    "bool",
                    "str",
                    "None",
                    "int",
                    "Optional[str]"
                ],
                "ranked": [
                    "list[]",
                    "Union[List, numpy.ndarray, pymatgen.core.lattice.Lattice]",
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "knowledge": [
                    "list[]",
                    "int",
                    "Union[List, numpy.ndarray, pymatgen.core.lattice.Lattice]",
                    "None",
                    "bool",
                    "Optional[int]"
                ],
                "knowledgemap": [
                    "bool"
                ],
                "is_merged": [
                    "bool",
                    "Tuple[str]",
                    "str",
                    "bytes",
                    "Optional[str]",
                    "Sequence[str]"
                ],
                "use_gold_f2": [
                    "bool",
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "cache": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Optional[float]"
                ]
            }
        },
        "gen_data_to_ir": {
            "name": "gen_data_to_ir",
            "location": 125,
            "return": [
                "None",
                "Iterable[Mapping[str, Any]]",
                "Optional[bool]"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "bool"
                ],
                "topk": [
                    "bool",
                    "float",
                    "Optional[Any]",
                    "Callable[[str], bool]",
                    "numpy.array",
                    "int",
                    "List[int]",
                    "str"
                ],
                "ranked": [
                    "list[int]",
                    "str",
                    "float",
                    "bool",
                    "Optional[Any]",
                    "Callable[[str], bool]",
                    "numpy.array",
                    "int",
                    "List[int]"
                ],
                "knowledge": [
                    "float",
                    "bool",
                    "typing.Any",
                    "Optional[Any]",
                    "str",
                    "None",
                    "Callable[[str], bool]",
                    "typing.Callable[str, bool]",
                    "numpy.array",
                    "list[int]",
                    "int",
                    "List[int]"
                ],
                "knowledgemap": [
                    "bool",
                    "str"
                ],
                "is_merged": [
                    "bool",
                    "str"
                ]
            }
        },
        "merge_ranked": {
            "name": "merge_ranked",
            "location": 149,
            "return": [
                "dict[, list[]]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "ranked": [
                    "str"
                ]
            }
        },
        "print_qa_inputs": {
            "name": "print_qa_inputs",
            "location": 171,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "List[List[Any]]",
                    "Union[Dict, List]",
                    "T",
                    "bytes",
                    "list"
                ],
                "typ": [
                    "str",
                    "bytes",
                    "dict[, ]",
                    "bytearray",
                    "dict",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "OBQA-master/bert/__init__.py": {},
    "OBQA-master/bert/models/bert_nli.py": {
        "chunks": {
            "name": "chunks",
            "location": 409,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 446,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 554,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 570,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 574,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 578,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "BertNLI.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "model": [
                    "typing.Text",
                    "str",
                    "dict",
                    "BinaryIO"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "str",
                    "Optional[str]",
                    "bool"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "train_batch_size": [
                    "int",
                    "Optional[int]",
                    "float",
                    "bool",
                    "Optional[Any]"
                ],
                "seed": [
                    "int",
                    "bool",
                    "str",
                    "Dict[str, Tuple[str, int, int]]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "List[str]",
                    "str",
                    "bool",
                    "Union[None, int]"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "Optional[str]",
                    "Union[int, str]",
                    "Union[None, str, Pattern[str]]",
                    "dict"
                ],
                "entail_label": [
                    "int",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Dict[int, Set[str]]",
                    "Tuple[int]"
                ],
                "grad_acc_steps": [
                    "int",
                    "bool",
                    "str"
                ],
                "num_of_epochs": [
                    "int",
                    "float"
                ],
                "learning_rate": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "warmup_proportion": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "action": [
                    "typing.Text",
                    "bool",
                    "int",
                    "dict",
                    "float",
                    "str"
                ]
            }
        },
        "BertNLI.create_examples": {
            "name": "create_examples",
            "location": 104,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict[str, torch.Tensor]",
                    "dict[, ]",
                    "Dict[str, torch.Tensor]",
                    "List[List[Any]]",
                    "dict",
                    "Union[Dict, List]",
                    "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                    "List[str]",
                    "int",
                    "Dict[str, Any]",
                    "Sequence[str]"
                ]
            }
        },
        "BertNLI.get_features": {
            "name": "get_features",
            "location": 110,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "str",
                    "int",
                    "raiden.utils.BlockNumber",
                    "raiden.utils.TokenAmount"
                ],
                "fname": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "T",
                    "dict"
                ]
            }
        },
        "BertNLI.get_dataloader": {
            "name": "get_dataloader",
            "location": 131,
            "return": [
                "tuple[None]",
                "tuple[DataLoader]",
                "Optional[int]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "bool",
                "Optional[str]",
                "dict",
                "Optional[Any]",
                "Optional[List[Any]]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "typing.Sequence[typing.Any]",
                    "Optional[int]",
                    "Optional[Sequence[Any]]"
                ],
                "fname": [
                    "str",
                    "bool",
                    "TextIO",
                    "typing.TextIO"
                ]
            }
        },
        "BertNLI.predict": {
            "name": "predict",
            "location": 145,
            "return": [
                "dict[typing.Text, dict[typing.Text, ]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "int",
                    "numpy.ndarray",
                    "raiden.utils.Address",
                    "Dict[str, Any]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "BertNLI.train": {
            "name": "train",
            "location": 175,
            "return": [
                "tuple[]",
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "list[]",
                    "Dict[str, torch.LongTensor]",
                    "list",
                    "bool",
                    "Optional[bool]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "BertNLI.predict_qa": {
            "name": "predict_qa",
            "location": 283,
            "return": [
                "tuple[dict[, ]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "int",
                    "list[]",
                    "list",
                    "dict[, ]",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "dict"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "int",
                    "list[]",
                    "list",
                    "dict[, ]",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "dict"
                ],
                "data": [
                    "str",
                    "Callable",
                    "bool",
                    "Optional[Callable[[Any], None]]"
                ],
                "model": [
                    "int",
                    "Optional[str]",
                    "str",
                    "Optional[int]"
                ],
                "typ": [
                    "str",
                    "bool",
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "ep": [
                    "bool",
                    "str",
                    "Optional[bytes]",
                    "bytes",
                    "None",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "BertNLI.score_qa": {
            "name": "score_qa",
            "location": 336,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "int",
                    "list[]",
                    "list",
                    "dict[, ]",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "dict"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "int",
                    "list[]",
                    "list",
                    "dict[, ]",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "dict"
                ],
                "data": [
                    "str",
                    "bool",
                    "float"
                ],
                "model": [
                    "int",
                    "raiden.utils.Address",
                    "Dict[int, dict]",
                    "dict"
                ],
                "typ": [
                    "str",
                    "bool",
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "ep": [
                    "str",
                    "bytes",
                    "int",
                    "list[]",
                    "list",
                    "dict[, ]",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "dict"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 417,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 438,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        }
    },
    "OBQA-master/bert/models/bert_qa.py": {
        "chunks": {
            "name": "chunks",
            "location": 556,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "select_field": {
            "name": "select_field",
            "location": 561,
            "return": [
                "list[list[]]",
                "str",
                "int",
                "Optional[dict]",
                "list"
            ],
            "arguments": {
                "features": [
                    "str",
                    "int",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ],
                "field": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "softmax": {
            "name": "softmax",
            "location": 570,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 633,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "typing.Any",
                    "Optional[Any]",
                    "float",
                    "bool",
                    "None",
                    "Callable[[str], bool]",
                    "typing.Callable[str, bool]",
                    "numpy.array",
                    "list[int]",
                    "int",
                    "List[int]"
                ],
                "tokenizer": [
                    "int",
                    "raiden.utils.Address",
                    "float",
                    "None",
                    "Optional[float]",
                    "raiden.utils.ChannelID",
                    "raiden.utils.BlockIdentifier"
                ],
                "max_seq_length": [
                    "int"
                ],
                "is_training": [
                    "bool",
                    "str",
                    "None",
                    "cmk.utils.type_defs.Ruleset",
                    "list[int]",
                    "Optional[bool]",
                    "List[int]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 733,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 749,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 753,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 757,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "BertQA.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "model": [
                    "typing.Text",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Union[int, str]",
                    "Union[None, str, Pattern[str]]",
                    "dict"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "str",
                    "Optional[str]",
                    "bool"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "train_batch_size": [
                    "int",
                    "bool"
                ],
                "seed": [
                    "int",
                    "bool",
                    "cmk.utils.type_defs.CheckPluginNameStr",
                    "List[Dict[str, Any]]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "List[str]",
                    "str",
                    "bool",
                    "Union[None, int]"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "Optional[str]",
                    "Union[int, str]",
                    "Union[None, str, Pattern[str]]",
                    "dict"
                ],
                "grad_acc_steps": [
                    "int",
                    "bool",
                    "str"
                ],
                "num_of_epochs": [
                    "int",
                    "float"
                ],
                "learning_rate": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "warmup_proportion": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "action": [
                    "typing.Text",
                    "bool",
                    "int",
                    "dict",
                    "float",
                    "str"
                ],
                "fp16": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "loss_scale": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "BertQA.create_examples": {
            "name": "create_examples",
            "location": 105,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict[str, torch.Tensor]",
                    "dict[, ]",
                    "Dict[str, torch.Tensor]",
                    "List[List[Any]]",
                    "dict",
                    "Union[Dict, List]",
                    "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                    "List[str]",
                    "int",
                    "Dict[str, Any]",
                    "Sequence[str]"
                ]
            }
        },
        "BertQA.get_features": {
            "name": "get_features",
            "location": 111,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "list[int]",
                    "torch.Tensor",
                    "int",
                    "str",
                    "List[int]",
                    "float",
                    "None",
                    "Optional[int]"
                ],
                "fname": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "T",
                    "dict"
                ]
            }
        },
        "BertQA.get_dataloader": {
            "name": "get_dataloader",
            "location": 132,
            "return": [
                "tuple[None]",
                "tuple[DataLoader]",
                "Optional[int]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "bool",
                "Optional[str]",
                "dict",
                "Optional[Any]",
                "Optional[List[Any]]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "typing.Sequence[typing.Any]",
                    "Optional[int]",
                    "Optional[Sequence[Any]]"
                ],
                "fname": [
                    "str",
                    "bool",
                    "TextIO",
                    "typing.TextIO"
                ]
            }
        },
        "BertQA.predict": {
            "name": "predict",
            "location": 146,
            "return": [
                "dict[typing.Text, dict[typing.Text, int]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes",
                    "int",
                    "numpy.ndarray"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text",
                    "Optional[float]",
                    "str",
                    "int",
                    "float",
                    "Callable[[numpy.ndarray, numpy.ndarray], float]"
                ]
            }
        },
        "BertQA.predict_single": {
            "name": "predict_single",
            "location": 176,
            "return": [
                "tuple[dict[typing.Text, dict[typing.Text, ]]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "int",
                    "numpy.ndarray",
                    "Union[str, int]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "BertQA.predict_multi": {
            "name": "predict_multi",
            "location": 195,
            "return": [
                "dict[typing.Text, ]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[str]",
                    "Optional[float]",
                    "Optional[List[str]]",
                    "List[str]"
                ],
                "epoch": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "no_cache": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "str",
                    "Tuple[int, str]"
                ],
                "write_dir": [
                    "Optional[str]",
                    "str",
                    "None",
                    "bool"
                ]
            }
        },
        "BertQA.train": {
            "name": "train",
            "location": 231,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "str",
                    "Optional[int]",
                    "IO[str]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text"
                ]
            }
        },
        "BertQA.predict_qa": {
            "name": "predict_qa",
            "location": 365,
            "return": [
                "dict",
                "Dict[str, Any]",
                "str",
                "Dict[str, Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "data": [
                    "bool",
                    "str",
                    "bytes",
                    "int",
                    "dict[str, typing.Union[int,bool]]",
                    "Dict[str, Union[int, bool]]"
                ],
                "model": [
                    "int",
                    "Optional[str]",
                    "str",
                    "List[int]"
                ],
                "typ": [
                    "bool",
                    "str",
                    "Union[os.PathLike, str]"
                ],
                "ep": [
                    "bool",
                    "Optional[bytes]",
                    "bytes",
                    "List[str]",
                    "None",
                    "Callable",
                    "list[str]",
                    "typing.Callable[, ]"
                ],
                "method": [
                    "typing.Text",
                    "bool",
                    "Optional[bytes]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "BertQA.get_score": {
            "name": "get_score",
            "location": 451,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes"
                ],
                "qid": [
                    "str",
                    "bytes"
                ],
                "scores": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "BertQA.get_label": {
            "name": "get_label",
            "location": 463,
            "return": [
                "str",
                "Optional[str]",
                "torch.nn.Module"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "list[str]",
                    "Union[str, \"DatabaseURL\"]",
                    "List[str]",
                    "Dict[str, str]"
                ],
                "qid": [
                    "list[str]",
                    "str",
                    "Union[str, \"DatabaseURL\"]",
                    "List[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "BertQA.score_qa": {
            "name": "score_qa",
            "location": 468,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "data": [
                    "int",
                    "str",
                    "dict[str, typing.Union[int,bool]]",
                    "bytes",
                    "numpy.ndarray",
                    "Dict[str, Union[int, bool]]"
                ],
                "model": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "Iterable[allennlp.data.instance.Instance]",
                    "str"
                ],
                "typ": [
                    "int",
                    "float",
                    "bytes",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "list",
                    "list[]"
                ],
                "ep": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "method": [
                    "typing.Text",
                    "bool",
                    "Optional[bytes]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 577,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "str",
                    "set[str]",
                    "bool",
                    "Set[str]",
                    "list[str]",
                    "List[str]",
                    "int"
                ],
                "context_sentence": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "str",
                    "typing.Sequence[typing.Sequence[float]]",
                    "float",
                    "Optional[dict]",
                    "dict[, ]",
                    "None"
                ],
                "ending_0": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "ending_1": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "ending_2": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "ending_3": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "label": [
                    "bool",
                    "None",
                    "Sequence[Sequence[float]]",
                    "str",
                    "float",
                    "Optional[dict]",
                    "typing.Sequence[typing.Sequence[float]]",
                    "dict[, ]"
                ]
            }
        },
        "InputExample.__str__": {
            "name": "__str__",
            "location": 595,
            "return": [
                "int",
                "bytes",
                "set"
            ],
            "arguments": {
                "self": []
            }
        },
        "InputExample.__repr__": {
            "name": "__repr__",
            "location": 598,
            "return": [
                "str",
                "List[int]",
                "Dict[int, Tuple[int, int]]",
                "allennlp.data.vocabulary.Vocabulary",
                "\"Pipeline\""
            ],
            "arguments": {
                "self": []
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 615,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "example_id": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None",
                    "Optional[float]",
                    "float"
                ],
                "choices_features": [
                    "str",
                    "Optional[float]",
                    "Optional[int]",
                    "Optional[str]",
                    "bool"
                ],
                "label": [
                    "int",
                    "str",
                    "float"
                ]
            }
        }
    },
    "OBQA-master/bert/models/bert_qa_cnn.py": {
        "chunks": {
            "name": "chunks",
            "location": 595,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "select_field": {
            "name": "select_field",
            "location": 600,
            "return": [
                "list[list[]]",
                "str",
                "int",
                "Optional[dict]",
                "list"
            ],
            "arguments": {
                "features": [
                    "str",
                    "int",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ],
                "field": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "softmax": {
            "name": "softmax",
            "location": 609,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 672,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "typing.Any",
                    "Optional[Any]",
                    "float",
                    "bool",
                    "None",
                    "Callable[[str], bool]",
                    "typing.Callable[str, bool]",
                    "numpy.array",
                    "list[int]",
                    "int",
                    "List[int]"
                ],
                "tokenizer": [
                    "int",
                    "raiden.utils.Address",
                    "float",
                    "None",
                    "Optional[float]",
                    "raiden.utils.ChannelID",
                    "raiden.utils.BlockIdentifier"
                ],
                "max_seq_length": [
                    "int"
                ],
                "is_training": [
                    "bool",
                    "str",
                    "None",
                    "cmk.utils.type_defs.Ruleset",
                    "list[int]",
                    "Optional[bool]",
                    "List[int]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 772,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 788,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 792,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 796,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "BertForMultipleChoiceCNN.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Mapping[str, Any]",
                    "typing.Mapping",
                    "Sequence",
                    "typing.Sequence[]"
                ],
                "num_choices": [
                    "int",
                    "bool"
                ]
            }
        },
        "BertForMultipleChoiceCNN.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "List[str]"
                ],
                "token_type_ids": [
                    "int",
                    "str",
                    "Optional[int]"
                ],
                "attention_mask": [
                    "int",
                    "str",
                    "slice",
                    "bool",
                    "allennlp.data.Vocabulary"
                ],
                "labels": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Optional[float]",
                    "float",
                    "str",
                    "torch.LongTensor",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "BertQACNN.__init__": {
            "name": "__init__",
            "location": 77,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "model": [
                    "typing.Text",
                    "Optional[float]",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Union[int, str]",
                    "Union[None, str, Pattern[str]]"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "train_batch_size": [
                    "int",
                    "bool"
                ],
                "seed": [
                    "int",
                    "bool",
                    "cmk.utils.type_defs.CheckPluginNameStr",
                    "List[Dict[str, Any]]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "List[str]",
                    "str",
                    "bool",
                    "Union[None, int]"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "Optional[float]",
                    "str",
                    "list",
                    "List[str]",
                    "Optional[int]"
                ],
                "grad_acc_steps": [
                    "int",
                    "bool",
                    "str"
                ],
                "num_of_epochs": [
                    "int",
                    "float"
                ],
                "learning_rate": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "warmup_proportion": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "action": [
                    "typing.Text",
                    "bool",
                    "int",
                    "dict",
                    "float",
                    "str"
                ],
                "fp16": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "loss_scale": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "BertQACNN.create_examples": {
            "name": "create_examples",
            "location": 144,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict[str, torch.Tensor]",
                    "dict[, ]",
                    "Dict[str, torch.Tensor]",
                    "List[List[Any]]",
                    "dict",
                    "Union[Dict, List]",
                    "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                    "List[str]",
                    "int",
                    "Dict[str, Any]",
                    "Sequence[str]"
                ]
            }
        },
        "BertQACNN.get_features": {
            "name": "get_features",
            "location": 150,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "list[int]",
                    "torch.Tensor",
                    "int",
                    "str",
                    "List[int]",
                    "float",
                    "None",
                    "Optional[int]"
                ],
                "fname": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "T",
                    "dict"
                ]
            }
        },
        "BertQACNN.get_dataloader": {
            "name": "get_dataloader",
            "location": 171,
            "return": [
                "tuple[None]",
                "tuple[DataLoader]",
                "Optional[int]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "bool",
                "Optional[str]",
                "dict",
                "Optional[Any]",
                "Optional[List[Any]]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "typing.Sequence[typing.Any]",
                    "Optional[int]",
                    "Optional[Sequence[Any]]"
                ],
                "fname": [
                    "str",
                    "bool",
                    "TextIO",
                    "typing.TextIO"
                ]
            }
        },
        "BertQACNN.predict": {
            "name": "predict",
            "location": 185,
            "return": [
                "dict[typing.Text, dict[typing.Text, int]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes",
                    "int",
                    "numpy.ndarray"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text",
                    "Optional[float]",
                    "str",
                    "int",
                    "float",
                    "Callable[[numpy.ndarray, numpy.ndarray], float]"
                ]
            }
        },
        "BertQACNN.predict_single": {
            "name": "predict_single",
            "location": 215,
            "return": [
                "tuple[dict[typing.Text, dict[typing.Text, ]]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "int",
                    "numpy.ndarray",
                    "Union[str, int]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "BertQACNN.predict_multi": {
            "name": "predict_multi",
            "location": 234,
            "return": [
                "dict[typing.Text, ]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[str]",
                    "Optional[float]",
                    "Optional[List[str]]",
                    "List[str]"
                ],
                "epoch": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "no_cache": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "str",
                    "Tuple[int, str]"
                ],
                "write_dir": [
                    "Optional[str]",
                    "str",
                    "None",
                    "bool"
                ]
            }
        },
        "BertQACNN.train": {
            "name": "train",
            "location": 270,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "str",
                    "Optional[int]",
                    "IO[str]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text"
                ]
            }
        },
        "BertQACNN.predict_qa": {
            "name": "predict_qa",
            "location": 404,
            "return": [
                "dict",
                "Dict[str, Any]",
                "str",
                "Dict[str, Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "data": [
                    "bool",
                    "str",
                    "bytes",
                    "int",
                    "dict[str, typing.Union[int,bool]]",
                    "Dict[str, Union[int, bool]]"
                ],
                "model": [
                    "int",
                    "Optional[str]",
                    "str",
                    "List[int]"
                ],
                "typ": [
                    "bool",
                    "str",
                    "Union[os.PathLike, str]"
                ],
                "ep": [
                    "bool",
                    "Optional[bytes]",
                    "bytes",
                    "List[str]",
                    "None",
                    "Callable",
                    "list[str]",
                    "typing.Callable[, ]"
                ],
                "method": [
                    "typing.Text",
                    "bool",
                    "Optional[bytes]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "BertQACNN.get_score": {
            "name": "get_score",
            "location": 490,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes"
                ],
                "qid": [
                    "str",
                    "bytes"
                ],
                "scores": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "BertQACNN.get_label": {
            "name": "get_label",
            "location": 502,
            "return": [
                "str",
                "Optional[str]",
                "torch.nn.Module"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "list[str]",
                    "Union[str, \"DatabaseURL\"]",
                    "List[str]",
                    "Dict[str, str]"
                ],
                "qid": [
                    "list[str]",
                    "str",
                    "Union[str, \"DatabaseURL\"]",
                    "List[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "BertQACNN.score_qa": {
            "name": "score_qa",
            "location": 507,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "data": [
                    "int",
                    "str",
                    "dict[str, typing.Union[int,bool]]",
                    "bytes",
                    "numpy.ndarray",
                    "Dict[str, Union[int, bool]]"
                ],
                "model": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "Iterable[allennlp.data.instance.Instance]",
                    "str"
                ],
                "typ": [
                    "int",
                    "float",
                    "bytes",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "list",
                    "list[]"
                ],
                "ep": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "method": [
                    "typing.Text",
                    "bool",
                    "Optional[bytes]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 616,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "str",
                    "set[str]",
                    "bool",
                    "Set[str]",
                    "list[str]",
                    "List[str]",
                    "int"
                ],
                "context_sentence": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "str",
                    "typing.Sequence[typing.Sequence[float]]",
                    "float",
                    "Optional[dict]",
                    "dict[, ]",
                    "None"
                ],
                "ending_0": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "ending_1": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "ending_2": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "ending_3": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Union[int, str]",
                    "str"
                ],
                "label": [
                    "bool",
                    "None",
                    "Sequence[Sequence[float]]",
                    "str",
                    "float",
                    "Optional[dict]",
                    "typing.Sequence[typing.Sequence[float]]",
                    "dict[, ]"
                ]
            }
        },
        "InputExample.__str__": {
            "name": "__str__",
            "location": 634,
            "return": [
                "int",
                "bytes",
                "set"
            ],
            "arguments": {
                "self": []
            }
        },
        "InputExample.__repr__": {
            "name": "__repr__",
            "location": 637,
            "return": [
                "str",
                "List[int]",
                "Dict[int, Tuple[int, int]]",
                "allennlp.data.vocabulary.Vocabulary",
                "\"Pipeline\""
            ],
            "arguments": {
                "self": []
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 654,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "example_id": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None",
                    "Optional[float]",
                    "float"
                ],
                "choices_features": [
                    "str",
                    "Optional[float]",
                    "Optional[int]",
                    "Optional[str]",
                    "bool"
                ],
                "label": [
                    "int",
                    "str",
                    "float"
                ]
            }
        }
    },
    "OBQA-master/bert/models/bert_qa_v2.py": {
        "chunks": {
            "name": "chunks",
            "location": 630,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "select_field": {
            "name": "select_field",
            "location": 635,
            "return": [
                "list[list[]]",
                "str",
                "int",
                "Optional[dict]",
                "list"
            ],
            "arguments": {
                "features": [
                    "str",
                    "int",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ],
                "field": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "softmax": {
            "name": "softmax",
            "location": 644,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 704,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "typing.Any",
                    "Optional[Any]",
                    "float",
                    "bool",
                    "None",
                    "Callable[[str], bool]",
                    "typing.Callable[str, bool]",
                    "numpy.array",
                    "list[int]",
                    "int",
                    "List[int]"
                ],
                "tokenizer": [
                    "int",
                    "raiden.utils.Address",
                    "float",
                    "None",
                    "Optional[float]",
                    "raiden.utils.ChannelID",
                    "raiden.utils.BlockIdentifier"
                ],
                "max_seq_length": [
                    "int"
                ],
                "is_training": [
                    "bool",
                    "str",
                    "None",
                    "cmk.utils.type_defs.Ruleset",
                    "list[int]",
                    "Optional[bool]",
                    "List[int]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 804,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 820,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 824,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 828,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "BertForMultipleChoiceV2.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Mapping[str, Any]",
                    "typing.Mapping",
                    "Sequence",
                    "typing.Sequence[]"
                ],
                "num_choices": [
                    "int",
                    "bool"
                ]
            }
        },
        "BertForMultipleChoiceV2.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "List[str]"
                ],
                "token_type_ids": [
                    "int",
                    "str",
                    "Optional[int]"
                ],
                "attention_mask": [
                    "int",
                    "str",
                    "slice",
                    "bool",
                    "allennlp.data.Vocabulary"
                ],
                "labels": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Optional[float]",
                    "float",
                    "str",
                    "torch.LongTensor",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "BertForMultipleChoiceCNN.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Mapping[str, Any]",
                    "typing.Mapping",
                    "Sequence",
                    "typing.Sequence[]"
                ],
                "num_choices": [
                    "int",
                    "bool"
                ]
            }
        },
        "BertForMultipleChoiceCNN.forward": {
            "name": "forward",
            "location": 80,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "List[str]"
                ],
                "token_type_ids": [
                    "int",
                    "str",
                    "Optional[int]"
                ],
                "attention_mask": [
                    "int",
                    "str",
                    "slice",
                    "bool",
                    "allennlp.data.Vocabulary"
                ],
                "labels": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Optional[float]",
                    "float",
                    "str",
                    "torch.LongTensor",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "BertQAV2.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "model": [
                    "typing.Text",
                    "Optional[float]",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Union[int, str]",
                    "Union[None, str, Pattern[str]]"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "train_batch_size": [
                    "int",
                    "bool"
                ],
                "seed": [
                    "int",
                    "bool",
                    "cmk.utils.type_defs.CheckPluginNameStr",
                    "List[Dict[str, Any]]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "List[str]",
                    "str",
                    "bool",
                    "Union[None, int]"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "Optional[float]",
                    "str",
                    "list",
                    "List[str]",
                    "Optional[int]"
                ],
                "grad_acc_steps": [
                    "int",
                    "bool",
                    "str"
                ],
                "num_of_epochs": [
                    "int",
                    "float"
                ],
                "learning_rate": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "warmup_proportion": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "action": [
                    "typing.Text",
                    "bool",
                    "int",
                    "dict",
                    "float",
                    "str"
                ],
                "fp16": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "loss_scale": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "BertQAV2.create_examples": {
            "name": "create_examples",
            "location": 178,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict[str, torch.Tensor]",
                    "dict[, ]",
                    "Dict[str, torch.Tensor]",
                    "List[List[Any]]",
                    "dict",
                    "Union[Dict, List]",
                    "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                    "List[str]",
                    "int",
                    "Dict[str, Any]",
                    "Sequence[str]"
                ]
            }
        },
        "BertQAV2.get_features": {
            "name": "get_features",
            "location": 185,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "list[int]",
                    "torch.Tensor",
                    "int",
                    "str",
                    "List[int]",
                    "float",
                    "None",
                    "Optional[int]"
                ],
                "fname": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "T",
                    "dict"
                ]
            }
        },
        "BertQAV2.get_dataloader": {
            "name": "get_dataloader",
            "location": 206,
            "return": [
                "tuple[None]",
                "tuple[DataLoader]",
                "Optional[int]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "bool",
                "Optional[str]",
                "dict",
                "Optional[Any]",
                "Optional[List[Any]]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "typing.Sequence[typing.Any]",
                    "Optional[int]",
                    "Optional[Sequence[Any]]"
                ],
                "fname": [
                    "str",
                    "bool",
                    "TextIO",
                    "typing.TextIO"
                ]
            }
        },
        "BertQAV2.predict": {
            "name": "predict",
            "location": 220,
            "return": [
                "dict[typing.Text, dict[typing.Text, int]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes",
                    "int",
                    "numpy.ndarray"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text",
                    "Optional[float]",
                    "str",
                    "int",
                    "float",
                    "Callable[[numpy.ndarray, numpy.ndarray], float]"
                ]
            }
        },
        "BertQAV2.predict_single": {
            "name": "predict_single",
            "location": 250,
            "return": [
                "tuple[dict[typing.Text, dict[typing.Text, ]]]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "int",
                    "numpy.ndarray",
                    "Union[str, int]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "BertQAV2.predict_multi": {
            "name": "predict_multi",
            "location": 269,
            "return": [
                "dict[typing.Text, ]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[str]",
                    "Optional[float]",
                    "Optional[List[str]]",
                    "List[str]"
                ],
                "epoch": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "no_cache": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "str",
                    "Tuple[int, str]"
                ],
                "write_dir": [
                    "Optional[str]",
                    "str",
                    "None",
                    "bool"
                ]
            }
        },
        "BertQAV2.train": {
            "name": "train",
            "location": 305,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "str",
                    "Optional[int]",
                    "IO[str]"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ],
                "method": [
                    "typing.Text"
                ]
            }
        },
        "BertQAV2.predict_qa": {
            "name": "predict_qa",
            "location": 439,
            "return": [
                "dict",
                "Dict[str, Any]",
                "str",
                "Dict[str, Dict[str, str]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "data": [
                    "bool",
                    "str",
                    "bytes",
                    "int",
                    "dict[str, typing.Union[int,bool]]",
                    "Dict[str, Union[int, bool]]"
                ],
                "model": [
                    "int",
                    "Optional[str]",
                    "str",
                    "List[int]"
                ],
                "typ": [
                    "bool",
                    "str",
                    "Union[os.PathLike, str]"
                ],
                "ep": [
                    "bool",
                    "Optional[bytes]",
                    "bytes",
                    "List[str]",
                    "None",
                    "Callable",
                    "list[str]",
                    "typing.Callable[, ]"
                ],
                "method": [
                    "typing.Text",
                    "bool",
                    "Optional[bytes]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "BertQAV2.get_score": {
            "name": "get_score",
            "location": 525,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes"
                ],
                "qid": [
                    "str",
                    "bytes"
                ],
                "scores": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "BertQAV2.get_label": {
            "name": "get_label",
            "location": 537,
            "return": [
                "str",
                "Optional[str]",
                "torch.nn.Module"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "list[str]",
                    "Union[str, \"DatabaseURL\"]",
                    "List[str]",
                    "Dict[str, str]"
                ],
                "qid": [
                    "list[str]",
                    "str",
                    "Union[str, \"DatabaseURL\"]",
                    "List[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "BertQAV2.score_qa": {
            "name": "score_qa",
            "location": 542,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "eval_dataloader": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "eval_index": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "data": [
                    "bool",
                    "Optional[bytes]",
                    "bytes",
                    "List[str]",
                    "None",
                    "Callable",
                    "list[str]",
                    "typing.Callable[, ]"
                ],
                "model": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "Iterable[allennlp.data.instance.Instance]",
                    "str"
                ],
                "typ": [
                    "int",
                    "float",
                    "bytes",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "list",
                    "list[]"
                ],
                "ep": [
                    "str",
                    "bytes",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "method": [
                    "typing.Text",
                    "bool",
                    "Optional[bytes]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 651,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "str",
                    "List[str]",
                    "list[str]",
                    "AsyncIterator[T]",
                    "collections.abc.AsyncIterator",
                    "Dict[str, Dict[str, str]]",
                    "dict[str, dict[str, str]]"
                ],
                "context_sentence": [
                    "int",
                    "float",
                    "str",
                    "Optional[str]",
                    "Union[float, Tuple[float, float]]",
                    "None",
                    "Optional[Callable[[Any], None]]",
                    "tuple[typing.Union[float,float]]",
                    "List[utils.CWLObjectType]",
                    "typing.Callable[typing.Any, None]",
                    "list[C]"
                ],
                "ending_0": [
                    "int",
                    "list[int]",
                    "bool",
                    "List[int]",
                    "raiden.utils.BlockHash",
                    "raiden.utils.BlockNumber"
                ],
                "ending_1": [
                    "int",
                    "list[int]",
                    "bool",
                    "List[int]",
                    "raiden.utils.BlockHash",
                    "raiden.utils.BlockNumber"
                ],
                "label": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "Optional[str]",
                    "Union[float, Tuple[float, float]]",
                    "Optional[Callable[[Any], None]]",
                    "tuple[typing.Union[float,float]]",
                    "List[utils.CWLObjectType]",
                    "typing.Callable[typing.Any, None]",
                    "list[C]"
                ]
            }
        },
        "InputExample.__str__": {
            "name": "__str__",
            "location": 667,
            "return": [
                "int",
                "bytes",
                "set"
            ],
            "arguments": {
                "self": []
            }
        },
        "InputExample.__repr__": {
            "name": "__repr__",
            "location": 670,
            "return": [
                "str",
                "List[int]",
                "Dict[int, Tuple[int, int]]",
                "allennlp.data.vocabulary.Vocabulary",
                "\"Pipeline\""
            ],
            "arguments": {
                "self": []
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 686,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "example_id": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None",
                    "Optional[float]",
                    "float"
                ],
                "choices_features": [
                    "str",
                    "Optional[float]",
                    "Optional[int]",
                    "Optional[str]",
                    "bool"
                ],
                "label": [
                    "int",
                    "str",
                    "float"
                ]
            }
        }
    },
    "OBQA-master/filterir/run_classifier.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 331,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "list[typing.Any]",
                    "numpy.ndarray",
                    "Optional[List[Any]]",
                    "IO",
                    "int"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 413,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 429,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 433,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "get_dataloader": {
            "name": "get_dataloader",
            "location": 438,
            "return": [
                "DataLoader",
                "str",
                "bool"
            ],
            "arguments": {
                "train_features": [
                    "str",
                    "list[]",
                    "list",
                    "sideeye.data.region.Region",
                    "int"
                ],
                "train_batch_size": [
                    "int",
                    "float"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 448,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "input_mask": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "segment_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "label_id": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 88,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 93,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "FIRProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 105,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "FIRProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 111,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "FIRProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 116,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "FIRProcessor.get_labels": {
            "name": "get_labels",
            "location": 121,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FIRProcessor._create_examples": {
            "name": "_create_examples",
            "location": 125,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "OBQAProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 141,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 147,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_labels": {
            "name": "get_labels",
            "location": 152,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "OBQAProcessor._create_examples": {
            "name": "_create_examples",
            "location": 156,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MrpcProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 171,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 177,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_labels": {
            "name": "get_labels",
            "location": 182,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MrpcProcessor._create_examples": {
            "name": "_create_examples",
            "location": 186,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        },
        "MnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 204,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 209,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 215,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 219,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "QnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 236,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "QnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 241,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "QnliProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 246,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "QnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 252,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "QnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 256,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "SnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 273,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 278,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 284,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 288,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "ColaProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 305,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 310,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_labels": {
            "name": "get_labels",
            "location": 315,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ColaProcessor._create_examples": {
            "name": "_create_examples",
            "location": 319,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "Optional[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/filterir/run_scorer.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 129,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 235,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 251,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 255,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "get_dataloader": {
            "name": "get_dataloader",
            "location": 260,
            "return": [
                "DataLoader",
                "str",
                "bool"
            ],
            "arguments": {
                "train_features": [
                    "str",
                    "list[]",
                    "list",
                    "sideeye.data.region.Region",
                    "int"
                ],
                "train_batch_size": [
                    "int",
                    "float"
                ]
            }
        },
        "softmax": {
            "name": "softmax",
            "location": 271,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 276,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 89,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 94,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "FIRProcessor.get_score_examples": {
            "name": "get_score_examples",
            "location": 106,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ],
                "fname": [
                    "str"
                ]
            }
        },
        "FIRProcessor.get_labels": {
            "name": "get_labels",
            "location": 111,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FIRProcessor._create_examples": {
            "name": "_create_examples",
            "location": 115,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/ir/run_ir-omcs.py": {
        "read_data_to_score": {
            "name": "read_data_to_score",
            "location": 12,
            "return": [
                "dict[typing.Text, typing.Union[dict[str, typing.Union[str,int,typing.Callable[, ],tuple[typing.Union[int,int,int]],dict[str, int]]],list[str]]]",
                "str",
                "Dict[str, str]",
                "float"
            ],
            "arguments": {
                "factfile": [
                    "str",
                    "Sequence[str]"
                ],
                "is_fact_fact": [
                    "bool",
                    "Callable",
                    "str"
                ],
                "datasets": [
                    "bytes",
                    "list[int]",
                    "bool",
                    "float",
                    "List[int]",
                    "Union[float, int]"
                ]
            }
        },
        "read_preranked_file": {
            "name": "read_preranked_file",
            "location": 44,
            "return": [
                "dict[, ]",
                "bool",
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "fname": [
                    "str"
                ]
            }
        }
    },
    "OBQA-master/ir/run_ir.py": {
        "choose_model": {
            "name": "choose_model",
            "location": 12,
            "return": [
                "SpacyIR",
                "Optional[str]",
                "models.PermissionLookup",
                "Callable"
            ],
            "arguments": {
                "topk": [
                    "int",
                    "Optional[str]",
                    "models.PermissionLookup",
                    "Callable"
                ]
            }
        },
        "read_data_to_score": {
            "name": "read_data_to_score",
            "location": 16,
            "return": [
                "dict[typing.Text, typing.Union[dict[str, typing.Union[str,int,typing.Callable[, ],tuple[typing.Union[int,int,int]],dict[str, int]]],list[str]]]",
                "str",
                "Dict[str, str]",
                "float"
            ],
            "arguments": {
                "factfile": [
                    "str",
                    "Sequence[str]"
                ],
                "is_fact_fact": [
                    "bool",
                    "Callable",
                    "str"
                ],
                "datasets": [
                    "bytes",
                    "list[int]",
                    "bool",
                    "float",
                    "List[int]",
                    "Union[float, int]"
                ]
            }
        }
    },
    "OBQA-master/ir/run_sts.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 290,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 373,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 389,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 393,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "pearson": {
            "name": "pearson",
            "location": 398,
            "return": [
                "int",
                "float",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bytes",
                    "bytearray",
                    "float",
                    "int",
                    "bool",
                    "Union[bytes, bytearray, memoryview]",
                    "torch.Tensor",
                    "torch.FloatTensor"
                ],
                "y": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 420,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 425,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "input_mask": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "segment_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "label_id": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 88,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 93,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "StsProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 105,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "StsProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 110,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "StsProcessor.get_labels": {
            "name": "get_labels",
            "location": 116,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "StsProcessor._create_examples": {
            "name": "_create_examples",
            "location": 120,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "OBQAProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 137,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 143,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_labels": {
            "name": "get_labels",
            "location": 148,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "OBQAProcessor._create_examples": {
            "name": "_create_examples",
            "location": 152,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MrpcProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 167,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 173,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_labels": {
            "name": "get_labels",
            "location": 178,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MrpcProcessor._create_examples": {
            "name": "_create_examples",
            "location": 182,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        },
        "MnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 200,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 205,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 211,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 215,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "SnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 232,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 237,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 243,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 247,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "ColaProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 264,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 269,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_labels": {
            "name": "get_labels",
            "location": 274,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ColaProcessor._create_examples": {
            "name": "_create_examples",
            "location": 278,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "Optional[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/ir/run_sts_eval.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 325,
            "return": [
                "list[InputFeatures]",
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 408,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 424,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 428,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "pearson": {
            "name": "pearson",
            "location": 434,
            "return": [
                "int",
                "Callable",
                "list[typing.Any]",
                "str",
                "list[bool]"
            ],
            "arguments": {
                "x": [
                    "int",
                    "float",
                    "torch.Tensor"
                ],
                "y": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 464,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 469,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "input_mask": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "segment_ids": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "label_id": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 88,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "bool",
                    "str",
                    "List[str]",
                    "list[str]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 92,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 97,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "StsProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 109,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "StsProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 114,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "StsProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 120,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "StsProcessor.get_labels": {
            "name": "get_labels",
            "location": 126,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "StsProcessor._create_examples": {
            "name": "_create_examples",
            "location": 130,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "OBQAProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 147,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 153,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 158,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "OBQAProcessor.get_labels": {
            "name": "get_labels",
            "location": 163,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "OBQAProcessor._create_examples": {
            "name": "_create_examples",
            "location": 167,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MrpcProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 182,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 188,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_labels": {
            "name": "get_labels",
            "location": 193,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MrpcProcessor._create_examples": {
            "name": "_create_examples",
            "location": 197,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        },
        "MnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 215,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 220,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 226,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "MnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 232,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 236,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "SnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 254,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 259,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 265,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "SnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 272,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 276,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "ColaProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 294,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 299,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 304,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "ColaProcessor.get_labels": {
            "name": "get_labels",
            "location": 309,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ColaProcessor._create_examples": {
            "name": "_create_examples",
            "location": 313,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/ir/run_sts_score.py": {
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 326,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 412,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 428,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 432,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "pearson": {
            "name": "pearson",
            "location": 437,
            "return": [
                "int",
                "float",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bytes",
                    "bytearray",
                    "float",
                    "int",
                    "bool",
                    "Union[bytes, bytearray, memoryview]",
                    "torch.Tensor",
                    "torch.FloatTensor"
                ],
                "y": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "warmup_linear": {
            "name": "warmup_linear",
            "location": 459,
            "return": [
                "float",
                "utils.Node",
                "str",
                "bool"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "warmup": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 464,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        },
        "DataProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 89,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "bool",
                    "str",
                    "List[str]",
                    "list[str]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "DataProcessor.get_labels": {
            "name": "get_labels",
            "location": 93,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataProcessor._read_tsv": {
            "name": "_read_tsv",
            "location": 98,
            "return": [
                "list[]",
                "str",
                "list",
                "Sequence[str]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[str]",
                    "list[str]"
                ],
                "input_file": [
                    "str"
                ],
                "quotechar": [
                    "str",
                    "bool",
                    "None"
                ]
            }
        },
        "StsProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 110,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "StsProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 115,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "StsProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 121,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "StsProcessor.get_labels": {
            "name": "get_labels",
            "location": 127,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "StsProcessor._create_examples": {
            "name": "_create_examples",
            "location": 131,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "OBQAProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 148,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 154,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "OBQAProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 159,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "OBQAProcessor.get_labels": {
            "name": "get_labels",
            "location": 164,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "OBQAProcessor._create_examples": {
            "name": "_create_examples",
            "location": 168,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "bytes"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MrpcProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 183,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 189,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MrpcProcessor.get_labels": {
            "name": "get_labels",
            "location": 194,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MrpcProcessor._create_examples": {
            "name": "_create_examples",
            "location": 198,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        },
        "MnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 216,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 221,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "MnliProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 227,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "MnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 233,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 237,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "SnliProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 255,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 260,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "SnliProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 266,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "SnliProcessor.get_labels": {
            "name": "get_labels",
            "location": 273,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SnliProcessor._create_examples": {
            "name": "_create_examples",
            "location": 277,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "AnyStr",
                    "typing.AnyStr"
                ]
            }
        },
        "ColaProcessor.get_train_examples": {
            "name": "get_train_examples",
            "location": 295,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_dev_examples": {
            "name": "get_dev_examples",
            "location": 300,
            "return": [
                "str",
                "bool",
                "os.PathLike",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str"
                ]
            }
        },
        "ColaProcessor.get_test_examples": {
            "name": "get_test_examples",
            "location": 305,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "data_dir": [
                    "str",
                    "bool"
                ]
            }
        },
        "ColaProcessor.get_labels": {
            "name": "get_labels",
            "location": 310,
            "return": [
                "list[typing.Text]",
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ColaProcessor._create_examples": {
            "name": "_create_examples",
            "location": 314,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "lines": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "Iterator[str]"
                ],
                "set_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "int",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/ir/score_ir.py": {
        "read_ranked": {
            "name": "read_ranked",
            "location": 9,
            "return": [
                "dict[, ]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "Union[str, IO[bytes]]"
                ],
                "topk": [
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "read_knowledge": {
            "name": "read_knowledge",
            "location": 18,
            "return": [
                "tuple[typing.Union[dict[typing.Union[str,set[str],dict[int, str],None], ],list[typing.Union[str,set[str],dict[int, str],None]]]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "read_hyp_dataset": {
            "name": "read_hyp_dataset",
            "location": 28,
            "return": [
                "dict[typing.Union[str,int], Entry]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "Union[str, IO[bytes]]"
                ]
            }
        },
        "merge_ranked": {
            "name": "merge_ranked",
            "location": 44,
            "return": [
                "dict[, list[]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "ranked": [
                    "str"
                ]
            }
        },
        "score_ranked_fact1": {
            "name": "score_ranked_fact1",
            "location": 68,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "ranked": [
                    "str",
                    "int",
                    "list",
                    "bytes",
                    "list[]",
                    "dict",
                    "dict[, ]",
                    "List[Optional[str]]",
                    "list[typing.Optional[str]]"
                ],
                "datasets": [
                    "bool",
                    "str"
                ],
                "knowledgemap": [
                    "str",
                    "bool",
                    "typing.Iterable[str]",
                    "Union[str, Iterable[str]]",
                    "Dict[str, Tuple[str, int, int]]"
                ],
                "knowledge": [
                    "str",
                    "bool",
                    "int",
                    "Optional[dict]"
                ],
                "is_merged": [
                    "bool",
                    "str"
                ]
            }
        }
    },
    "OBQA-master/ir/__init__.py": {},
    "OBQA-master/ir/models/bert_cnn.py": {
        "softmax": {
            "name": "softmax",
            "location": 203,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "chunks": {
            "name": "chunks",
            "location": 208,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 245,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 340,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 356,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 360,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "pearson": {
            "name": "pearson",
            "location": 365,
            "return": [
                "int",
                "float",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bytes",
                    "bytearray",
                    "float",
                    "int",
                    "bool",
                    "Union[bytes, bytearray, memoryview]",
                    "torch.Tensor",
                    "torch.FloatTensor"
                ],
                "y": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "BertForCNN.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "config": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "num_labels": [
                    "int",
                    "list[str]",
                    "str",
                    "cmk.utils.type_defs.HostName",
                    "cmk.utils.type_defs.ServiceName",
                    "List[str]"
                ]
            }
        },
        "BertForCNN.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_ids": [
                    "int",
                    "str",
                    "dict[str, str]",
                    "Dict[str, str]",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "token_type_ids": [
                    "int",
                    "None",
                    "str",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "attention_mask": [
                    "int",
                    "None",
                    "str",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "labels": [
                    "None",
                    "Optional[int]",
                    "Optional[float]",
                    "int",
                    "Optional[str]",
                    "Optional[bool]",
                    "str"
                ]
            }
        },
        "BertCNNIR.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "model": [
                    "str",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "dict[str, typing.Any]",
                    "None",
                    "bool",
                    "Optional[Dict[str, str]]",
                    "dict[str, str]"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "raiden.utils.Balance",
                    "str",
                    "Optional[int]",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.TokenAmount"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "str",
                    "bool",
                    "float"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "Optional[Set[str]]",
                    "flambe.nn.Module",
                    "Optional[int]"
                ],
                "entail_label": [
                    "int",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Dict[int, Set[str]]",
                    "Tuple[int]"
                ]
            }
        },
        "BertCNNIR.create_eval_examples": {
            "name": "create_eval_examples",
            "location": 96,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "hyps": [
                    "dict[, ]",
                    "str",
                    "cmk.utils.type_defs.EventRule",
                    "dict"
                ],
                "facts": [
                    "bool",
                    "allennlp.data.dataseDataset",
                    "float"
                ]
            }
        },
        "BertCNNIR.get_features": {
            "name": "get_features",
            "location": 104,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "max_seq_length": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "tokenizer": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "tokenfile": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "chunk_id": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "BertCNNIR.predict": {
            "name": "predict",
            "location": 125,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bool",
                    "raiden.utils.NetworkTimeout",
                    "int"
                ],
                "outfile": [
                    "str",
                    "IO",
                    "int",
                    "BinaryIO"
                ],
                "tokenfile": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "no_cache": [
                    "bool",
                    "int",
                    "bytes",
                    "bytearray"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 216,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 237,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        }
    },
    "OBQA-master/ir/models/bert_nli.py": {
        "softmax": {
            "name": "softmax",
            "location": 164,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "chunks": {
            "name": "chunks",
            "location": 169,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 206,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 301,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 317,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 321,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "pearson": {
            "name": "pearson",
            "location": 326,
            "return": [
                "int",
                "float",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bytes",
                    "bytearray",
                    "float",
                    "int",
                    "bool",
                    "Union[bytes, bytearray, memoryview]",
                    "torch.Tensor",
                    "torch.FloatTensor"
                ],
                "y": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "BertNLIIR.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "model": [
                    "str",
                    "int",
                    "dict[str, typing.Any]",
                    "Optional[Dict[str, Any]]",
                    "None",
                    "bool",
                    "dict[str, str]",
                    "Optional[Dict[str, str]]",
                    "Dict[str, Any]"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "str",
                    "raiden.utils.Balance",
                    "bool",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.TokenAmount"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "str",
                    "bool",
                    "float"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "flambe.nn.Module",
                    "Union[np.ndarray, Dict[str, np.ndarray], loompy.LayerManager]"
                ],
                "entail_label": [
                    "int",
                    "bool",
                    "Optional[str]",
                    "str",
                    "Dict[int, Set[str]]",
                    "Tuple[int]"
                ]
            }
        },
        "BertNLIIR.create_eval_examples": {
            "name": "create_eval_examples",
            "location": 57,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "hyps": [
                    "dict[, ]",
                    "str",
                    "cmk.utils.type_defs.EventRule",
                    "dict"
                ],
                "facts": [
                    "bool",
                    "allennlp.data.dataseDataset",
                    "float"
                ]
            }
        },
        "BertNLIIR.get_features": {
            "name": "get_features",
            "location": 65,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "max_seq_length": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "tokenizer": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "tokenfile": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "chunk_id": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "BertNLIIR.predict": {
            "name": "predict",
            "location": 86,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bool",
                    "raiden.utils.NetworkTimeout",
                    "int"
                ],
                "outfile": [
                    "str",
                    "IO",
                    "int",
                    "BinaryIO"
                ],
                "tokenfile": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "no_cache": [
                    "bool",
                    "int",
                    "bytes",
                    "bytearray"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 177,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 198,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        }
    },
    "OBQA-master/ir/models/bert_sts.py": {
        "chunks": {
            "name": "chunks",
            "location": 172,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "l": [
                    "int",
                    "list",
                    "Sequence",
                    "List[str]",
                    "List[int]"
                ],
                "n": [
                    "int",
                    "list",
                    "list[]",
                    "Sequence",
                    "typing.Sequence[]",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "convert_examples_to_features": {
            "name": "convert_examples_to_features",
            "location": 209,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "torch.Tensor",
                "List[int]"
            ],
            "arguments": {
                "examples": [
                    "str",
                    "list[str]",
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]",
                    "Optional[str]",
                    "List[str]",
                    "Union[int, float]"
                ],
                "label_list": [
                    "str",
                    "Dict[str, List[str]]",
                    "bool",
                    "dict[str, list[str]]",
                    "List[Tuple[Any, str]]",
                    "list[tuple[typing.Union[typing.Any,str]]]"
                ],
                "max_seq_length": [
                    "int",
                    "List[int]",
                    "tuple",
                    "raiden.utils.Address",
                    "str"
                ],
                "tokenizer": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Union[str,int]]",
                    "Dict[str, Union[str, int]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "_truncate_seq_pair": {
            "name": "_truncate_seq_pair",
            "location": 303,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tokens_a": [
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "tokens_b": [
                    "List[int]",
                    "int"
                ],
                "max_length": [
                    "int",
                    "float"
                ]
            }
        },
        "accuracy": {
            "name": "accuracy",
            "location": 319,
            "return": [
                "torch.Tensor",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "out": [
                    "str",
                    "int",
                    "float"
                ],
                "labels": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "average": {
            "name": "average",
            "location": 323,
            "return": [
                "float",
                "str",
                "Optional[int]",
                "torch.FloatTensor",
                "Optional[List[int]]"
            ],
            "arguments": {
                "x": [
                    "list",
                    "numpy.ndarray",
                    "float",
                    "List[float]"
                ]
            }
        },
        "pearson": {
            "name": "pearson",
            "location": 328,
            "return": [
                "int",
                "float",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bytes",
                    "bytearray",
                    "float",
                    "int",
                    "bool",
                    "Union[bytes, bytearray, memoryview]",
                    "torch.Tensor",
                    "torch.FloatTensor"
                ],
                "y": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "BertSTSIR.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dir": [
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "model": [
                    "str",
                    "int",
                    "dict[str, typing.Any]",
                    "Optional[Dict[str, Any]]",
                    "None",
                    "bool",
                    "dict[str, str]",
                    "Optional[Dict[str, str]]",
                    "Dict[str, Any]"
                ],
                "topk": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "bert_model": [
                    "typing.Text",
                    "str",
                    "raiden.utils.Balance",
                    "bool",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.TokenAmount"
                ],
                "do_lower_case": [
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "Optional[str]"
                ],
                "eval_batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "Callable[[int], bool]",
                    "str",
                    "bool"
                ],
                "max_seq_length": [
                    "int",
                    "str",
                    "bool",
                    "float"
                ],
                "num_labels": [
                    "int",
                    "bool",
                    "flambe.nn.Module",
                    "Union[np.ndarray, Dict[str, np.ndarray], loompy.LayerManager]"
                ]
            }
        },
        "BertSTSIR.create_eval_examples": {
            "name": "create_eval_examples",
            "location": 56,
            "return": [
                "list[InputExample]",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "hyps": [
                    "dict[str, set[str]]",
                    "Dict[str, Set[str]]",
                    "Type"
                ],
                "facts": [
                    "list[str]",
                    "numpy.ndarray",
                    "List[str]"
                ],
                "preranked": [
                    "Optional[Sequence[float]]",
                    "None",
                    "str",
                    "Optional[List[str]]",
                    "typing.Sequence[float]",
                    "list[str]",
                    "Optional[Dict[str, Any]]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "BertSTSIR.get_features": {
            "name": "get_features",
            "location": 72,
            "return": [
                "tuple[]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "eval_examples": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "float",
                    "None",
                    "Optional[List[float]]",
                    "list[float]",
                    "List[int]",
                    "list[int]"
                ],
                "max_seq_length": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "float",
                    "None",
                    "Optional[List[float]]",
                    "list[float]",
                    "List[int]",
                    "list[int]"
                ],
                "tokenizer": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "float",
                    "None",
                    "Optional[List[float]]",
                    "list[float]",
                    "List[int]",
                    "list[int]"
                ],
                "tokenfile": [
                    "str",
                    "list[str]",
                    "int",
                    "List[str]",
                    "bytes"
                ],
                "chunk_id": [
                    "int",
                    "str",
                    "Optional[int]",
                    "None"
                ],
                "no_cache": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "BertSTSIR.predict": {
            "name": "predict",
            "location": 94,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[B]",
                    "list[str]",
                    "Callable[[bytes], bytes]",
                    "Dict[str, Any]",
                    "List[utils.models.Base]",
                    "List[str]",
                    "dict",
                    "int"
                ],
                "outfile": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "BinaryIO"
                ],
                "tokenfile": [
                    "str",
                    "int"
                ],
                "preranked": [
                    "str",
                    "None",
                    "bytes",
                    "Tuple[float, str]",
                    "dict",
                    "tuple[typing.Union[float,str]]",
                    "dict[, ]"
                ]
            }
        },
        "InputExample.__init__": {
            "name": "__init__",
            "location": 180,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "guid": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_a": [
                    "bool",
                    "str",
                    "list[C]",
                    "int",
                    "List['cirq.Circuit']"
                ],
                "text_b": [
                    "bool",
                    "None",
                    "int"
                ],
                "label": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "List['cirq.Circuit']",
                    "list[C]"
                ]
            }
        },
        "InputFeatures.__init__": {
            "name": "__init__",
            "location": 201,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "uuid": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "input_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "input_mask": [
                    "bool",
                    "bytes",
                    "list[str]",
                    "List[str]",
                    "str",
                    "None",
                    "Optional[str]",
                    "list[]",
                    "Optional[List[Any]]",
                    "Optional[bool]",
                    "list"
                ],
                "segment_ids": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "label_id": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        }
    },
    "OBQA-master/ir/models/spacy_based_ir.py": {
        "SpacyIR.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "topk": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "SpacyIR.score": {
            "name": "score",
            "location": 14,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "p": [
                    "int",
                    "float"
                ],
                "h": [
                    "int",
                    "float"
                ]
            }
        },
        "SpacyIR.predict": {
            "name": "predict",
            "location": 19,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[str]",
                    "Callable[[bytes], bytes]",
                    "Dict[str, Any]",
                    "List[str]",
                    "dict",
                    "int"
                ],
                "outfile": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "BinaryIO"
                ],
                "tokenfile": [
                    "int",
                    "None",
                    "bytes",
                    "bool",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/copynet/copynet.py": {
        "findExtraVocab": {
            "name": "findExtraVocab",
            "location": 38,
            "return": [
                "list[typing.Union[str,typing.Any]]",
                "set",
                "str",
                "Dict[str, Any]",
                "Dict[str, Dict[str, int]]"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "List[List[Any]]",
                    "bytes",
                    "Dict[AbstractSet[str], Set[Any]]",
                    "List[Dict[str, Any]]",
                    "bool"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/copynet/copynet_seq2seq.py": {
        "CopyNetSeq2Seq.__init__": {
            "name": "__init__",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "bool",
                    "float"
                ],
                "source_embedder": [
                    "int",
                    "Callable[[T], List[T]]",
                    "tuple",
                    "str",
                    "Tuple[int, int]"
                ],
                "encoder": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "pynn.nn.NeuralNetwork",
                    "Set[str]",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]"
                ],
                "attention": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "pynn.nn.NeuralNetwork",
                    "Set[str]",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]"
                ],
                "beam_size": [
                    "int",
                    "float"
                ],
                "max_decoding_steps": [
                    "int",
                    "float"
                ],
                "target_embedding_dim": [
                    "int",
                    "float",
                    "model.Model",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ],
                "copy_token": [
                    "bool",
                    "Iterable[str]"
                ],
                "source_namespace": [
                    "int",
                    "Callable[[T], List[T]]",
                    "tuple",
                    "str",
                    "Tuple[int, int]"
                ],
                "target_namespace": [
                    "int",
                    "float",
                    "bool"
                ],
                "tensor_based_metric": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Sequence[int]",
                    "float"
                ],
                "token_based_metric": [
                    "str",
                    "int"
                ]
            }
        },
        "CopyNetSeq2Seq.forward": {
            "name": "forward",
            "location": 147,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "str",
                    "Optional[str]",
                    "List[Dict[str, Any]]",
                    "bytes",
                    "List[str]"
                ],
                "source_token_ids": [
                    "bytes",
                    "torch.Tensor",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame, None]",
                    "data.Channel"
                ],
                "source_to_target": [
                    "torch.Tensor",
                    "int",
                    "Dict[str, str]",
                    "Callable",
                    "Iterable[int]",
                    "Union[numpy.ndarray, pandas.DataFrame, None]"
                ],
                "metadata": [
                    "dict",
                    "Optional[str]",
                    "bool"
                ],
                "target_tokens": [
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]",
                    "django.db.models.Model",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "Optional[gdpr.models.LegalReason]"
                ],
                "target_token_ids": [
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]",
                    "django.db.models.Model",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "Optional[gdpr.models.LegalReason]"
                ]
            }
        },
        "CopyNetSeq2Seq._gather_extended_gold_tokens": {
            "name": "_gather_extended_gold_tokens",
            "location": 221,
            "return": [
                "str",
                "Tuple[int, int]",
                "models.User",
                "int"
            ],
            "arguments": {
                "self": [],
                "target_tokens": [
                    "bytes",
                    "TextIO",
                    "str"
                ],
                "source_token_ids": [
                    "str",
                    "int",
                    "bytes",
                    "Optional[str]",
                    "bool"
                ],
                "target_token_ids": [
                    "int",
                    "str",
                    "Optional[str]",
                    "Callable"
                ]
            }
        },
        "CopyNetSeq2Seq._init_decoder_state": {
            "name": "_init_decoder_state",
            "location": 272,
            "return": [
                "bool",
                "str",
                "Callable",
                "app.models.Tweet"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "CopyNetSeq2Seq._encode": {
            "name": "_encode",
            "location": 292,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "zam_repondeur.services.fetch.an.dossiers.models.DossierRef",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ]
            }
        },
        "CopyNetSeq2Seq._decoder_step": {
            "name": "_decoder_step",
            "location": 304,
            "return": [
                "Callable",
                "List[str]",
                "dict",
                "ajapaik.ajapaik.models.Album",
                "int",
                "allennlp.common.util.JsonDict"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "int",
                    "List[bool]",
                    "str",
                    "torch.Tensor",
                    "Dict[str, int]",
                    "bool"
                ],
                "selective_weights": [
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "state": [
                    "int",
                    "Optional[torch.Tensor]",
                    "Dict[str, torch.Tensor]",
                    "torch.Tensor",
                    "Optional[bytes]"
                ]
            }
        },
        "CopyNetSeq2Seq._get_generation_scores": {
            "name": "_get_generation_scores",
            "location": 329,
            "return": [
                "str",
                "Optional[str]",
                "torch.Tensor",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "CopyNetSeq2Seq._get_copy_scores": {
            "name": "_get_copy_scores",
            "location": 332,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "str",
                    "dict",
                    "Iterable[str]",
                    "int",
                    "Tuple[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "CopyNetSeq2Seq._get_ll_contrib": {
            "name": "_get_ll_contrib",
            "location": 343,
            "return": [
                "str",
                "Tuple[str]",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "generation_scores": [
                    "int",
                    "torch.Tensor",
                    "List[float]",
                    "List[str]",
                    "bool"
                ],
                "generation_scores_mask": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "copy_scores": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "target_tokens": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "bool",
                    "torch.Tensor"
                ],
                "target_to_source": [
                    "int",
                    "bytes",
                    "bool"
                ],
                "copy_mask": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ]
            }
        },
        "CopyNetSeq2Seq._forward_loss": {
            "name": "_forward_loss",
            "location": 417,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "target_tokens": [
                    "Dict[str, torch.LongTensor]",
                    "int",
                    "bytes",
                    "List[float]",
                    "List[bytes]"
                ],
                "target_token_ids": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "state": [
                    "int"
                ]
            }
        },
        "CopyNetSeq2Seq._forward_beam_search": {
            "name": "_forward_beam_search",
            "location": 506,
            "return": [
                "Dict[str, Any]",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "Type[numpy.number]",
                    "torch.Tensor",
                    "Tuple[int]"
                ]
            }
        },
        "CopyNetSeq2Seq._get_input_and_selective_weights": {
            "name": "_get_input_and_selective_weights",
            "location": 523,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "allennlp.nn.decoding.decoder_step.DecoderStep",
                    "int",
                    "dict",
                    "bool",
                    "Optional[int]"
                ],
                "state": [
                    "float",
                    "Type[numpy.number]",
                    "numpy.ndarray",
                    "Tuple[int]",
                    "Dict[str, Any]"
                ]
            }
        },
        "CopyNetSeq2Seq._gather_final_log_probs": {
            "name": "_gather_final_log_probs",
            "location": 604,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "generation_log_probs": [
                    "torch.Tensor",
                    "bytes"
                ],
                "copy_log_probs": [
                    "int",
                    "str",
                    "dict",
                    "List[bytes]",
                    "Set[int]"
                ],
                "state": [
                    "int",
                    "List[List[allennlp.data.fields.production_rule_field.ProductionRuleArray]]",
                    "bool"
                ]
            }
        },
        "CopyNetSeq2Seq.take_search_step": {
            "name": "take_search_step",
            "location": 683,
            "return": [
                "Dict[str, Any]",
                "Callable",
                "story.models.Character",
                "dict",
                "int",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "Dict[str, float]",
                    "str",
                    "List[List[Any]]",
                    "List[List[str]]",
                    "Optional[dict]"
                ],
                "state": [
                    "str",
                    "Dict[str, torch.Tensor]",
                    "Dict[\"core.Edge\", \"state.State\"]",
                    "dict",
                    "Optional[torch.Tensor]",
                    "torch.Tensor"
                ]
            }
        },
        "CopyNetSeq2Seq._get_predicted_tokens": {
            "name": "_get_predicted_tokens",
            "location": 774,
            "return": [
                "int",
                "limbic.emotion.models.LexiconLimbicModel",
                "zerver.models.Recipient",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "predicted_indices": [
                    "int",
                    "float",
                    "Optional[str]",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "str",
                    "Optional[numpy.ndarray]"
                ],
                "batch_metadata": [
                    "list",
                    "int",
                    "Tuple[float, float]",
                    "bool"
                ],
                "n_best": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "CopyNetSeq2Seq.decode": {
            "name": "decode",
            "location": 809,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "src.models.todoist_task.TodoistTask"
                ]
            }
        },
        "CopyNetSeq2Seq.get_metrics": {
            "name": "get_metrics",
            "location": 823,
            "return": [
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "Optional[str]",
                    "dict",
                    "bytes",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/copynet/copynet_seq2seq_dataset_reader.py": {
        "CopyNetDatasetReader.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "target_namespace": [
                    "bool",
                    "None",
                    "tuple[typing.Union[int,...]]",
                    "int",
                    "autorecurse.gnumake.data.Makefile",
                    "Optional[int]",
                    "Optional[Tuple[int, ...]]"
                ],
                "source_tokenizer": [
                    "int",
                    "None",
                    "Callable",
                    "typing.Callable[, ]",
                    "Optional[int]",
                    "bool"
                ],
                "target_tokenizer": [
                    "str",
                    "None",
                    "Mapping[str, Any]",
                    "typing.Mapping"
                ],
                "source_token_indexers": [
                    "Optional[Exception]",
                    "None",
                    "dict",
                    "Exception",
                    "str",
                    "bytes",
                    "Dict[str, str]",
                    "int",
                    "dict[, ]",
                    "dict[str, str]"
                ],
                "lazy": [
                    "bool",
                    "str",
                    "int",
                    "Set[str]"
                ]
            }
        },
        "CopyNetDatasetReader._read": {
            "name": "_read",
            "location": 109,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "CopyNetDatasetReader._tokens_to_ids": {
            "name": "_tokens_to_ids",
            "location": 125,
            "return": [
                "list[int]",
                "str",
                "int",
                "Set[str]",
                "Dict[str, Any]",
                "list"
            ],
            "arguments": {
                "tokens": [
                    "list[allennlp.data.tokenizers.Token]",
                    "list[int]",
                    "List[allennlp.data.tokenizers.Token]",
                    "str",
                    "allennlp.data.vocabulary.Vocabulary",
                    "List[int]",
                    "bool",
                    "allennlp.data.tokenizers.token.Token",
                    "List[allennlp.data.tokenizers.token.Token]"
                ]
            }
        },
        "CopyNetDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 133,
            "return": [
                "Instance",
                "Dict[str, Union[int, str]]",
                "Dict[str, str]",
                "str",
                "Set[str]",
                "frozenset[Any]",
                "List[str]",
                "Final"
            ],
            "arguments": {
                "self": [],
                "source_string": [
                    "str",
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]"
                ],
                "target_string": [
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/copynet/namespace_swapping_field.py": {
        "NamespaceSwappingField.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "bool"
                ],
                "target_namespace": [
                    "dict",
                    "dict[, ]",
                    "Callable[[], None]",
                    "typing.Callable[[], None]",
                    "Optional[Dict]",
                    "None"
                ]
            }
        },
        "NamespaceSwappingField.index": {
            "name": "index",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int"
                ]
            }
        },
        "NamespaceSwappingField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 39,
            "return": [
                "dict[typing.Text, int]",
                "str",
                "int",
                "Hashable",
                "bytes",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NamespaceSwappingField.as_tensor": {
            "name": "as_tensor",
            "location": 43,
            "return": [
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "NamespaceSwappingField.empty_field": {
            "name": "empty_field",
            "location": 50,
            "return": [
                "NamespaceSwappingField",
                "str",
                "type"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "OBQA-master/seq2seq/copynet/mergeGenFact2/mergeFact2ToData.py": {
        "mergeData": {
            "name": "mergeData",
            "location": 5,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "fact2File": [
                    "str",
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "srcFile": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 61,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/dataPreperation/Fact2_Only_F1_H_exact_tokens.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 6,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/dataPreperation/Fact2_Only_F1_H_similar_tokens.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 6,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str"
                ],
                "nlp": [
                    "int",
                    "typing.Iterator",
                    "Iterator[int]",
                    "tuple[int]",
                    "bool",
                    "Tuple[int]"
                ],
                "statsOut": [
                    "str",
                    "Optional[List[Any]]",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 105,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/dataPreperation/Original_Fact2.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 6,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/dataPreperation/Original_Fact2_allCols.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 6,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/dataPreperation/Original_Fact2_All_Hypo.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 5,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/dataPreperation/Original_Fact2_Aug.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 7,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 71,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/IRFact2/fact2Validity.py": {},
    "OBQA-master/seq2seq/IRFact2/IR_for_copynet.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 10,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ],
                "order": [
                    "int",
                    "IO[str]",
                    "list"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/IRFact2/IR_for_copynet_merged.py": {
        "dataPreparation": {
            "name": "dataPreparation",
            "location": 5,
            "return": [
                "str",
                "int",
                "List[str]"
            ],
            "arguments": {
                "file": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/newOBQA/copynet_obqa.py": {
        "CopyNetSeq2Seq.__init__": {
            "name": "__init__",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "bool",
                    "float"
                ],
                "source_embedder": [
                    "int",
                    "Callable[[T], List[T]]",
                    "tuple",
                    "str",
                    "Tuple[int, int]"
                ],
                "encoder": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "pynn.nn.NeuralNetwork",
                    "Set[str]",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]"
                ],
                "attention": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "pynn.nn.NeuralNetwork",
                    "Set[str]",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]"
                ],
                "beam_size": [
                    "int",
                    "float"
                ],
                "max_decoding_steps": [
                    "int",
                    "float"
                ],
                "target_embedding_dim": [
                    "int",
                    "float",
                    "model.Model",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ],
                "copy_token": [
                    "bool",
                    "Iterable[str]"
                ],
                "source_namespace": [
                    "int",
                    "Callable[[T], List[T]]",
                    "tuple",
                    "str",
                    "Tuple[int, int]"
                ],
                "target_namespace": [
                    "int",
                    "float",
                    "bool"
                ],
                "tensor_based_metric": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Sequence[int]",
                    "float"
                ],
                "token_based_metric": [
                    "str",
                    "int"
                ]
            }
        },
        "CopyNetSeq2Seq.forward": {
            "name": "forward",
            "location": 147,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "str",
                    "Optional[str]",
                    "List[Dict[str, Any]]",
                    "bytes",
                    "List[str]"
                ],
                "source_token_ids": [
                    "bytes",
                    "torch.Tensor",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame, None]",
                    "data.Channel"
                ],
                "source_to_target": [
                    "torch.Tensor",
                    "int",
                    "Dict[str, str]",
                    "Callable",
                    "Iterable[int]",
                    "Union[numpy.ndarray, pandas.DataFrame, None]"
                ],
                "metadata": [
                    "dict",
                    "Optional[str]",
                    "bool"
                ],
                "target_tokens": [
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]",
                    "django.db.models.Model",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "Optional[gdpr.models.LegalReason]"
                ],
                "target_token_ids": [
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]",
                    "django.db.models.Model",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "Optional[gdpr.models.LegalReason]"
                ]
            }
        },
        "CopyNetSeq2Seq._gather_extended_gold_tokens": {
            "name": "_gather_extended_gold_tokens",
            "location": 221,
            "return": [
                "str",
                "Tuple[int, int]",
                "models.User",
                "int"
            ],
            "arguments": {
                "self": [],
                "target_tokens": [
                    "bytes",
                    "TextIO",
                    "str"
                ],
                "source_token_ids": [
                    "str",
                    "int",
                    "bytes",
                    "Optional[str]",
                    "bool"
                ],
                "target_token_ids": [
                    "int",
                    "str",
                    "Optional[str]",
                    "Callable"
                ]
            }
        },
        "CopyNetSeq2Seq._init_decoder_state": {
            "name": "_init_decoder_state",
            "location": 272,
            "return": [
                "bool",
                "str",
                "Callable",
                "app.models.Tweet"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "CopyNetSeq2Seq._encode": {
            "name": "_encode",
            "location": 292,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "zam_repondeur.services.fetch.an.dossiers.models.DossierRef",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ]
            }
        },
        "CopyNetSeq2Seq._decoder_step": {
            "name": "_decoder_step",
            "location": 304,
            "return": [
                "Callable",
                "List[str]",
                "dict",
                "ajapaik.ajapaik.models.Album",
                "int",
                "allennlp.common.util.JsonDict"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "int",
                    "List[bool]",
                    "str",
                    "torch.Tensor",
                    "Dict[str, int]",
                    "bool"
                ],
                "selective_weights": [
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "state": [
                    "int",
                    "Optional[torch.Tensor]",
                    "Dict[str, torch.Tensor]",
                    "torch.Tensor",
                    "Optional[bytes]"
                ]
            }
        },
        "CopyNetSeq2Seq._get_generation_scores": {
            "name": "_get_generation_scores",
            "location": 329,
            "return": [
                "str",
                "Optional[str]",
                "torch.Tensor",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "CopyNetSeq2Seq._get_copy_scores": {
            "name": "_get_copy_scores",
            "location": 332,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "str",
                    "dict",
                    "Iterable[str]",
                    "int",
                    "Tuple[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "CopyNetSeq2Seq._get_ll_contrib": {
            "name": "_get_ll_contrib",
            "location": 343,
            "return": [
                "str",
                "Tuple[str]",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "generation_scores": [
                    "int",
                    "torch.Tensor",
                    "List[float]",
                    "List[str]",
                    "bool"
                ],
                "generation_scores_mask": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "copy_scores": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "target_tokens": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "target_to_source": [
                    "int",
                    "bytes",
                    "bool"
                ],
                "copy_mask": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ]
            }
        },
        "CopyNetSeq2Seq._forward_loss": {
            "name": "_forward_loss",
            "location": 414,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "target_tokens": [
                    "Dict[str, torch.LongTensor]",
                    "int",
                    "bytes",
                    "List[float]",
                    "List[bytes]"
                ],
                "target_token_ids": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "state": [
                    "int"
                ]
            }
        },
        "CopyNetSeq2Seq._forward_beam_search": {
            "name": "_forward_beam_search",
            "location": 503,
            "return": [
                "Dict[str, Any]",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "Type[numpy.number]",
                    "torch.Tensor",
                    "Tuple[int]"
                ]
            }
        },
        "CopyNetSeq2Seq._get_input_and_selective_weights": {
            "name": "_get_input_and_selective_weights",
            "location": 520,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "allennlp.nn.decoding.decoder_step.DecoderStep",
                    "int",
                    "dict",
                    "bool",
                    "Optional[int]"
                ],
                "state": [
                    "float",
                    "Type[numpy.number]",
                    "numpy.ndarray",
                    "Tuple[int]",
                    "Dict[str, Any]"
                ]
            }
        },
        "CopyNetSeq2Seq._gather_final_log_probs": {
            "name": "_gather_final_log_probs",
            "location": 601,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "generation_log_probs": [
                    "torch.Tensor",
                    "bytes"
                ],
                "copy_log_probs": [
                    "int",
                    "str",
                    "dict",
                    "List[bytes]",
                    "Set[int]"
                ],
                "state": [
                    "int",
                    "List[List[allennlp.data.fields.production_rule_field.ProductionRuleArray]]",
                    "bool"
                ]
            }
        },
        "CopyNetSeq2Seq.take_search_step": {
            "name": "take_search_step",
            "location": 680,
            "return": [
                "Dict[str, Any]",
                "Callable",
                "story.models.Character",
                "dict",
                "int",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "Dict[str, float]",
                    "str",
                    "List[List[Any]]",
                    "List[List[str]]",
                    "Optional[dict]"
                ],
                "state": [
                    "str",
                    "Dict[str, torch.Tensor]",
                    "Dict[\"core.Edge\", \"state.State\"]",
                    "dict",
                    "Optional[torch.Tensor]",
                    "torch.Tensor"
                ]
            }
        },
        "CopyNetSeq2Seq._get_predicted_tokens": {
            "name": "_get_predicted_tokens",
            "location": 771,
            "return": [
                "int",
                "limbic.emotion.models.LexiconLimbicModel",
                "zerver.models.Recipient",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "predicted_indices": [
                    "int",
                    "float",
                    "Optional[str]",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "str",
                    "Optional[numpy.ndarray]"
                ],
                "batch_metadata": [
                    "list",
                    "int",
                    "Tuple[float, float]",
                    "bool"
                ],
                "n_best": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "CopyNetSeq2Seq.decode": {
            "name": "decode",
            "location": 806,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "src.models.todoist_task.TodoistTask"
                ]
            }
        },
        "CopyNetSeq2Seq.get_metrics": {
            "name": "get_metrics",
            "location": 820,
            "return": [
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "Optional[str]",
                    "dict",
                    "bytes",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/fact2MergeIRData.py": {
        "main": {
            "name": "main",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "srcPredFile": [
                    "str"
                ],
                "srcIRFile": [
                    "str"
                ],
                "order": [
                    "str",
                    "bool",
                    "Sequence[str]",
                    "typing.Sequence[str]"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/MergeFact2IRData.py": {
        "main": {
            "name": "main",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "srcPredFile": [
                    "str"
                ],
                "srcIRFile": [
                    "str"
                ],
                "order": [
                    "str",
                    "int",
                    "list[str]",
                    "List[str]",
                    "bool"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/run.py": {},
    "OBQA-master/seq2seq/newOBQA/dataset_readers/obqa.py": {
        "ObqaDatasetReader.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool",
                    "int"
                ],
                "tokenizer": [
                    "List[Tuple[int, int]]",
                    "None",
                    "Tuple[int, int]",
                    "str",
                    "list[tuple[typing.Union[int,int]]]",
                    "List[int]",
                    "tuple[typing.Union[int,int]]",
                    "list[int]",
                    "Optional[List[str]]",
                    "list[str]"
                ],
                "token_indexers": [
                    "int",
                    "None",
                    "bool"
                ]
            }
        },
        "ObqaDatasetReader._read": {
            "name": "_read",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "ObqaDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 91,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "hypo_fact1": [
                    "List[str]",
                    "int",
                    "list[str]",
                    "float",
                    "Type[Dict[str, dict]]",
                    "typing.Type"
                ],
                "fact2": [
                    "List[str]",
                    "None",
                    "int",
                    "float",
                    "list[str]",
                    "Type[Dict[str, dict]]",
                    "typing.Type"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/dataset_readers/obqa_read.py": {
        "ObqaDatasetReader.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool",
                    "int"
                ],
                "tokenizer": [
                    "List[Tuple[int, int]]",
                    "None",
                    "Tuple[int, int]",
                    "str",
                    "list[tuple[typing.Union[int,int]]]",
                    "List[int]",
                    "tuple[typing.Union[int,int]]",
                    "list[int]",
                    "Optional[List[str]]",
                    "list[str]"
                ],
                "token_indexers": [
                    "int",
                    "None",
                    "bool"
                ]
            }
        },
        "ObqaDatasetReader._read": {
            "name": "_read",
            "location": 32,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "ObqaDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 91,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "hypo_fact1": [
                    "List[str]",
                    "int",
                    "list[str]",
                    "float",
                    "Type[Dict[str, dict]]",
                    "typing.Type"
                ],
                "fact2": [
                    "List[str]",
                    "None",
                    "int",
                    "float",
                    "list[str]",
                    "Type[Dict[str, dict]]",
                    "typing.Type"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/dataset_readers/obqa_reader.py": {
        "ObqaCopyNetDatasetReader.__init__": {
            "name": "__init__",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "target_namespace": [
                    "bool",
                    "None",
                    "tuple[typing.Union[int,...]]",
                    "int",
                    "autorecurse.gnumake.data.Makefile",
                    "Optional[int]",
                    "Optional[Tuple[int, ...]]"
                ],
                "source_tokenizer": [
                    "int",
                    "None",
                    "Callable",
                    "typing.Callable[, ]",
                    "Optional[int]",
                    "bool"
                ],
                "target_tokenizer": [
                    "str",
                    "None",
                    "Mapping[str, Any]",
                    "typing.Mapping"
                ],
                "source_token_indexers": [
                    "Optional[Exception]",
                    "None",
                    "dict",
                    "Exception",
                    "str",
                    "bytes",
                    "Dict[str, str]",
                    "int",
                    "dict[, ]",
                    "dict[str, str]"
                ],
                "lazy": [
                    "bool",
                    "str",
                    "int",
                    "Set[str]"
                ]
            }
        },
        "ObqaCopyNetDatasetReader._read": {
            "name": "_read",
            "location": 121,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "ObqaCopyNetDatasetReader._tokens_to_ids": {
            "name": "_tokens_to_ids",
            "location": 137,
            "return": [
                "list[int]",
                "str",
                "int",
                "Set[str]",
                "Dict[str, Any]",
                "list"
            ],
            "arguments": {
                "tokens": [
                    "list[allennlp.data.tokenizers.Token]",
                    "list[int]",
                    "List[allennlp.data.tokenizers.Token]",
                    "str",
                    "allennlp.data.vocabulary.Vocabulary",
                    "List[int]",
                    "bool",
                    "allennlp.data.tokenizers.token.Token",
                    "List[allennlp.data.tokenizers.token.Token]"
                ]
            }
        },
        "ObqaCopyNetDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 145,
            "return": [
                "Instance",
                "Dict[str, Union[int, str]]",
                "Dict[str, str]",
                "str",
                "Set[str]",
                "frozenset[Any]",
                "List[str]",
                "Final"
            ],
            "arguments": {
                "self": [],
                "src_id": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "source_string": [
                    "str",
                    "Dict[int, int]",
                    "dict[int, int]"
                ],
                "target_string": [
                    "str",
                    "None",
                    "Optional[str]",
                    "list[S]",
                    "Optional[List[\"SoftwareApplication\"]]",
                    "int",
                    "Optional[int]",
                    "Optional[\"CustomerResourceIdentifier\"]"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/dataset_readers/__init__.py": {},
    "OBQA-master/seq2seq/newOBQA/metrics/overlap_metric.py": {
        "OverlapMetric.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OverlapMetric.__call__": {
            "name": "__call__",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "pred": [
                    "Callable",
                    "int",
                    "typing.Callable[, ]",
                    "float"
                ],
                "gold": [
                    "Callable",
                    "int",
                    "typing.Callable[, ]",
                    "float"
                ]
            }
        },
        "OverlapMetric.get_metric": {
            "name": "get_metric",
            "location": 44,
            "return": [
                "dict[typing.Text, int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "OverlapMetric.reset": {
            "name": "reset",
            "location": 52,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OverlapMetric.__str__": {
            "name": "__str__",
            "location": 57,
            "return": [
                "typing.Text",
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/metrics/__init__.py": {},
    "OBQA-master/seq2seq/newOBQA/models/copynet_obqa.py": {
        "OBQACopyNetSeq2Seq.__init__": {
            "name": "__init__",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "bool",
                    "float"
                ],
                "source_embedder": [
                    "int",
                    "Callable[[T], List[T]]",
                    "tuple",
                    "str",
                    "Tuple[int, int]"
                ],
                "encoder": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "pynn.nn.NeuralNetwork",
                    "Set[str]",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]"
                ],
                "attention": [
                    "bool",
                    "float",
                    "Optional[int]",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "pynn.nn.NeuralNetwork",
                    "Set[str]",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]"
                ],
                "beam_size": [
                    "int",
                    "float"
                ],
                "max_decoding_steps": [
                    "int",
                    "float"
                ],
                "target_embedding_dim": [
                    "int",
                    "float",
                    "model.Model",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ],
                "copy_token": [
                    "bool",
                    "Iterable[str]"
                ],
                "source_namespace": [
                    "int",
                    "Callable[[T], List[T]]",
                    "tuple",
                    "str",
                    "Tuple[int, int]"
                ],
                "target_namespace": [
                    "int",
                    "float",
                    "bool"
                ],
                "overlap_based_metric": [
                    "str",
                    "int"
                ],
                "tensor_based_metric": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Sequence[int]",
                    "float"
                ],
                "token_based_metric": [
                    "str",
                    "int"
                ]
            }
        },
        "OBQACopyNetSeq2Seq.forward": {
            "name": "forward",
            "location": 149,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "str",
                    "Optional[str]",
                    "List[Dict[str, Any]]",
                    "bytes",
                    "List[str]"
                ],
                "source_token_ids": [
                    "bytes",
                    "torch.Tensor",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame, None]",
                    "data.Channel"
                ],
                "source_to_target": [
                    "torch.Tensor",
                    "int",
                    "Dict[str, str]",
                    "Callable",
                    "Iterable[int]",
                    "Union[numpy.ndarray, pandas.DataFrame, None]"
                ],
                "metadata": [
                    "dict",
                    "Optional[str]",
                    "bool"
                ],
                "target_tokens": [
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]",
                    "django.db.models.Model",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "Optional[gdpr.models.LegalReason]"
                ],
                "target_token_ids": [
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]",
                    "django.db.models.Model",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "Optional[gdpr.models.LegalReason]"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._gather_extended_gold_tokens": {
            "name": "_gather_extended_gold_tokens",
            "location": 229,
            "return": [
                "str",
                "Tuple[int, int]",
                "models.User",
                "int"
            ],
            "arguments": {
                "self": [],
                "target_tokens": [
                    "bytes",
                    "TextIO",
                    "str"
                ],
                "source_token_ids": [
                    "str",
                    "int",
                    "bytes",
                    "Optional[str]",
                    "bool"
                ],
                "target_token_ids": [
                    "int",
                    "str",
                    "Optional[str]",
                    "Callable"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._init_decoder_state": {
            "name": "_init_decoder_state",
            "location": 280,
            "return": [
                "bool",
                "str",
                "Callable",
                "app.models.Tweet"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._encode": {
            "name": "_encode",
            "location": 300,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "zam_repondeur.services.fetch.an.dossiers.models.DossierRef",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._decoder_step": {
            "name": "_decoder_step",
            "location": 312,
            "return": [
                "Callable",
                "List[str]",
                "dict",
                "ajapaik.ajapaik.models.Album",
                "int",
                "allennlp.common.util.JsonDict"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "int",
                    "List[bool]",
                    "str",
                    "torch.Tensor",
                    "Dict[str, int]",
                    "bool"
                ],
                "selective_weights": [
                    "numpy.ndarray",
                    "str",
                    "List[str]"
                ],
                "state": [
                    "int",
                    "Optional[torch.Tensor]",
                    "Dict[str, torch.Tensor]",
                    "torch.Tensor",
                    "Optional[bytes]"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._get_generation_scores": {
            "name": "_get_generation_scores",
            "location": 337,
            "return": [
                "str",
                "Optional[str]",
                "torch.Tensor",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._get_copy_scores": {
            "name": "_get_copy_scores",
            "location": 340,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "str",
                    "dict",
                    "Iterable[str]",
                    "int",
                    "Tuple[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._get_ll_contrib": {
            "name": "_get_ll_contrib",
            "location": 351,
            "return": [
                "str",
                "Tuple[str]",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "generation_scores": [
                    "int",
                    "torch.Tensor",
                    "List[float]",
                    "List[str]",
                    "bool"
                ],
                "generation_scores_mask": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "copy_scores": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "target_tokens": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "target_to_source": [
                    "int",
                    "bytes",
                    "bool"
                ],
                "copy_mask": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "Optional[dict]",
                    "Optional[List[Any]]",
                    "Callable"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._forward_loss": {
            "name": "_forward_loss",
            "location": 422,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "target_tokens": [
                    "Dict[str, torch.LongTensor]",
                    "int",
                    "bytes",
                    "List[float]",
                    "List[bytes]"
                ],
                "target_token_ids": [
                    "torch.Tensor",
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "state": [
                    "int"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._forward_beam_search": {
            "name": "_forward_beam_search",
            "location": 511,
            "return": [
                "Dict[str, Any]",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "Type[numpy.number]",
                    "torch.Tensor",
                    "Tuple[int]"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._get_input_and_selective_weights": {
            "name": "_get_input_and_selective_weights",
            "location": 528,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "allennlp.nn.decoding.decoder_step.DecoderStep",
                    "int",
                    "dict",
                    "bool",
                    "Optional[int]"
                ],
                "state": [
                    "float",
                    "Type[numpy.number]",
                    "numpy.ndarray",
                    "Tuple[int]",
                    "Dict[str, Any]"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._gather_final_log_probs": {
            "name": "_gather_final_log_probs",
            "location": 609,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "generation_log_probs": [
                    "torch.Tensor",
                    "bytes"
                ],
                "copy_log_probs": [
                    "int",
                    "str",
                    "dict",
                    "List[bytes]",
                    "Set[int]"
                ],
                "state": [
                    "int",
                    "List[List[allennlp.data.fields.production_rule_field.ProductionRuleArray]]",
                    "bool"
                ]
            }
        },
        "OBQACopyNetSeq2Seq.take_search_step": {
            "name": "take_search_step",
            "location": 688,
            "return": [
                "Dict[str, Any]",
                "Callable",
                "story.models.Character",
                "dict",
                "int",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "Dict[str, float]",
                    "str",
                    "List[List[Any]]",
                    "List[List[str]]",
                    "Optional[dict]"
                ],
                "state": [
                    "str",
                    "Dict[str, torch.Tensor]",
                    "Dict[\"core.Edge\", \"state.State\"]",
                    "dict",
                    "Optional[torch.Tensor]",
                    "torch.Tensor"
                ]
            }
        },
        "OBQACopyNetSeq2Seq._get_predicted_tokens": {
            "name": "_get_predicted_tokens",
            "location": 779,
            "return": [
                "int",
                "limbic.emotion.models.LexiconLimbicModel",
                "zerver.models.Recipient",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "predicted_indices": [
                    "int",
                    "float",
                    "Optional[str]",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "str",
                    "Optional[numpy.ndarray]"
                ],
                "batch_metadata": [
                    "list",
                    "int",
                    "Tuple[float, float]",
                    "bool"
                ],
                "n_best": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "OBQACopyNetSeq2Seq.decode": {
            "name": "decode",
            "location": 816,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "src.models.todoist_task.TodoistTask"
                ]
            }
        },
        "OBQACopyNetSeq2Seq.get_metrics": {
            "name": "get_metrics",
            "location": 830,
            "return": [
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "dict",
                    "Optional[str]",
                    "bytes",
                    "Mapping[str, Any]"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/newOBQA/models/__init__.py": {},
    "OBQA-master/seq2seq/Seq2Seq/obqa_seq2seq.py": {
        "SimpleSeq2Seq.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "dict",
                    "bool",
                    "numpy.ndarray",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "source_embedder": [
                    "Callable",
                    "allennlp.data.tokenizers.Token.izer",
                    "int"
                ],
                "encoder": [
                    "bool",
                    "int",
                    "float"
                ],
                "max_decoding_steps": [
                    "int",
                    "float"
                ],
                "attention": [
                    "bool",
                    "int",
                    "float"
                ],
                "attention_function": [
                    "bool",
                    "int",
                    "float"
                ],
                "beam_size": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray",
                    "bool",
                    "Union[int, float]",
                    "Optional[int]"
                ],
                "target_namespace": [
                    "int",
                    "Optional[float]",
                    "tuple",
                    "List[str]"
                ],
                "target_embedding_dim": [
                    "bool",
                    "str",
                    "int"
                ],
                "scheduled_sampling_ratio": [
                    "bool",
                    "int",
                    "float"
                ],
                "use_bleu": [
                    "bool",
                    "int"
                ],
                "extra_vocab": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "SimpleSeq2Seq.take_step": {
            "name": "take_step",
            "location": 152,
            "return": [
                "\"Vector\"",
                "data.Race",
                "Optional[BaseException]",
                "bytes",
                "List[zerver.models.DefaultStreamGroup]"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "str",
                    "bytes",
                    "Callable"
                ],
                "state": [
                    "dict",
                    "torch.Tensor",
                    "List[bytes]",
                    "Union[str, Sequence[str]]",
                    "str"
                ]
            }
        },
        "SimpleSeq2Seq.createRestrictedVocabMask": {
            "name": "createRestrictedVocabMask",
            "location": 220,
            "return": [
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "Optional[str]",
                    "list",
                    "int",
                    "float",
                    "str",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "tuple"
                ],
                "target_tokens": [
                    "Dict[str, torch.LongTensor]",
                    "bool",
                    "List[str]",
                    "str"
                ]
            }
        },
        "SimpleSeq2Seq.toStringFromIdx": {
            "name": "toStringFromIdx",
            "location": 264,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "a": [
                    "List[str]",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq.findVocabTensorTokens": {
            "name": "findVocabTensorTokens",
            "location": 270,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocabTensorInput": [
                    "bool",
                    "List[str]",
                    "int",
                    "float"
                ]
            }
        },
        "SimpleSeq2Seq.forward": {
            "name": "forward",
            "location": 278,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "str",
                    "bytes",
                    "Optional[str]",
                    "List[allennlp.data.tokenizers.token.Token]",
                    "IO"
                ],
                "target_tokens": [
                    "bool",
                    "str",
                    "dict",
                    "Dict[str, Dict[str, str]]",
                    "numpy.ndarray",
                    "OrderedDict"
                ]
            }
        },
        "SimpleSeq2Seq.decode": {
            "name": "decode",
            "location": 358,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "Callable[..., None]",
                    "magic.models.Deck",
                    "Exception"
                ]
            }
        },
        "SimpleSeq2Seq._encode": {
            "name": "_encode",
            "location": 393,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "zam_repondeur.services.fetch.an.dossiers.models.DossierRef",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq._init_decoder_state": {
            "name": "_init_decoder_state",
            "location": 407,
            "return": [
                "bool",
                "str",
                "Callable",
                "app.models.Tweet"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "SimpleSeq2Seq._forward_loop": {
            "name": "_forward_loop",
            "location": 423,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "numpy.ndarray",
                    "Sequence[Sequence[str]]",
                    "Sequence[Tuple[str, int]]",
                    "List[List[int]]",
                    "torch.Tensor",
                    "List[str]",
                    "List[int]",
                    "bytes"
                ],
                "target_tokens": []
            }
        },
        "SimpleSeq2Seq._forward_beam_search": {
            "name": "_forward_beam_search",
            "location": 541,
            "return": [
                "str",
                "Dict[str, Any]",
                "Callable",
                "int",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "int",
                    "Type[numpy.number]",
                    "Sequence[Sequence[str]]"
                ]
            }
        },
        "SimpleSeq2Seq._prepare_output_projections": {
            "name": "_prepare_output_projections",
            "location": 562,
            "return": [
                "torch.Tensor",
                "bytes",
                "numpy.array",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "int",
                    "List[float]",
                    "bool",
                    "torch.Tensor"
                ],
                "state": [
                    "Iterable[core.models.Grouping]",
                    "bool",
                    "Callable"
                ]
            }
        },
        "SimpleSeq2Seq._prepare_attended_input": {
            "name": "_prepare_attended_input",
            "location": 614,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "decoder_hidden_state": [
                    "numpy.ndarray",
                    "int",
                    "bool",
                    "torch.Tensor"
                ],
                "encoder_outputs": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "List[List[int]]"
                ],
                "encoder_outputs_mask": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "SimpleSeq2Seq._get_loss": {
            "name": "_get_loss",
            "location": 634,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "logits": [
                    "str",
                    "bool"
                ],
                "targets": [
                    "str",
                    "Tuple[int, int]",
                    "Callable[[], object]",
                    "models.characters.mods_base.Mod",
                    "int"
                ],
                "target_mask": [
                    "int",
                    "autorecurse.gnumake.data.Makefile",
                    "slice",
                    "str",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq.get_metrics": {
            "name": "get_metrics",
            "location": 671,
            "return": [
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "str",
                    "Dict[str, bool]",
                    "Optional[str]",
                    "dict"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/Seq2Seq/Seq2SeqControl.py": {
        "findExtraVocab": {
            "name": "findExtraVocab",
            "location": 38,
            "return": [
                "list[typing.Union[str,typing.Any]]",
                "set",
                "str",
                "Dict[str, Any]",
                "Dict[str, Dict[str, int]]"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "List[List[Any]]",
                    "bytes",
                    "Dict[AbstractSet[str], Set[Any]]",
                    "List[Dict[str, Any]]",
                    "bool"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "OBQA-master/seq2seq/Seq2Seq_Restricted/obqa_seq2seq.py": {
        "SimpleSeq2Seq.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "dict",
                    "bool",
                    "numpy.ndarray",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "source_embedder": [
                    "Callable",
                    "allennlp.data.tokenizers.Token.izer",
                    "int"
                ],
                "encoder": [
                    "bool",
                    "int",
                    "float"
                ],
                "max_decoding_steps": [
                    "int",
                    "float"
                ],
                "attention": [
                    "bool",
                    "int",
                    "float"
                ],
                "attention_function": [
                    "bool",
                    "int",
                    "float"
                ],
                "beam_size": [
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray",
                    "bool",
                    "Union[int, float]",
                    "Optional[int]"
                ],
                "target_namespace": [
                    "int",
                    "Optional[float]",
                    "tuple",
                    "List[str]"
                ],
                "target_embedding_dim": [
                    "bool",
                    "str",
                    "int"
                ],
                "scheduled_sampling_ratio": [
                    "bool",
                    "int",
                    "float"
                ],
                "use_bleu": [
                    "bool",
                    "int"
                ],
                "extra_vocab": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "SimpleSeq2Seq.take_step": {
            "name": "take_step",
            "location": 152,
            "return": [
                "\"Vector\"",
                "data.Race",
                "Optional[BaseException]",
                "bytes",
                "List[zerver.models.DefaultStreamGroup]"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "str",
                    "bytes",
                    "Callable"
                ],
                "state": [
                    "dict",
                    "torch.Tensor",
                    "int"
                ]
            }
        },
        "SimpleSeq2Seq.createRestrictedVocabMask": {
            "name": "createRestrictedVocabMask",
            "location": 220,
            "return": [
                "str",
                "Iterable[int]",
                "int",
                "IO[str]",
                "Optional[str]",
                "Iterable[numpy.dtype]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "Optional[str]",
                    "list",
                    "int",
                    "float",
                    "str",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "tuple"
                ],
                "target_tokens": [
                    "Dict[str, torch.LongTensor]",
                    "bool",
                    "List[str]",
                    "str"
                ]
            }
        },
        "SimpleSeq2Seq.toStringFromIdx": {
            "name": "toStringFromIdx",
            "location": 263,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "a": [
                    "List[str]",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq.findVocabTensorTokens": {
            "name": "findVocabTensorTokens",
            "location": 269,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "vocabTensorInput": [
                    "bool",
                    "List[str]",
                    "int",
                    "float"
                ]
            }
        },
        "SimpleSeq2Seq.forward": {
            "name": "forward",
            "location": 277,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "int",
                    "str",
                    "bytearray",
                    "bool",
                    "List[int]"
                ],
                "target_tokens": [
                    "Callable[[T], bool]",
                    "str",
                    "bool",
                    "bytes",
                    "Optional[str]",
                    "Optional[dict]"
                ]
            }
        },
        "SimpleSeq2Seq.decode": {
            "name": "decode",
            "location": 357,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "Callable[..., None]",
                    "magic.models.Deck",
                    "Exception"
                ]
            }
        },
        "SimpleSeq2Seq._encode": {
            "name": "_encode",
            "location": 392,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "zam_repondeur.services.fetch.an.dossiers.models.DossierRef",
                    "Dict[str, Any]",
                    "str",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq._init_decoder_state": {
            "name": "_init_decoder_state",
            "location": 406,
            "return": [
                "bool",
                "str",
                "Callable",
                "app.models.Tweet"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str, torch.Tensor]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "SimpleSeq2Seq._forward_loop": {
            "name": "_forward_loop",
            "location": 422,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "numpy.ndarray",
                    "Sequence[Sequence[str]]",
                    "Sequence[Tuple[str, int]]",
                    "List[List[int]]",
                    "torch.Tensor",
                    "List[str]",
                    "List[int]",
                    "bytes"
                ],
                "target_tokens": [],
                "vocabTensor": [
                    "str",
                    "Sequence[str]",
                    "List[int]",
                    "int"
                ]
            }
        },
        "SimpleSeq2Seq._forward_beam_search": {
            "name": "_forward_beam_search",
            "location": 540,
            "return": [
                "str",
                "Dict[str, Any]",
                "Callable",
                "int",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "int",
                    "Type[numpy.number]",
                    "Sequence[Sequence[str]]"
                ]
            }
        },
        "SimpleSeq2Seq._prepare_output_projections": {
            "name": "_prepare_output_projections",
            "location": 561,
            "return": [
                "torch.Tensor",
                "bytes",
                "numpy.array",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "last_predictions": [
                    "int",
                    "List[float]",
                    "bool",
                    "torch.Tensor"
                ],
                "state": [
                    "Iterable[core.models.Grouping]",
                    "bool",
                    "Callable"
                ]
            }
        },
        "SimpleSeq2Seq._prepare_attended_input": {
            "name": "_prepare_attended_input",
            "location": 613,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "decoder_hidden_state": [
                    "numpy.ndarray",
                    "int",
                    "bool",
                    "torch.Tensor"
                ],
                "encoder_outputs": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "List[List[int]]"
                ],
                "encoder_outputs_mask": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "SimpleSeq2Seq._get_loss": {
            "name": "_get_loss",
            "location": 633,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "logits": [
                    "str",
                    "bool"
                ],
                "targets": [
                    "str",
                    "Tuple[int, int]",
                    "Callable[[], object]",
                    "models.characters.mods_base.Mod",
                    "int"
                ],
                "target_mask": [
                    "int",
                    "autorecurse.gnumake.data.Makefile",
                    "slice",
                    "str",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq.get_metrics": {
            "name": "get_metrics",
            "location": 670,
            "return": [
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "str",
                    "Dict[str, bool]",
                    "Optional[str]",
                    "dict"
                ]
            }
        }
    },
    "OBQA-master/seq2seq/Seq2Seq_Restricted/Seq2SeqControl.py": {
        "findExtraVocab": {
            "name": "findExtraVocab",
            "location": 38,
            "return": [
                "list[typing.Union[str,typing.Any]]",
                "set",
                "str",
                "Dict[str, Any]",
                "Dict[str, Dict[str, int]]"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "List[List[Any]]",
                    "bytes",
                    "Dict[AbstractSet[str], Set[Any]]",
                    "List[Dict[str, Any]]",
                    "bool"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    }
}
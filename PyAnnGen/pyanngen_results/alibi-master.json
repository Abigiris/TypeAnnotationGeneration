{
    "alibi-master/setup.py": {
        "readme": {
            "name": "readme",
            "location": 4,
            "return": [
                "str"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/exceptions.py": {
        "AlibiException.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[A,bool]"
                ]
            }
        }
    },
    "alibi-master/alibi/saving.py": {
        "load_explainer": {
            "name": "load_explainer",
            "location": 42,
            "return": [
                "str",
                "pathlib.Path",
                "List[str]"
            ],
            "arguments": {
                "path": [
                    "str",
                    "pathlib.Path",
                    "Union[str, pathlib.Path]"
                ],
                "predictor": [
                    "str",
                    "bool"
                ]
            }
        },
        "save_explainer": {
            "name": "save_explainer",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "str",
                    "pathlib.Path",
                    "int",
                    "Optional[path.Path]",
                    "path.Path"
                ],
                "path": [
                    "pathlib.Path",
                    "Union[str, pathlib.Path]",
                    "Optional[pathlib.Path]",
                    "Union[str, os.PathLike]",
                    "str"
                ]
            }
        },
        "_simple_save": {
            "name": "_simple_save",
            "location": 109,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "List[str]",
                    "pathlib.Path",
                    "Sequence[str]",
                    "Optional[int]"
                ],
                "path": [
                    "pathlib.Path",
                    "str",
                    "Optional[str]",
                    "Sequence[str]",
                    "Union[List, str]",
                    "Union[str, pathlib.Path]"
                ]
            }
        },
        "_simple_load": {
            "name": "_simple_load",
            "location": 117,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "Optional[str]",
                    "Sequence[str]",
                    "str",
                    "Union[str, pathlib.Path]",
                    "os.PathLike",
                    "npipes.utils.typeshed.pathlike",
                    "Union[List, str]"
                ],
                "predictor": [
                    "str",
                    "int",
                    "Optional[List[str]]"
                ],
                "meta": [
                    "str",
                    "bool",
                    "Sequence",
                    "Union[pathlib.Path, str]",
                    "float"
                ]
            }
        },
        "_load_IntegratedGradients": {
            "name": "_load_IntegratedGradients",
            "location": 124,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "Optional[str]",
                    "os.PathLike",
                    "str",
                    "Sequence[str]",
                    "Union[str, pathlib.Path]",
                    "Union[List, str]"
                ],
                "predictor": [
                    "Optional[List[str]]",
                    "str",
                    "Dict[str, Any]",
                    "int",
                    "bool",
                    "Set[str]"
                ],
                "meta": [
                    "Optional[List[str]]",
                    "str",
                    "Dict[str, Any]",
                    "int",
                    "bool",
                    "Set[str]"
                ]
            }
        },
        "_save_IntegratedGradients": {
            "name": "_save_IntegratedGradients",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [],
                "path": [
                    "pathlib.Path",
                    "str",
                    "Sequence[str]",
                    "Optional[str]",
                    "Union[List, str]",
                    "Union[str, pathlib.Path]",
                    "npipes.utils.typeshed.pathlike"
                ]
            }
        },
        "_load_AnchorImage": {
            "name": "_load_AnchorImage",
            "location": 150,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "path": [
                    "str",
                    "npipes.utils.typeshed.pathlike",
                    "Optional[str]",
                    "Union[List, str]",
                    "Union[str, pathlib.Path]"
                ],
                "predictor": [
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "Optional[List[str]]",
                    "bool",
                    "Set[str]"
                ],
                "meta": [
                    "pathlib.Path",
                    "norfs.fs.base.Path",
                    "bool"
                ]
            }
        },
        "_save_AnchorImage": {
            "name": "_save_AnchorImage",
            "location": 164,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "str",
                    "raiden.utils.Secret",
                    "int",
                    "Optional[str]"
                ],
                "path": [
                    "pathlib.Path",
                    "Union[str, pathlib.Path]",
                    "Union[List, str]",
                    "npipes.utils.typeshed.pathlike",
                    "str"
                ]
            }
        },
        "_load_AnchorText": {
            "name": "_load_AnchorText",
            "location": 179,
            "return": [
                "str",
                "bool",
                "Type[T]"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "dict",
                    "str",
                    "Dict[str, pathlib.Path]"
                ],
                "predictor": [
                    "int",
                    "str",
                    "bool",
                    "Dict[str, Any]",
                    "Set[str]"
                ],
                "meta": [
                    "Iterable[str]",
                    "str",
                    "bool",
                    "pathlib.Path",
                    "Iterable[pathlib.Path]"
                ]
            }
        },
        "_save_AnchorText": {
            "name": "_save_AnchorText",
            "location": 211,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "str",
                    "Dict[str, int]",
                    "int"
                ],
                "path": [
                    "pathlib.Path",
                    "Union[str, pathlib.Path]"
                ]
            }
        },
        "_save_KernelShap": {
            "name": "_save_KernelShap",
            "location": 235,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "str",
                    "list",
                    "List[Dict]"
                ],
                "path": [
                    "str",
                    "list",
                    "List[Dict]"
                ]
            }
        },
        "_save_TreelShap": {
            "name": "_save_TreelShap",
            "location": 240,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "str",
                    "list",
                    "List[Dict]"
                ],
                "path": [
                    "str",
                    "list",
                    "List[Dict]"
                ]
            }
        },
        "_save_CounterfactualRL": {
            "name": "_save_CounterfactualRL",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "raiden.utils.Address",
                    "str",
                    "raiden.utils.PaymentID"
                ],
                "path": [
                    "pathlib.Path",
                    "pathx.Path",
                    "bytes",
                    "cmk.utils.type_defs.ConfigSerial",
                    "cmk.utils.type_defs.HostName"
                ]
            }
        },
        "_helper_load_CounterfactualRL": {
            "name": "_helper_load_CounterfactualRL",
            "location": 306,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "dict",
                    "path.Path"
                ],
                "predictor": [
                    "str",
                    "int",
                    "Optional[List[str]]"
                ],
                "explainer": [
                    "pathlib.Path",
                    "str"
                ]
            }
        },
        "_load_CounterfactualRL": {
            "name": "_load_CounterfactualRL",
            "location": 326,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "Sequence[str]",
                    "str"
                ],
                "predictor": [
                    "str"
                ],
                "meta": [
                    "str",
                    "norfs.fs.base.Path",
                    "pathlib.Path"
                ]
            }
        },
        "_save_CounterfactualRLTabular": {
            "name": "_save_CounterfactualRLTabular",
            "location": 351,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "str",
                    "Iterable[str]"
                ],
                "path": [
                    "str",
                    "Iterable[str]"
                ]
            }
        },
        "_load_CounterfactualRLTabular": {
            "name": "_load_CounterfactualRLTabular",
            "location": 355,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "Sequence[str]",
                    "str"
                ],
                "predictor": [
                    "str"
                ],
                "meta": [
                    "str",
                    "norfs.fs.base.Path",
                    "pathlib.Path"
                ]
            }
        },
        "_save_SimilarityExplainer": {
            "name": "_save_SimilarityExplainer",
            "location": 380,
            "return": [
                "None"
            ],
            "arguments": {
                "explainer": [
                    "pathlib.Path",
                    "List[str]"
                ],
                "path": [
                    "pathlib.Path",
                    "str",
                    "Sequence[str]",
                    "Optional[str]",
                    "Union[List, str]",
                    "Union[str, pathlib.Path]",
                    "npipes.utils.typeshed.pathlike"
                ]
            }
        },
        "_load_SimilarityExplainer": {
            "name": "_load_SimilarityExplainer",
            "location": 390,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "Optional[str]",
                    "os.PathLike",
                    "str",
                    "Sequence[str]",
                    "Union[str, pathlib.Path]",
                    "Union[List, str]"
                ],
                "predictor": [
                    "Optional[List[str]]",
                    "str",
                    "Dict[str, Any]",
                    "int",
                    "bool",
                    "Set[str]"
                ],
                "meta": [
                    "str",
                    "norfs.fs.base.Path",
                    "pathlib.Path"
                ]
            }
        },
        "_save_ProtoSelect": {
            "name": "_save_ProtoSelect",
            "location": 401,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "Union[str, bytes, int]",
                    "Union[str, pathlib.Path]",
                    "bool",
                    "List[Tuple[pathlib.PurePosixPath, parso.python.tree.Scope]]",
                    "Sequence"
                ]
            }
        },
        "_load_ProtoSelect": {
            "name": "_load_ProtoSelect",
            "location": 405,
            "return": [
                "ProtoSelect",
                "None"
            ],
            "arguments": {
                "path": [
                    "str",
                    "norfs.fs.base.Path",
                    "pathlib.Path"
                ],
                "meta": [
                    "str",
                    "norfs.fs.base.Path",
                    "pathlib.Path"
                ]
            }
        },
        "NumpyEncoder.default": {
            "name": "default",
            "location": 410,
            "return": [
                "int",
                "float",
                "Callable[[Mapping],T]",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "obj": [
                    "int",
                    "Union[str, int]",
                    "Dict[int, int]"
                ]
            }
        }
    },
    "alibi-master/alibi/version.py": {},
    "alibi-master/alibi/__init__.py": {},
    "alibi-master/alibi/api/defaults.py": {},
    "alibi-master/alibi/api/interfaces.py": {
        "default_meta": {
            "name": "default_meta",
            "location": 19,
            "return": [
                "Dict[(str, Optional[Union[(Dict[(nothing, nothing)], List[nothing])]])]"
            ],
            "arguments": {}
        },
        "AlibiPrettyPrinter.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AlibiPrettyPrinter._pprint_dict": {
            "name": "_pprint_dict",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "object": [
                    "dict",
                    "list",
                    "bool",
                    "List[str]",
                    "Sequence[Any]",
                    "Dict[str, bool]"
                ],
                "stream": [
                    "Dict",
                    "str"
                ],
                "indent": [
                    "Dict",
                    "bytes"
                ],
                "allowance": [
                    "int",
                    "Dict[str,Any]",
                    "Optional[str]",
                    "Callable"
                ],
                "context": [
                    "Dict[str,Any]",
                    "Callable",
                    "Optional[str]",
                    "int",
                    "str",
                    "None"
                ],
                "level": [
                    "Dict[str,Any]",
                    "Callable",
                    "Optional[str]",
                    "int",
                    "str",
                    "None"
                ]
            }
        },
        "Base.__attrs_post_init__": {
            "name": "__attrs_post_init__",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Base._update_metadata": {
            "name": "_update_metadata",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_dict": [
                    "dict",
                    "Union[Dict, List]"
                ],
                "params": [
                    "bool",
                    "bytes",
                    "Dict",
                    "str",
                    "List[Dict[str,Any]]"
                ]
            }
        },
        "Explainer.explain": {
            "name": "explain",
            "location": 109,
            "return": [
                "Explanation",
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "Explainer.load": {
            "name": "load",
            "location": 113,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "Tuple[str]"
                ],
                "path": [
                    "str",
                    "bool"
                ],
                "predictor": [
                    "str",
                    "bool"
                ]
            }
        },
        "Explainer.reset_predictor": {
            "name": "reset_predictor",
            "location": 130,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Explainer.save": {
            "name": "save",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        },
        "Summariser.summarise": {
            "name": "summarise",
            "location": 159,
            "return": [
                "Explanation",
                "None"
            ],
            "arguments": {
                "self": [],
                "num_prototypes": [
                    "int",
                    "Optional[int]",
                    "List[float]",
                    "float",
                    "None"
                ]
            }
        },
        "Summariser.load": {
            "name": "load",
            "location": 163,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "Tuple[str]"
                ],
                "path": [
                    "str",
                    "bool",
                    "Tuple[str]"
                ]
            }
        },
        "Summariser.save": {
            "name": "save",
            "location": 166,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "Union[str,bytes,int]",
                    "str",
                    "Sequence",
                    "bool",
                    "bytes",
                    "int"
                ]
            }
        },
        "FitMixin.fit": {
            "name": "fit",
            "location": 172,
            "return": [
                "Explainer",
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "Explanation.__attrs_post_init__": {
            "name": "__attrs_post_init__",
            "location": 184,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Explanation.to_json": {
            "name": "to_json",
            "location": 191,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Explanation.from_json": {
            "name": "from_json",
            "location": 202,
            "return": [
                "Explanation"
            ],
            "arguments": {
                "cls": [
                    "Type[_TExplanation]"
                ],
                "jsonrepr": [
                    "Dict",
                    "Dict[str,Any]",
                    "str"
                ]
            }
        },
        "Explanation.__getitem__": {
            "name": "__getitem__",
            "location": 223,
            "return": [
                "list",
                "List[T]",
                "List[float]",
                "int"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "List[str]",
                    "abc.Mapping"
                ]
            }
        }
    },
    "alibi-master/alibi/api/__init__.py": {},
    "alibi-master/alibi/api/tests/test_interfaces.py": {
        "test_incomplete_explainer": {
            "name": "test_incomplete_explainer",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_explainer_with_init": {
            "name": "test_explainer_with_init",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_explainer_valid_meta": {
            "name": "test_explainer_valid_meta",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_incomplete_fitexplainer": {
            "name": "test_incomplete_fitexplainer",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_fitexplainer": {
            "name": "test_fitexplainer",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_explanation": {
            "name": "test_explanation",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_serialize_deserialize_explanation": {
            "name": "test_serialize_deserialize_explanation",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test__update_metadata": {
            "name": "test__update_metadata",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {
                "data_dict": [
                    "Dict",
                    "List[str]",
                    "Dict[str,Any]"
                ]
            }
        },
        "test__update_metatada_params": {
            "name": "test__update_metatada_params",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "data_dict": [
                    "Dict[str,Any]",
                    "Dict",
                    "Dict[str,numpy.ndarray]",
                    "Union[list,dict]",
                    "List"
                ]
            }
        },
        "SimpleExplainer.explain": {
            "name": "explain",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "List",
                    "T"
                ]
            }
        },
        "SimpleExplainerWithInit.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleExplainerWithInit.explain": {
            "name": "explain",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "List",
                    "T"
                ]
            }
        },
        "IncompleteFitExplainer.explain": {
            "name": "explain",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "List",
                    "T"
                ]
            }
        },
        "SimpleFitExplainer.fit": {
            "name": "fit",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "List",
                    "T"
                ]
            }
        },
        "SimpleFitExplainer.explain": {
            "name": "explain",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "List",
                    "T"
                ]
            }
        }
    },
    "alibi-master/alibi/api/tests/__init__.py": {},
    "alibi-master/alibi/confidence/model_linearity.py": {
        "_linear_superposition": {
            "name": "_linear_superposition",
            "location": 13,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "alphas": [
                    "int",
                    "Callable",
                    "str"
                ],
                "vecs": [
                    "int",
                    "Callable",
                    "str"
                ],
                "shape": [
                    "int",
                    "str",
                    "list",
                    "Sequence[float]",
                    "List[str]"
                ]
            }
        },
        "_calculate_global_linearity": {
            "name": "_calculate_global_linearity",
            "location": 34,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable",
                    "Callable[[], float]",
                    "float"
                ],
                "input_shape": [
                    "tuple",
                    "numpy.ndarray",
                    "int",
                    "Optional[numpy.ndarray]",
                    "float"
                ],
                "X_samples": [
                    "int",
                    "float",
                    "str"
                ],
                "model_type": [
                    "str",
                    "bool"
                ],
                "alphas": [
                    "int",
                    "float",
                    "bool",
                    "bytes",
                    "numpy.array"
                ]
            }
        },
        "_calculate_pairwise_linearity": {
            "name": "_calculate_pairwise_linearity",
            "location": 106,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predict_fn": [
                    "Callable",
                    "float",
                    "bool",
                    "Optional[int]",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "x": [
                    "numpy.ndarray",
                    "Callable[[str, str], float]",
                    "Optional[int]",
                    "Optional[numpy.ndarray]",
                    "float"
                ],
                "input_shape": [
                    "tuple",
                    "float",
                    "numpy.ndarray",
                    "int",
                    "Optional[float]",
                    "bool"
                ],
                "X_samples": [
                    "int",
                    "float",
                    "Optional[Union[float, Any]]",
                    "Optional[Iterable[\"Outcome\"]]"
                ],
                "model_type": [
                    "str",
                    "bool",
                    "int",
                    "list",
                    "Optional[str]"
                ],
                "alphas": [
                    "numpy.ndarray",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "_sample_knn": {
            "name": "_sample_knn",
            "location": 187,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray"
                ],
                "X_train": [
                    "float",
                    "int"
                ],
                "nb_samples": [
                    "int",
                    "str",
                    "float",
                    "numpy.ndarray",
                    "Container",
                    "List[str]"
                ]
            }
        },
        "_sample_grid": {
            "name": "_sample_grid",
            "location": 222,
            "return": [
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "str",
                    "Sequence",
                    "list",
                    "set",
                    "float"
                ],
                "feature_range": [
                    "float",
                    "int",
                    "Callable"
                ],
                "epsilon": [
                    "float",
                    "int"
                ],
                "nb_samples": [
                    "int",
                    "Tuple[int,int]",
                    "Optional[int]"
                ],
                "res": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "_linearity_measure": {
            "name": "_linearity_measure",
            "location": 263,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predict_fn": [
                    "str",
                    "Callable",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "Union[int, float]"
                ],
                "X_train": [
                    "None",
                    "numpy.ndarray",
                    "Optional[Dict]"
                ],
                "feature_range": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "Optional[Dict]",
                    "numpy.ndarray",
                    "Optional[float]"
                ],
                "method": [
                    "None",
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable[Any]",
                    "Optional[numpy.ndarray]"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "Tuple[float,float]",
                    "Union[float,numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "nb_samples": [
                    "int",
                    "float",
                    "Tuple[float,float]",
                    "numpy.ndarray"
                ],
                "res": [
                    "int",
                    "float",
                    "Tuple[float,float]",
                    "Union[float,numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "alphas": [
                    "None",
                    "numpy.ndarray",
                    "float",
                    "Tuple[numpy.dtype]"
                ],
                "model_type": [
                    "Text",
                    "str",
                    "Callable",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "agg": [
                    "Text",
                    "str",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable[Any]",
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "infer_feature_range": {
            "name": "infer_feature_range",
            "location": 336,
            "return": [
                "int",
                "numpy.ndarray",
                "List[int]",
                "float",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "X_train": [
                    "numpy.array",
                    "float",
                    "int"
                ]
            }
        },
        "linearity_measure": {
            "name": "linearity_measure",
            "location": 444,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "predict_fn": [
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "x": [
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "feature_range": [
                    "None",
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "method": [
                    "Text",
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "X_train": [
                    "None",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Union[None,float,int]",
                    "Optional[Dict]"
                ],
                "epsilon": [
                    "float",
                    "str",
                    "int",
                    "numpy.ndarray",
                    "Callable"
                ],
                "nb_samples": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "res": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "alphas": [
                    "None",
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "agg": [
                    "Text",
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ],
                "model_type": [
                    "Text",
                    "str",
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Callable"
                ]
            }
        },
        "LinearityMeasure.__init__": {
            "name": "__init__",
            "location": 354,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "method": [
                    "Text",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "Optional[Mapping]",
                    "Optional[Dict[str,Any]]"
                ],
                "epsilon": [
                    "float",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "Optional[Mapping]",
                    "Optional[Dict[str,Any]]"
                ],
                "nb_samples": [
                    "int",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "Optional[Mapping]",
                    "Optional[Dict[str,Any]]"
                ],
                "res": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str",
                    "float"
                ],
                "alphas": [
                    "None",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "Optional[Mapping]",
                    "Optional[Dict[str,Any]]"
                ],
                "model_type": [
                    "Text",
                    "bool",
                    "str",
                    "Callable",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "agg": [
                    "Text",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "Optional[Mapping]",
                    "Optional[Dict[str,Any]]"
                ],
                "verbose": [
                    "bool",
                    "Optional[int]",
                    "Type[T]",
                    "Optional[Mapping]",
                    "Optional[Dict[str,Any]]"
                ]
            }
        },
        "LinearityMeasure.fit": {
            "name": "fit",
            "location": 392,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X_train": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "LinearityMeasure.score": {
            "name": "score",
            "location": 406,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predict_fn": [
                    "Callable",
                    "int"
                ],
                "x": [
                    "Callable",
                    "numpy.ndarray",
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/confidence/trustscore.py": {
        "TrustScore.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k_filter": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "alpha": [
                    "float",
                    "Callable",
                    "bool",
                    "str",
                    "Optional[str]",
                    "List",
                    "int",
                    "Iterable[str]"
                ],
                "filter_type": [
                    "Optional[str]",
                    "str",
                    "None",
                    "bool",
                    "Type",
                    "Dict[str,List[Any]]",
                    "Dict[str,list[Any]]"
                ],
                "leaf_size": [
                    "int",
                    "Callable[[int],bool]",
                    "str",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "metric": [
                    "Text",
                    "Callable",
                    "bool",
                    "str",
                    "Optional[str]",
                    "List",
                    "int",
                    "Iterable[str]"
                ],
                "dist_filter_type": [
                    "Text",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "TrustScore.filter_by_distance_knn": {
            "name": "filter_by_distance_knn",
            "location": 47,
            "return": [
                "numpy.ndarray",
                "Optional[bool]",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray"
                ]
            }
        },
        "TrustScore.filter_by_probability_knn": {
            "name": "filter_by_probability_knn",
            "location": 71,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str",
                    "numpy.ndarray"
                ],
                "Y": [
                    "int",
                    "numpy.ndarray",
                    "Callable[numpy.ndarray,numpy.ndarray]",
                    "float",
                    "Union[pandas.Series,numpy.ndarray]",
                    "Callable[[numpy.ndarray],numpy.ndarray]",
                    "Callable[[numpy.ndarray],float]"
                ]
            }
        },
        "TrustScore.fit": {
            "name": "fit",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str",
                    "Dict[str,Any]",
                    "numpy.ndarray"
                ],
                "Y": [
                    "None",
                    "Optional[numpy.array]",
                    "bool",
                    "List[int]",
                    "Optional[bool]",
                    "Optional[int]",
                    "int",
                    "Optional[T]"
                ],
                "classes": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "float",
                    "int",
                    "Optional[float]",
                    "Tuple[Union[int,int]]",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Optional[Tuple[int,int]]",
                    "Optional[bool]",
                    "Tuple[int,int]"
                ]
            }
        },
        "TrustScore.score": {
            "name": "score",
            "location": 149,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str",
                    "numpy.ndarray",
                    "Tuple",
                    "Mapping",
                    "float",
                    "int",
                    "Mapping[str,float]"
                ],
                "Y": [
                    "int",
                    "numpy.ndarray"
                ],
                "k": [
                    "int",
                    "float",
                    "List[int]",
                    "str",
                    "Union[int,Sequence[int]]"
                ],
                "dist_type": [
                    "Text",
                    "str",
                    "float",
                    "Set",
                    "Sequence[Any]"
                ]
            }
        }
    },
    "alibi-master/alibi/confidence/__init__.py": {},
    "alibi-master/alibi/confidence/tests/test_model_linearity.py": {
        "test_linear_superposition": {
            "name": "test_linear_superposition",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "input_shape": [
                    "str",
                    "int"
                ],
                "nb_instances": [
                    "bool"
                ]
            }
        },
        "test_sample_knn": {
            "name": "test_sample_knn",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_instances": [],
                "nb_samples": [
                    "float",
                    "Dict[str,numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "test_sample_grid": {
            "name": "test_sample_grid",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "nb_instances": [],
                "nb_samples": [
                    "float",
                    "str",
                    "numpy.ndarray"
                ],
                "input_shape": []
            }
        },
        "test_linearity_measure_class": {
            "name": "test_linearity_measure_class",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "method": [
                    "Dict"
                ],
                "epsilon": [
                    "Dict"
                ],
                "res": [
                    "Dict"
                ],
                "nb_instances": [
                    "str",
                    "float",
                    "Dict[str,Sequence[Any]]"
                ],
                "agg": [
                    "Dict"
                ]
            }
        },
        "test_linearity_measure_reg": {
            "name": "test_linearity_measure_reg",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "method": [
                    "bool",
                    "str",
                    "Dict",
                    "int"
                ],
                "epsilon": [
                    "bool",
                    "str",
                    "Dict",
                    "int"
                ],
                "res": [
                    "bool",
                    "str",
                    "Dict",
                    "int"
                ],
                "nb_instances": [
                    "List[float]",
                    "str"
                ],
                "agg": [
                    "bool",
                    "str",
                    "Dict",
                    "int"
                ]
            }
        },
        "test_LinearityMeasure_class": {
            "name": "test_LinearityMeasure_class",
            "location": 157,
            "return": [
                "None"
            ],
            "arguments": {
                "method": [
                    "str",
                    "bytes"
                ],
                "epsilon": [
                    "str",
                    "bytes"
                ],
                "res": [
                    "str",
                    "bytes"
                ],
                "nb_instances": [
                    "str",
                    "int",
                    "bool"
                ],
                "agg": [
                    "str",
                    "bytes"
                ]
            }
        },
        "test_LinearityMeasure_reg": {
            "name": "test_LinearityMeasure_reg",
            "location": 182,
            "return": [
                "None"
            ],
            "arguments": {
                "method": [
                    "str",
                    "bool",
                    "Dict[str,str]",
                    "Callable",
                    "Dict",
                    "int"
                ],
                "epsilon": [
                    "str",
                    "bool",
                    "Dict[str,str]",
                    "Callable",
                    "Dict",
                    "int"
                ],
                "res": [
                    "str",
                    "bool",
                    "Dict[str,str]",
                    "Callable",
                    "Dict",
                    "int"
                ],
                "nb_instances": [
                    "bool",
                    "str",
                    "List[str]",
                    "Tuple",
                    "float"
                ],
                "agg": [
                    "str",
                    "bool",
                    "Dict[str,str]",
                    "Callable",
                    "Dict",
                    "int"
                ]
            }
        },
        "test_linearity_measure_class.predict_fn": {
            "name": "predict_fn",
            "location": 76,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_linearity_measure_reg.predict_fn_svr": {
            "name": "predict_fn_svr",
            "location": 107,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "int",
                    "dict"
                ]
            }
        },
        "test_linearity_measure_reg.predict_fn": {
            "name": "predict_fn",
            "location": 110,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_linearity_measure_reg.predict_fn_multi": {
            "name": "predict_fn_multi",
            "location": 141,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_LinearityMeasure_class.predict_fn": {
            "name": "predict_fn",
            "location": 167,
            "return": [],
            "arguments": {
                "x": []
            }
        },
        "test_LinearityMeasure_reg.predict_fn": {
            "name": "predict_fn",
            "location": 191,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "int",
                    "dict"
                ]
            }
        },
        "test_LinearityMeasure_reg.predict_fn_multi": {
            "name": "predict_fn_multi",
            "location": 198,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        }
    },
    "alibi-master/alibi/confidence/tests/test_trustscore.py": {
        "test_trustscore": {
            "name": "test_trustscore",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "filter_type": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/confidence/tests/__init__.py": {},
    "alibi-master/alibi/datasets/default.py": {
        "fetch_imagenet_10": {
            "name": "fetch_imagenet_10",
            "location": 32,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "url_id": [
                    "int",
                    "str"
                ]
            }
        },
        "load_cats": {
            "name": "load_cats",
            "location": 75,
            "return": [
                "Union[(alibi.utils.data.Bunch, Tuple[(Any, np.ndarray)])]"
            ],
            "arguments": {
                "target_size": [
                    "Tuple[int]",
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "return_X_y": [
                    "bool",
                    "Dict[str,str]",
                    "int",
                    "List[str]",
                    "Sequence"
                ]
            }
        },
        "fetch_imagenet": {
            "name": "fetch_imagenet",
            "location": 123,
            "return": [
                "None"
            ],
            "arguments": {
                "category": [
                    "Text",
                    "bool",
                    "str"
                ],
                "nb_images": [
                    "int",
                    "bool",
                    "str"
                ],
                "target_size": [
                    "Tuple[int]",
                    "bool",
                    "str"
                ],
                "min_std": [
                    "float",
                    "bool",
                    "str"
                ],
                "seed": [
                    "int",
                    "bool",
                    "str"
                ],
                "return_X_y": [
                    "bool",
                    "str"
                ]
            }
        },
        "fetch_movie_sentiment": {
            "name": "fetch_movie_sentiment",
            "location": 130,
            "return": [
                "Union[(alibi.utils.data.Bunch, Tuple[(List[str], List[int])])]"
            ],
            "arguments": {
                "return_X_y": [
                    "bool",
                    "str",
                    "int",
                    "List[str]",
                    "Optional[Iterable[str]]"
                ],
                "url_id": [
                    "int",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "fetch_adult": {
            "name": "fetch_adult",
            "location": 176,
            "return": [
                "Union[(alibi.utils.data.Bunch, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "features_drop": [
                    "None",
                    "Optional[List[str]]",
                    "List[logging.Handler]",
                    "bool",
                    "str",
                    "List[InlineContent]",
                    "Optional[int]",
                    "int"
                ],
                "return_X_y": [
                    "bool",
                    "List[Dict[str,Any]]",
                    "int",
                    "Optional[List[str]]",
                    "str"
                ],
                "url_id": [
                    "int",
                    "str",
                    "bool",
                    "Dict"
                ]
            }
        }
    },
    "alibi-master/alibi/datasets/tensorflow.py": {
        "fetch_fashion_mnist": {
            "name": "fetch_fashion_mnist",
            "location": 9,
            "return": [
                "Union[(alibi.utils.data.Bunch, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "return_X_y": [
                    "bool",
                    "List[str]",
                    "str",
                    "int",
                    "Dict[str,Any]"
                ]
            }
        }
    },
    "alibi-master/alibi/datasets/__init__.py": {},
    "alibi-master/alibi/datasets/tests/test_datasets.py": {
        "test_adult": {
            "name": "test_adult",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "return_X_y": [
                    "bool"
                ]
            }
        },
        "test_movie_sentiment": {
            "name": "test_movie_sentiment",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "return_X_y": [
                    "float",
                    "str"
                ]
            }
        },
        "test_cats": {
            "name": "test_cats",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "return_X_y": [
                    "int",
                    "float",
                    "Optional[int]",
                    "str",
                    "None"
                ],
                "target_size": [
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        }
    },
    "alibi-master/alibi/datasets/tests/__init__.py": {},
    "alibi-master/alibi/explainers/ale.py": {
        "get_quantiles": {
            "name": "get_quantiles",
            "location": 261,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "values": [
                    "int",
                    "Type",
                    "Optional[Pattern[str]]",
                    "str",
                    "float",
                    "dict"
                ],
                "num_quantiles": [
                    "int",
                    "List[int]"
                ],
                "interpolation": [
                    "Text",
                    "int",
                    "Type",
                    "Optional[Pattern[str]]",
                    "str",
                    "float",
                    "Dict"
                ]
            }
        },
        "bisect_fun": {
            "name": "bisect_fun",
            "location": 282,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "fun": [
                    "int",
                    "Callable",
                    "str"
                ],
                "target": [
                    "int",
                    "Callable",
                    "str"
                ],
                "lo": [
                    "int",
                    "Callable",
                    "str"
                ],
                "hi": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "minimum_satisfied": {
            "name": "minimum_satisfied",
            "location": 315,
            "return": [
                "int",
                "Tuple",
                "str"
            ],
            "arguments": {
                "values": [
                    "numpy.ndarray",
                    "Optional[Dict[str, numpy.ma.MaskedArray]]",
                    "Optional[numpy.ndarray]"
                ],
                "min_bin_points": [
                    "int",
                    "float",
                    "numpy.array",
                    "Optional[int]",
                    "pandas.Series",
                    "bool",
                    "str"
                ],
                "n": [
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "str",
                    "Union[int, float]"
                ]
            }
        },
        "adaptive_grid": {
            "name": "adaptive_grid",
            "location": 341,
            "return": [
                "Tuple[int]",
                "int",
                "List[int]",
                "List[dict]"
            ],
            "arguments": {
                "values": [
                    "numpy.ndarray",
                    "int",
                    "Iterable[Any]",
                    "T",
                    "str"
                ],
                "min_bin_points": [
                    "int",
                    "str",
                    "float",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "ale_num": {
            "name": "ale_num",
            "location": 385,
            "return": [
                "numpy.ndarray",
                "int"
            ],
            "arguments": {
                "predictor": [
                    "float",
                    "Sequence[float]",
                    "List[int]",
                    "int"
                ],
                "X": [
                    "numpy.ndarray",
                    "int"
                ],
                "feature": [
                    "numpy.ndarray",
                    "int"
                ],
                "feature_grid_points": [
                    "None",
                    "int",
                    "logging.LogRecord",
                    "Optional[numpy.ndarray]",
                    "str",
                    "Type[T]"
                ],
                "min_bin_points": [
                    "int",
                    "str",
                    "numpy.ndarray"
                ],
                "check_feature_resolution": [
                    "bool",
                    "numpy.ndarray",
                    "float"
                ],
                "low_resolution_threshold": [
                    "int",
                    "str",
                    "float",
                    "bool",
                    "vimiv.api.modes.Mode"
                ],
                "extrapolate_constant": [
                    "bool",
                    "numpy.ndarray",
                    "float"
                ],
                "extrapolate_constant_perc": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "vimiv.api.modes.Mode"
                ],
                "extrapolate_constant_min": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "vimiv.api.modes.Mode"
                ]
            }
        },
        "plot_ale": {
            "name": "plot_ale",
            "location": 539,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "exp": [
                    "numpy.ndarray",
                    "int",
                    "List[List[str]]",
                    "List[Union[int, str]]",
                    "pandas.DataFrame"
                ],
                "features": [
                    "Text",
                    "int",
                    "List[int]",
                    "numpy.ndarray"
                ],
                "targets": [
                    "Text",
                    "int",
                    "List[Tuple[int,int]]",
                    "List[str]"
                ],
                "n_cols": [
                    "int",
                    "List",
                    "float"
                ],
                "sharey": [
                    "Text",
                    "str",
                    "int",
                    "bool"
                ],
                "constant": [
                    "bool",
                    "int",
                    "List[str]",
                    "float"
                ],
                "ax": [
                    "None",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Optional[str]"
                ],
                "line_kw": [
                    "None",
                    "numpy.ndarray",
                    "Optional[List[int]]",
                    "Optional[int]",
                    "int",
                    "Optional[Dict[str,Any]]"
                ],
                "fig_kw": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "Union[None,float,int]",
                    "Optional[str]",
                    "numpy.ndarray"
                ]
            }
        },
        "_plot_one_ale_num": {
            "name": "_plot_one_ale_num",
            "location": 678,
            "return": [
                "bool",
                "int",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "exp": [
                    "int",
                    "bool",
                    "dict",
                    "Optional[float]"
                ],
                "feature": [
                    "int",
                    "bool",
                    "dict",
                    "Optional[float]"
                ],
                "targets": [
                    "int",
                    "bool",
                    "dict",
                    "float",
                    "numpy.ndarray"
                ],
                "constant": [
                    "bool",
                    "int",
                    "Dict",
                    "Optional[float]"
                ],
                "ax": [
                    "None",
                    "int",
                    "Optional[int]",
                    "Union[int,None]",
                    "str"
                ],
                "legend": [
                    "bool",
                    "str",
                    "Tuple[str]"
                ],
                "line_kw": [
                    "Optional[float]",
                    "int",
                    "dict"
                ]
            }
        },
        "ALE.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "int",
                    "Optional[Dict]",
                    "bool"
                ],
                "feature_names": [
                    "None",
                    "str",
                    "Optional[str]"
                ],
                "target_names": [
                    "None",
                    "str",
                    "Optional[str]",
                    "bytes"
                ],
                "check_feature_resolution": [
                    "bool",
                    "str",
                    "int",
                    "Union[str,int]"
                ],
                "low_resolution_threshold": [
                    "int",
                    "Optional[int]",
                    "Sequence[str]",
                    "str",
                    "bytes",
                    "Dict[str,Any]"
                ],
                "extrapolate_constant": [
                    "bool",
                    "Dict",
                    "List[str]",
                    "Optional[List[str]]",
                    "numpy.ndarray",
                    "str",
                    "Dict[str,Any]"
                ],
                "extrapolate_constant_perc": [
                    "float",
                    "Optional[int]",
                    "Sequence[str]",
                    "str",
                    "bytes",
                    "Dict[str,Any]",
                    "int"
                ],
                "extrapolate_constant_min": [
                    "float",
                    "Optional[int]",
                    "Sequence[str]",
                    "str",
                    "bytes",
                    "Dict[str,Any]",
                    "int"
                ]
            }
        },
        "ALE.explain": {
            "name": "explain",
            "location": 97,
            "return": [
                "str",
                "apistar.interfaces.Injector",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "float",
                    "numpy.array"
                ],
                "features": [
                    "Dict[str, Set[str]]",
                    "int",
                    "str",
                    "List[List[str]]",
                    "Dict[str, int]"
                ],
                "min_bin_points": [
                    "int",
                    "pandas.DataFrame",
                    "float",
                    "numpy.ndarray"
                ],
                "grid_points": [
                    "None",
                    "Sequence[str]",
                    "str",
                    "float",
                    "Optional[dict]",
                    "Dict[str,Any]",
                    "Optional[Dict[str,str]]"
                ]
            }
        },
        "ALE._build_explanation": {
            "name": "_build_explanation",
            "location": 222,
            "return": [
                "Explanation",
                "bool",
                "str",
                "bytearray",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "ale_values": [
                    "List[numpy.ndarray]",
                    "float",
                    "bool",
                    "int",
                    "List[float]",
                    "str"
                ],
                "ale0": [
                    "List[numpy.ndarray]",
                    "float",
                    "bool",
                    "int",
                    "List[float]",
                    "str"
                ],
                "constant_value": [
                    "List[numpy.ndarray]",
                    "float",
                    "bool",
                    "int",
                    "List[float]",
                    "str"
                ],
                "feature_values": [
                    "List[numpy.ndarray]",
                    "float",
                    "bool",
                    "int",
                    "List[float]",
                    "str"
                ],
                "feature_deciles": [
                    "List[numpy.ndarray]",
                    "float",
                    "bool",
                    "int",
                    "List[float]",
                    "str"
                ],
                "feature_names": [
                    "List[numpy.ndarray]",
                    "float",
                    "bool",
                    "int",
                    "List[float]",
                    "str"
                ]
            }
        },
        "ALE.reset_predictor": {
            "name": "reset_predictor",
            "location": 249,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "adaptive_grid.minimum_not_satisfied": {
            "name": "minimum_not_satisfied",
            "location": 370,
            "return": [
                "int",
                "str",
                "Iterable[numpy.dtype]"
            ],
            "arguments": {
                "values": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[str]",
                    "Union[int, float]",
                    "str",
                    "Tuple[float, float]"
                ],
                "min_bin_points": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[str]",
                    "Union[int, float]",
                    "str",
                    "Tuple[float, float]"
                ],
                "n": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[str]",
                    "Union[int, float]",
                    "str",
                    "Tuple[float, float]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cem.py": {
        "CEM.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predict": [
                    "int",
                    "numpy.ndarray",
                    "Union[int, str]",
                    "bool"
                ],
                "mode": [
                    "int",
                    "List[int]",
                    "float",
                    "numpy.ndarray",
                    "bool"
                ],
                "shape": [
                    "int",
                    "Optional[Sequence[str]]"
                ],
                "kappa": [
                    "float",
                    "bool",
                    "str",
                    "Mapping[str,Tuple[float,float,float]]"
                ],
                "beta": [
                    "float",
                    "Optional[float]"
                ],
                "feature_range": [
                    "Tuple[float]",
                    "Optional[float]",
                    "float"
                ],
                "gamma": [
                    "float",
                    "int",
                    "List[int]",
                    "numpy.ndarray",
                    "bool"
                ],
                "ae_model": [
                    "None",
                    "str",
                    "List[str]",
                    "float"
                ],
                "learning_rate_init": [
                    "float",
                    "int",
                    "Optional[int]",
                    "Dict[str,Tuple[str,int,int]]",
                    "Union[float,numpy.ndarray]",
                    "bool"
                ],
                "max_iterations": [
                    "int",
                    "Optional[int]"
                ],
                "c_init": [
                    "float",
                    "int"
                ],
                "c_steps": [
                    "int",
                    "float"
                ],
                "eps": [
                    "Tuple[float]",
                    "int",
                    "List[int]",
                    "float",
                    "numpy.ndarray",
                    "bool"
                ],
                "clip": [
                    "Tuple[float]",
                    "int",
                    "List[int]",
                    "float",
                    "numpy.ndarray",
                    "bool"
                ],
                "update_num_grad": [
                    "int",
                    "bool",
                    "Container[int]"
                ],
                "no_info_val": [
                    "None",
                    "int",
                    "Optional[int]",
                    "str",
                    "Mapping",
                    "float"
                ],
                "write_dir": [
                    "None",
                    "int",
                    "Optional[int]",
                    "Optional[Any]",
                    "str",
                    "bool",
                    "Optional[dict]"
                ],
                "sess": [
                    "None",
                    "bool",
                    "List",
                    "List[str]",
                    "Callable[,int]",
                    "str"
                ]
            }
        },
        "CEM.fit": {
            "name": "fit",
            "location": 299,
            "return": [
                "CEM",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "memoryview",
                    "Optional[int]",
                    "int",
                    "Dict[str, str]"
                ],
                "no_info_type": [
                    "Text",
                    "str",
                    "Optional[Any]",
                    "Dict",
                    "IO[str]",
                    "Optional[str]"
                ]
            }
        },
        "CEM.loss_fn": {
            "name": "loss_fn",
            "location": 328,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "pred_proba": [
                    "List['cirq.Qid']",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "Y": [
                    "List['cirq.Qid']",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "CEM.perturb": {
            "name": "perturb",
            "location": 358,
            "return": [
                "Tuple",
                "int",
                "List[int]",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "float",
                    "numpy.array"
                ],
                "eps": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ],
                "proba": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "List",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "CEM.get_gradients": {
            "name": "get_gradients",
            "location": 392,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "float",
                    "int"
                ],
                "Y": [
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "CEM.attack": {
            "name": "attack",
            "location": 447,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "Y": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "verbose": [
                    "bool",
                    "int"
                ]
            }
        },
        "CEM.explain": {
            "name": "explain",
            "location": 657,
            "return": [
                "Explanation",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "List[int]"
                ],
                "Y": [
                    "None",
                    "Optional[Tuple]",
                    "Optional[numpy.ndarray]",
                    "T",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "verbose": [
                    "bool",
                    "numpy.ndarray",
                    "Tuple[float,float]",
                    "Optional[int]"
                ]
            }
        },
        "CEM.reset_predictor": {
            "name": "reset_predictor",
            "location": 721,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "CEM.get_gradients.f": {
            "name": "f",
            "location": 413,
            "return": [
                "float",
                "int",
                "str"
            ],
            "arguments": {
                "preds_pert": [
                    "str",
                    "Sequence[float]",
                    "Union[str, bool, None]",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "CEM.get_gradients.g": {
            "name": "g",
            "location": 416,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "preds_pert": [
                    "BaseException"
                ]
            }
        },
        "CEM.attack.compare": {
            "name": "compare",
            "location": 475,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "numpy.ndarray",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "Union[int, slice]"
                ],
                "y": [
                    "int",
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cfproto.py": {
        "CounterFactualProto": {
            "name": "CounterFactualProto",
            "location": 22,
            "return": [
                "List[List[str]]",
                "CounterfactualProto"
            ],
            "arguments": {}
        },
        "CounterfactualProto.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predict": [
                    "bool",
                    "List[int]",
                    "int",
                    "raiden.utils.Secret"
                ],
                "shape": [],
                "kappa": [
                    "float",
                    "str",
                    "bool",
                    "int"
                ],
                "beta": [
                    "Mapping[str,Tuple[float,float,float]]",
                    "float"
                ],
                "feature_range": [
                    "Tuple[float]",
                    "Optional[numpy.ndarray]",
                    "bool"
                ],
                "gamma": [
                    "float",
                    "Callable",
                    "int",
                    "numpy.array",
                    "numpy.ndarray",
                    "Dict[str,Any]",
                    "Optional[List[Any]]"
                ],
                "ae_model": [
                    "None",
                    "Callable",
                    "int",
                    "numpy.array",
                    "numpy.ndarray",
                    "Dict[str,Any]",
                    "Optional[List[Any]]"
                ],
                "enc_model": [
                    "None",
                    "Callable",
                    "int",
                    "numpy.array",
                    "numpy.ndarray",
                    "Dict[str,Any]",
                    "Optional[List[Any]]"
                ],
                "theta": [
                    "float",
                    "int",
                    "Iterator[str]",
                    "raiden.utils.TokenNetworkRegistryAddress"
                ],
                "cat_vars": [
                    "None",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Dict[str,str]"
                ],
                "ohe": [
                    "bool",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Dict[str,str]"
                ],
                "use_kdtree": [
                    "bool",
                    "Callable",
                    "int",
                    "numpy.array",
                    "numpy.ndarray",
                    "Dict[str,Any]",
                    "Optional[List[Any]]"
                ],
                "learning_rate_init": [
                    "float",
                    "int"
                ],
                "max_iterations": [
                    "int",
                    "float"
                ],
                "c_init": [
                    "float",
                    "int",
                    "str",
                    "Tuple[int,int]",
                    "Callable[[float],None]"
                ],
                "c_steps": [
                    "int",
                    "str",
                    "Tuple[int,int]",
                    "Callable[[float],None]"
                ],
                "eps": [
                    "Tuple[float]",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Dict[str,str]"
                ],
                "clip": [
                    "Tuple[float]",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Dict[str,str]"
                ],
                "update_num_grad": [
                    "int",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Dict[str,str]"
                ],
                "write_dir": [
                    "None",
                    "str",
                    "bool",
                    "Optional[str]",
                    "Optional[Dict[str,str]]",
                    "int"
                ],
                "sess": [
                    "None",
                    "bool",
                    "Optional[List[str]]",
                    "Optional[float]",
                    "Dict[str,str]"
                ]
            }
        },
        "CounterfactualProto.fit": {
            "name": "fit",
            "location": 662,
            "return": [
                "CounterfactualProto",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "str",
                    "Dict[str, Any]"
                ],
                "trustscore_kwargs": [
                    "None",
                    "str",
                    "Optional[str]",
                    "bool"
                ],
                "d_type": [
                    "Text",
                    "str",
                    "List[str]"
                ],
                "w": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "disc_perc": [
                    "Tuple[int]",
                    "str",
                    "Callable[,bool]"
                ],
                "standardize_cat_vars": [
                    "bool",
                    "str",
                    "int",
                    "float",
                    "List[str]"
                ],
                "smooth": [
                    "float",
                    "str",
                    "int",
                    "List[str]"
                ],
                "center": [
                    "bool",
                    "str",
                    "int",
                    "float",
                    "List[str]"
                ],
                "update_feature_range": [
                    "bool",
                    "str",
                    "int",
                    "float",
                    "List[str]"
                ]
            }
        },
        "CounterfactualProto.loss_fn": {
            "name": "loss_fn",
            "location": 819,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "pred_proba": [
                    "List['cirq.Qid']",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "Y": [
                    "List['cirq.Qid']",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "CounterfactualProto.get_gradients": {
            "name": "get_gradients",
            "location": 844,
            "return": [
                "str",
                "List[int]",
                "int",
                "utils.Node",
                "raiden.utils.Tuple[int, int]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "Y": [
                    "bool",
                    "int",
                    "str",
                    "Optional[int]",
                    "Callable",
                    "dict"
                ],
                "grads_shape": [
                    "int",
                    "float"
                ],
                "cat_vars_ord": [
                    "int",
                    "numpy.ndarray",
                    "Optional[float]",
                    "tuple",
                    "float"
                ]
            }
        },
        "CounterfactualProto.score": {
            "name": "score",
            "location": 916,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "Optional[str]"
                ],
                "adv_class": [
                    "dict",
                    "str",
                    "List[\"Block\"]"
                ],
                "orig_class": [
                    "dict",
                    "str",
                    "List[\"Block\"]"
                ],
                "eps": [
                    "float",
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "CounterfactualProto.attack": {
            "name": "attack",
            "location": 951,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "bool",
                    "Optional[int]"
                ],
                "Y": [
                    "int",
                    "str",
                    "bool",
                    "torch.utils.data.Dataset",
                    "float"
                ],
                "target_class": [
                    "None",
                    "str",
                    "Optional[str]",
                    "bool",
                    "Optional[List[str]]"
                ],
                "k": [
                    "None",
                    "bool",
                    "str",
                    "Dict",
                    "Optional[Tuple[str,str]]"
                ],
                "k_type": [
                    "Text",
                    "Union[bool,Iterable[str]]",
                    "str",
                    "bool"
                ],
                "threshold": [
                    "float",
                    "bool",
                    "Callable",
                    "Callable[[str],Any]"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "float",
                    "str"
                ],
                "print_every": [
                    "int",
                    "List[bool]",
                    "Tuple"
                ],
                "log_every": [
                    "int",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "CounterfactualProto.explain": {
            "name": "explain",
            "location": 1275,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "float",
                    "Callable",
                    "Optional[numpy.ndarray]",
                    "Optional[int]"
                ],
                "Y": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "bool",
                    "Optional[dict]",
                    "Optional[List[str]]",
                    "Optional[int]",
                    "Optional[Callable[[List],Any]]",
                    "Optional[Set[str]]"
                ],
                "target_class": [
                    "bool",
                    "None"
                ],
                "k": [
                    "bool",
                    "None"
                ],
                "k_type": [
                    "bool",
                    "Text"
                ],
                "threshold": [
                    "bool",
                    "float"
                ],
                "verbose": [
                    "bool"
                ],
                "print_every": [
                    "bool",
                    "int"
                ],
                "log_every": [
                    "bool",
                    "int"
                ]
            }
        },
        "CounterfactualProto.reset_predictor": {
            "name": "reset_predictor",
            "location": 1385,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "CounterfactualProto.get_gradients.f": {
            "name": "f",
            "location": 878,
            "return": [
                "float",
                "int",
                "str"
            ],
            "arguments": {
                "preds_pert": [
                    "str",
                    "Sequence[float]",
                    "Union[str, bool, None]",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "CounterfactualProto.get_gradients.g": {
            "name": "g",
            "location": 881,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "preds_pert": [
                    "BaseException"
                ]
            }
        },
        "CounterfactualProto.attack.compare": {
            "name": "compare",
            "location": 993,
            "return": [
                "bool",
                "str",
                "utils.Node"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ],
                "y": [
                    "int"
                ]
            }
        },
        "CounterfactualProto.__init__.is_eq": {
            "name": "is_eq",
            "location": 230,
            "return": [
                "numpy.ndarray",
                "Dict[str, int]",
                "float",
                "bytearray",
                "cirq.google.api.v1.operations_pb2.Operation",
                "str"
            ],
            "arguments": {
                "col": [
                    "int",
                    "Sequence[int]",
                    "bool",
                    "str",
                    "Optional[float]"
                ],
                "cat_cols": [
                    "int",
                    "Sequence[int]",
                    "bool",
                    "str",
                    "Optional[float]"
                ]
            }
        },
        "CounterfactualProto.__init__.cond_loop": {
            "name": "cond_loop",
            "location": 249,
            "return": [
                "bytearray",
                "str",
                "List[int]",
                "float"
            ],
            "arguments": {
                "icol": [
                    "bool",
                    "Optional[str]",
                    "Optional[bool]",
                    "List[Tuple[int, int]]"
                ],
                "iohe": [
                    "bool",
                    "Optional[int]",
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "icat": [
                    "bool",
                    "Optional[int]",
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "adv_to_map": [
                    "bool",
                    "Optional[str]",
                    "Optional[bool]",
                    "List[Tuple[int, int]]"
                ],
                "adv_map": [
                    "bool",
                    "Optional[int]",
                    "List[int]",
                    "List[str]",
                    "str"
                ],
                "map_cols": [
                    "bool",
                    "Optional[str]",
                    "Optional[bool]",
                    "List[Tuple[int, int]]"
                ]
            }
        },
        "CounterfactualProto.__init__.body_ord_to_num": {
            "name": "body_ord_to_num",
            "location": 268,
            "return": [
                "List",
                "Dict",
                "Dict[str,int]",
                "Iterable[str]",
                "numpy.ndarray"
            ],
            "arguments": {
                "icol": [
                    "str",
                    "numpy.ndarray",
                    "list",
                    "tuple",
                    "int",
                    "dict"
                ],
                "iohe": [
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "Tuple[int, int, int]",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "List['cirq.Circuit']",
                    "str"
                ],
                "icat": [
                    "str",
                    "Callable",
                    "Dict[str, object]",
                    "Tuple[int]",
                    "float"
                ],
                "adv_to_map": [
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "Tuple[int, int, int]",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "List['cirq.Circuit']",
                    "str"
                ],
                "adv_map": [
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "map_cols": [
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "Tuple[int, int, int]",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "List['cirq.Circuit']",
                    "str"
                ]
            }
        },
        "CounterfactualProto.__init__.body_num_to_ord": {
            "name": "body_num_to_ord",
            "location": 308,
            "return": [
                "str",
                "List"
            ],
            "arguments": {
                "icol": [
                    "str",
                    "tuple",
                    "numpy.ndarray",
                    "Optional[Dict[str, Any]]",
                    "dict"
                ],
                "iohe": [
                    "int",
                    "List['cirq.Circuit']",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "raiden.utils.Callable",
                    "Exception"
                ],
                "icat": [
                    "str",
                    "Tuple[int]",
                    "float",
                    "Callable"
                ],
                "adv_to_map": [
                    "int",
                    "List['cirq.Circuit']",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "raiden.utils.Callable",
                    "Exception"
                ],
                "adv_map": [
                    "str",
                    "int",
                    "Dict[str, str]",
                    "Optional[Union[str, int]]"
                ],
                "map_cols": [
                    "int",
                    "List['cirq.Circuit']",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "raiden.utils.Callable",
                    "Exception"
                ]
            }
        },
        "CounterfactualProto.__init__.body_ohe_to_num": {
            "name": "body_ohe_to_num",
            "location": 343,
            "return": [
                "List",
                "Dict",
                "Dict[str,int]",
                "Iterable[str]",
                "numpy.ndarray"
            ],
            "arguments": {
                "icol": [
                    "str",
                    "numpy.ndarray",
                    "list",
                    "tuple",
                    "int",
                    "dict"
                ],
                "iohe": [
                    "Dict[str, int]"
                ],
                "icat": [
                    "str",
                    "Callable",
                    "Dict[str, object]",
                    "Tuple[int]",
                    "float"
                ],
                "adv_to_map": [
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "Tuple[int, int, int]",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "List['cirq.Circuit']",
                    "str"
                ],
                "adv_map": [
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "map_cols": [
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "Tuple[int, int, int]",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "List['cirq.Circuit']",
                    "str"
                ]
            }
        },
        "CounterfactualProto.__init__.body_num_to_ohe": {
            "name": "body_num_to_ohe",
            "location": 387,
            "return": [
                "str",
                "List"
            ],
            "arguments": {
                "icol": [
                    "numpy.ndarray",
                    "Optional[int]",
                    "Tuple[int]",
                    "Dict[str, Any]",
                    "bool"
                ],
                "iohe": [
                    "bool",
                    "float",
                    "recidiviz.calculator.pipeline.utils.incarceration_period_index.IncarcerationPeriodIndex",
                    "Optional[numpy.ndarray]",
                    "numpy.array"
                ],
                "icat": [
                    "str",
                    "Tuple[int]",
                    "float",
                    "Callable"
                ],
                "adv_to_map": [
                    "int",
                    "List['cirq.Circuit']",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "raiden.utils.Callable",
                    "Exception"
                ],
                "adv_map": [
                    "int",
                    "List['cirq.Circuit']",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "raiden.utils.Callable",
                    "Exception"
                ],
                "map_cols": [
                    "int",
                    "List['cirq.Circuit']",
                    "Optional[int]",
                    "Type[T]",
                    "bool",
                    "raiden.utils.Callable",
                    "Exception"
                ]
            }
        },
        "CounterfactualProto.__init__.apply_map": {
            "name": "apply_map",
            "location": 437,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "adv_to_map": [
                    "int",
                    "float",
                    "utils.mssql_counters.Section",
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "to_num": [
                    "bool",
                    "int",
                    "Callable"
                ]
            }
        },
        "CounterfactualProto.__init__.body_ord_to_num.true_fn": {
            "name": "true_fn",
            "location": 287,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_ord_to_num.false_fn": {
            "name": "false_fn",
            "location": 295,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ord.true_fn": {
            "name": "true_fn",
            "location": 327,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ord.false_fn": {
            "name": "false_fn",
            "location": 330,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_ohe_to_num.true_fn": {
            "name": "true_fn",
            "location": 369,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_ohe_to_num.false_fn": {
            "name": "false_fn",
            "location": 373,
            "return": [],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ohe.true_fn": {
            "name": "true_fn",
            "location": 407,
            "return": [
                "int",
                "bytes",
                "str"
            ],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ohe.false_fn": {
            "name": "false_fn",
            "location": 412,
            "return": [
                "dict",
                "str",
                "IO[str]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "CounterfactualProto.__init__.body_num_to_ohe.while_ohe": {
            "name": "while_ohe",
            "location": 418,
            "return": [
                "List[str]",
                "str",
                "Iterable[T]",
                "float",
                "int",
                "List[\"DictDataLoader\"]",
                "type"
            ],
            "arguments": {
                "i_ohe": [
                    "int",
                    "bool",
                    "float"
                ],
                "i_ohe_cat": [
                    "int",
                    "List[int]",
                    "Optional[str]",
                    "Dict[str, int]",
                    "bool"
                ],
                "adv_ohe": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "CounterfactualProto.__init__.body_num_to_ohe.body_ohe": {
            "name": "body_ohe",
            "location": 421,
            "return": [
                "List",
                "float",
                "int",
                "List[numpy.array]"
            ],
            "arguments": {
                "i_ohe": [
                    "int",
                    "Optional[int]",
                    "Dict[int, List[Any]]",
                    "raiden.utils.Address.Hex"
                ],
                "i_ohe_cat": [
                    "Optional[int]",
                    "int",
                    "Dict[int, List[Any]]",
                    "raiden.utils.Address.Hex"
                ],
                "adv_ohe": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cfrl_base.py": {
        "NormalActionNoise.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mu": [
                    "int",
                    "apistar.interfaces.Router",
                    "bool",
                    "float"
                ],
                "sigma": [
                    "int",
                    "apistar.interfaces.Router",
                    "bool",
                    "float"
                ]
            }
        },
        "NormalActionNoise.__call__": {
            "name": "__call__",
            "location": 51,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "int",
                    "Sequence[str]",
                    "numpy.ndarray"
                ]
            }
        },
        "NormalActionNoise.__repr__": {
            "name": "__repr__",
            "location": 66,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ReplayBuffer.__init__": {
            "name": "__init__",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "size": [
                    "int",
                    "bytes"
                ]
            }
        },
        "ReplayBuffer.append": {
            "name": "append",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "numpy.ndarray",
                    "raiden.utils.TokenAmount"
                ],
                "Y_m": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Optional[float]",
                    "bytes"
                ],
                "Y_t": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Optional[float]",
                    "bytes"
                ],
                "Z": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "Z_cf_tilde": [
                    "int",
                    "float",
                    "Optional[int]"
                ],
                "C": [
                    "float",
                    "bool"
                ],
                "R_tilde": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "ReplayBuffer.sample": {
            "name": "sample",
            "location": 172,
            "return": [
                "Dict[Text,None]",
                "bool",
                "Optional[str]",
                "logging.LogRecord",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CounterfactualRL.__init__": {
            "name": "__init__",
            "location": 332,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "Union[int, str]",
                    "int"
                ],
                "encoder": [
                    "str",
                    "Union[int, str]",
                    "int"
                ],
                "decoder": [
                    "str",
                    "Union[int, str]",
                    "int"
                ],
                "coeff_sparsity": [
                    "str",
                    "Union[int, str]",
                    "int"
                ],
                "coeff_consistency": [
                    "str",
                    "Union[int, str]",
                    "int"
                ],
                "latent_dim": [
                    "None",
                    "str",
                    "Union[int,str]",
                    "int"
                ],
                "backend": [
                    "Text",
                    "Dict",
                    "int",
                    "Dict[str,str]"
                ],
                "seed": [
                    "int",
                    "str",
                    "Dict[str,object]",
                    "List[str]",
                    "Callable[[str],None]"
                ]
            }
        },
        "CounterfactualRL._serialize_params": {
            "name": "_serialize_params",
            "location": 411,
            "return": [
                "Dict",
                "int",
                "Dict[,list]",
                "Callable",
                "str"
            ],
            "arguments": {
                "params": [
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "Dict[str, Dict[str, int]]",
                    "Optional[Dict[str, Any]]",
                    "Dict[str, str]"
                ]
            }
        },
        "CounterfactualRL._get_name": {
            "name": "_get_name",
            "location": 445,
            "return": [
                "str",
                "Optional[str]",
                "Text"
            ],
            "arguments": {
                "a": []
            }
        },
        "CounterfactualRL._verify_backend": {
            "name": "_verify_backend",
            "location": 468,
            "return": [
                "None"
            ],
            "arguments": {
                "backend": [
                    "bytes"
                ]
            }
        },
        "CounterfactualRL._select_backend": {
            "name": "_select_backend",
            "location": 488,
            "return": [
                "str",
                "torch.Tensor",
                "Iterable[int]",
                "float"
            ],
            "arguments": {
                "self": [],
                "backend": [
                    "bytes"
                ]
            }
        },
        "CounterfactualRL._validate_kwargs": {
            "name": "_validate_kwargs",
            "location": 501,
            "return": [
                "Dict[Text,]",
                "float",
                "int",
                "str",
                "IO[Any]",
                "Dict[str,bool]"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ],
                "encoder": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ],
                "decoder": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ],
                "latent_dim": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ],
                "coeff_sparsity": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ],
                "coeff_consistency": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ],
                "backend": [
                    "dict",
                    "Dict[str, Any]",
                    "int"
                ],
                "seed": [
                    "Dict[str, Any]",
                    "int",
                    "dict"
                ]
            }
        },
        "CounterfactualRL.load": {
            "name": "load",
            "location": 603,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "Tuple[str]"
                ],
                "path": [
                    "str"
                ],
                "predictor": [
                    "str"
                ]
            }
        },
        "CounterfactualRL.reset_predictor": {
            "name": "reset_predictor",
            "location": 606,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "CounterfactualRL.save": {
            "name": "save",
            "location": 618,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "CounterfactualRL.fit": {
            "name": "fit",
            "location": 621,
            "return": [
                "CounterfactualRL",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bytes",
                    "torch.nn.Module",
                    "bool",
                    "dict",
                    "torch.Tensor"
                ]
            }
        },
        "CounterfactualRL._validate_target": {
            "name": "_validate_target",
            "location": 750,
            "return": [
                "None"
            ],
            "arguments": {
                "Y_t": [
                    "int",
                    "Optional[int]",
                    "Optional[str]",
                    "Optional[numpy.array]",
                    "List[int]",
                    "list"
                ]
            }
        },
        "CounterfactualRL._validate_condition": {
            "name": "_validate_condition",
            "location": 766,
            "return": [
                "None"
            ],
            "arguments": {
                "C": [
                    "Set[str]",
                    "int",
                    "str"
                ]
            }
        },
        "CounterfactualRL._is_classification": {
            "name": "_is_classification",
            "location": 779,
            "return": [
                "bool",
                "str",
                "numpy.ndarray",
                "int"
            ],
            "arguments": {
                "pred": [
                    "str",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "CounterfactualRL.explain": {
            "name": "explain",
            "location": 794,
            "return": [
                "Tuple[str, str]",
                "str",
                "qutebrowser.utils.usertypes.Backend",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "List[str]",
                    "Optional[Sequence]",
                    "float",
                    "torch.Tensor",
                    "tensorflow.Tensor",
                    "int"
                ],
                "Y_t": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "torch.Tensor"
                ],
                "C": [
                    "None",
                    "Optional[int]",
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "bool"
                ]
            }
        },
        "CounterfactualRL._compute_counterfactual": {
            "name": "_compute_counterfactual",
            "location": 870,
            "return": [
                "Dict[Text,]",
                "bool",
                "Optional[str]",
                "logging.LogRecord",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "Y_t": [
                    "int",
                    "List[int]",
                    "numpy.ndarray"
                ],
                "C": [
                    "None",
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "Optional[int]",
                    "torch.Tensor",
                    "slice"
                ]
            }
        },
        "CounterfactualRL._build_explanation": {
            "name": "_build_explanation",
            "location": 960,
            "return": [
                "Explanation",
                "int",
                "bool",
                "cmk.utils.type_defs.EventRule",
                "bytes",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "List[float]"
                ],
                "Y_m": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "List[float]"
                ],
                "X_cf": [
                    "bool",
                    "str",
                    "dict",
                    "Dict[str, List[str]]",
                    "Dict[str, Any]",
                    "float"
                ],
                "Y_m_cf": [
                    "bool",
                    "str",
                    "dict",
                    "Dict[str, List[str]]",
                    "Dict[str, Any]",
                    "float"
                ],
                "Y_t": [
                    "int",
                    "str",
                    "List[str]",
                    "float",
                    "interfaces.message.LoadedMessageInterface"
                ],
                "C": [
                    "str",
                    "int",
                    "Dict[str, str]",
                    "bytes"
                ]
            }
        },
        "Postprocessing.__call__": {
            "name": "__call__",
            "location": 1009,
            "return": [
                "Any",
                "None"
            ],
            "arguments": {
                "self": [],
                "X_cf": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "List[Tuple]",
                    "Callable"
                ],
                "X": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "List[Tuple]",
                    "Callable"
                ],
                "C": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "List[Tuple]",
                    "Callable"
                ]
            }
        },
        "Callback.__call__": {
            "name": "__call__",
            "location": 1039,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "step": [
                    "bool",
                    "List[Tuple[str, str]]",
                    "Sequence[dict]",
                    "list",
                    "List[str]"
                ],
                "update": [
                    "bool",
                    "List[Tuple[str, str]]",
                    "Sequence[dict]",
                    "list",
                    "List[str]"
                ],
                "model": [
                    "bool",
                    "List[Tuple[str, str]]",
                    "Sequence[dict]",
                    "list",
                    "List[str]"
                ],
                "sample": [
                    "bool",
                    "List[Tuple[str, str]]",
                    "Sequence[dict]",
                    "list",
                    "List[str]"
                ],
                "losses": [
                    "bool",
                    "List[Tuple[str, str]]",
                    "Sequence[dict]",
                    "list",
                    "List[str]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/cfrl_tabular.py": {
        "SampleTabularPostprocessing.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "category_map": [
                    "int",
                    "apistar.interfaces.Router",
                    "bool",
                    "float"
                ],
                "stats": [
                    "int",
                    "apistar.interfaces.Router",
                    "bool",
                    "float"
                ]
            }
        },
        "SampleTabularPostprocessing.__call__": {
            "name": "__call__",
            "location": 54,
            "return": [
                "Tuple[Tuple[int, Any]]",
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "X_cf": [
                    "numpy.ndarray",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "torch.Tensor",
                    "int",
                    "float",
                    "Callable"
                ],
                "X": [
                    "numpy.ndarray",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "torch.Tensor",
                    "int",
                    "float",
                    "Callable"
                ],
                "C": [
                    "numpy.ndarray",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "torch.Tensor",
                    "int",
                    "float",
                    "Callable"
                ]
            }
        },
        "ConcatTabularPostprocessing.__call__": {
            "name": "__call__",
            "location": 82,
            "return": [
                "numpy.ndarray",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "X_cf": [
                    "int",
                    "Dict[str, Any]",
                    "numpy.ndarray",
                    "Container",
                    "float",
                    "Union[int, float]"
                ],
                "X": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "List[Tuple]",
                    "Callable"
                ],
                "C": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "List[Tuple]",
                    "Callable"
                ]
            }
        },
        "CounterfactualRLTabular.__init__": {
            "name": "__init__",
            "location": 109,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "torch.Tensor",
                    "str"
                ],
                "encoder": [
                    "torch.Tensor",
                    "str"
                ],
                "decoder": [
                    "torch.Tensor",
                    "str"
                ],
                "encoder_preprocessor": [
                    "int",
                    "apistar.interfaces.Router",
                    "bool",
                    "float"
                ],
                "decoder_inv_preprocessor": [
                    "int",
                    "apistar.interfaces.Router",
                    "bool",
                    "float"
                ],
                "coeff_sparsity": [
                    "torch.Tensor",
                    "str"
                ],
                "coeff_consistency": [
                    "torch.Tensor",
                    "str"
                ],
                "feature_names": [
                    "Dict[str, Any]",
                    "pymap.interfaces.backend.BackendInterface",
                    "str",
                    "dict"
                ],
                "category_map": [
                    "bytes",
                    "dict"
                ],
                "immutable_features": [
                    "None",
                    "int",
                    "str",
                    "Dict[str,str]"
                ],
                "ranges": [
                    "None",
                    "int",
                    "bool"
                ],
                "weight_num": [
                    "float",
                    "Optional[cmk.utils.type_defs.HostAddress]",
                    "str"
                ],
                "weight_cat": [
                    "float",
                    "rl_algorithms.utils.config.ConfigDict",
                    "Callable"
                ],
                "latent_dim": [
                    "None",
                    "torch.Tensor",
                    "str"
                ],
                "backend": [
                    "Text",
                    "torch.Tensor",
                    "str"
                ],
                "seed": [
                    "int",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "CounterfactualRLTabular._select_backend": {
            "name": "_select_backend",
            "location": 229,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "backend": [
                    "cmk.utils.type_defs.HostName",
                    "cmk.utils.type_defs.ServiceName",
                    "Callable"
                ]
            }
        },
        "CounterfactualRLTabular._validate_input": {
            "name": "_validate_input",
            "location": 240,
            "return": [
                "str",
                "utils.Node"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "CounterfactualRLTabular.fit": {
            "name": "fit",
            "location": 259,
            "return": [
                "bool",
                "utils.Node",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "bool"
                ]
            }
        },
        "CounterfactualRLTabular.explain": {
            "name": "explain",
            "location": 281,
            "return": [
                "float",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]"
                ],
                "Y_t": [
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "C": [
                    "int",
                    "numpy.ndarray",
                    "str",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]"
                ],
                "diversity": [
                    "bool",
                    "torch.Tensor",
                    "int",
                    "float"
                ],
                "num_samples": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]"
                ],
                "patience": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]"
                ],
                "tolerance": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Optional[int]"
                ]
            }
        },
        "CounterfactualRLTabular._diversity": {
            "name": "_diversity",
            "location": 390,
            "return": [
                "bytes",
                "str",
                "Tuple[str, str]",
                "qutebrowser.utils.usertypes.Backend"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "Optional[Union[int, slice]]",
                    "int",
                    "list"
                ],
                "Y_t": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytearray",
                    "str"
                ],
                "C": [
                    "numpy.ndarray",
                    "Optional[int]",
                    "Optional[numpy.ndarray]",
                    "Callable",
                    "raiden.utils.Callable",
                    "tensorflow.Tensor"
                ],
                "num_samples": [
                    "int",
                    "numpy.ndarray",
                    "Union[int,None]",
                    "Union[str,Tuple[str,str]]",
                    "Optional[int]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "str",
                    "numpy.ndarray",
                    "Sequence",
                    "bool"
                ],
                "patience": [
                    "int",
                    "Union[float,None]",
                    "str",
                    "Union[Tuple[int,float],None]",
                    "Union[str,None]",
                    "Union[numpy.ndarray,List[numpy.ndarray]]",
                    "Optional[int]"
                ],
                "tolerance": [
                    "float",
                    "Optional[int]",
                    "int",
                    "bool",
                    "utils.times.Seconds"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/counterfactual.py": {
        "_define_func": {
            "name": "_define_func",
            "location": 15,
            "return": [
                "Tuple[Text]",
                "Union[numbers.Real,numpy.ndarray]",
                "str",
                "Callable[[KT],VT]"
            ],
            "arguments": {
                "predict_fn": [
                    "int",
                    "Callable",
                    "type",
                    "str",
                    "Type['Model']",
                    "Dict[str, Any]",
                    "float"
                ],
                "pred_class": [
                    "int",
                    "Callable",
                    "type",
                    "str",
                    "Type['Model']",
                    "Dict[str, Any]",
                    "float"
                ],
                "target_class": [
                    "Text",
                    "Union[str,int]",
                    "int"
                ]
            }
        },
        "CounterFactual": {
            "name": "CounterFactual",
            "location": 64,
            "return": [
                "bool",
                "Counterfactual"
            ],
            "arguments": {}
        },
        "_define_func.func": {
            "name": "func",
            "location": 39,
            "return": [],
            "arguments": {
                "X": []
            }
        },
        "Counterfactual.__init__": {
            "name": "__init__",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predict_fn": [
                    "str",
                    "List[float]",
                    "bool"
                ],
                "shape": [
                    "bool",
                    "float"
                ],
                "distance_fn": [
                    "Text",
                    "str",
                    "List[str]"
                ],
                "target_proba": [
                    "float",
                    "int",
                    "bool"
                ],
                "target_class": [
                    "Text",
                    "bool",
                    "str",
                    "List[Tuple[str,Any]]"
                ],
                "max_iter": [
                    "int",
                    "Optional[int]",
                    "float",
                    "str"
                ],
                "early_stop": [
                    "int",
                    "Callable",
                    "bool",
                    "float",
                    "Union[float,Tuple[float,float]]",
                    "Dict[str,Any]"
                ],
                "lam_init": [
                    "float",
                    "Callable",
                    "bool",
                    "int",
                    "Union[float,Tuple[float,float]]",
                    "Dict[str,Any]"
                ],
                "max_lam_steps": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Dict[str,str]"
                ],
                "tol": [
                    "float",
                    "Callable",
                    "bool",
                    "int",
                    "Union[float,Tuple[float,float]]",
                    "Dict[str,Any]"
                ],
                "learning_rate_init": [
                    "float",
                    "int",
                    "raiden.utils.TokenAmount",
                    "Callable[[numpy.ndarray,numpy.ndarray],float]",
                    "str"
                ],
                "feature_range": [
                    "Tuple[float]",
                    "Mapping[str,Tuple[float,float,float]]",
                    "str"
                ],
                "eps": [
                    "float",
                    "Callable",
                    "bool",
                    "int",
                    "Union[float,Tuple[float,float]]",
                    "Dict[str,Any]"
                ],
                "init": [
                    "Text",
                    "Callable",
                    "bool",
                    "int",
                    "float",
                    "Union[float,Tuple[float,float]]",
                    "Dict[str,Any]"
                ],
                "decay": [
                    "bool",
                    "Tuple[str,int]",
                    "int"
                ],
                "write_dir": [
                    "None",
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "bool"
                ],
                "debug": [
                    "bool",
                    "Callable",
                    "int",
                    "float",
                    "Union[float,Tuple[float,float]]",
                    "Dict[str,Any]"
                ],
                "sess": [
                    "None",
                    "str",
                    "List",
                    "Dict[str,Set[str]]",
                    "bool"
                ]
            }
        },
        "Counterfactual._initialize": {
            "name": "_initialize",
            "location": 291,
            "return": [
                "bool",
                "str",
                "utils.Node"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "Counterfactual.fit": {
            "name": "fit",
            "location": 302,
            "return": [
                "Counterfactual",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ],
                "y": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "Counterfactual.explain": {
            "name": "explain",
            "location": 325,
            "return": [
                "Explanation",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "Counterfactual._prob_condition": {
            "name": "_prob_condition",
            "location": 378,
            "return": [
                "bool",
                "str",
                "List[str]",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "X_current": [
                    "int",
                    "str",
                    "MutableMapping[str, Any]"
                ]
            }
        },
        "Counterfactual._update_exp": {
            "name": "_update_exp",
            "location": 381,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "i": [
                    "int",
                    "float",
                    "str",
                    "Mapping"
                ],
                "l_step": [
                    "int",
                    "bool",
                    "float",
                    "bytearray"
                ],
                "lam": [
                    "List[Dict[str, Any]]",
                    "Dict[str, int]",
                    "int",
                    "bool",
                    "Dict[str, Any]",
                    "bytes"
                ],
                "cf_found": [
                    "bool",
                    "float",
                    "int"
                ],
                "X_current": [
                    "Dict[str, Any]",
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "Counterfactual._write_tb": {
            "name": "_write_tb",
            "location": 410,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lam": [
                    "int",
                    "List[int]",
                    "bool",
                    "numpy.ndarray",
                    "float"
                ],
                "lam_lb": [
                    "bool",
                    "Hashable",
                    "float",
                    "Set[str]",
                    "Dict[str, Set[str]]"
                ],
                "lam_ub": [
                    "bool",
                    "Hashable",
                    "float",
                    "Set[str]",
                    "Dict[str, Set[str]]"
                ],
                "cf_found": [
                    "bool",
                    "Hashable",
                    "float",
                    "Set[str]",
                    "Dict[str, Set[str]]"
                ],
                "X_current": [
                    "str",
                    "bool",
                    "Type",
                    "Hashable"
                ]
            }
        },
        "Counterfactual._bisect_lambda": {
            "name": "_bisect_lambda",
            "location": 451,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "cf_found": [
                    "int",
                    "str",
                    "dict",
                    "Optional[float]"
                ],
                "l_step": [
                    "int",
                    "str",
                    "dict",
                    "Optional[float]"
                ],
                "lam": [
                    "str",
                    "dict",
                    "int",
                    "bool",
                    "numpy.ndarray"
                ],
                "lam_lb": [
                    "int",
                    "str",
                    "dict",
                    "Dict[str, int]"
                ],
                "lam_ub": [
                    "int",
                    "str",
                    "logging.Logger"
                ]
            }
        },
        "Counterfactual._minimize_loss": {
            "name": "_minimize_loss",
            "location": 478,
            "return": [
                "None",
                "Union[tuple,list]",
                "List[int]",
                "Dict[str,Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "numpy.ndarray",
                    "int"
                ],
                "X_init": [
                    "numpy.ndarray",
                    "str",
                    "Container",
                    "int",
                    "float"
                ],
                "Y": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "Counterfactual.reset_predictor": {
            "name": "reset_predictor",
            "location": 631,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/integrated_gradients.py": {
        "_compute_convergence_delta": {
            "name": "_compute_convergence_delta",
            "location": 19,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "int",
                    "float",
                    "Union[int, str]"
                ],
                "input_dtypes": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "str"
                ],
                "attributions": [
                    "int",
                    "List[int]",
                    "str",
                    "Sized",
                    "numpy.ndarray",
                    "List[float]",
                    "List[List[int]]"
                ],
                "start_point": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "bool",
                    "raiden.utils.BlockIdentifier"
                ],
                "end_point": [
                    "str",
                    "int",
                    "numpy.ndarray",
                    "bool"
                ],
                "forward_kwargs": [
                    "int",
                    "float",
                    "Union[int, str]"
                ],
                "target": [
                    "int",
                    "float",
                    "Union[int, str]"
                ],
                "_is_list": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "str"
                ]
            }
        },
        "_select_target": {
            "name": "_select_target",
            "location": 98,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "preds": [
                    "List['cirq.Qid']",
                    "int"
                ],
                "targets": [
                    "Dict[str, Any]",
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "_run_forward": {
            "name": "_run_forward",
            "location": 129,
            "return": [
                "str",
                "int",
                "bool",
                "list"
            ],
            "arguments": {
                "model": [
                    "numpy.ndarray",
                    "Optional[Dict[str, numpy.ma.MaskedArray]]",
                    "tensorflow.Tensor",
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']",
                    "Optional[Exception]",
                    "utils.Node"
                ],
                "x": [
                    "numpy.ndarray",
                    "Union[tensorflow.Tensor, numpy.ndarray]",
                    "int",
                    "tensorflow.Tensor",
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']",
                    "bool"
                ],
                "target": [
                    "float",
                    "int",
                    "dict"
                ],
                "forward_kwargs": [
                    "Optional[numpy.ndarray]",
                    "Optional[numpy.array]",
                    "int",
                    "Optional[Exception]"
                ]
            }
        },
        "_run_forward_from_layer": {
            "name": "_run_forward_from_layer",
            "location": 163,
            "return": [
                "Dict[str, Any]",
                "bool",
                "str"
            ],
            "arguments": {
                "model": [
                    "numpy.ndarray",
                    "Union[int, str]",
                    "int",
                    "Optional[bool]",
                    "bool"
                ],
                "layer": [
                    "bool",
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "str",
                    "Optional[float]"
                ],
                "orig_call": [
                    "dict",
                    "bool",
                    "Callable",
                    "int",
                    "float",
                    "str"
                ],
                "orig_dummy_input": [
                    "numpy.ndarray",
                    "bool",
                    "str",
                    "tensorflow.keras.Model",
                    "float",
                    "Optional[float]"
                ],
                "x": [
                    "bool",
                    "str",
                    "List[cmk.gui.plugins.views.utils.Sorter.Entry]"
                ],
                "target": [
                    "bool",
                    "List[cmk.gui.plugins.views.utils.Cell]",
                    "str",
                    "int"
                ],
                "forward_kwargs": [
                    "bool",
                    "Optional[bool]",
                    "Callable[[Type, str], bool]",
                    "Optional['Entity']",
                    "Optional[List[Any]]",
                    "List[str]",
                    "Optional[str]"
                ],
                "run_from_layer_inputs": [
                    "bool",
                    "str",
                    "List[cmk.gui.plugins.views.utils.Sorter.Entry]"
                ],
                "select_target": [
                    "int",
                    "Set[str]"
                ]
            }
        },
        "_run_forward_to_layer": {
            "name": "_run_forward_to_layer",
            "location": 243,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "model": [
                    "List[Dict[str, Any]]",
                    "str",
                    "Union[AsyncIterable[Any], Iterable[Any]]"
                ],
                "layer": [
                    "bool",
                    "Optional[cirq.google.api.v2.device_pb2.DeviceSpecification]",
                    "Optional[Dict[str, int]]",
                    "float",
                    "List[str]"
                ],
                "orig_call": [
                    "str",
                    "int",
                    "float",
                    "Optional[str]"
                ],
                "x": [
                    "List[Dict[str, Any]]",
                    "str",
                    "Union[AsyncIterable[Any], Iterable[Any]]"
                ],
                "forward_kwargs": [
                    "List[Dict[str, Any]]",
                    "str",
                    "Union[AsyncIterable[Any], Iterable[Any]]"
                ],
                "run_to_layer_inputs": [
                    "Optional[List[str]]",
                    "bool",
                    "List[str]",
                    "str"
                ]
            }
        },
        "_forward_input_baseline": {
            "name": "_forward_input_baseline",
            "location": 309,
            "return": [
                "int",
                "List[int]",
                "str",
                "bool",
                "Union[str, bool, None]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "recidiviz.calculator.pipeline.utils.time_range_utils.TimeRange",
                    "float"
                ],
                "bls": [
                    "Union[int, str]",
                    "Optional[int]",
                    "Optional[bool]",
                    "int"
                ],
                "model": [
                    "int",
                    "float",
                    "bool"
                ],
                "layer": [
                    "Optional[Dict[str, numpy.ma.MaskedArray]]",
                    "int",
                    "Optional[numpy.ndarray]",
                    "bool",
                    "numpy.ndarray"
                ],
                "orig_call": [
                    "int",
                    "float",
                    "bool"
                ],
                "forward_kwargs": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "Optional[int]",
                    "bool"
                ],
                "forward_to_inputs": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "_gradients_input": {
            "name": "_gradients_input",
            "location": 370,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "int",
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']",
                    "numpy.ndarray",
                    "list"
                ],
                "x": [
                    "Sequence[Mapping]",
                    "Dict[str, int]"
                ],
                "target": [
                    "int",
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']",
                    "numpy.ndarray",
                    "list"
                ],
                "forward_kwargs": [
                    "Optional[Dict[str, numpy.ma.MaskedArray]]",
                    "Optional[numpy.ndarray]",
                    "bool",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "_gradients_layer": {
            "name": "_gradients_layer",
            "location": 405,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "model": [
                    "str",
                    "float",
                    "bool",
                    "Dict[str, int]",
                    "int"
                ],
                "layer": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "float"
                ],
                "orig_call": [
                    "int",
                    "Callable",
                    "dict",
                    "bool",
                    "str"
                ],
                "orig_dummy_input": [
                    "int"
                ],
                "x": [
                    "float",
                    "numpy.ndarray"
                ],
                "target": [
                    "str",
                    "float",
                    "bool",
                    "Dict[str, int]",
                    "int"
                ],
                "forward_kwargs": [
                    "Optional[int]"
                ],
                "compute_layer_inputs_gradients": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "_format_baseline": {
            "name": "_format_baseline",
            "location": 507,
            "return": [
                "str",
                "int",
                "List[List[str]]",
                "tuple"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray",
                    "tensorflow.Tensor",
                    "float"
                ],
                "baselines": [
                    "Optional[int]",
                    "int",
                    "numpy.ndarray",
                    "Union[None, str, int, float]",
                    "Optional[str]"
                ]
            }
        },
        "_format_target": {
            "name": "_format_target",
            "location": 536,
            "return": [
                "str",
                "int",
                "List[List[str]]",
                "tuple"
            ],
            "arguments": {
                "target": [
                    "Optional[int]",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "nb_samples": [
                    "int",
                    "List[int]",
                    "str"
                ]
            }
        },
        "_check_target": {
            "name": "_check_target",
            "location": 566,
            "return": [
                "None"
            ],
            "arguments": {
                "output_shape": [
                    "str",
                    "int",
                    "bytes",
                    "tuple"
                ],
                "target": [
                    "Optional[str]",
                    "str",
                    "Optional[float]",
                    "Optional[bool]"
                ],
                "nb_samples": [
                    "str",
                    "bytes",
                    "BinaryIO"
                ]
            }
        },
        "_get_target_from_target_fn": {
            "name": "_get_target_from_target_fn",
            "location": 631,
            "return": [
                "str",
                "bytes",
                "int"
            ],
            "arguments": {
                "target_fn": [
                    "int",
                    "str",
                    "List[str]",
                    "Sequence[Any]",
                    "numpy.ndarray"
                ],
                "model": [
                    "int",
                    "numpy.ndarray",
                    "Union[int, str]"
                ],
                "X": [
                    "int",
                    "numpy.ndarray",
                    "Union[int, str]"
                ],
                "forward_kwargs": [
                    "Optional[float]",
                    "Optional[bool]",
                    "Optional[Dict[str, str]]",
                    "numpy.ndarray"
                ]
            }
        },
        "_sum_integral_terms": {
            "name": "_sum_integral_terms",
            "location": 675,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "step_sizes": [
                    "int",
                    "float"
                ],
                "grads": [
                    "int",
                    "str",
                    "list",
                    "Tuple[str, str]"
                ]
            }
        },
        "_calculate_sum_int": {
            "name": "_calculate_sum_int",
            "location": 705,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "batches": [
                    "int",
                    "Optional[bool]",
                    "float",
                    "bool",
                    "str"
                ],
                "model": [
                    "Optional[int]",
                    "Any",
                    "str"
                ],
                "target": [
                    "Optional[int]",
                    "Any",
                    "str"
                ],
                "target_paths": [
                    "str",
                    "int"
                ],
                "n_steps": [
                    "int",
                    "Optional[bool]",
                    "float",
                    "bool",
                    "str"
                ],
                "nb_samples": [
                    "int",
                    "Optional[bool]",
                    "float",
                    "bool",
                    "str"
                ],
                "step_sizes": [
                    "int",
                    "Optional[int]"
                ],
                "j": [
                    "int",
                    "Optional[bool]",
                    "float",
                    "bool",
                    "str"
                ]
            }
        },
        "_validate_output": {
            "name": "_validate_output",
            "location": 756,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "int",
                    "list"
                ],
                "target": [
                    "int",
                    "raiden.utils.Address"
                ]
            }
        },
        "_compute_convergence_delta._sum_rows": {
            "name": "_sum_rows",
            "location": 63,
            "return": [
                "[[]]",
                "int",
                "float",
                "List[int]",
                "Union[bool, None]"
            ],
            "arguments": {
                "inp": [
                    "int",
                    "list",
                    "str",
                    "bool"
                ]
            }
        },
        "_run_forward_from_layer.feed_layer": {
            "name": "feed_layer",
            "location": 206,
            "return": [],
            "arguments": {
                "layer": [
                    "str",
                    "int"
                ]
            }
        },
        "_run_forward_to_layer.take_layer": {
            "name": "take_layer",
            "location": 275,
            "return": [],
            "arguments": {
                "layer": [
                    "str",
                    "int"
                ]
            }
        },
        "_gradients_layer.watch_layer": {
            "name": "watch_layer",
            "location": 442,
            "return": [],
            "arguments": {
                "layer": [
                    "str",
                    "int"
                ],
                "tape": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "IntegratedGradients.__init__": {
            "name": "__init__",
            "location": 784,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "Optional[float]",
                    "bool"
                ],
                "layer": [
                    "Optional[int]",
                    "Optional[float]",
                    "bool",
                    "Optional[List[int]]"
                ],
                "target_fn": [
                    "int",
                    "float",
                    "bool"
                ],
                "method": [
                    "bool",
                    "int",
                    "Iterator[numpy.ndarray]",
                    "Optional[\"GraphLogger\"]"
                ],
                "n_steps": [
                    "bool",
                    "int",
                    "Iterator[numpy.ndarray]",
                    "Optional[\"GraphLogger\"]"
                ],
                "internal_batch_size": [
                    "int",
                    "bool",
                    "float",
                    "Tuple[int]"
                ]
            }
        },
        "IntegratedGradients.explain": {
            "name": "explain",
            "location": 854,
            "return": [
                "qutebrowser.utils.usertypes.Backend",
                "bytes",
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "int",
                    "List[Dict[str, str]]",
                    "List[List[Any]]"
                ],
                "forward_kwargs": [
                    "int",
                    "Optional[float]",
                    "List[Dict[str, int]]",
                    "float"
                ],
                "baselines": [
                    "int",
                    "Callable"
                ],
                "target": [
                    "Optional[int]",
                    "float",
                    "Optional[qutebrowser.api.apitypes.Tab]"
                ],
                "attribute_to_layer_inputs": [
                    "numpy.ndarray",
                    "int",
                    "Tuple[int, int]",
                    "str",
                    "float",
                    "numpy.array"
                ]
            }
        },
        "IntegratedGradients._build_explanation": {
            "name": "_build_explanation",
            "location": 1071,
            "return": [
                "bool",
                "str",
                "bytearray",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']"
                ],
                "forward_kwargs": [
                    "List[numpy.ndarray]",
                    "Optional[Tuple]",
                    "Optional[numpy.ndarray]",
                    "Union[tensorflow.keras.models.Model, 'keras.models.Model']",
                    "Optional[Union[int, Any]]"
                ],
                "baselines": [
                    "numpy.ndarray",
                    "list",
                    "List[int]",
                    "Union[int, str]",
                    "Callable"
                ],
                "target": [
                    "numpy.ndarray",
                    "list",
                    "List[int]",
                    "Union[int, str]",
                    "Callable"
                ],
                "attributions": [
                    "Dict[str, Any]",
                    "List[Dict]",
                    "tensorflow.Tensor"
                ],
                "deltas": [
                    "numpy.ndarray",
                    "list",
                    "List[int]",
                    "Union[int, str]",
                    "Callable"
                ]
            }
        },
        "IntegratedGradients.reset_predictor": {
            "name": "reset_predictor",
            "location": 1094,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "IntegratedGradients._compute_attributions_list_input": {
            "name": "_compute_attributions_list_input",
            "location": 1106,
            "return": [
                "List[int]",
                "List[str]",
                "bytes",
                "bool",
                "Sequence[int]",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "numpy.ndarray",
                    "Iterable[float]"
                ],
                "baselines": [
                    "numpy.ndarray",
                    "Tuple[float, float]",
                    "int",
                    "bool"
                ],
                "target": [
                    "Optional[str]",
                    "str",
                    "Optional[numpy.ndarray]",
                    "int",
                    "Optional[Tuple]",
                    "bool",
                    "Optional[float]"
                ],
                "step_sizes": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Optional[int]",
                    "List[bytes]",
                    "List[str]"
                ],
                "alphas": [
                    "int",
                    "float"
                ],
                "nb_samples": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Optional[int]",
                    "List[bytes]",
                    "List[str]"
                ],
                "forward_kwargs": [
                    "numpy.ndarray",
                    "List[str]",
                    "List[List[Callable]]",
                    "Optional[Tuple[int, int]]",
                    "Optional[int]",
                    "Optional[numpy.ndarray]"
                ],
                "compute_layer_inputs_gradients": [
                    "int",
                    "raiden.utils.ChannelID",
                    "numpy.ndarray",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.TokenAmount"
                ]
            }
        },
        "IntegratedGradients._compute_attributions_tensor_input": {
            "name": "_compute_attributions_tensor_input",
            "location": 1231,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "numpy.ndarray"
                ],
                "baselines": [
                    "int",
                    "numpy.ndarray"
                ],
                "target": [
                    "Optional[int]",
                    "Optional[float]",
                    "Optional[numpy.ndarray]",
                    "Optional[dict]",
                    "Optional[Dict]"
                ],
                "step_sizes": [
                    "int",
                    "bool"
                ],
                "alphas": [
                    "int",
                    "numpy.ndarray"
                ],
                "nb_samples": [
                    "int",
                    "bool"
                ],
                "forward_kwargs": [
                    "numpy.ndarray",
                    "Optional[Dict[str, numpy.ma.MaskedArray]]",
                    "Optional[int]",
                    "Optional[Dict]"
                ],
                "compute_layer_inputs_gradients": [
                    "int",
                    "Optional[bool]",
                    "raiden.utils.TokenAmount",
                    "float"
                ]
            }
        },
        "_run_forward_from_layer.feed_layer.decorator": {
            "name": "decorator",
            "location": 212,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "_run_forward_to_layer.take_layer.decorator": {
            "name": "decorator",
            "location": 281,
            "return": [],
            "arguments": {
                "func": []
            }
        },
        "_gradients_layer.watch_layer.decorator": {
            "name": "decorator",
            "location": 452,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "func": [
                    "Callable",
                    "Callable[..., None]"
                ]
            }
        },
        "_run_forward_from_layer.feed_layer.decorator.wrapper": {
            "name": "wrapper",
            "location": 213,
            "return": [],
            "arguments": {}
        },
        "_run_forward_to_layer.take_layer.decorator.wrapper": {
            "name": "wrapper",
            "location": 282,
            "return": [],
            "arguments": {}
        },
        "_gradients_layer.watch_layer.decorator.wrapper": {
            "name": "wrapper",
            "location": 453,
            "return": [
                "List[int]",
                "Dict[str, int]",
                "List[dict]"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/shap_wrappers.py": {
        "rank_by_importance": {
            "name": "rank_by_importance",
            "location": 33,
            "return": [
                "Dict[str,dict[Text,list[str]]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "shap_values": [
                    "Optional[bool]",
                    "str",
                    "float",
                    "T",
                    "List[str]",
                    "int"
                ],
                "feature_names": [
                    "Union[List[str], Tuple[str], None]",
                    "str",
                    "int"
                ]
            }
        },
        "sum_categories": {
            "name": "sum_categories",
            "location": 109,
            "return": [
                "Optional[int]",
                "int",
                "trezor.utils.Writer",
                "float",
                "List[int]",
                "str"
            ],
            "arguments": {
                "values": [
                    "numpy.ndarray",
                    "int"
                ],
                "start_idx": [
                    "Sequence[int]",
                    "float",
                    "Optional[int]"
                ],
                "enc_feat_dim": [
                    "Sequence[int]",
                    "float",
                    "Optional[int]"
                ]
            }
        },
        "sum_categories._get_slices": {
            "name": "_get_slices",
            "location": 158,
            "return": [
                "List",
                "str",
                "bool"
            ],
            "arguments": {
                "start": [
                    "Sequence[int]",
                    "int"
                ],
                "dim": [
                    "Sequence[int]",
                    "int",
                    "float",
                    "pandas.Timestamp"
                ],
                "arr_trailing_dim": [
                    "int",
                    "numpy.ndarray",
                    "List[int]"
                ]
            }
        },
        "sum_categories._reduction": {
            "name": "_reduction",
            "location": 197,
            "return": [
                "bool",
                "pandas.DataFrame",
                "str"
            ],
            "arguments": {
                "arr": [
                    "int",
                    "VT"
                ],
                "axis": [
                    "int",
                    "VT"
                ],
                "indices": [
                    "None",
                    "int",
                    "VT"
                ]
            }
        },
        "KernelExplainerWrapper.__init__": {
            "name": "__init__",
            "location": 239,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KernelExplainerWrapper.get_explanation": {
            "name": "get_explanation",
            "location": 252,
            "return": [
                "Tuple",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "numpy.ndarray",
                    "numpy.array",
                    "float"
                ]
            }
        },
        "KernelExplainerWrapper.return_attribute": {
            "name": "return_attribute",
            "location": 276,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "KernelShap.__init__": {
            "name": "__init__",
            "location": 289,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "bool",
                    "str",
                    "dict",
                    "list",
                    "bytes"
                ],
                "link": [
                    "Text",
                    "str",
                    "IO",
                    "Dict[str,str]",
                    "Optional[str]"
                ],
                "feature_names": [
                    "None",
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Optional[str]"
                ],
                "categorical_names": [
                    "None",
                    "str",
                    "pandas.DataFrame",
                    "bool",
                    "Optional[str]"
                ],
                "task": [
                    "Text",
                    "str",
                    "Optional[str]"
                ],
                "seed": [
                    "None",
                    "bool",
                    "str",
                    "Dict",
                    "List",
                    "bytes"
                ],
                "distributed_opts": [
                    "List[str]",
                    "None"
                ]
            }
        },
        "KernelShap._check_inputs": {
            "name": "_check_inputs",
            "location": 373,
            "return": [
                "None",
                "Union[tuple,list]",
                "List[int]",
                "Dict[str,Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[shap.utils._legacy.Data, pandas.DataFrame, numpy.ndarray, scipy.sparse.spmatrix]",
                    "Optional[str]",
                    "bool",
                    "Dict[str, Any]",
                    "List[str]",
                    "List[utils.models.Base]"
                ],
                "group_names": [
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "List[dict]",
                    "list",
                    "dict",
                    "List[str]"
                ],
                "groups": [
                    "Optional[List[Any]]",
                    "pandas.DataFrame",
                    "str",
                    "Dict[str, Any]"
                ],
                "weights": [
                    "Optional[List[Any]]",
                    "str",
                    "List[str]",
                    "Tuple[int]",
                    "Dict[str, List[float]]",
                    "bool",
                    "Type[T]",
                    "list"
                ]
            }
        },
        "KernelShap._summarise_background": {
            "name": "_summarise_background",
            "location": 507,
            "return": [
                "shap_utils_@_Data",
                "raiden.utils.signer.Signer",
                "str",
                "Optional[float]",
                "bool",
                "Awaitable",
                "pymessagebus.api.CallNextMiddleware"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[shap.utils._legacy.Data, pandas.DataFrame, numpy.ndarray, scipy.sparse.spmatrix]",
                    "int",
                    "Union[pandas.DataFrame, numpy.ndarray]"
                ],
                "n_background_samples": [
                    "int",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "str"
                ]
            }
        },
        "KernelShap._get_data": {
            "name": "_get_data",
            "location": 549,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "dict",
                    "str",
                    "Union[shap.utils._legacy.Data, pandas.DataFrame, numpy.ndarray, scipy.sparse.spmatrix]",
                    "bytes",
                    "Dict[str, Any]"
                ],
                "group_names": [
                    "str",
                    "List[Dict[str, Any]]",
                    "bool",
                    "Optional[List[Dict]]",
                    "dict",
                    "Optional[str]"
                ],
                "groups": [
                    "str",
                    "List[Dict[str, Any]]",
                    "bool",
                    "Optional[List[Dict]]",
                    "dict",
                    "Optional[str]"
                ],
                "weights": [
                    "str",
                    "List[Dict[str, Any]]",
                    "bool",
                    "Optional[List[Dict]]",
                    "dict",
                    "Optional[str]"
                ]
            }
        },
        "KernelShap._": {
            "name": "_",
            "location": 658,
            "return": [
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "pandas.DataFrame",
                    "Optional[Dict]"
                ]
            }
        },
        "KernelShap.fit": {
            "name": "fit",
            "location": 676,
            "return": [
                "KernelShap",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "bool",
                    "str",
                    "numpy.ndarray",
                    "int"
                ],
                "summarise_background": [
                    "bool",
                    "str",
                    "int",
                    "float",
                    "Dict[str,Any]"
                ],
                "n_background_samples": [
                    "int",
                    "List[int]",
                    "raiden.utils.TokenAmount"
                ],
                "group_names": [
                    "None",
                    "Optional[str]",
                    "int",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "Optional[float]",
                    "Optional[bool]",
                    "bool",
                    "Dict[str,np.ndarray]"
                ],
                "groups": [
                    "str",
                    "Callable",
                    "List[str]",
                    "dict",
                    "Optional[str]",
                    "bool",
                    "Optional[Dict[str, float]]"
                ],
                "weights": [
                    "None",
                    "bool",
                    "str",
                    "float"
                ]
            }
        },
        "KernelShap.explain": {
            "name": "explain",
            "location": 787,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "int"
                ],
                "summarise_result": [
                    "bool",
                    "List",
                    "int",
                    "str",
                    "List[bool]",
                    "float"
                ],
                "cat_vars_start_idx": [
                    "None",
                    "List",
                    "int",
                    "str",
                    "List[bool]",
                    "float"
                ],
                "cat_vars_enc_dim": [
                    "None",
                    "List",
                    "int",
                    "str",
                    "List[bool]",
                    "float"
                ]
            }
        },
        "KernelShap._build_explanation": {
            "name": "_build_explanation",
            "location": 876,
            "return": [
                "Explanation",
                "bool",
                "str",
                "bytearray",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[int, float]",
                    "\"Span\"",
                    "pandas.DataFrame"
                ],
                "shap_values": [
                    "Optional[str]",
                    "str",
                    "Optional[Union[Any, Any]]",
                    "Dict[str, Any]",
                    "int"
                ],
                "expected_value": [
                    "List[float]",
                    "List[numpy.ndarray]",
                    "numpy.array",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "KernelShap._check_result_summarisation": {
            "name": "_check_result_summarisation",
            "location": 955,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "summarise_result": [
                    "bool",
                    "Dict[int, List[str]]",
                    "Dict[int, int]",
                    "str"
                ],
                "cat_vars_start_idx": [
                    "Sequence[int]",
                    "int"
                ],
                "cat_vars_enc_dim": [
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "KernelShap.reset_predictor": {
            "name": "reset_predictor",
            "location": 985,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "TreeShap.__init__": {
            "name": "__init__",
            "location": 1009,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "Optional[int]",
                    "Optional[str]",
                    "bool"
                ],
                "model_output": [
                    "Text",
                    "str",
                    "bytes",
                    "Optional[str]",
                    "Dict[str,Dict[str,str]]"
                ],
                "feature_names": [
                    "None",
                    "str",
                    "bool",
                    "int"
                ],
                "categorical_names": [
                    "None",
                    "str",
                    "bool",
                    "int"
                ],
                "task": [
                    "str",
                    "Text"
                ],
                "seed": [
                    "None",
                    "str",
                    "Optional[int]",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "TreeShap.fit": {
            "name": "fit",
            "location": 1107,
            "return": [
                "TreeShap",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "None",
                    "int",
                    "Dict",
                    "numpy.ndarray",
                    "List[Dict[str,Any]]",
                    "Tuple[pandas.DataFrame,pandas.DataFrame]",
                    "Position"
                ],
                "summarise_background": [
                    "bool",
                    "Optional[int]",
                    "str",
                    "Dict"
                ],
                "n_background_samples": [
                    "int",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "BinaryIO",
                    "List[str]"
                ]
            }
        },
        "TreeShap._check_inputs": {
            "name": "_check_inputs",
            "location": 1192,
            "return": [
                "None"
            ],
            "arguments": {
                "background_data": [
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Dict[str, Any]",
                    "int",
                    "dict",
                    "bytes"
                ]
            }
        },
        "TreeShap._summarise_background": {
            "name": "_summarise_background",
            "location": 1210,
            "return": [
                "logging.LogRecord",
                "int",
                "Optional[bool]",
                "Sequence[str]"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "int",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "str"
                ],
                "n_background_samples": [
                    "int",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "str"
                ]
            }
        },
        "TreeShap.explain": {
            "name": "explain",
            "location": 1231,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "Tuple[int, int]",
                    "dict",
                    "list",
                    "Optional[float]",
                    "int",
                    "numpy.ndarray"
                ],
                "y": [
                    "None",
                    "bool",
                    "Dict",
                    "int",
                    "str",
                    "IO",
                    "bytes",
                    "Callable[,None]"
                ],
                "interactions": [
                    "bool",
                    "int",
                    "str",
                    "Awaitable",
                    "Optional[bool]",
                    "Tuple[Any,int,Dict[str,str]]"
                ],
                "approximate": [
                    "bool",
                    "int",
                    "Tuple[int,int]",
                    "float",
                    "List[int]",
                    "List[float]"
                ],
                "check_additivity": [
                    "bool",
                    "int",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "tree_limit": [
                    "None",
                    "float",
                    "bool",
                    "List[Dict]",
                    "numpy.ndarray"
                ],
                "summarise_result": [
                    "bool",
                    "Optional[Sequence[int]]",
                    "Optional[numpy.ndarray]",
                    "int",
                    "Optional[Any]"
                ],
                "cat_vars_start_idx": [
                    "None",
                    "numpy.ndarray",
                    "SupportsFloat",
                    "bool",
                    "Optional[int]",
                    "float",
                    "Optional[numpy.ndarray]"
                ],
                "cat_vars_enc_dim": [
                    "None",
                    "numpy.ndarray",
                    "SupportsFloat",
                    "bool",
                    "Optional[int]",
                    "float",
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "TreeShap._xgboost_interactions": {
            "name": "_xgboost_interactions",
            "location": 1347,
            "return": [
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "TreeShap._check_interactions": {
            "name": "_check_interactions",
            "location": 1362,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "approximate": [
                    "MutableSet[T]",
                    "Dict[str, float]",
                    "Dict[str, Any]",
                    "int"
                ],
                "background_data": [
                    "Union[numpy.ndarray, pandas.DataFrame, None]",
                    "int",
                    "bytes",
                    "dict",
                    "Sequence"
                ],
                "y": [
                    "Optional[numpy.ndarray]",
                    "Dict[str, Any]",
                    "Optional[Tuple[int, int]]",
                    "Mapping",
                    "list",
                    "List[Dict]"
                ]
            }
        },
        "TreeShap._check_explainer_setup": {
            "name": "_check_explainer_setup",
            "location": 1407,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "Union[numpy.ndarray, pandas.DataFrame, None]",
                    "str",
                    "bytes",
                    "int"
                ],
                "model_output": [
                    "str",
                    "float",
                    "bytes",
                    "Iterable[T]",
                    "int"
                ],
                "y": [
                    "Optional[numpy.ndarray]",
                    "Optional[str]",
                    "Optional[float]",
                    "Optional[bool]",
                    "Dict[str, Callable]"
                ]
            }
        },
        "TreeShap._build_explanation": {
            "name": "_build_explanation",
            "location": 1457,
            "return": [
                "Explanation",
                "bool",
                "str",
                "bytearray",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float"
                ],
                "shap_output": [
                    "List[numpy.ndarray]",
                    "Tuple[int, Callable]",
                    "str",
                    "float"
                ],
                "expected_value": [
                    "List[float]",
                    "int",
                    "float",
                    "Union[\"GenericFixed\", \"Table\"]",
                    "numpy.ndarray"
                ]
            }
        },
        "TreeShap._check_result_summarisation": {
            "name": "_check_result_summarisation",
            "location": 1579,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "summarise_result": [
                    "bool",
                    "int",
                    "dict",
                    "Dict[str, Any]",
                    "Dict[str, Dict[str, str]]",
                    "Mapping[str, Any]"
                ],
                "cat_vars_start_idx": [
                    "Sequence[int]",
                    "int"
                ],
                "cat_vars_enc_dim": [
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "TreeShap.reset_predictor": {
            "name": "reset_predictor",
            "location": 1601,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/__init__.py": {},
    "alibi-master/alibi/explainers/anchors/anchor_base.py": {
        "AnchorBaseBeam.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "samplers": [
                    "int",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "AnchorBaseBeam._init_state": {
            "name": "_init_state",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "bytes",
                    "int",
                    "dict",
                    "bool",
                    "float",
                    "Optional[Iterable]",
                    "numpy.ndarray"
                ],
                "coverage_data": [
                    "int",
                    "Tuple[int, int]",
                    "Sequence[Mapping[str, Any]]",
                    "Union[int, float]",
                    "bool",
                    "List[FrozenSet[str]]"
                ]
            }
        },
        "AnchorBaseBeam._sort": {
            "name": "_sort",
            "location": 67,
            "return": [
                "tuple"
            ],
            "arguments": {
                "x": [
                    "tuple",
                    "commands.utils.types.FileList",
                    "List[str]",
                    "str"
                ],
                "allow_duplicates": [
                    "bool",
                    "List",
                    "str",
                    "float",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "AnchorBaseBeam.dup_bernoulli": {
            "name": "dup_bernoulli",
            "location": 89,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "p": [
                    "int",
                    "Optional[int]"
                ],
                "level": [
                    "int",
                    "float",
                    "Collection[int]"
                ],
                "n_iter": [
                    "int",
                    "str",
                    "bool",
                    "List"
                ]
            }
        },
        "AnchorBaseBeam.dlow_bernoulli": {
            "name": "dlow_bernoulli",
            "location": 121,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "p": [
                    "int",
                    "float",
                    "Optional[Tuple[int, int]]"
                ],
                "level": [
                    "int"
                ],
                "n_iter": [
                    "int",
                    "str",
                    "bool",
                    "List"
                ]
            }
        },
        "AnchorBaseBeam.compute_beta": {
            "name": "compute_beta",
            "location": 153,
            "return": [
                "str",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "n_features": [
                    "int",
                    "float"
                ],
                "t": [
                    "int",
                    "float"
                ],
                "delta": [
                    "int",
                    "float"
                ]
            }
        },
        "AnchorBaseBeam._get_coverage_samples": {
            "name": "_get_coverage_samples",
            "location": 175,
            "return": [
                "int",
                "bytes",
                "Dict[str, Any]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": [],
                "coverage_samples": [
                    "Callable[[T], List[T]]",
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "samplers": [
                    "None",
                    "bool",
                    "str",
                    "T",
                    "Dict"
                ]
            }
        },
        "AnchorBaseBeam.select_critical_arms": {
            "name": "select_critical_arms",
            "location": 197,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "means": [
                    "int",
                    "float",
                    "List[float]"
                ],
                "ub": [
                    "int",
                    "float",
                    "numpy.random.RandomState",
                    "list",
                    "Tuple[float, float]"
                ],
                "lb": [
                    "int",
                    "float",
                    "numpy.random.RandomState",
                    "list",
                    "Tuple[float, float]"
                ],
                "n_samples": [
                    "int",
                    "float",
                    "numpy.random.RandomState",
                    "list",
                    "Tuple[float, float]"
                ],
                "delta": [
                    "int",
                    "Sequence[T]",
                    "list"
                ],
                "top_n": [
                    "int",
                    "float",
                    "numpy.random.RandomState",
                    "list",
                    "Tuple[float, float]"
                ],
                "t": [
                    "int",
                    "Sequence[T]",
                    "list"
                ]
            }
        },
        "AnchorBaseBeam.kllucb": {
            "name": "kllucb",
            "location": 249,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "str",
                    "int",
                    "Sequence[Sequence[float]]",
                    "numpy.ndarray",
                    "bool",
                    "Sized",
                    "list",
                    "Dict[str, str]"
                ],
                "init_stats": [
                    "float",
                    "dict",
                    "bool",
                    "str",
                    "Iterator[numpy.ndarray]",
                    "int"
                ],
                "epsilon": [
                    "float",
                    "dict",
                    "bool",
                    "str",
                    "Iterator[numpy.ndarray]",
                    "int"
                ],
                "delta": [
                    "float",
                    "Tuple[int]",
                    "numpy.ndarray",
                    "int"
                ],
                "batch_size": [
                    "float",
                    "dict",
                    "bool",
                    "str",
                    "Iterator[numpy.ndarray]",
                    "int"
                ],
                "top_n": [
                    "int",
                    "float",
                    "list",
                    "bool"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "Optional[int]",
                    "Tuple[int,int]"
                ],
                "verbose_every": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Tuple[int,int]"
                ]
            }
        },
        "AnchorBaseBeam.draw_samples": {
            "name": "draw_samples",
            "location": 332,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "int",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "bool"
                ]
            }
        },
        "AnchorBaseBeam.propose_anchors": {
            "name": "propose_anchors",
            "location": 361,
            "return": [
                "List[tuple]"
            ],
            "arguments": {
                "self": [],
                "previous_best": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AnchorBaseBeam.update_state": {
            "name": "update_state",
            "location": 419,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "covered_true": [
                    "float",
                    "str",
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "covered_false": [
                    "float",
                    "str",
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "labels": [
                    "int",
                    "str",
                    "tuple",
                    "List[int]"
                ],
                "samples": [
                    "tuple",
                    "str",
                    "bytes",
                    "List[Dict[str, Any]]",
                    "int"
                ],
                "anchor": [
                    "Dict[str, Any]",
                    "dict",
                    "bytes",
                    "int",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "AnchorBaseBeam.get_init_stats": {
            "name": "get_init_stats",
            "location": 475,
            "return": [
                "collections.defaultdict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "list",
                    "str",
                    "Dict[str, str]",
                    "Tuple[int]",
                    "List[int]",
                    "List[Dict[str, Any]]",
                    "List[T]"
                ],
                "coverages": [
                    "bool",
                    "int",
                    "str",
                    "T"
                ]
            }
        },
        "AnchorBaseBeam.get_anchor_metadata": {
            "name": "get_anchor_metadata",
            "location": 505,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "features": [
                    "tuple",
                    "str",
                    "int",
                    "float"
                ],
                "success": [
                    "tuple",
                    "str",
                    "int",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "AnchorBaseBeam.to_sample": {
            "name": "to_sample",
            "location": 578,
            "return": [
                "int",
                "numpy.ndarray",
                "float",
                "Dict[str,numpy.ndarray]",
                "Dict",
                "str"
            ],
            "arguments": {
                "means": [
                    "numpy.ndarray",
                    "float",
                    "Dict[str, numpy.ndarray]",
                    "dict",
                    "str",
                    "int"
                ],
                "ubs": [
                    "numpy.ndarray",
                    "float",
                    "Dict[str, numpy.ndarray]",
                    "dict",
                    "str",
                    "int"
                ],
                "lbs": [
                    "numpy.ndarray",
                    "float",
                    "Dict[str, numpy.ndarray]",
                    "dict",
                    "str",
                    "int"
                ],
                "desired_confidence": [
                    "numpy.ndarray",
                    "float",
                    "Dict[str, numpy.ndarray]",
                    "dict",
                    "str",
                    "int"
                ],
                "epsilon_stop": [
                    "numpy.ndarray",
                    "float",
                    "Dict[str, numpy.ndarray]",
                    "dict",
                    "str",
                    "int"
                ]
            }
        },
        "AnchorBaseBeam.anchor_beam": {
            "name": "anchor_beam",
            "location": 605,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "delta": [
                    "float",
                    "numpy.ndarray",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "Union[int,float]",
                    "numpy.ndarray",
                    "Optional[int]",
                    "bool"
                ],
                "desired_confidence": [
                    "float",
                    "bool",
                    "int",
                    "Tuple[numpy.dtype]"
                ],
                "beam_size": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "float"
                ],
                "epsilon_stop": [
                    "float",
                    "Optional[float]",
                    "Tuple",
                    "numpy.ndarray"
                ],
                "min_samples_start": [
                    "int",
                    "bool",
                    "float",
                    "Tuple[numpy.dtype]"
                ],
                "max_anchor_size": [
                    "None",
                    "int",
                    "Union[float,int]",
                    "Tuple",
                    "float"
                ],
                "stop_on_first": [
                    "bool",
                    "int",
                    "float",
                    "Tuple[numpy.dtype]"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray"
                ],
                "coverage_samples": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]",
                    "bytes"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "verbose_every": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "float"
                ]
            }
        },
        "AnchorBaseBeam.get_init_stats.array_factory": {
            "name": "array_factory",
            "location": 492,
            "return": [
                "Callable",
                "int",
                "utils.Node"
            ],
            "arguments": {
                "size": [
                    "int",
                    "tuple",
                    "float",
                    "Tuple[float, float]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_explanation.py": {
        "AnchorExplanation.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "exp_type": [
                    "str",
                    "Type",
                    "Union[str,List[str]]",
                    "List[str]"
                ],
                "exp_map": [
                    "str",
                    "bool"
                ]
            }
        },
        "AnchorExplanation.names": {
            "name": "names",
            "location": 22,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "AnchorExplanation.features": {
            "name": "features",
            "location": 41,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "int",
                    "float",
                    "None",
                    "Iterable[Optional[Any]]",
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.precision": {
            "name": "precision",
            "location": 60,
            "return": [
                "bool",
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "int",
                    "None",
                    "float",
                    "Iterable[Optional[Any]]",
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.coverage": {
            "name": "coverage",
            "location": 82,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "partial_index": [
                    "int",
                    "None",
                    "float",
                    "Iterable[Optional[Any]]",
                    "Optional[int]"
                ]
            }
        },
        "AnchorExplanation.examples": {
            "name": "examples",
            "location": 104,
            "return": [
                "List",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "only_different_prediction": [
                    "bool",
                    "int",
                    "Callable",
                    "str"
                ],
                "only_same_prediction": [
                    "bool",
                    "int",
                    "Callable",
                    "str"
                ],
                "partial_index": [
                    "float",
                    "None",
                    "str",
                    "List[Tuple[str,numpy.generic]]",
                    "int",
                    "List[tuple[Union[str,numpy.generic]]]",
                    "Optional[str]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_image.py": {
        "scale_image": {
            "name": "scale_image",
            "location": 27,
            "return": [
                "numpy.ndarray",
                "int",
                "str"
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "int"
                ],
                "scale": [
                    "Tuple[int]",
                    "float",
                    "str",
                    "bool",
                    "Dict"
                ]
            }
        },
        "AnchorImageSampler.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "int",
                    "Optional[int]",
                    "List[str]"
                ],
                "segmentation_fn": [
                    "List[float]",
                    "int",
                    "float",
                    "Iterator[int]",
                    "Tuple[int]"
                ],
                "custom_segmentation": [
                    "int",
                    "float",
                    "bool"
                ],
                "image": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "List[int]",
                    "Optional[bytes]",
                    "Union[int, float]",
                    "bool"
                ],
                "images_background": [
                    "None",
                    "str",
                    "Tuple[int,int]",
                    "numpy.ndarray",
                    "float",
                    "Tuple[int,int,int]"
                ],
                "p_sample": [
                    "float",
                    "int",
                    "Tuple[str]",
                    "str",
                    "bool"
                ],
                "n_covered_ex": [
                    "int",
                    "List[float]",
                    "float",
                    "Iterator[int]",
                    "Tuple[int]"
                ]
            }
        },
        "AnchorImageSampler.__call__": {
            "name": "__call__",
            "location": 92,
            "return": [
                "List[Union[list,float]]",
                "List",
                "str",
                "bool",
                "Type",
                "int",
                "Union[numbers.Real,numpy.ndarray]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[int]",
                    "float",
                    "numpy.ndarray"
                ],
                "num_samples": [
                    "int",
                    "str",
                    "bool",
                    "utils.Rect",
                    "float"
                ],
                "compute_labels": [
                    "bool",
                    "Iterable[Any]",
                    "int"
                ]
            }
        },
        "AnchorImageSampler.compare_labels": {
            "name": "compare_labels",
            "location": 152,
            "return": [
                "bool",
                "Dict",
                "str",
                "Sequence[str]",
                "int",
                "Iterable[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "int",
                    "Sequence[Tuple[float, float]]",
                    "Dict[str, str]",
                    "bytes",
                    "Callable[[str], bool]"
                ]
            }
        },
        "AnchorImageSampler._choose_superpixels": {
            "name": "_choose_superpixels",
            "location": 169,
            "return": [
                "str",
                "raiden.utils.signer.Signer",
                "Optional[float]",
                "int",
                "List[Dict[str, Any]]",
                "Dict[str, str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int"
                ],
                "p_sample": [
                    "float",
                    "int",
                    "Tuple[int,int]"
                ]
            }
        },
        "AnchorImageSampler.perturbation": {
            "name": "perturbation",
            "location": 198,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "List[List[int]]",
                    "float"
                ],
                "num_samples": [
                    "int",
                    "Optional[int]",
                    "float"
                ]
            }
        },
        "AnchorImageSampler.generate_superpixels": {
            "name": "generate_superpixels",
            "location": 268,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "AnchorImageSampler._preprocess_img": {
            "name": "_preprocess_img",
            "location": 286,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "numpy.ndarray",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "AnchorImage.__init__": {
            "name": "__init__",
            "location": 310,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Optional[str]",
                    "int",
                    "Optional[bool]",
                    "Optional[Sequence[str]]"
                ],
                "image_shape": [
                    "Dict[str, Any]",
                    "Mapping",
                    "dict",
                    "Dict[str, str]"
                ],
                "dtype": [
                    "Optional[str]",
                    "int",
                    "Optional[bool]",
                    "Optional[Sequence[str]]"
                ],
                "segmentation_fn": [
                    "Text",
                    "str",
                    "Optional[str]",
                    "recidiviz.utils.regions.Region"
                ],
                "segmentation_kwargs": [
                    "None",
                    "recidiviz.utils.regions.Region",
                    "Optional[str]"
                ],
                "images_background": [
                    "None",
                    "Tuple[str,object]",
                    "bool",
                    "Set[cmk.utils.type_defs.CheckPluginName]",
                    "int"
                ],
                "seed": [
                    "numpy.ndarray",
                    "None"
                ]
            }
        },
        "AnchorImage.generate_superpixels": {
            "name": "generate_superpixels",
            "location": 404,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "AnchorImage._preprocess_img": {
            "name": "_preprocess_img",
            "location": 422,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "numpy.ndarray",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "AnchorImage.explain": {
            "name": "explain",
            "location": 444,
            "return": [
                "str",
                "int",
                "bytes",
                "float"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "Optional[Sequence[str]]",
                    "Tuple[int, Callable]",
                    "bool",
                    "numpy.ndarray",
                    "alibi.api.interfaces.Explanation"
                ],
                "p_sample": [
                    "float",
                    "Optional[Sequence[str]]",
                    "Tuple[int,Callable]",
                    "bool",
                    "numpy.ndarray",
                    "alibi.api.interfaces.Explanation"
                ],
                "threshold": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "delta": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "tau": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "coverage_samples": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "beam_size": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "stop_on_first": [
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "max_anchor_size": [
                    "None",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "min_samples_start": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "n_covered_ex": [
                    "int",
                    "Optional[Sequence[str]]",
                    "Tuple[int,Callable]",
                    "bool",
                    "numpy.ndarray",
                    "alibi.api.interfaces.Explanation"
                ],
                "binary_cache_size": [
                    "int",
                    "bytes"
                ],
                "cache_margin": [
                    "int",
                    "bytes"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "verbose_every": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "AnchorImage._build_explanation": {
            "name": "_build_explanation",
            "location": 554,
            "return": [
                "bool",
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "Iterable[str]",
                    "int",
                    "numpy.ndarray"
                ],
                "result": [
                    "int",
                    "bytes",
                    "bool"
                ],
                "predicted_label": [
                    "numpy.ndarray",
                    "list",
                    "Sequence[T]",
                    "Sequence[Sequence[float]]",
                    "dict",
                    "float"
                ],
                "params": [
                    "dict",
                    "Dict[str, List[str]]",
                    "int",
                    "Dict[str, float]",
                    "Dict[str, Any]"
                ],
                "sampler": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "AnchorImage.overlay_mask": {
            "name": "overlay_mask",
            "location": 603,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "int",
                    "numpy.ndarray"
                ],
                "segments": [
                    "str",
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "mask_features": [
                    "numpy.ndarray",
                    "str",
                    "numpy.array",
                    "int",
                    "Tuple[int, int, int]"
                ],
                "scale": [
                    "Tuple[int]",
                    "int",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "AnchorImage._transform_predictor": {
            "name": "_transform_predictor",
            "location": 633,
            "return": [
                "ArgmaxTransformer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Dict[str, Tuple[int, int]]",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "AnchorImage.reset_predictor": {
            "name": "reset_predictor",
            "location": 654,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_tabular.py": {
        "TabularSampler.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[dict]"
                ],
                "disc_perc": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[dict]"
                ],
                "numerical_features": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[dict]"
                ],
                "categorical_features": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[dict]"
                ],
                "feature_names": [
                    "Optional[str]",
                    "str",
                    "bool"
                ],
                "feature_values": [
                    "int",
                    "bool",
                    "str"
                ],
                "n_covered_ex": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[dict]"
                ],
                "seed": [
                    "None",
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "TabularSampler.deferred_init": {
            "name": "deferred_init",
            "location": 69,
            "return": [
                "TabularSampler",
                "str",
                "apistar.interfaces.Router",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "bytes",
                    "dict",
                    "Dict[str, Any]",
                    "str",
                    "Optional[bytes]",
                    "Dict[str, str]"
                ],
                "d_train_data": [
                    "bytes",
                    "dict",
                    "Dict[str, Any]",
                    "str",
                    "Optional[bytes]",
                    "Dict[str, str]"
                ]
            }
        },
        "TabularSampler._set_data": {
            "name": "_set_data",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "Callable",
                    "Dict[str, Any]",
                    "dict"
                ],
                "d_train_data": [
                    "dict",
                    "Tuple[int, str, bytearray]",
                    "Dict[str, str]",
                    "bool",
                    "str",
                    "bytes",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "TabularSampler._set_discretizer": {
            "name": "_set_discretizer",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "disc_perc": [
                    "Callable",
                    "dict",
                    "Optional[str]",
                    "Dict[str, Any]",
                    "Callable[[str], T]"
                ]
            }
        },
        "TabularSampler._set_numerical_feats_stats": {
            "name": "_set_numerical_feats_stats",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TabularSampler.set_instance_label": {
            "name": "set_instance_label",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int"
                ]
            }
        },
        "TabularSampler.set_n_covered": {
            "name": "set_n_covered",
            "location": 137,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_covered": [
                    "int"
                ]
            }
        },
        "TabularSampler._get_data_index": {
            "name": "_get_data_index",
            "location": 151,
            "return": [
                "Dict",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "TabularSampler.__call__": {
            "name": "__call__",
            "location": 171,
            "return": [
                "List",
                "str",
                "bool",
                "Type",
                "int",
                "Union[numbers.Real,numpy.ndarray]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "float",
                    "Sequence",
                    "utils.Rect"
                ],
                "num_samples": [
                    "int",
                    "str",
                    "bytearray",
                    "float"
                ],
                "compute_labels": [
                    "bool",
                    "Iterable[Any]",
                    "int"
                ]
            }
        },
        "TabularSampler.compare_labels": {
            "name": "compare_labels",
            "location": 233,
            "return": [
                "bool",
                "Dict",
                "str",
                "Sequence[str]",
                "int",
                "Iterable[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "int",
                    "Sequence[Tuple[float, float]]",
                    "Dict[str, str]",
                    "bytes",
                    "Callable[[str], bool]"
                ]
            }
        },
        "TabularSampler.perturbation": {
            "name": "perturbation",
            "location": 250,
            "return": [
                "Tuple[float]",
                "str",
                "Dict",
                "List",
                "bool"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "bool",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Tuple[int]",
                    "Optional[numpy.dtype]",
                    "Dict[str, Dict[str, int]]",
                    "int"
                ],
                "num_samples": [
                    "int",
                    "List[str]"
                ]
            }
        },
        "TabularSampler.handle_unk_features": {
            "name": "handle_unk_features",
            "location": 323,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "allowed_bins": [
                    "str",
                    "Optional[Any]",
                    "Callable"
                ],
                "num_samples": [
                    "int",
                    "Tuple[int, int]",
                    "Optional[int]",
                    "Union[None, int]"
                ],
                "samples": [
                    "int",
                    "bool",
                    "str",
                    "Tuple[int]",
                    "Optional[int]"
                ],
                "unk_feature_values": [
                    "bool",
                    "int",
                    "str",
                    "Callable"
                ]
            }
        },
        "TabularSampler.replace_features": {
            "name": "replace_features",
            "location": 355,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "int",
                    "raiden.utils.Address",
                    "Callable[[str], int]",
                    "Optional[int]"
                ],
                "allowed_rows": [
                    "int",
                    "List[AnyStr]",
                    "Optional[int]"
                ],
                "uniq_feat_ids": [
                    "int",
                    "Union[str, Iterable[str]]",
                    "Tuple[Any, str]",
                    "Dict[str, Any]",
                    "float"
                ],
                "partial_anchor_rows": [
                    "bytes",
                    "List[Tuple[int, int]]",
                    "Tuple[int, int]",
                    "list",
                    "Sequence[Sequence[float]]",
                    "int",
                    "List[str]"
                ],
                "nb_partial_anchors": [
                    "str",
                    "List[str]",
                    "int",
                    "Union[int, argonautica.utils.Void]",
                    "bytes"
                ],
                "num_samples": [
                    "Optional[int]",
                    "int",
                    "bool"
                ]
            }
        },
        "TabularSampler.get_features_index": {
            "name": "get_features_index",
            "location": 437,
            "return": [
                "List[str]",
                "bool",
                "Dict[str, Set[str]]",
                "Callable",
                "List[Tuple[int, int]]",
                "str",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "dict",
                    "str",
                    "bool"
                ]
            }
        },
        "TabularSampler.build_lookups": {
            "name": "build_lookups",
            "location": 499,
            "return": [
                "bool",
                "List"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "Callable[[numpy.ndarray], float]",
                    "nevergrad.common.Callable[[numpy.ndarray], numpy.ndarray]"
                ]
            }
        },
        "AnchorTabular.__init__": {
            "name": "__init__",
            "location": 584,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "int",
                    "Optional[Dict]",
                    "bool"
                ],
                "feature_names": [
                    "str",
                    "Optional[Sequence[Any]]"
                ],
                "categorical_names": [
                    "int",
                    "bool",
                    "Dict[str, Any]",
                    "str",
                    "bytes",
                    "Dict[str, 'LabwareDefinition']"
                ],
                "dtype": [
                    "str",
                    "int",
                    "Optional[Dict]",
                    "bool"
                ],
                "ohe": [
                    "bool",
                    "str",
                    "Optional[str]"
                ],
                "seed": [
                    "None",
                    "utils.MinMaxStats",
                    "Dict",
                    "List[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "List[str]",
                    "str",
                    "Iterable[Tuple[int,int]]"
                ]
            }
        },
        "AnchorTabular.fit": {
            "name": "fit",
            "location": 650,
            "return": [
                "AnchorTabular",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "str",
                    "bytes",
                    "Dict[str, Any]",
                    "defaultdict",
                    "dict"
                ],
                "disc_perc": [
                    "Tuple[int]",
                    "Dict[str,Any]",
                    "bytes",
                    "Dict[str,Dict[str,Any]]",
                    "int",
                    "Optional[Dict[str,str]]"
                ]
            }
        },
        "AnchorTabular._build_sampling_lookups": {
            "name": "_build_sampling_lookups",
            "location": 691,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Iterable[List[T]]"
                ]
            }
        },
        "AnchorTabular.explain": {
            "name": "explain",
            "location": 705,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "Tuple[int, int]",
                    "tuple",
                    "list"
                ],
                "threshold": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int"
                ],
                "delta": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int"
                ],
                "tau": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "coverage_samples": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "beam_size": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "stop_on_first": [
                    "bool",
                    "int",
                    "Iterable[Any]"
                ],
                "max_anchor_size": [
                    "None",
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "float"
                ],
                "min_samples_start": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "n_covered_ex": [
                    "int",
                    "bool",
                    "float",
                    "str"
                ],
                "binary_cache_size": [
                    "int"
                ],
                "cache_margin": [
                    "int"
                ],
                "verbose": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "verbose_every": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ]
            }
        },
        "AnchorTabular._build_explanation": {
            "name": "_build_explanation",
            "location": 810,
            "return": [
                "bool",
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "raiden.utils.Any",
                    "int"
                ],
                "result": [
                    "List[List]",
                    "List[List[str]]",
                    "Dict[int, Dict[str, Any]]",
                    "list"
                ],
                "predicted_label": [
                    "int",
                    "mode.utils.Deque[T]",
                    "list",
                    "Iterable[str]",
                    "List[Union[\"PipeChain\", str]]"
                ],
                "params": [
                    "Dict[str, str]",
                    "T",
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "list",
                    "Iterable[Tuple[Hashable, Any]]",
                    "dict"
                ]
            }
        },
        "AnchorTabular.add_names_to_exp": {
            "name": "add_names_to_exp",
            "location": 857,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "explanation": [
                    "bool"
                ]
            }
        },
        "AnchorTabular.predictor": {
            "name": "predictor",
            "location": 932,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Optional[Tuple[float, float]]",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "AnchorTabular._transform_predictor": {
            "name": "_transform_predictor",
            "location": 953,
            "return": [
                "ArgmaxTransformer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Dict[str, Tuple[int, int]]",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "AnchorTabular._transform_ohe_predictor": {
            "name": "_transform_ohe_predictor",
            "location": 976,
            "return": [
                "ArgmaxTransformer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AnchorTabular.reset_predictor": {
            "name": "reset_predictor",
            "location": 981,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_tabular_distributed.py": {
        "DistributedAnchorBaseBeam.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "samplers": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ]
            }
        },
        "DistributedAnchorBaseBeam._get_coverage_samples": {
            "name": "_get_coverage_samples",
            "location": 28,
            "return": [
                "int",
                "bytes",
                "Dict[str, Any]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": [],
                "coverage_samples": [
                    "bool",
                    "str",
                    "bytes"
                ],
                "samplers": [
                    "bool",
                    "str",
                    "bytes"
                ]
            }
        },
        "DistributedAnchorBaseBeam.draw_samples": {
            "name": "draw_samples",
            "location": 48,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "anchors": [
                    "int",
                    "numpy.ndarray",
                    "List[int]",
                    "Sequence[Sequence[float]]",
                    "Sized"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ]
            }
        },
        "RemoteSampler.__init__": {
            "name": "__init__",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RemoteSampler.__call__": {
            "name": "__call__",
            "location": 97,
            "return": [
                "List",
                "int",
                "numpy.matrix",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "anchors_batch": [
                    "numpy.ndarray",
                    "List[float]",
                    "bool"
                ],
                "num_samples": [
                    "Optional[int]",
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Collection[\"Issue\"]"
                ],
                "compute_labels": [
                    "bool",
                    "Optional[int]",
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Collection[Issue]"
                ]
            }
        },
        "RemoteSampler.set_instance_label": {
            "name": "set_instance_label",
            "location": 121,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str"
                ]
            }
        },
        "RemoteSampler.set_n_covered": {
            "name": "set_n_covered",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_covered": [
                    "int"
                ]
            }
        },
        "RemoteSampler._get_sampler": {
            "name": "_get_sampler",
            "location": 153,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "RemoteSampler.build_lookups": {
            "name": "build_lookups",
            "location": 163,
            "return": [
                "List",
                "bool",
                "Type[T]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "mailbox.MailboxDataInterface[pymap.interfaces.message.MessageT]",
                    "str"
                ]
            }
        },
        "DistributedAnchorTabular.__init__": {
            "name": "__init__",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "Union[Optional[str], Literal[Literal]]",
                    "Optional[List[str]]"
                ],
                "feature_names": [
                    "str",
                    "Union[Optional[str], Literal[Literal]]",
                    "Optional[List[str]]"
                ],
                "categorical_names": [
                    "None",
                    "str",
                    "Union[Optional[str],Literal[Literal]]",
                    "Optional[List[str]]"
                ],
                "dtype": [
                    "str",
                    "Union[Optional[str], Literal[Literal]]",
                    "Optional[List[str]]"
                ],
                "ohe": [
                    "bool",
                    "str",
                    "Union[Optional[str],Literal[Literal]]",
                    "Optional[List[str]]"
                ],
                "seed": [
                    "None",
                    "str",
                    "Union[Optional[str],Literal[Literal]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "DistributedAnchorTabular.fit": {
            "name": "fit",
            "location": 195,
            "return": [
                "DistributedAnchorTabular",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_data": [
                    "str",
                    "bytes",
                    "Dict[str, Any]",
                    "defaultdict",
                    "dict"
                ],
                "disc_perc": [
                    "Tuple[int]",
                    "bytes",
                    "Mapping[str,Any]",
                    "Dict[str,Any]",
                    "Dict",
                    "Optional[Dict[str,str]]",
                    "Dict[str,Dict[str,Any]]"
                ]
            }
        },
        "DistributedAnchorTabular._build_sampling_lookups": {
            "name": "_build_sampling_lookups",
            "location": 249,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Iterable[T]",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "Callable[[numpy.ndarray], float]",
                    "numpy.ndarray",
                    "dict"
                ]
            }
        },
        "DistributedAnchorTabular.explain": {
            "name": "explain",
            "location": 262,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "Mapping[str, Tuple[float, float, float]]",
                    "Union[int, float]",
                    "str"
                ],
                "threshold": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int"
                ],
                "delta": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int"
                ],
                "tau": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "coverage_samples": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "beam_size": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "stop_on_first": [
                    "bool",
                    "int",
                    "Iterable[Any]"
                ],
                "max_anchor_size": [
                    "None",
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "float"
                ],
                "min_samples_start": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ],
                "n_covered_ex": [
                    "int",
                    "bool",
                    "float",
                    "str"
                ],
                "binary_cache_size": [
                    "int",
                    "Optional[float]",
                    "Union[Tuple[int,int],int]"
                ],
                "cache_margin": [
                    "int",
                    "Optional[float]",
                    "Union[Tuple[int,int],int]"
                ],
                "verbose": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "verbose_every": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "float"
                ]
            }
        },
        "DistributedAnchorTabular.reset_predictor": {
            "name": "reset_predictor",
            "location": 332,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/anchor_text.py": {
        "AnchorText.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Callable",
                    "str",
                    "bool",
                    "Iterable[str]",
                    "int"
                ],
                "sampling_strategy": [
                    "Text",
                    "int",
                    "str",
                    "float"
                ],
                "nlp": [
                    "None",
                    "str",
                    "bool",
                    "float"
                ],
                "language_model": [
                    "None",
                    "str",
                    "bool",
                    "float"
                ],
                "seed": [
                    "int",
                    "Dict[str,Optional[str]]",
                    "mode.utils.Counter[faustypes.TP]",
                    "Dict[str,List[Any]]"
                ]
            }
        },
        "AnchorText._validate_kwargs": {
            "name": "_validate_kwargs",
            "location": 202,
            "return": [
                "Tuple[dict]",
                "bool",
                "int",
                "cmk.utils.type_defs.ServiceName",
                "cmk.utils.type_defs.HostName",
                "float",
                "utils.Node",
                "str"
            ],
            "arguments": {
                "self": [],
                "sampling_strategy": [
                    "str",
                    "bool",
                    "int"
                ],
                "nlp": [
                    "None",
                    "Optional[str]",
                    "Type[T]",
                    "bool",
                    "str"
                ],
                "language_model": [
                    "None",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "AnchorText.sampler": {
            "name": "sampler",
            "location": 259,
            "return": [
                "bool",
                "List[float]",
                "List"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "str",
                    "bool",
                    "int",
                    "Sequence"
                ],
                "num_samples": [
                    "int",
                    "str",
                    "bool",
                    "numpy.ndarray",
                    "Dict[str, str]"
                ],
                "compute_labels": [
                    "bool",
                    "Dict",
                    "List[str]",
                    "List[List[Any]]",
                    "Iterable[Any]"
                ]
            }
        },
        "AnchorText.compare_labels": {
            "name": "compare_labels",
            "location": 313,
            "return": [
                "bool",
                "Sequence[str]",
                "int",
                "str",
                "Optional[bool]",
                "Optional[int]",
                "Dict",
                "Dict[str,Any]"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "int",
                    "Sequence[Tuple[float, float]]",
                    "Dict[str, str]",
                    "bytes",
                    "Callable[[str], bool]"
                ]
            }
        },
        "AnchorText.explain": {
            "name": "explain",
            "location": 330,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "tuple",
                    "bool"
                ],
                "threshold": [
                    "float",
                    "int",
                    "Callable",
                    "List"
                ],
                "delta": [
                    "float",
                    "int",
                    "Callable",
                    "List"
                ],
                "tau": [
                    "float",
                    "int",
                    "Callable",
                    "List"
                ],
                "batch_size": [
                    "int",
                    "Callable",
                    "List"
                ],
                "coverage_samples": [
                    "int",
                    "Callable",
                    "List"
                ],
                "beam_size": [
                    "int",
                    "Callable",
                    "List"
                ],
                "stop_on_first": [
                    "bool",
                    "int",
                    "Callable",
                    "List"
                ],
                "max_anchor_size": [
                    "None",
                    "int",
                    "Callable",
                    "List"
                ],
                "min_samples_start": [
                    "int",
                    "Callable",
                    "List"
                ],
                "n_covered_ex": [
                    "int",
                    "str",
                    "bool",
                    "List[Dict[str,Any]]",
                    "Tuple[float,float]",
                    "float"
                ],
                "binary_cache_size": [
                    "int",
                    "float",
                    "bool",
                    "numpy.ndarray"
                ],
                "cache_margin": [
                    "int",
                    "float",
                    "bool",
                    "numpy.ndarray"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "Callable",
                    "List"
                ],
                "verbose_every": [
                    "int",
                    "Callable",
                    "List"
                ]
            }
        },
        "AnchorText._build_explanation": {
            "name": "_build_explanation",
            "location": 457,
            "return": [
                "bool",
                "Explanation"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "bool",
                    "List[str]",
                    "dict",
                    "Optional[Callable]",
                    "str"
                ],
                "result": [
                    "str",
                    "List[str]",
                    "utils.RichStatus",
                    "dict"
                ],
                "predicted_label": [
                    "int",
                    "numpy.ndarray",
                    "str",
                    "Dict[str, Any]"
                ],
                "params": [
                    "bool",
                    "Optional[str]",
                    "Optional[bool]",
                    "int"
                ]
            }
        },
        "AnchorText._transform_predictor": {
            "name": "_transform_predictor",
            "location": 493,
            "return": [
                "ArgmaxTransformer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "Dict[str, Tuple[int, int]]",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "AnchorText.reset_predictor": {
            "name": "reset_predictor",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AnchorText._seed": {
            "name": "_seed",
            "location": 525,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "float",
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/language_model_text_sampler.py": {
        "LanguageModelSampler.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "raiden.utils.Locksroot",
                    "Iterable[str]",
                    "str",
                    "dict",
                    "Dict[str, Dict[str, int]]",
                    "Dict[str, Any]",
                    "Dict[str, str]"
                ],
                "perturb_opts": [
                    "str",
                    "tensorflow.estimator.Estimator"
                ]
            }
        },
        "LanguageModelSampler.get_sample_ids": {
            "name": "get_sample_ids",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "punctuation": [],
                "stopwords": [
                    "bool",
                    "set",
                    "int"
                ]
            }
        },
        "LanguageModelSampler.set_text": {
            "name": "set_text",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "LanguageModelSampler.__call__": {
            "name": "__call__",
            "location": 139,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "str"
                ],
                "num_samples": [
                    "int",
                    "str"
                ]
            }
        },
        "LanguageModelSampler.perturb_sentence": {
            "name": "perturb_sentence",
            "location": 159,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "Optional[int]"
                ],
                "num_samples": [
                    "int",
                    "Optional[int]",
                    "str"
                ],
                "sample_proba": [
                    "float",
                    "int",
                    "bool"
                ],
                "top_n": [
                    "int",
                    "str",
                    "List[str]",
                    "Tuple[int]"
                ],
                "batch_size_lm": [
                    "int",
                    "str",
                    "List[str]",
                    "Tuple[int]"
                ],
                "filling": [
                    "Text",
                    "int",
                    "Optional[int]",
                    "str"
                ]
            }
        },
        "LanguageModelSampler.create_mask": {
            "name": "create_mask",
            "location": 222,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "List[str]",
                    "str",
                    "Dict[str, Any]",
                    "Tuple[str, str, str, str, str, str, str, str]",
                    "Optional[int]"
                ],
                "num_samples": [
                    "int",
                    "List[str]",
                    "str",
                    "bool"
                ],
                "sample_proba": [
                    "float",
                    "int",
                    "Optional[numpy.dtype]",
                    "Tuple[float,float]",
                    "Optional[Tuple[int,int]]",
                    "Tuple[int,int]",
                    "str"
                ],
                "filling": [
                    "Text",
                    "bool",
                    "str",
                    "float"
                ],
                "frac_mask_templates": [
                    "float",
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "LanguageModelSampler._append_tail": {
            "name": "_append_tail",
            "location": 309,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "self": [],
                "raw": [
                    "bool",
                    "Dict[str, Any]",
                    "Set[int]",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "LanguageModelSampler._joiner": {
            "name": "_joiner",
            "location": 333,
            "return": [
                "Callable",
                "str",
                "trezor.utils.Writer",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "list",
                    "str",
                    "bytes"
                ],
                "dtype": [
                    "None",
                    "float",
                    "numpy.ndarray",
                    "Union[numpy.ndarray,numpy.void]",
                    "int",
                    "str",
                    "tensorflow.Tensor"
                ]
            }
        },
        "LanguageModelSampler.fill_mask": {
            "name": "fill_mask",
            "location": 356,
            "return": [
                "Tuple[(np.ndarray, Any)]"
            ],
            "arguments": {
                "self": [],
                "raw": [
                    "bool",
                    "int",
                    "Optional[int]"
                ],
                "data": [
                    "bool",
                    "int",
                    "Optional[int]"
                ],
                "num_samples": [
                    "bool",
                    "int",
                    "Optional[int]"
                ],
                "top_n": [
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "batch_size_lm": [
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "filling": [
                    "Text",
                    "bool",
                    "float",
                    "Dict"
                ]
            }
        },
        "LanguageModelSampler._remove_subwords": {
            "name": "_remove_subwords",
            "location": 403,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "raw": [
                    "str"
                ],
                "row": [
                    "str"
                ],
                "col": [
                    "int",
                    "list",
                    "numpy.ndarray",
                    "Sequence[int]"
                ],
                "punctuation": [
                    "Text",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "LanguageModelSampler._perturb_instances_parallel": {
            "name": "_perturb_instances_parallel",
            "location": 439,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "int",
                    "Sequence[int]",
                    "str",
                    "list"
                ],
                "raw": [
                    "int",
                    "bool",
                    "Dict[str, int]"
                ],
                "data": [
                    "int",
                    "bool",
                    "raiden.utils.BlockTimeout",
                    "raiden.utils.TokenAmount"
                ],
                "top_n": [
                    "int",
                    "bool",
                    "float",
                    "Optional[dict]"
                ],
                "batch_size_lm": [
                    "int",
                    "raiden.utils.BlockNumber",
                    "Union[int,str]",
                    "Optional[bool]"
                ],
                "temperature": [
                    "float",
                    "bool",
                    "int"
                ],
                "use_proba": [
                    "bool",
                    "int"
                ]
            }
        },
        "LanguageModelSampler._perturb_instance_ar": {
            "name": "_perturb_instance_ar",
            "location": 539,
            "return": [
                "Tuple[(Any, _T2)]"
            ],
            "arguments": {
                "self": [],
                "num_samples": [
                    "bool",
                    "bytes",
                    "float",
                    "Optional[dict]"
                ],
                "raw": [
                    "bool",
                    "Optional[float]"
                ],
                "data": [
                    "str",
                    "Optional[Callable[[dict], None]]",
                    "dict",
                    "Optional[str]"
                ],
                "top_n": [
                    "int",
                    "bool",
                    "bytes",
                    "float",
                    "Optional[dict]"
                ],
                "batch_size": [
                    "int",
                    "Optional[float]",
                    "raiden.utils.BlockNumber",
                    "Union[int,str]"
                ],
                "temperature": [
                    "float",
                    "bool",
                    "int"
                ],
                "use_proba": [
                    "bool",
                    "int"
                ]
            }
        },
        "LanguageModelSampler.set_data_type": {
            "name": "set_data_type",
            "location": 635,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LanguageModelSampler.seed": {
            "name": "seed",
            "location": 663,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "Optional[int]",
                    "int",
                    "Tuple[str, str]",
                    "str",
                    "list",
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/text_samplers.py": {
        "load_spacy_lexeme_prob": {
            "name": "load_spacy_lexeme_prob",
            "location": 84,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "nlp": [
                    "str",
                    "Sequence[str]",
                    "int"
                ]
            }
        },
        "Neighbors.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nlp_obj": [
                    "int",
                    "list",
                    "str"
                ],
                "n_similar": [
                    "int",
                    "List",
                    "str"
                ],
                "w_prob": [
                    "float",
                    "numpy.ndarray",
                    "bytes",
                    "np.ndarray",
                    "str",
                    "int"
                ]
            }
        },
        "Neighbors.neighbors": {
            "name": "neighbors",
            "location": 39,
            "return": [
                "Dict[(str, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "int",
                    "List['Book']",
                    "List['Photo']",
                    "Optional[dict]",
                    "List['Token']",
                    "str",
                    "List[str]"
                ],
                "tag": [
                    "str",
                    "Dict[str, str]",
                    "bool",
                    "List[Tuple[str, str]]"
                ],
                "top_n": [
                    "int",
                    "str",
                    "Optional[str]",
                    "list"
                ]
            }
        },
        "AnchorTextSampler.set_text": {
            "name": "set_text",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "Iterable[Tuple[int, int]]"
                ]
            }
        },
        "AnchorTextSampler.__call__": {
            "name": "__call__",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "bool",
                    "int",
                    "List[int]"
                ],
                "num_samples": [
                    "bool",
                    "int",
                    "List[int]"
                ]
            }
        },
        "AnchorTextSampler._joiner": {
            "name": "_joiner",
            "location": 129,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "numpy.ndarray",
                    "str",
                    "TextIO"
                ],
                "dtype": [
                    "None",
                    "numpy.dtype",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "UnknownSampler.__init__": {
            "name": "__init__",
            "location": 153,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nlp": [
                    "int",
                    "bool",
                    "float"
                ],
                "perturb_opts": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "UnknownSampler.set_text": {
            "name": "set_text",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "int",
                    "Union[List[str], List[Any]]"
                ]
            }
        },
        "UnknownSampler.__call__": {
            "name": "__call__",
            "location": 191,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "Mapping[Any, Any]",
                    "tuple",
                    "bool",
                    "float",
                    "Optional[bool]"
                ],
                "num_samples": [
                    "int",
                    "List[int]",
                    "Collection[int]",
                    "list"
                ]
            }
        },
        "UnknownSampler.set_data_type": {
            "name": "set_data_type",
            "location": 235,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimilaritySampler.__init__": {
            "name": "__init__",
            "location": 250,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "nlp": [
                    "int",
                    "bool",
                    "float"
                ],
                "perturb_opts": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "SimilaritySampler.set_text": {
            "name": "set_text",
            "location": 278,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "int",
                    "Union[List[str], List[Any]]"
                ]
            }
        },
        "SimilaritySampler.find_similar_words": {
            "name": "find_similar_words",
            "location": 299,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimilaritySampler.__call__": {
            "name": "__call__",
            "location": 310,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "anchor": [
                    "int",
                    "float"
                ],
                "num_samples": [
                    "int",
                    "float"
                ]
            }
        },
        "SimilaritySampler.perturb_sentence_similarity": {
            "name": "perturb_sentence_similarity",
            "location": 331,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "present": [
                    "tuple",
                    "List[bool]"
                ],
                "n": [
                    "int",
                    "Optional[int]",
                    "Sequence[Any]"
                ],
                "sample_proba": [
                    "float",
                    "int",
                    "bool",
                    "numpy.random.RandomState",
                    "Tuple[int,int]"
                ],
                "forbidden": [
                    "frozenset",
                    "float",
                    "bool"
                ],
                "forbidden_tags": [
                    "Set[Text]",
                    "frozenset",
                    "float",
                    "bool"
                ],
                "forbidden_words": [
                    "Set[Text]",
                    "frozenset",
                    "float",
                    "bool"
                ],
                "temperature": [
                    "float",
                    "int"
                ],
                "pos": [
                    "Set[Text]",
                    "frozenset",
                    "float",
                    "bool"
                ],
                "use_proba": [
                    "bool",
                    "str"
                ]
            }
        },
        "SimilaritySampler.set_data_type": {
            "name": "set_data_type",
            "location": 413,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/explainers/anchors/__init__.py": {},
    "alibi-master/alibi/explainers/backends/cfrl_base.py": {
        "identity_function": {
            "name": "identity_function",
            "location": 11,
            "return": [
                "Tuple[float,float]",
                "int"
            ],
            "arguments": {
                "X": [
                    "int",
                    "T"
                ]
            }
        },
        "generate_empty_condition": {
            "name": "generate_empty_condition",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "X": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "List",
                    "T"
                ]
            }
        },
        "get_classification_reward": {
            "name": "get_classification_reward",
            "location": 40,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "Y_pred": [
                    "float",
                    "List",
                    "bytes",
                    "str",
                    "int"
                ],
                "Y_true": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "bool",
                    "None"
                ]
            }
        },
        "get_hard_distribution": {
            "name": "get_hard_distribution",
            "location": 68,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "Y": [
                    "int",
                    "List[T]",
                    "str",
                    "numpy.ndarray",
                    "Literal"
                ],
                "num_classes": [
                    "int",
                    "None",
                    "bool",
                    "float",
                    "Optional[float]",
                    "str",
                    "Optional[str]",
                    "Optional[int]"
                ]
            }
        },
        "CounterfactualRLDataset.predict_batches": {
            "name": "predict_batches",
            "location": 102,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "X": [
                    "List",
                    "int",
                    "numpy.ndarray"
                ],
                "predictor": [
                    "float",
                    "str",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]",
                    "Callable[[str,str],float]",
                    "Callable[str,str,float]"
                ],
                "batch_size": [
                    "int",
                    "List",
                    "numpy.ndarray"
                ]
            }
        },
        "CounterfactualRLDataset.__len__": {
            "name": "__len__",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CounterfactualRLDataset.__getitem__": {
            "name": "__getitem__",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "T",
                    "List[str]",
                    "Dict[str,Any]",
                    "Optional[Dict[str,Any]]",
                    "None"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/cfrl_tabular.py": {
        "get_conditional_dim": {
            "name": "get_conditional_dim",
            "location": 19,
            "return": [
                "int"
            ],
            "arguments": {
                "feature_names": [
                    "List[str]",
                    "str",
                    "list",
                    "Set[str]"
                ],
                "category_map": [
                    "int",
                    "List[int]",
                    "str"
                ]
            }
        },
        "split_ohe": {
            "name": "split_ohe",
            "location": 40,
            "return": [
                "Tuple[(list, list)]"
            ],
            "arguments": {
                "X_ohe": [
                    "list",
                    "int"
                ],
                "category_map": [
                    "int",
                    "dict",
                    "Sequence[T]",
                    "Union[pandas.Series, pandas.DataFrame]"
                ]
            }
        },
        "generate_numerical_condition": {
            "name": "generate_numerical_condition",
            "location": 86,
            "return": [
                "float",
                "str",
                "torch.FloatTensor",
                "T"
            ],
            "arguments": {
                "X_ohe": [
                    "bool",
                    "str",
                    "Dict[str, List[Any]]",
                    "Optional[dict]",
                    "List[int]",
                    "int",
                    "List[float]"
                ],
                "feature_names": [
                    "int",
                    "str",
                    "Optional[str]",
                    "bool",
                    "List[str]",
                    "\"Node\"",
                    "list"
                ],
                "category_map": [
                    "int",
                    "Set[int]"
                ],
                "ranges": [
                    "int",
                    "Union[float, int]",
                    "float",
                    "tuple",
                    "Optional[int]",
                    "List[float]"
                ],
                "immutable_features": [
                    "int",
                    "str"
                ],
                "conditional": [
                    "bool",
                    "int",
                    "str",
                    "Tuple[int]"
                ]
            }
        },
        "generate_categorical_condition": {
            "name": "generate_categorical_condition",
            "location": 161,
            "return": [
                "bool",
                "int",
                "List[Tuple[str, str]]"
            ],
            "arguments": {
                "X_ohe": [
                    "str",
                    "bool",
                    "Optional[int]",
                    "int"
                ],
                "feature_names": [
                    "str",
                    "List[str]",
                    "Collection[str]",
                    "Optional[str]",
                    "Dict[str, Any]",
                    "bool"
                ],
                "category_map": [
                    "str",
                    "bool"
                ],
                "immutable_features": [
                    "str",
                    "int",
                    "bytes"
                ],
                "conditional": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "Tuple[int,int]"
                ]
            }
        },
        "generate_condition": {
            "name": "generate_condition",
            "location": 225,
            "return": [
                "bool",
                "int",
                "List[Tuple[str, str]]"
            ],
            "arguments": {
                "X_ohe": [
                    "int",
                    "float",
                    "str"
                ],
                "feature_names": [
                    "int",
                    "bytes",
                    "numpy.ndarray",
                    "bool"
                ],
                "category_map": [
                    "int",
                    "bytes",
                    "numpy.ndarray",
                    "bool"
                ],
                "ranges": [
                    "int",
                    "float",
                    "str"
                ],
                "immutable_features": [
                    "int",
                    "float",
                    "str"
                ],
                "conditional": [
                    "bool",
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "sample_numerical": {
            "name": "sample_numerical",
            "location": 286,
            "return": [
                "List[float]",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "X_hat_num_split": [
                    "bool",
                    "float",
                    "int",
                    "str"
                ],
                "X_ohe_num_split": [
                    "int",
                    "Optional[int]",
                    "Union[int, float]",
                    "Optional[float]"
                ],
                "C_num_split": [
                    "int",
                    "Callable",
                    "Optional[float]",
                    "float",
                    "dict"
                ],
                "stats": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "str",
                    "dict"
                ]
            }
        },
        "sample_categorical": {
            "name": "sample_categorical",
            "location": 337,
            "return": [
                "list"
            ],
            "arguments": {
                "X_hat_cat_split": [
                    "bool",
                    "Callable[[str], float]",
                    "torch.Tensor",
                    "torch.LongTensor",
                    "float",
                    "numpy.ndarray"
                ],
                "C_cat_split": [
                    "int",
                    "bool",
                    "Union[str, Tuple[str, str]]",
                    "Tuple[numpy.dtype]"
                ]
            }
        },
        "sample": {
            "name": "sample",
            "location": 372,
            "return": [
                "list"
            ],
            "arguments": {
                "X_hat_split": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Collection[int]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]"
                ],
                "X_ohe": [
                    "str",
                    "int",
                    "torch.Tensor",
                    "Tuple[int, int]",
                    "Tuple[float, float]"
                ],
                "C": [
                    "int",
                    "Optional[List[int]]",
                    "Optional[int]",
                    "Tuple[str, str]",
                    "str"
                ],
                "category_map": [
                    "int",
                    "str",
                    "List[int]",
                    "numpy.ndarray"
                ],
                "stats": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Collection[int]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]"
                ]
            }
        },
        "get_he_preprocessor": {
            "name": "get_he_preprocessor",
            "location": 425,
            "return": [
                "Tuple[(Any, Callable[([Any], Any)])]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any, Any]]",
                    "bool",
                    "str"
                ],
                "feature_names": [
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any, Any]]",
                    "bool",
                    "str"
                ],
                "category_map": [
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any, Any]]",
                    "bool",
                    "str"
                ],
                "feature_types": [
                    "None",
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any,Any]]",
                    "bool",
                    "str"
                ]
            }
        },
        "get_statistics": {
            "name": "get_statistics",
            "location": 532,
            "return": [
                "Dict[(int, Dict[(str, Any)])]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[Exception]"
                ],
                "preprocessor": [
                    "float",
                    "numpy.ndarray",
                    "int",
                    "str"
                ],
                "category_map": [
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[Exception]"
                ]
            }
        },
        "get_numerical_conditional_vector": {
            "name": "get_numerical_conditional_vector",
            "location": 569,
            "return": [
                "list"
            ],
            "arguments": {
                "X": [
                    "Optional[bool]",
                    "int",
                    "Optional[dict]",
                    "Optional[Tuple[int, ...]]",
                    "pandas.DataFrame",
                    "Optional[numpy.ndarray]"
                ],
                "condition": [
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "preprocessor": [
                    "bool",
                    "int",
                    "Optional[bool]",
                    "Tuple[int, int, int]",
                    "Callable",
                    "Optional[dict]"
                ],
                "feature_names": [
                    "Optional[str]",
                    "Optional[int]",
                    "bool",
                    "int",
                    "Optional[bool]"
                ],
                "category_map": [
                    "float",
                    "Optional[List[Any]]",
                    "Optional[str]",
                    "Optional[Union[float, str]]"
                ],
                "stats": [
                    "int",
                    "str",
                    "Sequence[int]",
                    "bool",
                    "List[int]"
                ],
                "ranges": [
                    "None",
                    "Optional[int]",
                    "Optional[str]",
                    "int",
                    "Optional[bool]"
                ],
                "immutable_features": [
                    "None",
                    "Optional[Sequence[Any]]",
                    "Optional[str]",
                    "Optional[bool]"
                ],
                "diverse": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "get_categorical_conditional_vector": {
            "name": "get_categorical_conditional_vector",
            "location": 687,
            "return": [
                "list"
            ],
            "arguments": {
                "X": [
                    "bool",
                    "Optional[\"Texte\"]",
                    "Optional[bool]",
                    "int",
                    "Dict[str, Any]"
                ],
                "condition": [
                    "str",
                    "Optional[str]",
                    "dict",
                    "List[\"libkol.types.ItemQuantity\"]"
                ],
                "preprocessor": [
                    "bool",
                    "str",
                    "int"
                ],
                "feature_names": [
                    "Optional[str]",
                    "Optional[Dict]",
                    "dict",
                    "Optional[Match]",
                    "Optional[Dict[str, Any]]"
                ],
                "category_map": [
                    "int",
                    "Optional[int]",
                    "Type['Frame']",
                    "bytes"
                ],
                "immutable_features": [
                    "None",
                    "Optional[str]",
                    "bool",
                    "List",
                    "Callable",
                    "Optional[List[str]]",
                    "Optional[Sequence[Any]]",
                    "Optional[List[Any]]"
                ],
                "diverse": [
                    "bool",
                    "str",
                    "Dict",
                    "Optional[Hashable]"
                ]
            }
        },
        "get_conditional_vector": {
            "name": "get_conditional_vector",
            "location": 766,
            "return": [
                "int",
                "List[int]",
                "str"
            ],
            "arguments": {
                "X": [
                    "List[Dict[str, Any]]",
                    "List[str]",
                    "Tuple[str]",
                    "List[Union[int, str]]",
                    "str",
                    "List[numpy.array]",
                    "List[float]",
                    "Union[str, List[str], Tuple[str, ...]]"
                ],
                "condition": [
                    "bool",
                    "str",
                    "Optional[T]",
                    "Optional[Any]"
                ],
                "preprocessor": [
                    "bool",
                    "str",
                    "Optional[T]",
                    "Optional[Any]"
                ],
                "feature_names": [
                    "int",
                    "List[int]",
                    "Callable",
                    "numpy.ndarray",
                    "Sequence[int]",
                    "List[float]",
                    "Optional[str]",
                    "str"
                ],
                "category_map": [
                    "bool",
                    "str",
                    "Optional[T]",
                    "Optional[Any]"
                ],
                "stats": [
                    "bool",
                    "str",
                    "Optional[T]",
                    "Optional[Any]"
                ],
                "ranges": [
                    "None",
                    "Optional[int]",
                    "Union[AbstractSetIntStr,MappingIntStrAny]",
                    "Optional[Any]",
                    "Optional[List]",
                    "Callable",
                    "Optional[List[str]]"
                ],
                "immutable_features": [
                    "None",
                    "Optional[Sequence[Any]]",
                    "numpy.array",
                    "Optional[str]",
                    "Optional[List[str]]",
                    "Optional[Tuple[int,int]]"
                ],
                "diverse": [
                    "bool",
                    "str",
                    "Optional[T]",
                    "Optional[Any]"
                ]
            }
        },
        "apply_category_mapping": {
            "name": "apply_category_mapping",
            "location": 858,
            "return": [
                "dict",
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "List[str]"
            ],
            "arguments": {
                "X": [
                    "numpy.array",
                    "tensorflow.Tensor"
                ],
                "category_map": [
                    "dict",
                    "str",
                    "Union[Dict, List]",
                    "Union[List, Dict]",
                    "Sequence[Any]",
                    "Callable"
                ]
            }
        },
        "get_he_preprocessor.get_inv_preprocessor": {
            "name": "get_inv_preprocessor",
            "location": 481,
            "return": [
                "int",
                "List[int]",
                "bytes",
                "str"
            ],
            "arguments": {
                "X_ohe": [
                    "int",
                    "numpy.ndarray",
                    "pandas.Series",
                    "bool",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/__init__.py": {},
    "alibi-master/alibi/explainers/backends/pytorch/cfrl_base.py": {
        "get_device": {
            "name": "get_device",
            "location": 104,
            "return": [
                "bytes",
                "bool",
                "Dict[Optional[str], Set[abilian.services.security.models.Role]]",
                "abilian.core.models.subjects.Principal",
                "dict",
                "Union[fonduer.candidates.models.Candidate, fonduer.candidates.models.Mention, fonduer.candidates.models.span_mention.TemporarySpanMention]"
            ],
            "arguments": {}
        },
        "get_optimizer": {
            "name": "get_optimizer",
            "location": 115,
            "return": [
                "str",
                "Optional[str]",
                "int",
                "Union[fonduer.candidates.models.Candidate, fonduer.candidates.models.Mention, fonduer.candidates.models.span_mention.TemporarySpanMention]",
                "dict"
            ],
            "arguments": {
                "model": [
                    "torch.nn.Module",
                    "bool",
                    "int"
                ],
                "lr": [
                    "float",
                    "torch.nn.Module",
                    "bool",
                    "int"
                ]
            }
        },
        "get_actor": {
            "name": "get_actor",
            "location": 126,
            "return": [
                "Actor",
                "str",
                "Dict"
            ],
            "arguments": {
                "hidden_dim": [
                    "Iterable[Iterable[float]]",
                    "Iterable[float]",
                    "Tuple[int, int, int]",
                    "int",
                    "str"
                ],
                "output_dim": [
                    "Iterable[Iterable[float]]",
                    "Iterable[float]",
                    "Tuple[int, int, int]",
                    "int",
                    "str"
                ]
            }
        },
        "get_critic": {
            "name": "get_critic",
            "location": 144,
            "return": [
                "Critic",
                "str",
                "bool"
            ],
            "arguments": {
                "hidden_dim": [
                    "str",
                    "bool"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 160,
            "return": [
                "Dict[Text,]",
                "utils.Node",
                "torch.FloatTensor",
                "cmk.utils.type_defs.ServiceName",
                "cmk.utils.type_defs.HostName",
                "int",
                "str",
                "Tuple[float,float,float]",
                "numpy.ndarray",
                "zerver.models.Realm"
            ],
            "arguments": {
                "X_hat_cf": [
                    "dict",
                    "Sequence[float]",
                    "float",
                    "int"
                ],
                "X": [
                    "dict",
                    "Sequence[float]",
                    "float",
                    "int"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 178,
            "return": [
                "Dict[Text,int]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "Z_cf_pred": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "Z_cf_tgt": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "data_generator": {
            "name": "data_generator",
            "location": 196,
            "return": [
                "DataLoader",
                "Dict",
                "bool",
                "db.models.taxon.FillDataLevel",
                "Union[shap.utils._legacy.Data,pandas.DataFrame,numpy.ndarray,scipy.sparse.spmatrix]",
                "Optional[float]",
                "int",
                "bytes"
            ],
            "arguments": {
                "X": [
                    "int",
                    "Tuple[float, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "encoder_preprocessor": [
                    "int",
                    "Tuple[float, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "predictor": [
                    "int",
                    "Tuple[float, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "conditional_func": [
                    "int",
                    "Tuple[float, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "batch_size": [
                    "int",
                    "Tuple[\"ndarray\", \"ndarray\"]",
                    "float"
                ],
                "shuffle": [
                    "int",
                    "float",
                    "Optional[torch.nn.Module]",
                    "bool"
                ],
                "num_workers": [
                    "int",
                    "float",
                    "Optional[torch.nn.Module]",
                    "bool"
                ]
            }
        },
        "encode": {
            "name": "encode",
            "location": 238,
            "return": [
                "int",
                "trezor.utils.Writer",
                "dict",
                "utils.Node",
                "Dict[str, int]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "float",
                    "Union[int, float]"
                ],
                "encoder": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "device": [
                    "int",
                    "float",
                    "Union[int, float]"
                ]
            }
        },
        "decode": {
            "name": "decode",
            "location": 260,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "Z": [
                    "str",
                    "bool",
                    "Tuple[int]",
                    "torch.Tensor",
                    "float",
                    "Union[str, type]",
                    "int"
                ],
                "decoder": [
                    "float",
                    "str",
                    "int",
                    "torch.Tensor"
                ],
                "device": [
                    "str",
                    "bool",
                    "Tuple[int]",
                    "torch.Tensor",
                    "float",
                    "Union[str, type]",
                    "int"
                ]
            }
        },
        "generate_cf": {
            "name": "generate_cf",
            "location": 282,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "Z": [
                    "numpy.ndarray",
                    "Sequence[int]",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "float",
                    "Optional[int]"
                ],
                "Y_m": [
                    "int",
                    "Tuple[float, float, float]",
                    "torch.Tensor"
                ],
                "Y_t": [
                    "int",
                    "Tuple[float, float, float]",
                    "torch.Tensor"
                ],
                "C": [
                    "int",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Optional[numpy.array]",
                    "Optional[float]"
                ],
                "encoder": [
                    "bool",
                    "int",
                    "tuple",
                    "numpy.ndarray",
                    "float"
                ],
                "decoder": [
                    "bool",
                    "int",
                    "tuple",
                    "numpy.ndarray",
                    "float"
                ],
                "actor": [
                    "bool",
                    "int",
                    "tuple",
                    "numpy.ndarray",
                    "float"
                ],
                "device": [
                    "float",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "add_noise": {
            "name": "add_noise",
            "location": 337,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "Z_cf": [
                    "str"
                ],
                "noise": [
                    "str"
                ],
                "act_low": [
                    "int",
                    "Optional[str]"
                ],
                "act_high": [
                    "int",
                    "Optional[str]"
                ],
                "step": [
                    "int",
                    "Optional[str]"
                ],
                "exploration_steps": [
                    "int",
                    "Optional[str]"
                ],
                "device": [
                    "str"
                ]
            }
        },
        "update_actor_critic": {
            "name": "update_actor_critic",
            "location": 385,
            "return": [
                "float",
                "zam_repondeur.models.Amendement",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "encoder": [
                    "int"
                ],
                "decoder": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "critic": [
                    "audiopyle.lib.models.compressed_feature.CompressedFeatureDTO",
                    "int",
                    "zerver.models.Realm",
                    "Dict[str, AsyncGenerator]",
                    "str",
                    "pywirelessmbus.utils.IMSTMessage"
                ],
                "actor": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "optimizer_critic": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "optimizer_actor": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "sparsity_loss": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "consistency_loss": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "coeff_sparsity": [
                    "salon.models.Stylist",
                    "int",
                    "Type[T]",
                    "dict",
                    "str"
                ],
                "coeff_consistency": [
                    "salon.models.Stylist",
                    "int",
                    "Type[T]",
                    "dict",
                    "str"
                ],
                "X": [
                    "float",
                    "int"
                ],
                "X_cf": [
                    "str",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "Z": [
                    "numpy.ndarray",
                    "float",
                    "torch.Tensor",
                    "int"
                ],
                "Z_cf_tilde": [
                    "int",
                    "str"
                ],
                "Y_m": [
                    "torch.Tensor",
                    "torch.LongTensor",
                    "List[int]",
                    "Optional[int]",
                    "dict"
                ],
                "Y_t": [
                    "torch.Tensor",
                    "torch.LongTensor",
                    "List[int]",
                    "Optional[int]",
                    "dict"
                ],
                "C": [
                    "int",
                    "numpy.ndarray",
                    "str",
                    "float",
                    "Optional[numpy.ndarray]"
                ],
                "R_tilde": [
                    "str",
                    "bytes",
                    "torch.Tensor"
                ],
                "device": [
                    "float",
                    "xarray.Dataset",
                    "int",
                    "dict"
                ]
            }
        },
        "to_numpy": {
            "name": "to_numpy",
            "location": 533,
            "return": [
                "np_@_ndarray",
                "Iterable[str]",
                "List",
                "None",
                "salon.models.Stylist",
                "Dict",
                "Dict[str,Any]",
                "IO[str]"
            ],
            "arguments": {
                "X": [
                    "Optional[numpy.ndarray]",
                    "Optional[str]",
                    "Type",
                    "int",
                    "fonduer.candidates.models.Candidate",
                    "Dict[str, List[float]]"
                ]
            }
        },
        "to_tensor": {
            "name": "to_tensor",
            "location": 561,
            "return": [
                "None",
                "daylighdb.models.User",
                "int",
                "Dict",
                "bool",
                "lunch_buddies.models.poll_responses.PollResponse",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "X": [
                    "float",
                    "Optional[Tuple]",
                    "int",
                    "Optional[numpy.ndarray]"
                ],
                "device": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "save_model": {
            "name": "save_model",
            "location": 578,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str",
                    "list",
                    "Optional[Sequence[str]]"
                ],
                "model": [
                    "str",
                    "list",
                    "Optional[Sequence[str]]"
                ]
            }
        },
        "load_model": {
            "name": "load_model",
            "location": 592,
            "return": [
                "GPy.models.GPRegression",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "path": [
                    "str",
                    "Callable",
                    "os.PathLike"
                ]
            }
        },
        "set_seed": {
            "name": "set_seed",
            "location": 610,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "int",
                    "str"
                ]
            }
        },
        "PtCounterfactualRLDataset.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "programl.models.base_batch_builder.BaseBatchBuilder"
                ],
                "preprocessor": [
                    "numpy.ndarray",
                    "Callable[[str, str], float]",
                    "float",
                    "List[float]"
                ],
                "predictor": [
                    "int",
                    "torch.BoolTensor",
                    "Union[Tuple[int, int], int]",
                    "List[float]",
                    "List[str]"
                ],
                "conditional_func": [
                    "str",
                    "bool",
                    "int",
                    "Optional[\"GraphLogger\"]",
                    "Dict[str, List[Any]]",
                    "numpy.array"
                ],
                "batch_size": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "torch.BoolTensor"
                ]
            }
        },
        "PtCounterfactualRLDataset.__len__": {
            "name": "__len__",
            "location": 77,
            "return": [
                "str",
                "utils.Node"
            ],
            "arguments": {
                "self": []
            }
        },
        "PtCounterfactualRLDataset.__getitem__": {
            "name": "__getitem__",
            "location": 80,
            "return": [
                "Dict[Text,]",
                "str",
                "raiden.utils.signer.Signer",
                "Optional[float]",
                "int",
                "List[Dict[str,Any]]",
                "Dict[str,str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "numpy.ndarray",
                    "str",
                    "bytes",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/pytorch/cfrl_tabular.py": {
        "sample_differentiable": {
            "name": "sample_differentiable",
            "location": 24,
            "return": [
                "List",
                "List[Dict[str,Any]]",
                "Dict",
                "str"
            ],
            "arguments": {
                "X_hat_split": [
                    "int",
                    "List[int]"
                ],
                "category_map": [
                    "int",
                    "bool",
                    "List[int]",
                    "List[Dict]"
                ]
            }
        },
        "l0_ohe": {
            "name": "l0_ohe",
            "location": 63,
            "return": [
                "int",
                "str",
                "bytearray",
                "Dict[str,list[str]]",
                "Optional[str]",
                "Tuple[str]",
                "float"
            ],
            "arguments": {
                "input": [
                    "List[list[T]]",
                    "torch.Tensor",
                    "int",
                    "bytes",
                    "str",
                    "List[List[T]]"
                ],
                "target": [
                    "bytes",
                    "str",
                    "torch.Tensor"
                ],
                "reduction": [
                    "Text",
                    "str",
                    "int",
                    "float",
                    "Union[float,int]"
                ]
            }
        },
        "l1_loss": {
            "name": "l1_loss",
            "location": 98,
            "return": [
                "str"
            ],
            "arguments": {
                "input": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None"
                ],
                "target": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None"
                ],
                "reduction": [
                    "Text",
                    "int",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 118,
            "return": [
                "bool",
                "Dict[Text,float]"
            ],
            "arguments": {
                "X_hat_split": [
                    "float",
                    "int",
                    "bool"
                ],
                "X_ohe": [
                    "bool",
                    "Tuple[Union[int,int]]",
                    "str",
                    "int",
                    "float",
                    "Tuple[Union[float,float]]",
                    "torch.Tensor",
                    "Tuple[int,int]",
                    "Tuple[float,float]"
                ],
                "category_map": [
                    "bool",
                    "Tuple[Union[int,int]]",
                    "str",
                    "int",
                    "float",
                    "Tuple[Union[float,float]]",
                    "torch.Tensor",
                    "Tuple[int,int]",
                    "Tuple[float,float]"
                ],
                "weight_num": [
                    "int",
                    "float"
                ],
                "weight_cat": [
                    "int",
                    "float"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 174,
            "return": [
                "Dict[Text,]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "Z_cf_pred": [
                    "str",
                    "bytes",
                    "List[str]"
                ],
                "Z_cf_tgt": [
                    "str",
                    "bytes",
                    "List[str]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/pytorch/__init__.py": {},
    "alibi-master/alibi/explainers/backends/tensorflow/cfrl_base.py": {
        "get_optimizer": {
            "name": "get_optimizer",
            "location": 115,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "model": [
                    "None",
                    "int",
                    "bool",
                    "str",
                    "django.db.backends.postgresql.schema.DatabaseSchemaEditor",
                    "models.Model",
                    "Optional[Any]",
                    "IO"
                ],
                "lr": [
                    "float",
                    "int",
                    "str",
                    "List[Dict[str,Any]]",
                    "Callable"
                ]
            }
        },
        "get_actor": {
            "name": "get_actor",
            "location": 133,
            "return": [
                "Actor",
                "str",
                "Dict"
            ],
            "arguments": {
                "hidden_dim": [
                    "Iterable[Iterable[float]]",
                    "Iterable[float]",
                    "Tuple[int, int, int]",
                    "int",
                    "str"
                ],
                "output_dim": [
                    "Iterable[Iterable[float]]",
                    "Iterable[float]",
                    "Tuple[int, int, int]",
                    "int",
                    "str"
                ]
            }
        },
        "get_critic": {
            "name": "get_critic",
            "location": 151,
            "return": [
                "Critic",
                "str",
                "bool"
            ],
            "arguments": {
                "hidden_dim": [
                    "str",
                    "bool"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 167,
            "return": [
                "Dict[Text,]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "X_hat_cf": [
                    "dict",
                    "Sequence[float]",
                    "float",
                    "int"
                ],
                "X": [
                    "dict",
                    "Sequence[float]",
                    "float",
                    "int"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 185,
            "return": [
                "Dict[Text,int]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "Z_cf_pred": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "Z_cf_tgt": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "data_generator": {
            "name": "data_generator",
            "location": 203,
            "return": [
                "TfCounterfactualRLDataset",
                "numpy.ndarray",
                "Dict[str,int]",
                "Dict[str,Any]",
                "int"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "encoder_preprocessor": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "predictor": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "conditional_func": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "batch_size": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "shuffle": [
                    "bool",
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "encode": {
            "name": "encode",
            "location": 239,
            "return": [
                "bool",
                "Optional[bool]",
                "int",
                "Optional[int]",
                "numpy.ndarray"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray"
                ],
                "encoder": [
                    "numpy.ndarray"
                ]
            }
        },
        "decode": {
            "name": "decode",
            "location": 259,
            "return": [
                "bool",
                "int",
                "Optional[int]",
                "Optional[bool]"
            ],
            "arguments": {
                "Z": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[float, float]"
                ],
                "decoder": [
                    "int",
                    "str",
                    "bool",
                    "Tuple[float, float]"
                ]
            }
        },
        "generate_cf": {
            "name": "generate_cf",
            "location": 279,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "Z": [
                    "numpy.ndarray",
                    "Sequence[int]",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "float",
                    "Optional[int]"
                ],
                "Y_m": [
                    "numpy.ndarray",
                    "int",
                    "Callable"
                ],
                "Y_t": [
                    "numpy.ndarray",
                    "int",
                    "Callable"
                ],
                "C": [
                    "int",
                    "list",
                    "numpy.ndarray",
                    "Tuple[int, int]",
                    "dict"
                ],
                "actor": [
                    "Optional[str]",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "list",
                    "int",
                    "Tuple[float, float]",
                    "bytes"
                ]
            }
        },
        "add_noise": {
            "name": "add_noise",
            "location": 322,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "Z_cf": [
                    "str"
                ],
                "noise": [
                    "int",
                    "Optional[str]"
                ],
                "act_low": [
                    "models.User",
                    "models.Membership"
                ],
                "act_high": [
                    "models.User",
                    "models.Membership"
                ],
                "step": [
                    "int",
                    "Optional[str]"
                ],
                "exploration_steps": [
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "initialize_optimizer": {
            "name": "initialize_optimizer",
            "location": 369,
            "return": [
                "None"
            ],
            "arguments": {
                "optimizer": [
                    "str",
                    "List[Dict[str, Any]]",
                    "List[List[Any]]"
                ],
                "model": [
                    "str",
                    "List[magic.models.Deck]"
                ]
            }
        },
        "initialize_optimizers": {
            "name": "initialize_optimizers",
            "location": 388,
            "return": [
                "None"
            ],
            "arguments": {
                "optimizer_actor": [
                    "str"
                ],
                "optimizer_critic": [
                    "str"
                ],
                "actor": [
                    "str"
                ],
                "critic": [
                    "str"
                ]
            }
        },
        "initialize_actor_critic": {
            "name": "initialize_actor_critic",
            "location": 409,
            "return": [
                "None"
            ],
            "arguments": {
                "actor": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "critic": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "Z": [
                    "int",
                    "float",
                    "bool",
                    "numpy.ndarray",
                    "str"
                ],
                "Z_cf_tilde": [
                    "str",
                    "float",
                    "numpy.dtype",
                    "bool",
                    "int"
                ],
                "Y_m": [
                    "int",
                    "numpy.ndarray",
                    "str",
                    "float"
                ],
                "Y_t": [
                    "int",
                    "numpy.ndarray",
                    "str",
                    "float"
                ],
                "C": [
                    "numpy.ndarray",
                    "List[str]",
                    "Optional[float]",
                    "Optional[Dict]",
                    "Optional[numpy.ndarray]",
                    "Union[None, float, int]"
                ]
            }
        },
        "update_actor_critic": {
            "name": "update_actor_critic",
            "location": 457,
            "return": [
                "Dict[Union[Text,Text],]",
                "float",
                "zam_repondeur.models.Amendement",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "encoder": [
                    "dict",
                    "int",
                    "str",
                    "salon.models.Stylist",
                    "Optional[Iterable[T]]",
                    "bool"
                ],
                "decoder": [
                    "dict",
                    "int",
                    "str",
                    "salon.models.Stylist",
                    "Optional[Iterable[T]]",
                    "bool"
                ],
                "critic": [
                    "bool",
                    "str"
                ],
                "actor": [
                    "bytes",
                    "bool",
                    "fonduer.parser.models.Document",
                    "int",
                    "Callable"
                ],
                "optimizer_critic": [
                    "dict",
                    "bool",
                    "int",
                    "Type",
                    "str",
                    "numpy.array",
                    "Dict[str, Any]"
                ],
                "optimizer_actor": [
                    "dict",
                    "bool",
                    "int",
                    "Type",
                    "str",
                    "numpy.array",
                    "Dict[str, Any]"
                ],
                "sparsity_loss": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "consistency_loss": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "coeff_sparsity": [
                    "salon.models.Stylist",
                    "int",
                    "Type[T]",
                    "dict",
                    "str"
                ],
                "coeff_consistency": [
                    "salon.models.Stylist",
                    "int",
                    "Type[T]",
                    "dict",
                    "str"
                ],
                "X": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "X_cf": [
                    "dict",
                    "int",
                    "str",
                    "salon.models.Stylist",
                    "Optional[Iterable[T]]",
                    "bool"
                ],
                "Z": [
                    "T",
                    "bool",
                    "int"
                ],
                "Z_cf_tilde": [
                    "float",
                    "zam_repondeur.models.Amendement",
                    "str",
                    "int",
                    "bool"
                ],
                "Y_m": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "List['cirq.Qid']"
                ],
                "Y_t": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "List['cirq.Qid']"
                ],
                "C": [
                    "str",
                    "models.data_frames.data_frame.GUIInterface",
                    "int",
                    "List[int]"
                ],
                "R_tilde": [
                    "Optional[bool]",
                    "Optional[int]",
                    "List[int]"
                ]
            }
        },
        "to_numpy": {
            "name": "to_numpy",
            "location": 590,
            "return": [
                "np_@_ndarray",
                "Dict[str,Any]",
                "List",
                "None",
                "Optional[app.models.User]",
                "django.db.models.Q.uerySet",
                "int",
                "Dict[UserID,services.user.transfer.models.User]"
            ],
            "arguments": {
                "X": [
                    "fonduer.candidates.models.Candidate",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        },
        "to_tensor": {
            "name": "to_tensor",
            "location": 617,
            "return": [
                "tf_@_Tensor",
                "bool",
                "None",
                "Optional[Sequence[str]]",
                "Optional[Callable]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "List[int]",
                    "Optional[numpy.array]",
                    "Optional[int]",
                    "numpy.ndarray"
                ]
            }
        },
        "save_model": {
            "name": "save_model",
            "location": 641,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "model": [
                    "str"
                ]
            }
        },
        "load_model": {
            "name": "load_model",
            "location": 655,
            "return": [
                "Optional[str]",
                "bool",
                "str",
                "List[zerver.models.UserProfile]"
            ],
            "arguments": {
                "path": [
                    "str",
                    "Optional[List[str]]",
                    "lms.lmsdb.models.Comment",
                    "Dict[str, int]",
                    "superseconnectors.sqla.models.SqlaTable"
                ]
            }
        },
        "set_seed": {
            "name": "set_seed",
            "location": 671,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "int",
                    "Any",
                    "str",
                    "Optional[str]",
                    "Iterable[str]"
                ]
            }
        },
        "TfCounterfactualRLDataset.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "programl.models.base_batch_builder.BaseBatchBuilder"
                ],
                "preprocessor": [
                    "numpy.ndarray",
                    "Callable[[str, str], float]",
                    "float",
                    "List[float]"
                ],
                "predictor": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "List[float]",
                    "List[str]"
                ],
                "conditional_func": [
                    "str",
                    "bool",
                    "int",
                    "Optional[\"GraphLogger\"]",
                    "Dict[str, List[Any]]",
                    "numpy.array"
                ],
                "batch_size": [
                    "int",
                    "Union[Tuple[int, int], int]"
                ],
                "shuffle": [
                    "bool",
                    "str",
                    "int",
                    "Optional[GraphLogger]",
                    "Dict[str,List[Any]]",
                    "numpy.array"
                ]
            }
        },
        "TfCounterfactualRLDataset.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TfCounterfactualRLDataset.__len__": {
            "name": "__len__",
            "location": 88,
            "return": [
                "int",
                "models.characters.mods_base.SlotTypes"
            ],
            "arguments": {
                "self": []
            }
        },
        "TfCounterfactualRLDataset.__getitem__": {
            "name": "__getitem__",
            "location": 91,
            "return": [
                "Dict[Text,]",
                "bool",
                "Optional[str]",
                "base_site.nubank.models.NubankCards",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "int",
                    "List[float]",
                    "numpy.ndarray",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/tensorflow/cfrl_tabular.py": {
        "sample_differentiable": {
            "name": "sample_differentiable",
            "location": 23,
            "return": [
                "List",
                "List[Dict[str,Any]]",
                "Dict",
                "str"
            ],
            "arguments": {
                "X_hat_split": [
                    "int",
                    "numpy.ndarray",
                    "List[int]"
                ],
                "category_map": [
                    "int",
                    "bool",
                    "List[int]",
                    "List[Dict]",
                    "numpy.ndarray"
                ]
            }
        },
        "l0_ohe": {
            "name": "l0_ohe",
            "location": 62,
            "return": [
                "int",
                "bytearray",
                "Optional[str]"
            ],
            "arguments": {
                "input": [],
                "target": [
                    "Tuple[Union[int,int]]",
                    "numpy.array",
                    "Tuple[int,int]"
                ],
                "reduction": [
                    "Text",
                    "str",
                    "int",
                    "float",
                    "Union[float,int]"
                ]
            }
        },
        "l1_loss": {
            "name": "l1_loss",
            "location": 97,
            "return": [
                "int",
                "bytearray",
                "Optional[str]"
            ],
            "arguments": {
                "input": [
                    "int",
                    "bytearray",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "target": [
                    "int",
                    "bytearray",
                    "Optional[str]"
                ],
                "reduction": [
                    "Text",
                    "str",
                    "int",
                    "float",
                    "Union[float,int]"
                ]
            }
        },
        "sparsity_loss": {
            "name": "sparsity_loss",
            "location": 128,
            "return": [
                "bool",
                "Dict[Text,float]"
            ],
            "arguments": {
                "X_hat_split": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bool"
                ],
                "X_ohe": [
                    "bool",
                    "str",
                    "Tuple[Union[int,int]]",
                    "int",
                    "float",
                    "Tuple[int,int]",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]"
                ],
                "category_map": [
                    "bool",
                    "str",
                    "Tuple[Union[int,int]]",
                    "int",
                    "float",
                    "Tuple[int,int]",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]"
                ],
                "weight_num": [
                    "int",
                    "float"
                ],
                "weight_cat": [
                    "int",
                    "float"
                ]
            }
        },
        "consistency_loss": {
            "name": "consistency_loss",
            "location": 185,
            "return": [
                "Dict[Text,]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "Z_cf_pred": [
                    "int",
                    "Callable",
                    "str"
                ],
                "Z_cf_tgt": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/backends/tensorflow/__init__.py": {},
    "alibi-master/alibi/explainers/similarity/base.py": {
        "BaseSimilarityExplainer.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "float",
                    "apistar.interfaces.Router",
                    "bool"
                ],
                "loss_fn": [
                    "int",
                    "float",
                    "apistar.interfaces.Router",
                    "bool"
                ],
                "sim_fn": [
                    "int",
                    "float",
                    "apistar.interfaces.Router",
                    "bool"
                ],
                "precompute_grads": [
                    "bool",
                    "int",
                    "apistar.interfaces.Router",
                    "float"
                ],
                "backend": [
                    "Optional[str]"
                ],
                "device": [
                    "str",
                    "None",
                    "bool",
                    "float",
                    "int"
                ],
                "meta": [
                    "None",
                    "Optional[float]",
                    "float",
                    "str",
                    "tensorflow.keras.losses.Loss",
                    "int",
                    "Optional[int]",
                    "Optional[str]",
                    "torch.Tensor"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "apistar.interfaces.Router",
                    "float"
                ]
            }
        },
        "BaseSimilarityExplainer.fit": {
            "name": "fit",
            "location": 65,
            "return": [
                "BaseSimilarityExplainer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X_train": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "Y_train": [
                    "float",
                    "Union[int,float]",
                    "int",
                    "Tuple[Any,List[Any]]",
                    "Tuple[Union[Any,list[Any]]]"
                ]
            }
        },
        "BaseSimilarityExplainer._verify_fit": {
            "name": "_verify_fit",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseSimilarityExplainer._match_shape_to_data": {
            "name": "_match_shape_to_data",
            "location": 109,
            "return": [
                "str",
                "bytes",
                "Union[Dict,Tuple]",
                "Dict[str,raiden.utils.Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "bytes",
                    "Dict[str,Any]",
                    "bool",
                    "Dict[str,str]"
                ],
                "target_type": [
                    "str",
                    "Optional[Dict]",
                    "Dict",
                    "None"
                ]
            }
        },
        "BaseSimilarityExplainer._compute_adhoc_similarity": {
            "name": "_compute_adhoc_similarity",
            "location": 142,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "grad_X": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "BaseSimilarityExplainer._compute_grad": {
            "name": "_compute_grad",
            "location": 158,
            "return": [
                "str",
                "bool",
                "List[int]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "int",
                    "torch.Tensor",
                    "tensorflow.Tensor",
                    "numpy.ndarray",
                    "numpy.array"
                ],
                "Y": [
                    "str",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "BaseSimilarityExplainer.reset_predictor": {
            "name": "reset_predictor",
            "location": 168,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/grad.py": {
        "get_options_string": {
            "name": "get_options_string",
            "location": 27,
            "return": [
                "Text",
                "str",
                "bytes",
                "golem_messages.message.base.Message"
            ],
            "arguments": {
                "enum": [
                    "str",
                    "bool",
                    "torch.Tensor",
                    "bytes"
                ]
            }
        },
        "GradientSimilarity.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "torch.Tensor",
                    "bool",
                    "str",
                    "raiden.utils.Any"
                ],
                "loss_fn": [
                    "torch.Tensor",
                    "bool",
                    "str",
                    "raiden.utils.Any"
                ],
                "sim_fn": [
                    "Text",
                    "Dict[str,Any]",
                    "str",
                    "Dict[str,float]",
                    "torch.device"
                ],
                "task": [
                    "Text",
                    "bytes",
                    "Dict",
                    "Optional[str]"
                ],
                "precompute_grads": [
                    "bool",
                    "torch.Tensor",
                    "str",
                    "raiden.utils.Any"
                ],
                "backend": [
                    "Text",
                    "Dict",
                    "Dict[str,Dict[str,Any]]",
                    "base.Connection"
                ],
                "device": [
                    "None",
                    "torch.Tensor",
                    "bool",
                    "str",
                    "raiden.utils.Any"
                ],
                "verbose": [
                    "bool",
                    "torch.Tensor",
                    "str",
                    "raiden.utils.Any"
                ]
            }
        },
        "GradientSimilarity.fit": {
            "name": "fit",
            "location": 137,
            "return": [
                "bool",
                "utils.Node",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "X_train": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ],
                "Y_train": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "GradientSimilarity._preprocess_args": {
            "name": "_preprocess_args",
            "location": 161,
            "return": [
                "Tuple",
                "int",
                "str",
                "List[int]",
                "float"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Union[pandas.DataFrame, numpy.ndarray]"
                ],
                "Y": [
                    "None",
                    "Optional[Dict[str,Any]]",
                    "Optional[int]",
                    "Dict"
                ]
            }
        },
        "GradientSimilarity.explain": {
            "name": "explain",
            "location": 201,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int"
                ],
                "Y": [
                    "int",
                    "None"
                ]
            }
        },
        "GradientSimilarity._build_explanation": {
            "name": "_build_explanation",
            "location": 255,
            "return": [
                "Explanation",
                "int",
                "bool",
                "cmk.utils.type_defs.EventRule",
                "bytes",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "scores": [
                    "str",
                    "bytes",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/metrics.py": {
        "dot": {
            "name": "dot",
            "location": 6,
            "return": [
                "Optional[int]",
                "str",
                "numpy.ndarray",
                "Optional[List[int]]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "Union[numpy.ndarray,pandas.DataFrame]"
                ],
                "Y": [
                    "int",
                    "numpy.ndarray",
                    "Union[numpy.ndarray,pandas.DataFrame]"
                ]
            }
        },
        "cos": {
            "name": "cos",
            "location": 27,
            "return": [
                "float",
                "Optional[int]",
                "str",
                "numpy.ndarray",
                "Optional[List[int]]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "nevergrad.common.Callable[[numpy.ndarray],numpy.ndarray]",
                    "numpy.array"
                ],
                "Y": [
                    "int",
                    "numpy.ndarray",
                    "nevergrad.common.Callable[[numpy.ndarray],numpy.ndarray]",
                    "numpy.array"
                ],
                "eps": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "asym_dot": {
            "name": "asym_dot",
            "location": 51,
            "return": [
                "Optional[int]",
                "str",
                "numpy.ndarray",
                "Optional[List[int]]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "Union[numpy.ndarray,pandas.DataFrame]"
                ],
                "Y": [
                    "int",
                    "numpy.ndarray"
                ],
                "eps": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/__init__.py": {},
    "alibi-master/alibi/explainers/similarity/backends/__init__.py": {
        "_select_backend": {
            "name": "_select_backend",
            "location": 14,
            "return": [
                "Type[Union[(alibi.explainers.similarity.backends.pytorch.base._PytorchBackend, alibi.explainers.similarity.backends.tensorflow.base._TensorFlowBackend)]]"
            ],
            "arguments": {
                "backend": [
                    "List[int]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/backends/pytorch/base.py": {
        "_PytorchBackend.get_grads": {
            "name": "get_grads",
            "location": 18,
            "return": [
                "dict",
                "Dict[str, Any]",
                "IO[str]",
                "Optional[str]"
            ],
            "arguments": {
                "model": [
                    "int",
                    "float"
                ],
                "X": [
                    "bool",
                    "int"
                ],
                "Y": [
                    "Optional[str]",
                    "Callable",
                    "str",
                    "None",
                    "MutableMapping[str,Any]",
                    "MutableMapping"
                ],
                "loss_fn": [
                    "Optional[str]",
                    "Callable",
                    "str",
                    "None",
                    "MutableMapping[str,Any]",
                    "MutableMapping"
                ]
            }
        },
        "_PytorchBackend.to_tensor": {
            "name": "to_tensor",
            "location": 57,
            "return": [
                "dict",
                "Dict[str, Any]",
                "List[str]",
                "List[dict]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "_PytorchBackend.set_device": {
            "name": "set_device",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "int",
                    "None",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "_PytorchBackend.to_numpy": {
            "name": "to_numpy",
            "location": 79,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "X": [
                    "int",
                    "str",
                    "Dict[str,str]",
                    "List[tuple[Union[Any,Any]]]",
                    "List[cirq.Qid]",
                    "bool",
                    "List[tuple[Union[str,torch.nn.Parameter]]]",
                    "List[Tuple[Any,Any]]",
                    "List[Tuple[str,torch.nn.Parameter]]"
                ]
            }
        },
        "_PytorchBackend.argmax": {
            "name": "argmax",
            "location": 84,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "X": [
                    "float",
                    "int",
                    "bytes",
                    "numpy.ndarray"
                ],
                "dim": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/backends/pytorch/__init__.py": {},
    "alibi-master/alibi/explainers/similarity/backends/tensorflow/base.py": {
        "_TensorFlowBackend.get_grads": {
            "name": "get_grads",
            "location": 18,
            "return": [
                "int",
                "List[int]",
                "bytes",
                "str"
            ],
            "arguments": {
                "model": [
                    "Optional[float]",
                    "float",
                    "numpy.array",
                    "None"
                ],
                "X": [
                    "Dict",
                    "numpy.ndarray",
                    "Union[tensorflow.Tensor,numpy.ndarray]",
                    "numpy.array"
                ],
                "Y": [
                    "int"
                ],
                "loss_fn": [
                    "int"
                ]
            }
        },
        "_TensorFlowBackend.to_tensor": {
            "name": "to_tensor",
            "location": 57,
            "return": [
                "Dict[str, Any]",
                "Dict[str, Dict[str, int]]",
                "Dict[str, int]"
            ],
            "arguments": {
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "_TensorFlowBackend.set_device": {
            "name": "set_device",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "device": [
                    "Optional[float]",
                    "None",
                    "str",
                    "Any",
                    "float",
                    "Optional[str]",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]"
                ]
            }
        },
        "_TensorFlowBackend.to_numpy": {
            "name": "to_numpy",
            "location": 73,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "_TensorFlowBackend.argmax": {
            "name": "argmax",
            "location": 78,
            "return": [
                "str",
                "List[str]",
                "List[int]",
                "List[list[float]]",
                "int",
                "float"
            ],
            "arguments": {
                "X": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ],
                "dim": [
                    "int",
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/similarity/backends/tensorflow/__init__.py": {},
    "alibi-master/alibi/explainers/tests/conftest.py": {
        "models": {
            "name": "models",
            "location": 32,
            "return": [
                "list[]"
            ],
            "arguments": {
                "request": [
                    "str"
                ]
            }
        },
        "mnist_data": {
            "name": "mnist_data",
            "location": 44,
            "return": [
                "dict",
                "str",
                "Dict[int, Dict[int, Any]]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "List[List[str]]"
            ],
            "arguments": {}
        },
        "boston_data": {
            "name": "boston_data",
            "location": 49,
            "return": [
                "dict",
                "str",
                "Dict[int, Dict[int, Any]]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "List[List[str]]"
            ],
            "arguments": {}
        },
        "iris_data": {
            "name": "iris_data",
            "location": 54,
            "return": [
                "dict",
                "str",
                "Dict[int, Dict[int, Any]]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "List[List[str]]"
            ],
            "arguments": {}
        },
        "adult_data": {
            "name": "adult_data",
            "location": 66,
            "return": [
                "dict",
                "str",
                "Dict[int, Dict[int, Any]]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "List[List[str]]"
            ],
            "arguments": {}
        },
        "movie_sentiment_data": {
            "name": "movie_sentiment_data",
            "location": 78,
            "return": [
                "Callable",
                "str",
                "Union[str, Sequence[str]]",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "rf_classifier": {
            "name": "rf_classifier",
            "location": 92,
            "return": [
                "Tuple[Optional[RandomForestClassifier]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "lr_classifier": {
            "name": "lr_classifier",
            "location": 123,
            "return": [
                "Tuple[Union[LogisticRegression,bool]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "lr_regressor": {
            "name": "lr_regressor",
            "location": 151,
            "return": [
                "Tuple[Union[LinearRegression,bool]]",
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "request": []
            }
        },
        "at_defaults": {
            "name": "at_defaults",
            "location": 177,
            "return": [
                "Dict[Text,Union[float,int,None]]",
                "str",
                "utils.Node",
                "List[int]",
                "int"
            ],
            "arguments": {
                "request": []
            }
        },
        "at_iris_explainer": {
            "name": "at_iris_explainer",
            "location": 200,
            "return": [
                "Tuple[AnchorTabular]",
                "Dict[str,Any]",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "iris_data": [
                    "bytes",
                    "bool",
                    "Tuple[int, str, bytearray]",
                    "int"
                ],
                "rf_classifier": [
                    "Dict[str, Any]",
                    "int",
                    "str",
                    "bool"
                ],
                "request": [
                    "Optional[str]",
                    "Callable[..., Awaitable]"
                ]
            }
        },
        "at_adult_explainer": {
            "name": "at_adult_explainer",
            "location": 218,
            "return": [
                "Tuple[AnchorTabular]",
                "Dict[str,Any]",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "adult_data": [
                    "bytes",
                    "bool",
                    "Tuple[int, str, bytearray]",
                    "int"
                ],
                "rf_classifier": [
                    "int",
                    "list",
                    "Optional[Dict]",
                    "bool",
                    "float",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]"
                ],
                "request": [
                    "Optional[str]",
                    "Callable[..., Awaitable]"
                ]
            }
        },
        "mock_kernel_shap_explainer": {
            "name": "mock_kernel_shap_explainer",
            "location": 241,
            "return": [
                "float",
                "Callable[[bytes], None]",
                "bool",
                "str"
            ],
            "arguments": {
                "request": [
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "mock_ale_explainer": {
            "name": "mock_ale_explainer",
            "location": 254,
            "return": [
                "ALE",
                "float",
                "Callable[[bytes],None]",
                "bool",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "mock_tree_shap_explainer": {
            "name": "mock_tree_shap_explainer",
            "location": 266,
            "return": [
                "Tuple[bytes]",
                "Optional[str]",
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {
                "monkeypatch": [
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Dict[str, str]"
                ],
                "request": [
                    "Callable[..., Awaitable[dict]]"
                ]
            }
        },
        "no_warnings": {
            "name": "no_warnings",
            "location": 290,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "caplog": [
                    "List[Dict[str, float]]",
                    "logging.Logger",
                    "str",
                    "IO[str]"
                ]
            }
        },
        "no_errors": {
            "name": "no_errors",
            "location": 302,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "caplog": [
                    "logging.LogRecord",
                    "IO[str]",
                    "logging.FileHandler"
                ]
            }
        },
        "pytest_configure": {
            "name": "pytest_configure",
            "location": 314,
            "return": [
                "None"
            ],
            "arguments": {
                "config": [
                    "Dict[str, Any]"
                ]
            }
        },
        "pytest_collection_modifyitems": {
            "name": "pytest_collection_modifyitems",
            "location": 320,
            "return": [
                "None"
            ],
            "arguments": {
                "config": [
                    "dict",
                    "Dict[str, Any]"
                ],
                "items": [
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "disable_tf2": {
            "name": "disable_tf2",
            "location": 337,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "lang_model": {
            "name": "lang_model",
            "location": 351,
            "return": [
                "str",
                "RobertaBase",
                "bytes",
                "BertBaseUncased",
                "int",
                "DistilbertBaseUncased",
                "bytearray",
                "None"
            ],
            "arguments": {
                "request": []
            }
        },
        "nlp": {
            "name": "nlp",
            "location": 367,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/tests/test_ale.py": {
        "test_ale_num_linear_regression": {
            "name": "test_ale_num_linear_regression",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "min_bin_points": [
                    "str",
                    "numpy.ndarray"
                ],
                "lr_regressor": [
                    "bool"
                ],
                "dataset": [
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "test_ale_num_logistic_regression": {
            "name": "test_ale_num_logistic_regression",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "min_bin_points": [
                    "str",
                    "Dict[str,numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "lr_classifier": [
                    "bool"
                ],
                "dataset": [
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "test_get_quantiles": {
            "name": "test_get_quantiles",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "input_dim": [
                    "int",
                    "Callable",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "Callable",
                    "bool"
                ],
                "num_points": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "test_adaptive_grid": {
            "name": "test_adaptive_grid",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "float",
                    "List[int]"
                ],
                "min_bin_points": [
                    "int",
                    "Dict"
                ]
            }
        },
        "uncollect_if_n_features_more_than_input_dim": {
            "name": "uncollect_if_n_features_more_than_input_dim",
            "location": 73,
            "return": [
                "bool",
                "str",
                "int",
                "float"
            ],
            "arguments": {}
        },
        "test_explain": {
            "name": "test_explain",
            "location": 91,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_ale_explainer": [],
                "features": [],
                "input_dim": [],
                "batch_size": [],
                "custom_grid": [],
                "num_grid_points": [
                    "int",
                    "click.testing.CliRunner"
                ]
            }
        },
        "test_constant_feature": {
            "name": "test_constant_feature",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "extrapolate_constant": [
                    "float",
                    "Optional[int]",
                    "int",
                    "Tuple[int,int]",
                    "None",
                    "Tuple[Union[int,int]]"
                ],
                "extrapolate_constant_perc": [
                    "float",
                    "Optional[int]",
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "extrapolate_constant_min": [
                    "float",
                    "Optional[int]",
                    "int",
                    "Tuple[int,int]",
                    "None",
                    "Tuple[Union[int,int]]"
                ],
                "constant_value": [
                    "float",
                    "int",
                    "bool",
                    "numpy.ndarray"
                ],
                "feature": [
                    "Optional[int]",
                    "int",
                    "float",
                    "str",
                    "None",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "custom_grid": [
                    "Optional[bool]",
                    "bool",
                    "None"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_base.py": {
        "test_anchor_base_beam": {
            "name": "test_anchor_base_beam",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "rf_classifier": [
                    "str"
                ],
                "at_defaults": [
                    "bytes",
                    "str"
                ],
                "at_iris_explainer": [
                    "Dict[str,Any]",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_image.py": {
        "test_scale_image": {
            "name": "test_scale_image",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "predict_fn": {
            "name": "predict_fn",
            "location": 25,
            "return": [
                "Dict[str, Dict[str, int]]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_sampler": {
            "name": "test_sampler",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "predict_fn": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "models": [
                    "bool"
                ],
                "mnist_data": [
                    "str",
                    "Dict[str,Optional[str]]",
                    "bool"
                ]
            }
        },
        "test_anchor_image": {
            "name": "test_anchor_image",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "predict_fn": [
                    "List[bool]",
                    "torch.Tensor"
                ],
                "models": [],
                "mnist_data": [
                    "str",
                    "bool"
                ],
                "images_background": [
                    "List",
                    "numpy.ndarray"
                ]
            }
        },
        "test_anchor_image_fails_init_torch_float64": {
            "name": "test_anchor_image_fails_init_torch_float64",
            "location": 169,
            "return": [
                "None"
            ],
            "arguments": {
                "predict_fn": [
                    "str"
                ],
                "models": [
                    "str"
                ]
            }
        },
        "bad_predictor": {
            "name": "bad_predictor",
            "location": 174,
            "return": [
                "List",
                "str",
                "List[Dict]",
                "List[str]",
                "Union[List,Tuple]",
                "numpy.array"
            ],
            "arguments": {
                "x": [
                    "List[str]",
                    "List[int]",
                    "Optional[List[str]]",
                    "List",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "test_anchor_image_fails_init_bad_image_shape_predictor_call": {
            "name": "test_anchor_image_fails_init_bad_image_shape_predictor_call",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_anchor_image_fails_bad_predictor_return_type": {
            "name": "test_anchor_image_fails_bad_predictor_return_type",
            "location": 194,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "predict_fn.func": {
            "name": "func",
            "location": 33,
            "return": [
                "str",
                "float",
                "Optional[str]"
            ],
            "arguments": {
                "image": [
                    "dict",
                    "torch.Tensor",
                    "numpy.ndarray",
                    "Dict[str, Any]",
                    "bytes"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_tabular.py": {
        "uncollect_if_test_explainer": {
            "name": "uncollect_if_test_explainer",
            "location": 15,
            "return": [
                "bool",
                "str",
                "int",
                "Dict"
            ],
            "arguments": {}
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "n_explainer_runs": [
                    "bytes",
                    "int",
                    "float",
                    "Optional[bool]",
                    "str",
                    "bool",
                    "Optional[int]"
                ],
                "at_defaults": [
                    "str",
                    "bool",
                    "int",
                    "rl_algorithms.utils.config.ConfigDict",
                    "float"
                ],
                "rf_classifier": [
                    "bool",
                    "float",
                    "int"
                ],
                "explainer": [
                    "str",
                    "Optional[numpy.ndarray]",
                    "raiden.utils.Address",
                    "raiden.utils.BlockIdentifier"
                ],
                "test_instance_idx": [
                    "str",
                    "int"
                ],
                "caplog": [
                    "bytes",
                    "int",
                    "float",
                    "Optional[bool]",
                    "str",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "uncollect_if_test_sampler": {
            "name": "uncollect_if_test_sampler",
            "location": 91,
            "return": [
                "bool",
                "str",
                "int",
                "Dict"
            ],
            "arguments": {}
        },
        "test_distributed_anchor_tabular": {
            "name": "test_distributed_anchor_tabular",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "ncpu": [
                    "int",
                    "float",
                    "bool",
                    "List[int]",
                    "List[numpy.ndarray]"
                ],
                "predict_type": [
                    "bool",
                    "int",
                    "str",
                    "Optional[int]",
                    "cmk.utils.type_defs.HostName"
                ],
                "at_defaults": [
                    "int",
                    "str",
                    "float",
                    "Optional[dict]",
                    "bool"
                ],
                "iris_data": [
                    "bytes",
                    "List[int]",
                    "str",
                    "torch.utils.data.DataLoader",
                    "Optional[\"TrackingData\"]",
                    "int",
                    "dict"
                ],
                "rf_classifier": [
                    "int",
                    "str",
                    "float",
                    "Optional[dict]",
                    "bool"
                ],
                "test_instance_idx": [
                    "bool",
                    "Dict[int, Set[int]]",
                    "int",
                    "tuple"
                ]
            }
        },
        "test_sampler": {
            "name": "test_sampler",
            "location": 210,
            "return": [
                "None"
            ],
            "arguments": {
                "test_instance_idx": [
                    "str",
                    "tuple"
                ],
                "anchors": [
                    "str",
                    "List[int]",
                    "Dict[str, Any]",
                    "Iterable[str]",
                    "List[str]"
                ],
                "nb_samples": [],
                "dataset": [
                    "str",
                    "Tuple[str, str]"
                ],
                "rf_classifier": [
                    "str",
                    "List[int]",
                    "Dict[str, Any]",
                    "Iterable[str]",
                    "List[str]"
                ],
                "explainer": [
                    "int",
                    "Sequence[int]",
                    "tests.basilisp.helpers.CompileFn",
                    "bool"
                ]
            }
        },
        "bad_predictor": {
            "name": "bad_predictor",
            "location": 313,
            "return": [
                "List",
                "str",
                "List[Dict]",
                "List[str]",
                "Union[List,Tuple]",
                "numpy.array"
            ],
            "arguments": {
                "x": [
                    "Optional[List[str]]",
                    "numpy.ndarray",
                    "List[int]",
                    "list"
                ]
            }
        },
        "test_anchor_tabular_fails_init_bad_feature_names_predictor_call": {
            "name": "test_anchor_tabular_fails_init_bad_feature_names_predictor_call",
            "location": 325,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_anchor_tabular_fails_bad_predictor_return_type": {
            "name": "test_anchor_tabular_fails_bad_predictor_return_type",
            "location": 333,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/tests/test_anchor_text.py": {
        "uncollect_if_test_explainer": {
            "name": "uncollect_if_test_explainer",
            "location": 17,
            "return": [
                "bool",
                "str",
                "int",
                "Dict"
            ],
            "arguments": {}
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "text": [
                    "str",
                    "bool"
                ],
                "n_punctuation_marks": [
                    "float",
                    "int",
                    "bytearray",
                    "bool",
                    "str",
                    "numpy.ndarray",
                    "Tuple[numpy.ndarray, numpy.ndarray]"
                ],
                "n_unique_words": [
                    "int",
                    "List[int]",
                    "bytes",
                    "str",
                    "Dict[int, str]",
                    "List[float]",
                    "List[Tuple[int, int]]"
                ],
                "lr_classifier": [
                    "int",
                    "bool"
                ],
                "predict_type": [
                    "List[int]",
                    "Optional[\"ShippingRateInputType\"]",
                    "Type[str]",
                    "dict"
                ],
                "anchor": [
                    "int"
                ],
                "use_proba": [
                    "Tuple[int]",
                    "Mapping[str, Tuple[float, float, float]]",
                    "int"
                ],
                "sampling_strategy": [
                    "str",
                    "type"
                ],
                "filling": [
                    "Tuple[int]",
                    "Mapping[str, Tuple[float, float, float]]",
                    "int"
                ],
                "threshold": [
                    "int",
                    "Iterable",
                    "Tuple[int, int, int, int]",
                    "numpy.array"
                ],
                "lang_model": [
                    "int",
                    "type"
                ],
                "nlp": [
                    "int",
                    "str"
                ]
            }
        },
        "test_neighbors": {
            "name": "test_neighbors",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "nlp": [
                    "tests.basilisp.helpers.CompileFn",
                    "str",
                    "tests.async_mock.Mock",
                    "float"
                ]
            }
        },
        "test_lm_punctuation": {
            "name": "test_lm_punctuation",
            "location": 160,
            "return": [
                "None"
            ],
            "arguments": {
                "text": [
                    "str",
                    "int",
                    "bool"
                ],
                "min_num": [
                    "str",
                    "int",
                    "bool"
                ],
                "lang_model": [
                    "str"
                ]
            }
        },
        "test_lm_stopwords": {
            "name": "test_lm_stopwords",
            "location": 191,
            "return": [
                "None"
            ],
            "arguments": {
                "text": [
                    "str",
                    "tests.basilisp.helpers.CompileFn",
                    "Tuple[str, str]"
                ],
                "stopwords": [
                    "Union[str, IO]",
                    "bytes",
                    "int"
                ],
                "lang_model": [
                    "str"
                ]
            }
        },
        "test_lm_precision": {
            "name": "test_lm_precision",
            "location": 228,
            "return": [
                "None"
            ],
            "arguments": {
                "lang_model": [
                    "Type",
                    "Sequence[int]",
                    "str"
                ],
                "lr_classifier": [
                    "bool",
                    "str"
                ],
                "movie_sentiment_data": [
                    "Dict[str, Optional[str]]",
                    "dict",
                    "tuple"
                ],
                "punctuation": [
                    "bool",
                    "str"
                ],
                "stopwords": [
                    "bool",
                    "str"
                ]
            }
        },
        "test_lm_stopwords_punctuation": {
            "name": "test_lm_stopwords_punctuation",
            "location": 279,
            "return": [
                "None"
            ],
            "arguments": {
                "lang_model": [
                    "int"
                ],
                "punctuation": [
                    "bool",
                    "str"
                ],
                "stopwords": [
                    "bool",
                    "str"
                ],
                "filling": [
                    "raiden.api.resAPIServer"
                ],
                "movie_sentiment_data": [
                    "dict",
                    "Dict[str, Optional[str]]",
                    "tuple",
                    "Dict[str, str]",
                    "Dict[str, Any]"
                ],
                "sample_proba": [
                    "bool",
                    "str"
                ],
                "nlp": [
                    "bool",
                    "int",
                    "Tuple[Any, Any, Any, Any, Any]"
                ]
            }
        },
        "test_lm_split": {
            "name": "test_lm_split",
            "location": 348,
            "return": [
                "None"
            ],
            "arguments": {
                "lang_model": [],
                "head_gt": [],
                "num_tokens": [
                    "int",
                    "Callable",
                    "float",
                    "str"
                ]
            }
        },
        "test_lm_mask": {
            "name": "test_lm_mask",
            "location": 368,
            "return": [
                "None"
            ],
            "arguments": {
                "lang_model": [
                    "str",
                    "int"
                ],
                "num_tokens": [
                    "int",
                    "Optional[Set[str]]",
                    "List[Dict[str, str]]"
                ],
                "sample_proba": [],
                "filling": [
                    "List[numpy.array]",
                    "List[int]",
                    "bool",
                    "raiden.tests.integration.fixtures.raiden_network.RestartNode"
                ]
            }
        },
        "test_lm_sample_punctuation": {
            "name": "test_lm_sample_punctuation",
            "location": 408,
            "return": [
                "None"
            ],
            "arguments": {
                "lang_model": [
                    "List[str]",
                    "raiden.utils.Address"
                ],
                "punctuation": [
                    "tests.conftesWorker",
                    "int",
                    "str"
                ],
                "filling": [
                    "tests.conftesWorker",
                    "int",
                    "str"
                ],
                "movie_sentiment_data": [
                    "Dict[str, Optional[str]]",
                    "dict",
                    "tuple"
                ],
                "sample_proba": [
                    "tests.conftesWorker",
                    "int",
                    "str"
                ]
            }
        },
        "bad_predictor_return_type": {
            "name": "bad_predictor_return_type",
            "location": 453,
            "return": [
                "Tuple[float, float]",
                "numpy.ndarray",
                "bool"
            ],
            "arguments": {
                "x": [
                    "type",
                    "numpy.ndarray",
                    "List[str]",
                    "Union[int, float]"
                ]
            }
        },
        "bad_predictor_input_type": {
            "name": "bad_predictor_input_type",
            "location": 462,
            "return": [
                "bool"
            ],
            "arguments": {
                "x": [
                    "float"
                ]
            }
        },
        "test_anchor_text_fails_init_bad_predictor_input_type_call": {
            "name": "test_anchor_text_fails_init_bad_predictor_input_type_call",
            "location": 471,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_anchor_text_fails_wrong_predictor_return_type": {
            "name": "test_anchor_text_fails_wrong_predictor_return_type",
            "location": 476,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/explainers/tests/test_cem.py": {
        "test_cem": {
            "name": "test_cem",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "disable_tf2": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_cfproto.py": {
        "tf_keras_iris_explainer": {
            "name": "tf_keras_iris_explainer",
            "location": 10,
            "return": [
                "typing.Generator[tuple[]]"
            ],
            "arguments": {
                "request": [],
                "models": [
                    "int",
                    "str"
                ],
                "iris_data": [
                    "List[str]",
                    "Dict[str,str]",
                    "str",
                    "bytes",
                    "Optional[bytes]"
                ]
            }
        },
        "test_tf_keras_iris_explainer": {
            "name": "test_tf_keras_iris_explainer",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "disable_tf2": [
                    "bool",
                    "raiden.utils.Callable"
                ],
                "iris_data": [
                    "List[list[int]]",
                    "int",
                    "str",
                    "List[str]",
                    "List[List[int]]",
                    "torch.utils.data.DataLoader",
                    "Optional[str]",
                    "bool"
                ],
                "tf_keras_iris_explainer": [
                    "str",
                    "int",
                    "float"
                ],
                "use_kdtree": [
                    "bool",
                    "raiden.utils.Callable"
                ],
                "k": [
                    "Sequence[int]",
                    "List[int]",
                    "Optional[float]",
                    "float",
                    "None"
                ]
            }
        },
        "tf_keras_adult_explainer": {
            "name": "tf_keras_adult_explainer",
            "location": 86,
            "return": [
                "typing.Generator[tuple[]]"
            ],
            "arguments": {
                "request": [
                    "bool"
                ],
                "models": [
                    "bool"
                ],
                "adult_data": [
                    "str",
                    "Dict",
                    "bob_emploi.frontend.api.auth_pb2.AuthRequest",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "test_tf_keras_adult_explainer": {
            "name": "test_tf_keras_adult_explainer",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "disable_tf2": [
                    "bool",
                    "raiden.utils.Callable"
                ],
                "adult_data": [
                    "str",
                    "bool",
                    "None",
                    "Optional[str]",
                    "int"
                ],
                "tf_keras_adult_explainer": [
                    "str",
                    "int",
                    "float"
                ],
                "use_kdtree": [
                    "bool",
                    "raiden.utils.Callable"
                ],
                "k": [
                    "List[int]",
                    "Optional[int]",
                    "int",
                    "numpy.ndarray",
                    "None"
                ],
                "d_type": [
                    "Type",
                    "Callable",
                    "raiden.utils.TokenAmount"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_cfrl.py": {
        "test_he_preprocessor": {
            "name": "test_he_preprocessor",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": []
            }
        },
        "test_split_ohe": {
            "name": "test_split_ohe",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": []
            }
        },
        "test_get_numerical_condition": {
            "name": "test_get_numerical_condition",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str"
                ]
            }
        },
        "test_get_categorical_condition": {
            "name": "test_get_categorical_condition",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str"
                ]
            }
        },
        "test_sample": {
            "name": "test_sample",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [],
                "seed": [
                    "int",
                    "str"
                ]
            }
        },
        "test_hard_distribution": {
            "name": "test_hard_distribution",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "Y_shape": [
                    "bool",
                    "int",
                    "str"
                ],
                "num_classes": [
                    "str",
                    "Iterable[Any]"
                ]
            }
        },
        "tf_keras_iris_explainer": {
            "name": "tf_keras_iris_explainer",
            "location": 242,
            "return": [
                "CounterfactualRLTabular",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "models": [
                    "bool",
                    "str"
                ],
                "iris_data": [
                    "bytes",
                    "torch.Tensor"
                ],
                "rf_classifier": [
                    "bytes",
                    "List[int]",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int, int, int]"
                ]
            }
        },
        "test_explainer": {
            "name": "test_explainer",
            "location": 303,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_keras_iris_explainer": [
                    "bool",
                    "str",
                    "int"
                ],
                "iris_data": [
                    "tensorflow.Tensor",
                    "Type['Frame']",
                    "int",
                    "torch.Tensor",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "test_sample_differentiable": {
            "name": "test_sample_differentiable",
            "location": 326,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "Iterable[int]"
                ],
                "backend": [
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        },
        "test_l0_loss": {
            "name": "test_l0_loss",
            "location": 376,
            "return": [
                "None"
            ],
            "arguments": {
                "reduction": [
                    "Iterable[Any]",
                    "str"
                ],
                "backend": []
            }
        },
        "test_l1_loss": {
            "name": "test_l1_loss",
            "location": 415,
            "return": [
                "None"
            ],
            "arguments": {
                "reduction": [
                    "Iterable[Any]",
                    "str"
                ],
                "backend": []
            }
        },
        "test_consistency_loss": {
            "name": "test_consistency_loss",
            "location": 447,
            "return": [
                "None"
            ],
            "arguments": {
                "backend": [
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        },
        "test_sparsity_loss": {
            "name": "test_sparsity_loss",
            "location": 473,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "Iterable[int]"
                ],
                "backend": [
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        },
        "test_l0_loss.generate_random_labels": {
            "name": "generate_random_labels",
            "location": 380,
            "return": [
                "Tuple",
                "str",
                "bool",
                "Dict[str,str]",
                "bytes",
                "float"
            ],
            "arguments": {}
        },
        "tf_keras_iris_explainer.DecoderList.__init__": {
            "name": "__init__",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "decoder": [
                    "str",
                    "torch.nn.Module"
                ]
            }
        },
        "tf_keras_iris_explainer.DecoderList.call": {
            "name": "call",
            "location": 268,
            "return": [
                "List",
                "int",
                "torch.utils.data.DataLoader",
                "float"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "Callable",
                    "int",
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_counterfactual.py": {
        "logistic_iris": {
            "name": "logistic_iris",
            "location": 13,
            "return": [
                "str",
                "Tuple[Union[list[str],int,str,tuple[Union[Literal,Any]],list,dict[str,Any],DefaultDict]]"
            ],
            "arguments": {}
        },
        "cf_iris_explainer": {
            "name": "cf_iris_explainer",
            "location": 20,
            "return": [
                "typing.Generator[tuple[typing.Union[float,int,set[],dict[int, dict[str, int]],str,int,float,list[list[bool]],str,set[],typing.Type,typing.Pattern,float,str]]]"
            ],
            "arguments": {
                "request": [],
                "logistic_iris": [
                    "str",
                    "Dict"
                ]
            }
        },
        "keras_mnist_cf_explainer": {
            "name": "keras_mnist_cf_explainer",
            "location": 32,
            "return": [
                "typing.Generator[tuple[str]]"
            ],
            "arguments": {
                "request": [],
                "models": [
                    "str"
                ]
            }
        },
        "test_define_func": {
            "name": "test_define_func",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "logistic_iris": [],
                "target_class": [
                    "Dict[str,Sequence[Any]]"
                ]
            }
        },
        "test_cf_explainer_iris": {
            "name": "test_cf_explainer_iris",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "disable_tf2": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ],
                "cf_iris_explainer": [
                    "bool"
                ]
            }
        },
        "test_keras_mnist_explainer": {
            "name": "test_keras_mnist_explainer",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "disable_tf2": [
                    "Optional[int]",
                    "int",
                    "str",
                    "bool",
                    "None"
                ],
                "keras_mnist_cf_explainer": [
                    "List[float]",
                    "str",
                    "int"
                ],
                "mnist_data": [
                    "List[list[int]]",
                    "List[List[int]]",
                    "bytes",
                    "Tuple",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_integrated_gradients.py": {
        "ffn_model": {
            "name": "ffn_model",
            "location": 57,
            "return": [
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "request": []
            }
        },
        "ffn_model_multi_inputs": {
            "name": "ffn_model_multi_inputs",
            "location": 78,
            "return": [
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "request": []
            }
        },
        "ffn_model_subclass": {
            "name": "ffn_model_subclass",
            "location": 103,
            "return": [
                "allennlp.models.model.Model",
                "Linear"
            ],
            "arguments": {
                "request": [
                    "Dict[str, Any]",
                    "list",
                    "bool"
                ]
            }
        },
        "ffn_model_subclass_list_input": {
            "name": "ffn_model_subclass_list_input",
            "location": 137,
            "return": [
                "Linear"
            ],
            "arguments": {
                "request": [
                    "dict"
                ]
            }
        },
        "ffn_model_sequential": {
            "name": "ffn_model_sequential",
            "location": 171,
            "return": [
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "request": []
            }
        },
        "uncollect_if_both_or_neither_target_fn_target": {
            "name": "uncollect_if_both_or_neither_target_fn_target",
            "location": 192,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "test_integrated_gradients_model_sequential": {
            "name": "test_integrated_gradients_model_sequential",
            "location": 212,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_sequential": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "method": [
                    "str",
                    "int",
                    "bool",
                    "Dict[str, int]"
                ],
                "baselines": [
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ],
                "target_fn": [
                    "str",
                    "int",
                    "bool",
                    "Dict[str, int]"
                ],
                "target": [
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "test_integrated_gradients_model_subclass": {
            "name": "test_integrated_gradients_model_subclass",
            "location": 241,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_subclass": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "method": [
                    "str",
                    "int",
                    "bool",
                    "Dict[str, int]"
                ],
                "baselines": [
                    "str",
                    "bool",
                    "Tuple[str]"
                ],
                "kwargs": [],
                "target_fn": [
                    "str",
                    "int",
                    "bool",
                    "Dict[str, int]"
                ],
                "target": [
                    "str",
                    "bool",
                    "Tuple[str]"
                ]
            }
        },
        "test_integrated_gradients_model_subclass_list_input": {
            "name": "test_integrated_gradients_model_subclass_list_input",
            "location": 271,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_subclass_list_input": [
                    "str",
                    "sustainerds.api.core.resource.ResourceContext"
                ],
                "method": [
                    "int",
                    "str"
                ],
                "baselines": [
                    "str",
                    "Iterable[Tuple[str, dict]]",
                    "int"
                ],
                "target_fn": [
                    "int",
                    "str"
                ],
                "target": [
                    "str",
                    "Iterable[Tuple[str, dict]]",
                    "int"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_multi_inputs": {
            "name": "test_integrated_gradients_binary_classification_multi_inputs",
            "location": 308,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_multi_inputs": [
                    "str",
                    "bool",
                    "Union[str, int]",
                    "int"
                ],
                "method": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "baselines": [
                    "str",
                    "Iterable[Tuple[str, dict]]",
                    "int",
                    "Optional[str]",
                    "bob_emploi.frontend.api.project_pb2.Project"
                ],
                "target_fn": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "target": [
                    "str",
                    "Iterable[Tuple[str, dict]]",
                    "int",
                    "Optional[str]",
                    "bob_emploi.frontend.api.project_pb2.Project"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_single_output_multi_inputs": {
            "name": "test_integrated_gradients_binary_classification_single_output_multi_inputs",
            "location": 345,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_multi_inputs": [
                    "str",
                    "bool"
                ],
                "method": [
                    "str",
                    "int"
                ],
                "baselines": [
                    "Iterable[Tuple[str, dict]]",
                    "int",
                    "pathfinding_service.api.PFSApi",
                    "bob_emploi.frontend.api.project_pb2.Project"
                ],
                "target_fn": [
                    "str",
                    "int"
                ],
                "target": [
                    "Iterable[Tuple[str, dict]]",
                    "int",
                    "pathfinding_service.api.PFSApi",
                    "bob_emploi.frontend.api.project_pb2.Project"
                ],
                "recwarn": [
                    "List[numpy.array]",
                    "List[int]",
                    "str",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "test_integrated_gradients_binary_classification": {
            "name": "test_integrated_gradients_binary_classification",
            "location": 390,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model": [
                    "bool",
                    "str"
                ],
                "method": [
                    "int",
                    "str"
                ],
                "baselines": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ],
                "target_fn": [
                    "int",
                    "str"
                ],
                "target": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_single_output": {
            "name": "test_integrated_gradients_binary_classification_single_output",
            "location": 418,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model": [
                    "bool"
                ],
                "method": [
                    "str",
                    "bool"
                ],
                "baselines": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ],
                "target_fn": [
                    "str",
                    "bool"
                ],
                "target": [
                    "Dict[str, Any]",
                    "int",
                    "str"
                ],
                "recwarn": [
                    "bool"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_single_output_squash_output": {
            "name": "test_integrated_gradients_binary_classification_single_output_squash_output",
            "location": 452,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model": [
                    "str",
                    "int",
                    "Optional[Dict[str, Any]]"
                ],
                "method": [
                    "bool"
                ],
                "baselines": [
                    "str",
                    "Dict[str, Any]",
                    "int"
                ],
                "target": [
                    "str",
                    "Dict[str, Any]",
                    "int"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_layer": {
            "name": "test_integrated_gradients_binary_classification_layer",
            "location": 482,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model": [
                    "bool",
                    "str"
                ],
                "method": [],
                "layer_nb": [
                    "Optional[str]",
                    "list"
                ],
                "baselines": [
                    "str",
                    "bool"
                ],
                "layer_inputs_attributions": [
                    "str"
                ],
                "target_fn": [],
                "target": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_layer_subclass": {
            "name": "test_integrated_gradients_binary_classification_layer_subclass",
            "location": 540,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_subclass": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "method": [
                    "str",
                    "Dict[str, int]",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "layer_nb": [
                    "str",
                    "list",
                    "Optional[str]"
                ],
                "baselines": [
                    "str",
                    "bool"
                ],
                "kwargs": [],
                "layer_inputs_attributions": [],
                "target_fn": [
                    "str",
                    "Dict[str, int]",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "target": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_integrated_gradients_regression": {
            "name": "test_integrated_gradients_regression",
            "location": 594,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model": [
                    "bool",
                    "str"
                ],
                "method": [
                    "bool"
                ],
                "baselines": [
                    "bool"
                ]
            }
        },
        "test_run_forward_from_layer": {
            "name": "test_run_forward_from_layer",
            "location": 614,
            "return": [
                "None"
            ],
            "arguments": {
                "layer_nb": [
                    "allennlp.models.Model"
                ],
                "run_from_layer_inputs": [
                    "int"
                ]
            }
        },
        "test_check_target": {
            "name": "test_check_target",
            "location": 691,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "test_select_target": {
            "name": "test_select_target",
            "location": 705,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "test_integrated_gradients_binary_classification_multi_layer": {
            "name": "test_integrated_gradients_binary_classification_multi_layer",
            "location": 725,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model": [
                    "bool",
                    "str"
                ],
                "method": [
                    "bool",
                    "Callable"
                ],
                "baselines": [
                    "bool"
                ]
            }
        },
        "test_integrated_gradients_binary_classification_multi_layer_subclassed": {
            "name": "test_integrated_gradients_binary_classification_multi_layer_subclassed",
            "location": 748,
            "return": [
                "None"
            ],
            "arguments": {
                "ffn_model_subclass": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "method": [
                    "str",
                    "List[str]",
                    "bool"
                ],
                "baselines": [
                    "bool",
                    "str"
                ]
            }
        },
        "good_model": {
            "name": "good_model",
            "location": 766,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "str",
                    "Iterable[List[T]]"
                ]
            }
        },
        "bad_model": {
            "name": "bad_model",
            "location": 775,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "str",
                    "Iterable[List[T]]"
                ]
            }
        },
        "test__get_target_from_target_fn__with_2d_output_argmax": {
            "name": "test__get_target_from_target_fn__with_2d_output_argmax",
            "location": 784,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test__get_target_from_target_fn__with_3d_output_argmax": {
            "name": "test__get_target_from_target_fn__with_3d_output_argmax",
            "location": 791,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "ffn_model_subclass.Linear.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dim": [],
                "activation": []
            }
        },
        "ffn_model_subclass.Linear.call": {
            "name": "call",
            "location": 117,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [],
                "mask": [
                    "None"
                ]
            }
        },
        "ffn_model_subclass_list_input.Linear.__init__": {
            "name": "__init__",
            "location": 146,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dim": [
                    "str"
                ],
                "activation": [
                    "str",
                    "bool",
                    "List[str]",
                    "float"
                ]
            }
        },
        "ffn_model_subclass_list_input.Linear.call": {
            "name": "call",
            "location": 153,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_shap_wrappers.py": {
        "gen_group_names": {
            "name": "gen_group_names",
            "location": 37,
            "return": [
                "None",
                "List[str]",
                "str",
                "Iterable",
                "Set",
                "int",
                "List"
            ],
            "arguments": {
                "n_groups": [
                    "int",
                    "bool"
                ]
            }
        },
        "random_ints_with_sum": {
            "name": "random_ints_with_sum",
            "location": 48,
            "return": [
                "typing.Generator[int]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        },
        "gen_random_groups": {
            "name": "gen_random_groups",
            "location": 63,
            "return": [
                "None",
                "Union[tuple,list]",
                "List[list]",
                "List[int]",
                "Dict[str,Any]",
                "str"
            ],
            "arguments": {
                "n_cols": [
                    "int",
                    "dict",
                    "Sequence[Any]",
                    "list",
                    "List[int]"
                ]
            }
        },
        "gen_random_weights": {
            "name": "gen_random_weights",
            "location": 86,
            "return": [
                "None",
                "Union[tuple,list]",
                "List[int]",
                "Dict[str,Any]",
                "str"
            ],
            "arguments": {
                "n_weights": [
                    "int",
                    "bool",
                    "float"
                ],
                "seed": [
                    "None",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "setup_groups_and_weights": {
            "name": "setup_groups_and_weights",
            "location": 99,
            "return": [
                "Tuple[None]",
                "str",
                "Tuple[str]",
                "bool"
            ],
            "arguments": {
                "dimensions": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "b_group_names": [
                    "bool",
                    "Optional[str]",
                    "Optional[float]",
                    "Optional[bool]",
                    "Optional[Iterable[str]]"
                ],
                "b_groups": [
                    "int",
                    "str",
                    "float"
                ],
                "b_weights": [
                    "int",
                    "str",
                    "float",
                    "utils.times.Seconds",
                    "List[str]"
                ],
                "seed": [
                    "None",
                    "int",
                    "float",
                    "Union[int,str]"
                ]
            }
        },
        "get_data": {
            "name": "get_data",
            "location": 125,
            "return": [
                "bool",
                "None",
                "str",
                "int"
            ],
            "arguments": {
                "kind": [
                    "Text",
                    "int",
                    "str",
                    "List[int]"
                ],
                "n_rows": [
                    "int",
                    "str",
                    "List[int]"
                ],
                "n_cols": [
                    "int",
                    "str",
                    "List[int]"
                ],
                "fnames": [
                    "None",
                    "int",
                    "List",
                    "float",
                    "Optional[int]"
                ],
                "seed": [
                    "None",
                    "int",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "get_labels": {
            "name": "get_labels",
            "location": 162,
            "return": [
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "n_rows": [
                    "int"
                ],
                "seed": [
                    "None",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "generate_test_data": {
            "name": "generate_test_data",
            "location": 171,
            "return": [
                "str",
                "Tuple[None]"
            ],
            "arguments": {
                "dimensions": [
                    "str",
                    "bool",
                    "int",
                    "Optional[str]"
                ],
                "b_group_names": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "Optional[Sequence[str]]"
                ],
                "b_groups": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "Optional[Sequence[str]]"
                ],
                "b_weights": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "Optional[Sequence[str]]"
                ],
                "correct": [
                    "bool",
                    "Optional[str]"
                ],
                "error_type": [
                    "None",
                    "str",
                    "bool",
                    "Optional[Sequence[str]]",
                    "Union[None,str,int]",
                    "Optional[str]"
                ],
                "data_type": [
                    "Text",
                    "bytes",
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "Tuple[str]",
                    "str"
                ],
                "dim_mismatch": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "seed": [
                    "None",
                    "float",
                    "Optional[str]",
                    "Optional[int]",
                    "int",
                    "Union[int,str]"
                ]
            }
        },
        "assert_groups": {
            "name": "assert_groups",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "background_data": [
                    "bytes",
                    "Mapping[str, Any]",
                    "dict"
                ],
                "group_names": [
                    "dict",
                    "pandas.DataFrame",
                    "str",
                    "bool",
                    "Union[str, None]",
                    "List[int]"
                ],
                "groups": [
                    "int",
                    "List[int]",
                    "Callable",
                    "List[List[Any]]",
                    "List[FrozenSet[str]]",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_rank_by_importance": {
            "name": "test_rank_by_importance",
            "location": 296,
            "return": [
                "None"
            ],
            "arguments": {
                "n_outputs": [
                    "str",
                    "List[str]",
                    "Dict[str, Any]",
                    "bytes",
                    "int",
                    "dict"
                ],
                "data_dimension": [
                    "str",
                    "List[str]",
                    "Dict[str, Any]",
                    "bytes",
                    "int",
                    "dict"
                ]
            }
        },
        "test_sum_categories": {
            "name": "test_sum_categories",
            "location": 369,
            "return": [
                "None"
            ],
            "arguments": {
                "n_feats": [
                    "Collection[int]",
                    "int",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "ndim": [
                    "int",
                    "bytes",
                    "bool",
                    "list"
                ],
                "feat_enc_dim": [
                    "Optional[numpy.ndarray]",
                    "Dict[str, List[float]]",
                    "Optional[List[str]]",
                    "set",
                    "list"
                ],
                "start_idx": [
                    "Optional[numpy.ndarray]",
                    "Dict[str, List[float]]",
                    "Optional[List[str]]",
                    "set",
                    "list"
                ]
            }
        },
        "mock_ker_expln_id": {
            "name": "mock_ker_expln_id",
            "location": 441,
            "return": [
                "str"
            ],
            "arguments": {
                "params": [
                    "str",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        },
        "test__get_data": {
            "name": "test__get_data",
            "location": 475,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_kernel_shap_explainer": [
                    "tests.test_util.aiohttp.AiohttpClientMocker",
                    "unittesmock.MagicMock",
                    "mock.MagicMock"
                ],
                "data_dimension": [
                    "str",
                    "duniterpy.api.clienClient"
                ],
                "data_type": [
                    "str",
                    "duniterpy.api.clienClient"
                ],
                "group_settings": [
                    "str"
                ],
                "input_settings": [
                    "str",
                    "duniterpy.api.clienClient"
                ]
            }
        },
        "uncollect_if_test_check_inputs_kernel": {
            "name": "uncollect_if_test_check_inputs_kernel",
            "location": 571,
            "return": [
                "bool",
                "str",
                "int",
                "Dict"
            ],
            "arguments": {}
        },
        "test__check_inputs_kernel": {
            "name": "test__check_inputs_kernel",
            "location": 608,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger",
                    "Collection[str]",
                    "bool"
                ],
                "mock_kernel_shap_explainer": [
                    "tests.test_util.aiohttp.AiohttpClientMocker"
                ],
                "data_type": [
                    "mock.MagicMock"
                ],
                "data_dimension": [
                    "dict",
                    "float",
                    "List[str]",
                    "str"
                ],
                "group_settings": [
                    "purplship.core.utils.xml.Element",
                    "tests.test_util.aiohttp.AiohttpClientMocker",
                    "unittesmock.MagicMock"
                ],
                "input_settings": [
                    "Optional[str]",
                    "mock.MagicMock"
                ],
                "summarise_background": [
                    "unittesmock.MagicMock",
                    "str",
                    "tests.components.withings.common.ComponentFactory",
                    "tests.test_util.aiohttp.AiohttpClientMocker"
                ]
            }
        },
        "test__summarise_background_kernel": {
            "name": "test__summarise_background_kernel",
            "location": 723,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "str",
                    "logging.Logger"
                ],
                "mock_kernel_shap_explainer": [
                    "unittesmock.MagicMock",
                    "str",
                    "Dict[str, Dict[str, str]]"
                ],
                "data_dimension": [
                    "str",
                    "Optional[Dict[str, Any]]"
                ],
                "data_type": [
                    "str",
                    "bool"
                ],
                "use_groups": [
                    "str",
                    "Optional[str]"
                ],
                "categorical_names": [
                    "str",
                    "raiden.utils.Address"
                ]
            }
        },
        "uncollect_if_test_fit_kernel": {
            "name": "uncollect_if_test_fit_kernel",
            "location": 788,
            "return": [
                "bool",
                "str",
                "int",
                "Dict"
            ],
            "arguments": {}
        },
        "test_fit_kernel": {
            "name": "test_fit_kernel",
            "location": 808,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger",
                    "Collection[str]",
                    "bool"
                ],
                "monkeypatch": [
                    "str",
                    "bool",
                    "Optional[Dict[str, Any]]"
                ],
                "mock_kernel_shap_explainer": [
                    "mock.Mock",
                    "tests.test_util.aiohttp.AiohttpClientMocker",
                    "tests.async_mock.MagicMock",
                    "unittesmock.MagicMock"
                ],
                "data_type": [
                    "bob_emploi.frontend.api.user_pb2.User"
                ],
                "summarise_background": [],
                "data_dimension": [
                    "pandas.DataFrame",
                    "Type",
                    "str",
                    "int"
                ],
                "group_settings": [
                    "str",
                    "Dict[str, Any]",
                    "neuromation.api.login._AuthConfig"
                ],
                "input_settings": [
                    "tests.async_mock.MagicMock",
                    "tests.basilisp.helpers.CompileFn",
                    "bool",
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_explain_kernel": {
            "name": "test_explain_kernel",
            "location": 947,
            "return": [
                "None"
            ],
            "arguments": {
                "monkeypatch": [
                    "unittesmock.MagicMock"
                ],
                "mock_kernel_shap_explainer": [
                    "tests.test_util.aiohttp.AiohttpClientMocker"
                ],
                "use_groups": [
                    "Dict[str, Any]",
                    "tuple"
                ],
                "summarise_result": [
                    "Callable",
                    "cmk.utils.structured_data.StructuredDataTree"
                ],
                "data_type": [
                    "tests.async_mock.Mock",
                    "mock.MagicMock"
                ]
            }
        },
        "test_build_explanation_kernel": {
            "name": "test_build_explanation_kernel",
            "location": 1048,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_kernel_shap_explainer": [
                    "tests.test_util.aiohttp.AiohttpClientMocker",
                    "unittesmock.MagicMock",
                    "tests.async_mock.MagicMock"
                ],
                "task": []
            }
        },
        "test_kernel_distributed_execution": {
            "name": "test_kernel_distributed_execution",
            "location": 1086,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_kernel_shap_explainer": [
                    "unittesmock.MagicMock"
                ],
                "mock_ker_exp_params": [
                    "unittesmock.MagicMock"
                ],
                "n_instances": [],
                "n_features": []
            }
        },
        "mock_tree_expln_id": {
            "name": "mock_tree_expln_id",
            "location": 1110,
            "return": [
                "str"
            ],
            "arguments": {
                "params": [
                    "Tuple['cirq.Qid']",
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "test__check_inputs_tree": {
            "name": "test__check_inputs_tree",
            "location": 1131,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger",
                    "List[Dict[str, float]]",
                    "Optional[logging.Logger]"
                ],
                "mock_tree_shap_explainer": [
                    "raiden.tests.fuzz.utils.SendSecretRevealInNode",
                    "utils.JobsType",
                    "Dict[str, Any]",
                    "List[Callable]",
                    "dict"
                ],
                "data_dimension": [
                    "Iterable[T]",
                    "int",
                    "Dict[str, Any]"
                ],
                "data_type": [
                    "Iterable[T]",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        },
        "test__summarise_background_tree": {
            "name": "test__summarise_background_tree",
            "location": 1162,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_tree_shap_explainer": [
                    "raiden.tests.fuzz.utils.SendSecretRevealInNode",
                    "bool",
                    "dict"
                ],
                "data_dimension": [
                    "bool",
                    "str",
                    "Optional[bool]",
                    "Union[None, dict]",
                    "dict"
                ],
                "data_type": [
                    "bytes",
                    "Optional[Dict]",
                    "Optional[str]",
                    "Optional",
                    "Tuple[int, int]"
                ],
                "categorical_names": [
                    "str",
                    "pandas.Series"
                ]
            }
        },
        "test_fit_tree": {
            "name": "test_fit_tree",
            "location": 1204,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger",
                    "List[Dict[str, float]]",
                    "Optional[logging.Logger]",
                    "bool"
                ],
                "monkeypatch": [
                    "str",
                    "Optional[int]",
                    "int"
                ],
                "mock_tree_shap_explainer": [
                    "bytes",
                    "Optional[cmk.utils.structured_data.StructuredDataTree]",
                    "Optional[Iterable[str]]"
                ],
                "data_type": [
                    "dict",
                    "str",
                    "T"
                ],
                "summarise_background": [
                    "Mapping[str, Any]"
                ],
                "data_dimension": [
                    "Optional[Tuple]",
                    "Optional[bool]"
                ]
            }
        },
        "test_explain_tree": {
            "name": "test_explain_tree",
            "location": 1281,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger",
                    "Optional[str]",
                    "logging.Formatter",
                    "Optional[logging.Logger]"
                ],
                "monkeypatch": [
                    "str",
                    "int",
                    "Mapping[str, str]",
                    "bool",
                    "Optional[int]",
                    "List[str]"
                ],
                "mock_tree_shap_explainer": [
                    "Optional[Dict]",
                    "Dict[str, Dict]",
                    "Optional[Sequence[str]]",
                    "Optional[cmk.utils.structured_data.StructuredDataTree]"
                ],
                "data_type": [
                    "\"Task\"",
                    "str",
                    "int"
                ],
                "summarise_result": [
                    "str",
                    "float",
                    "bool",
                    "int"
                ],
                "interactions": [
                    "str",
                    "float",
                    "bool",
                    "int"
                ]
            }
        },
        "test__check_interactions": {
            "name": "test__check_interactions",
            "location": 1351,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger",
                    "Optional[logging.Logger]"
                ],
                "mock_tree_shap_explainer": [
                    "Optional[str]",
                    "Sequence[str]",
                    "Optional[Iterable[Any]]",
                    "utils.JobsType",
                    "Optional[cmk.utils.structured_data.StructuredDataTree]"
                ],
                "data_type": [
                    "Callable",
                    "cmk.utils.type_defs.HostName",
                    "cmk.utils.type_defs.ServiceName",
                    "flask.testing.FlaskClient",
                    "int",
                    "TextIO"
                ],
                "approximate": [
                    "bytes",
                    "Tuple[paradigm.models.Base, tests.utils.Kwargs]"
                ],
                "labels": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "Optional[Iterable[str]]"
                ]
            }
        },
        "test__check_explainer_setup": {
            "name": "test__check_explainer_setup",
            "location": 1392,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_tree_shap_explainer": [
                    "raiden.tests.fuzz.utils.SendSecretRevealInNode",
                    "utils.JobsType"
                ],
                "data_type": [
                    "str",
                    "Dict[str, Any]",
                    "flask.testing.FlaskClient",
                    "bob_emploi.frontend.api.action_pb2.ActionTemplate",
                    "TextIO"
                ],
                "labels": [
                    "str",
                    "Tuple[int, int]"
                ]
            }
        },
        "uncollect_if_test_tree_api": {
            "name": "uncollect_if_test_tree_api",
            "location": 1444,
            "return": [
                "bool",
                "int",
                "pandas.DataFrame",
                "Optional[List[str]]"
            ],
            "arguments": {}
        },
        "test_tree_api": {
            "name": "test_tree_api",
            "location": 1469,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_tree_shap_explainer": [
                    "Optional[Dict]",
                    "Optional[str]",
                    "List[Optional[str]]",
                    "Dict[str, Any]",
                    "Optional[cmk.utils.structured_data.StructuredDataTree]",
                    "Optional[Sequence[str]]",
                    "Dict[str, Dict]"
                ],
                "data_type": [
                    "str",
                    "bool",
                    "Optional[Any]",
                    "bob_emploi.frontend.api.diagnostic_pb2.DiagnosticCategory"
                ],
                "summarise_result": [
                    "Dict[str, str]"
                ],
                "labels": [
                    "dict",
                    "bool",
                    "List[str]",
                    "list"
                ],
                "interactions": [
                    "List[Tuple[float, Any]]",
                    "str",
                    "Optional[List[str]]",
                    "Iterable[int]"
                ],
                "task": [
                    "dict",
                    "bool",
                    "Set[str]"
                ],
                "approximate": [
                    "List[Tuple[float, Any]]",
                    "str",
                    "Optional[List[str]]",
                    "Iterable[int]"
                ]
            }
        },
        "test__check_result_summarisation": {
            "name": "test__check_result_summarisation",
            "location": 1609,
            "return": [
                "None"
            ],
            "arguments": {
                "caplog": [
                    "logging.Logger"
                ],
                "mock_tree_shap_explainer": [
                    "bool",
                    "Optional[str]"
                ],
                "cat_vars_start_enc_dim": [
                    "Callable",
                    "bool"
                ]
            }
        },
        "KMeansMock.__init__": {
            "name": "__init__",
            "location": 271,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "seed": [
                    "None",
                    "int",
                    "rl_algorithms.utils.config.ConfigDict",
                    "pandas.DataFrame",
                    "List"
                ]
            }
        },
        "KMeansMock._mock_kmeans": {
            "name": "_mock_kmeans",
            "location": 275,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "T",
                    "int",
                    "raiden.utils.Address"
                ],
                "n_clusters": [
                    "T",
                    "int",
                    "raiden.utils.Address"
                ]
            }
        },
        "KMeansMock.__call__": {
            "name": "__call__",
            "location": 278,
            "return": [
                "str",
                "Optional[List[str]]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "background_data": [
                    "int",
                    "bytes",
                    "bool",
                    "str",
                    "Tuple[int]"
                ],
                "n_background_samples": [
                    "str",
                    "int"
                ]
            }
        },
        "test_rank_by_importance.get_column_ranks": {
            "name": "get_column_ranks",
            "location": 301,
            "return": [
                "Tuple",
                "Callable",
                "str",
                "List[List[int]]"
            ],
            "arguments": {
                "X": [
                    "numpy.array",
                    "float",
                    "int",
                    "Iterable[T]"
                ],
                "ascending": [
                    "bool",
                    "str",
                    "Iterable[str]",
                    "Optional[float]",
                    "Callable"
                ]
            }
        },
        "test_tree_api.setter": {
            "name": "setter",
            "location": 1474,
            "return": [
                "None"
            ],
            "arguments": {
                "obj": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[bool]"
                ],
                "attr": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[bool]"
                ],
                "val": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[bool]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/utils.py": {
        "predict_fcn": {
            "name": "predict_fcn",
            "location": 5,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "predict_type": [
                    "Optional[Type[BaseException]]",
                    "Type",
                    "str",
                    "BaseException",
                    "None",
                    "Exception",
                    "Optional[BaseException]"
                ],
                "clf": [
                    "str",
                    "numpy.ndarray",
                    "numpy.array"
                ],
                "preproc": [
                    "str",
                    "None",
                    "numpy.array"
                ]
            }
        },
        "get_random_matrix": {
            "name": "get_random_matrix",
            "location": 32,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {}
        },
        "MockTreeExplainer.__init__": {
            "name": "__init__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "str",
                    "List[int]",
                    "bool",
                    "Tuple[int]",
                    "List[float]",
                    "Tuple[Union[float,float,float,float]]",
                    "Tuple[float,float,float,float]",
                    "int"
                ],
                "seed": [
                    "int",
                    "List",
                    "None"
                ]
            }
        },
        "MockTreeExplainer.shap_values": {
            "name": "shap_values",
            "location": 62,
            "return": [
                "List",
                "float",
                "List[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "MockTreeExplainer.shap_interaction_values": {
            "name": "shap_interaction_values",
            "location": 73,
            "return": [
                "List",
                "int",
                "List[int]",
                "Optional[int]",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "List",
                    "numpy.ndarray"
                ]
            }
        },
        "MockTreeExplainer._set_expected_value": {
            "name": "_set_expected_value",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MockTreeExplainer.__call__": {
            "name": "__call__",
            "location": 97,
            "return": [
                "MockTreeExplainer"
            ],
            "arguments": {
                "self": [
                    "_TMockTreeExplainer@@MockTreeExplainer@@"
                ]
            }
        },
        "MockTreeExplainer._check_input": {
            "name": "_check_input",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/__init__.py": {},
    "alibi-master/alibi/explainers/tests/test_simiarlity/conftest.py": {
        "set_seed": {
            "name": "set_seed",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "seed": {
            "name": "seed",
            "location": 33,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "get_flattened_model_parameters": {
            "name": "get_flattened_model_parameters",
            "location": 39,
            "return": [
                "dict",
                "Dict[str, Any]",
                "Iterable[str]",
                "IO[str]",
                "int"
            ],
            "arguments": {
                "model": [
                    "Set[int]",
                    "int",
                    "base.Connection"
                ]
            }
        },
        "random_reg_dataset": {
            "name": "random_reg_dataset",
            "location": 50,
            "return": [
                "Tuple[Union[tuple[Union[int,tuple[Union[float,float,float,float,float]],str,float]],tuple[Union[str,dict,int,set,list[str]]]]]",
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "random_cls_dataset": {
            "name": "random_cls_dataset",
            "location": 64,
            "return": [
                "Tuple[Union[tuple[Union[int,tuple[Union[float,float,float,float,float]],str]],tuple[Union[str,dict,int,list[str]]]]]",
                "bool",
                "Optional[bool]",
                "Optional[str]",
                "Iterable[cirq.Qid]",
                "Optional[Exception]"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "linear_cls_model": {
            "name": "linear_cls_model",
            "location": 78,
            "return": [
                "Tuple[Union[dict[str,Any],str,dict,list[tuple[Union[Any,Any]]],list,float]]",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]",
                    "Dict"
                ]
            }
        },
        "linear_reg_model": {
            "name": "linear_reg_model",
            "location": 105,
            "return": [
                "Tuple[Union[dict[str,Any],str,dict,list[tuple[Union[Any,Any]]],list,Type]]",
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]"
                ]
            }
        },
        "linear_models": {
            "name": "linear_models",
            "location": 132,
            "return": [
                "Tuple[Union[bool,str,tuple[Union[Literal,int,Literal,int]],tuple[str],dict[str,str],list[str]]]",
                "numpy.ndarray",
                "int",
                "Optional[str]",
                "Dict[str,numpy.ndarray]"
            ],
            "arguments": {
                "request": []
            }
        },
        "tf_linear_model": {
            "name": "tf_linear_model",
            "location": 146,
            "return": [
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable",
                "Optional[str]",
                "dict"
            ],
            "arguments": {
                "input_shape": [
                    "numpy.ndarray"
                ],
                "output_shape": [
                    "numpy.ndarray"
                ]
            }
        },
        "torch_linear_model": {
            "name": "torch_linear_model",
            "location": 157,
            "return": [
                "Model",
                "int",
                "torch.nn.Module",
                "List[List[int]]"
            ],
            "arguments": {
                "input_shape_arg": [
                    "int",
                    "str",
                    "bool"
                ],
                "output_shape_arg": [
                    "Tuple[int,int]",
                    "int",
                    "Tuple[Union[int,int]]",
                    "Sequence[int]",
                    "bytearray"
                ]
            }
        },
        "torch_linear_model.Model.__init__": {
            "name": "__init__",
            "location": 164,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Iterable[Iterable[float]]",
                    "torch.Tensor",
                    "int",
                    "List[int]",
                    "Optional[int]"
                ],
                "output_shape": [
                    "Iterable[Iterable[float]]",
                    "torch.Tensor",
                    "int",
                    "List[int]",
                    "Optional[int]"
                ]
            }
        },
        "torch_linear_model.Model.forward": {
            "name": "forward",
            "location": 172,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "numpy.ndarray",
                    "Iterable[List[T]]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/test_backends.py": {
        "test_backends": {
            "name": "test_backends",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "random_cls_dataset": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "bool"
                ],
                "linear_models": [
                    "bool",
                    "bytes",
                    "str",
                    "Union[str,int]"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/test_grad_methods_integration.py": {
        "loss_torch": {
            "name": "loss_torch",
            "location": 23,
            "return": [
                "str"
            ],
            "arguments": {
                "X": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ],
                "Y": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "compute_angle": {
            "name": "compute_angle",
            "location": 27,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float"
                ],
                "b": [
                    "int",
                    "float"
                ]
            }
        },
        "ds": {
            "name": "ds",
            "location": 36,
            "return": [],
            "arguments": {}
        },
        "normed_ds": {
            "name": "normed_ds",
            "location": 42,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {}
        },
        "test_correct_grad_dot_sim_result_torch": {
            "name": "test_correct_grad_dot_sim_result_torch",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "bool"
                ],
                "normed_ds": [
                    "bool",
                    "Union[int, float]",
                    "Union[Tuple[int], Tuple[int, int]]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "test_correct_grad_cos_sim_result_torch": {
            "name": "test_correct_grad_cos_sim_result_torch",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "str",
                    "Dict[str, object]"
                ],
                "ds": [
                    "List[str]",
                    "int",
                    "str",
                    "List[\"Outcome\"]",
                    "float"
                ]
            }
        },
        "test_grad_cos_result_order_torch": {
            "name": "test_grad_cos_result_order_torch",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_grad_dot_result_order_torch": {
            "name": "test_grad_dot_result_order_torch",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "loss_tf": {
            "name": "loss_tf",
            "location": 131,
            "return": [
                "str"
            ],
            "arguments": {
                "y": [
                    "tensorflow.Tensor",
                    "Tuple[tensorflow.Tensor]",
                    "bool",
                    "int",
                    "Iterable",
                    "str"
                ],
                "x": [
                    "tensorflow.Tensor",
                    "Tuple[tensorflow.Tensor]",
                    "bool",
                    "int",
                    "Iterable",
                    "str"
                ]
            }
        },
        "test_correct_grad_dot_sim_result_tf": {
            "name": "test_correct_grad_dot_sim_result_tf",
            "location": 135,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "bool"
                ],
                "normed_ds": [
                    "bool",
                    "Union[int, float]",
                    "Union[Tuple[int], Tuple[int, int]]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "test_correct_grad_cos_sim_result_tf": {
            "name": "test_correct_grad_cos_sim_result_tf",
            "location": 157,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "str",
                    "Dict[str, object]"
                ],
                "ds": [
                    "int",
                    "float",
                    "List[str]",
                    "str"
                ]
            }
        },
        "test_grad_dot_result_order_tf": {
            "name": "test_grad_dot_result_order_tf",
            "location": 179,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_grad_cos_result_order_tf": {
            "name": "test_grad_cos_result_order_tf",
            "location": 198,
            "return": [
                "None"
            ],
            "arguments": {
                "seed": [
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_multiple_test_instances_grad_cos": {
            "name": "test_multiple_test_instances_grad_cos",
            "location": 219,
            "return": [
                "None"
            ],
            "arguments": {
                "precompute_grads": [
                    "dict"
                ]
            }
        },
        "test_multiple_test_instances_grad_dot": {
            "name": "test_multiple_test_instances_grad_dot",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {
                "precompute_grads": [
                    "dict"
                ]
            }
        },
        "test_multiple_test_instances_stored_grads_asym_dot": {
            "name": "test_multiple_test_instances_stored_grads_asym_dot",
            "location": 268,
            "return": [
                "None"
            ],
            "arguments": {
                "precompute_grads": [
                    "dict"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/test_grad_methods_unit.py": {
        "test_method_explanations": {
            "name": "test_method_explanations",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "linear_cls_model": [
                    "str",
                    "bool",
                    "Callable",
                    "Dict[str,Dict[str,Any]]",
                    "Dict[str,dict[str,Any]]"
                ],
                "random_cls_dataset": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ]
            }
        },
        "test_explainer_method_preprocessing": {
            "name": "test_explainer_method_preprocessing",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "linear_cls_model": [
                    "str",
                    "int",
                    "Callable",
                    "Dict[str,Dict[str,Any]]",
                    "Dict[str,dict[str,Any]]"
                ],
                "random_cls_dataset": [
                    "int",
                    "str",
                    "bytes",
                    "bool"
                ]
            }
        },
        "test_method_sim_fn_error_messaging": {
            "name": "test_method_sim_fn_error_messaging",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "linear_cls_model": [
                    "bool"
                ]
            }
        },
        "test_method_task_error_messaging": {
            "name": "test_method_task_error_messaging",
            "location": 119,
            "return": [
                "None"
            ],
            "arguments": {
                "linear_cls_model": [
                    "bool"
                ]
            }
        },
        "test_task_classification_input": {
            "name": "test_task_classification_input",
            "location": 154,
            "return": [
                "None"
            ],
            "arguments": {
                "random_cls_dataset": [
                    "float",
                    "int",
                    "Set",
                    "bool"
                ],
                "linear_cls_model": [
                    "str",
                    "int",
                    "Dict[str,dict[str,Any]]",
                    "Dict[str,Dict[str,Any]]",
                    "bool"
                ]
            }
        },
        "test_regression_task_input": {
            "name": "test_regression_task_input",
            "location": 185,
            "return": [
                "None"
            ],
            "arguments": {
                "linear_reg_model": [],
                "random_reg_dataset": [
                    "bool",
                    "str",
                    "Mapping[str,Any]",
                    "Mapping",
                    "Union[int,float]",
                    "float"
                ]
            }
        },
        "test_device_error_msgs": {
            "name": "test_device_error_msgs",
            "location": 219,
            "return": [
                "None"
            ],
            "arguments": {
                "linear_reg_model": [
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/explainers/tests/test_simiarlity/__init__.py": {},
    "alibi-master/alibi/models/__init__.py": {},
    "alibi-master/alibi/models/pytorch/actor_critic.py": {
        "Actor.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "str",
                    "int",
                    "bytearray"
                ],
                "output_dim": [
                    "Iterable[Iterable[float]]",
                    "Iterable[float]"
                ]
            }
        },
        "Actor.forward": {
            "name": "forward",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "Critic.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "str",
                    "int",
                    "Iterable[str]"
                ]
            }
        },
        "Critic.forward": {
            "name": "forward",
            "location": 79,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": []
            }
        }
    },
    "alibi-master/alibi/models/pytorch/autoencoder.py": {
        "AE.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "int",
                    "float",
                    "bool"
                ],
                "decoder": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "AE.forward": {
            "name": "forward",
            "location": 44,
            "return": [
                "str",
                "int",
                "Dict[int,Any]",
                "List"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "HeAE.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[A,bool]"
                ],
                "decoder": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[A,bool]"
                ]
            }
        },
        "HeAE.forward": {
            "name": "forward",
            "location": 89,
            "return": [
                "str",
                "int",
                "List",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/cfrl_models.py": {
        "MNISTClassifier.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dim": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MNISTClassifier.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "MNISTEncoder.__init__": {
            "name": "__init__",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MNISTEncoder.forward": {
            "name": "forward",
            "location": 97,
            "return": [
                "str",
                "int",
                "List[str]",
                "float",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "Union[int,slice]",
                    "torch.Tensor"
                ]
            }
        },
        "MNISTDecoder.__init__": {
            "name": "__init__",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MNISTDecoder.forward": {
            "name": "forward",
            "location": 147,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "torch.Tensor"
                ]
            }
        },
        "ADULTEncoder.__init__": {
            "name": "__init__",
            "location": 177,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int",
                    "float",
                    "bool"
                ],
                "latent_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ADULTEncoder.forward": {
            "name": "forward",
            "location": 192,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "T"
                ]
            }
        },
        "ADULTDecoder.__init__": {
            "name": "__init__",
            "location": 217,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "Iterable[float]",
                    "str",
                    "int",
                    "List[T]"
                ],
                "output_dims": [
                    "List",
                    "str",
                    "List[tuple]",
                    "src.core.model.library.Library",
                    "int",
                    "List[Tuple]"
                ]
            }
        },
        "ADULTDecoder.forward": {
            "name": "forward",
            "location": 232,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "T"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/metrics.py": {
        "LossContainer.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "loss": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "name": [
                    "List[str]",
                    "str",
                    "Dict"
                ]
            }
        },
        "LossContainer.__call__": {
            "name": "__call__",
            "location": 40,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "str",
                    "Callable",
                    "List[int]",
                    "int"
                ],
                "y_true": [
                    "str",
                    "Callable",
                    "List[int]",
                    "int"
                ]
            }
        },
        "LossContainer.result": {
            "name": "result",
            "location": 64,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "LossContainer.reset": {
            "name": "reset",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Metric.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "reduction": [
                    "bool",
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "Text",
                    "List[str]",
                    "str",
                    "Dict"
                ]
            }
        },
        "Metric.compute_metric": {
            "name": "compute_metric",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "float",
                    "str",
                    "bool",
                    "int"
                ],
                "y_true": [
                    "float",
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "Metric.update_state": {
            "name": "update_state",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "values": [
                    "Dict[str,Any]",
                    "int",
                    "numpy.ndarray",
                    "Iterable"
                ]
            }
        },
        "Metric.result": {
            "name": "result",
            "location": 114,
            "return": [
                "Dict[(_T0, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Metric.reset": {
            "name": "reset",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AccuracyMetric.__init__": {
            "name": "__init__",
            "location": 139,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Text",
                    "str",
                    "Sequence[str]"
                ]
            }
        },
        "AccuracyMetric.compute_metric": {
            "name": "compute_metric",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "int",
                    "List[int]",
                    "Union[numpy.ndarray,numpy.void]"
                ],
                "y_true": [
                    "List[Dict]",
                    "List[dict]",
                    "str",
                    "bytes",
                    "Optional[str]",
                    "Dict",
                    "None",
                    "List[List[Any]]",
                    "List[list[Any]]"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/model.py": {
        "Model.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.compile": {
            "name": "compile",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "Mapping",
                    "int"
                ],
                "loss": [
                    "int",
                    "bool",
                    "models.base.Model"
                ],
                "loss_weights": [
                    "None",
                    "str",
                    "bytes",
                    "Sequence[T]"
                ],
                "metrics": [
                    "None",
                    "Type",
                    "Optional[AbstractSet[str]]",
                    "bool"
                ]
            }
        },
        "Model.validate_prediction_labels": {
            "name": "validate_prediction_labels",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "list",
                    "torch.LongTensor",
                    "List[str]",
                    "DefaultDict[int, List[Any]]",
                    "List[Dict[str, Any]]",
                    "List[raiden.utils.Address]"
                ],
                "y_true": [
                    "int",
                    "bytes",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "Model.compute_loss": {
            "name": "compute_loss",
            "location": 106,
            "return": [
                "Tuple[(Any, dict)]"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "float",
                    "Optional[int]",
                    "bool"
                ],
                "y_true": [
                    "int",
                    "List[int]",
                    "Optional[str]",
                    "Callable"
                ]
            }
        },
        "Model.compute_metrics": {
            "name": "compute_metrics",
            "location": 148,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "y_pred": [
                    "str",
                    "int",
                    "bool"
                ],
                "y_true": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "Model.train_step": {
            "name": "train_step",
            "location": 182,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Iterable[List[T]]",
                    "Iterable[Any]",
                    "Type",
                    "List[Union[\"PipeChain\", str]]",
                    "Tuple[int, int]",
                    "Iterable[T]"
                ],
                "y": [
                    "List[Type]",
                    "Type",
                    "Optional[str]",
                    "Tuple[int, int]",
                    "fonduer.candidates.models.Candidate"
                ]
            }
        },
        "Model.test_step": {
            "name": "test_step",
            "location": 221,
            "return": [
                "Dict",
                "str",
                "List[str]",
                "Sequence[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "y": [
                    "dict",
                    "set",
                    "Tuple[int]"
                ]
            }
        },
        "Model.fit": {
            "name": "fit",
            "location": 256,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "trainloader": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "epochs": [
                    "int",
                    "List[Tuple[int, int]]"
                ]
            }
        },
        "Model.evaluate": {
            "name": "evaluate",
            "location": 291,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "testloader": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "Model._metrics_to_str": {
            "name": "_metrics_to_str",
            "location": 321,
            "return": [
                "str"
            ],
            "arguments": {
                "metrics": [
                    "dict",
                    "Dict[str, Any]",
                    "List[Tuple[Any, ...]]",
                    "Optional[Tuple[str, ...]]",
                    "Mapping"
                ]
            }
        },
        "Model._reset_loss": {
            "name": "_reset_loss",
            "location": 339,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model._reset_metrics": {
            "name": "_reset_metrics",
            "location": 349,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.save_weights": {
            "name": "save_weights",
            "location": 357,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        },
        "Model.load_weights": {
            "name": "load_weights",
            "location": 363,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "alibi-master/alibi/models/pytorch/__init__.py": {},
    "alibi-master/alibi/models/tensorflow/actor_critic.py": {
        "Actor.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "Iterable[float]",
                    "str",
                    "int",
                    "List[T]"
                ],
                "output_dim": [
                    "Iterable[Iterable[float]]",
                    "Iterable[float]"
                ]
            }
        },
        "Actor.call": {
            "name": "call",
            "location": 36,
            "return": [
                "int",
                "str",
                "List[Union[Any,Any]]",
                "Union[bool,List[bool]]",
                "float",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "Critic.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "Critic.call": {
            "name": "call",
            "location": 80,
            "return": [
                "str",
                "int",
                "float",
                "Union[bool,List[bool]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": []
            }
        }
    },
    "alibi-master/alibi/models/tensorflow/autoencoder.py": {
        "AE.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "int",
                    "float",
                    "bool"
                ],
                "decoder": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "AE.call": {
            "name": "call",
            "location": 37,
            "return": [
                "str",
                "Union[bool, List[bool]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int",
                    "Iterable[List[T]]",
                    "bytes",
                    "Iterable[list[T]]"
                ]
            }
        },
        "HeAE.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "encoder": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[A,bool]"
                ],
                "decoder": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[A,bool]"
                ]
            }
        },
        "HeAE.build": {
            "name": "build",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "str",
                    "Iterable[str]",
                    "Mapping",
                    "Mapping[str,Any]",
                    "Dict"
                ]
            }
        },
        "HeAE.call": {
            "name": "call",
            "location": 100,
            "return": [
                "T",
                "bool",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/models/tensorflow/cfrl_models.py": {
        "MNISTClassifier.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_dim": [
                    "int",
                    "str",
                    "Dict",
                    "Tuple[str,str]"
                ]
            }
        },
        "MNISTClassifier.call": {
            "name": "call",
            "location": 40,
            "return": [
                "float",
                "str",
                "int",
                "Union[bool,List[bool]]",
                "List[list[int]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "training": [
                    "bool",
                    "tensorflow.Tensor",
                    "float"
                ]
            }
        },
        "MNISTEncoder.__init__": {
            "name": "__init__",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MNISTEncoder.call": {
            "name": "call",
            "location": 93,
            "return": [
                "int",
                "str",
                "float",
                "Union[bool,List[bool]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ]
            }
        },
        "MNISTDecoder.__init__": {
            "name": "__init__",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MNISTDecoder.call": {
            "name": "call",
            "location": 138,
            "return": [
                "int",
                "str",
                "float",
                "Union[bool,List[bool]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Sequence[Any]"
                ]
            }
        },
        "ADULTEncoder.__init__": {
            "name": "__init__",
            "location": 169,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "int",
                    "float",
                    "bool"
                ],
                "latent_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ADULTEncoder.call": {
            "name": "call",
            "location": 184,
            "return": [
                "List",
                "str",
                "int",
                "Union[bool,List[bool]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Iterable[T]",
                    "tensorflow.Tensor",
                    "int",
                    "float"
                ]
            }
        },
        "ADULTDecoder.__init__": {
            "name": "__init__",
            "location": 211,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_dim": [
                    "Iterable[float]",
                    "str",
                    "int",
                    "List[T]"
                ],
                "output_dims": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "Type"
                ]
            }
        },
        "ADULTDecoder.call": {
            "name": "call",
            "location": 227,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Iterable[T]",
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/models/tensorflow/__init__.py": {},
    "alibi-master/alibi/prototypes/protoselect.py": {
        "_helper_protoselect_euclidean_1knn": {
            "name": "_helper_protoselect_euclidean_1knn",
            "location": 234,
            "return": [
                "None",
                "Optional[str]",
                "Optional[bool]",
                "str",
                "bool",
                "Optional[int]"
            ],
            "arguments": {
                "summariser": [
                    "Optional[int]"
                ],
                "num_prototypes": [
                    "int",
                    "str",
                    "Optional[int]"
                ],
                "eps": [
                    "int",
                    "List[List[int]]",
                    "float"
                ],
                "knn_kw": [
                    "int",
                    "List[List[int]]",
                    "float"
                ]
            }
        },
        "_get_splits": {
            "name": "_get_splits",
            "location": 272,
            "return": [
                "Tuple[list]",
                "Set[str]",
                "Tuple[list[tuple]]",
                "str",
                "List",
                "int"
            ],
            "arguments": {
                "trainset": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[Callable[[Any], None]]"
                ],
                "valset": [
                    "str",
                    "list"
                ],
                "kfold_kw": [
                    "str",
                    "float",
                    "bool"
                ]
            }
        },
        "cv_protoselect_euclidean": {
            "name": "cv_protoselect_euclidean",
            "location": 313,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "trainset": [
                    "str",
                    "int"
                ],
                "protoset": [
                    "None",
                    "bool",
                    "Optional[str]",
                    "Optional[int]",
                    "Optional[Mapping[str,str]]",
                    "List[str]",
                    "int"
                ],
                "valset": [
                    "None",
                    "float",
                    "bool",
                    "int",
                    "Optional[List[int]]"
                ],
                "num_prototypes": [
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "Union[int,float]",
                    "float"
                ],
                "eps_grid": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Optional[int]",
                    "Optional[List[int]]",
                    "Optional[utils.types.Vec3D]"
                ],
                "quantiles": [
                    "None",
                    "Optional[int]",
                    "Optional[str]",
                    "str",
                    "numpy.ndarray",
                    "Optional[List[int]]",
                    "List[str]"
                ],
                "grid_size": [
                    "int",
                    "List",
                    "str",
                    "Union[float,numpy.ndarray]",
                    "float",
                    "Dict[str,Tuple[str,int,int]]"
                ],
                "n_splits": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]",
                    "List",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "float"
                ],
                "preprocess_fn": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Optional[List[int]]",
                    "Optional[int]"
                ],
                "protoselect_kw": [
                    "None",
                    "Optional[int]",
                    "bool",
                    "Optional[Mapping[str,str]]",
                    "bytes"
                ],
                "knn_kw": [
                    "None",
                    "Tuple[str,int]",
                    "Optional[dict]",
                    "Union[None,float,int]",
                    "Optional[float]",
                    "matplotlib.colorbar.Colorbar",
                    "Optional[Dict[str,Any]]"
                ],
                "kfold_kw": [
                    "None",
                    "numpy.ndarray",
                    "str",
                    "Optional[List[str]]",
                    "Optional[GraphQLFieldResolver]",
                    "Optional[str]",
                    "Optional[float]"
                ]
            }
        },
        "_batch_preprocessing": {
            "name": "_batch_preprocessing",
            "location": 448,
            "return": [
                "bool",
                "utils.Node",
                "numpy.ndarray"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "preprocess_fn": [
                    "list",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "_imscatterplot": {
            "name": "_imscatterplot",
            "location": 477,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "numpy.array"
                ],
                "y": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "numpy.array"
                ],
                "images": [
                    "numpy.ndarray",
                    "str"
                ],
                "ax": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray",
                    "matplotlib.colorbar.Colorbar"
                ],
                "fig_kw": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "float",
                    "bool"
                ],
                "image_size": [
                    "Tuple[int]",
                    "numpy.ndarray",
                    "List",
                    "Dict",
                    "float"
                ],
                "zoom": [
                    "None",
                    "Optional[int]",
                    "Union[int,float]",
                    "Optional[float]",
                    "List[str]"
                ],
                "zoom_lb": [
                    "float",
                    "numpy.ndarray",
                    "int"
                ],
                "zoom_ub": [
                    "float",
                    "numpy.ndarray",
                    "int"
                ],
                "sort_by_zoom": [
                    "bool",
                    "Iterable[Any]",
                    "int"
                ]
            }
        },
        "visualize_image_prototypes": {
            "name": "visualize_image_prototypes",
            "location": 547,
            "return": [
                "str",
                "Optional[str]",
                "torch.utils.data.DataLoader"
            ],
            "arguments": {
                "summary": [
                    "numpy.ndarray",
                    "bool",
                    "Tuple[int, int]",
                    "str"
                ],
                "trainset": [
                    "numpy.ndarray",
                    "int",
                    "str"
                ],
                "reducer": [
                    "int",
                    "utils.diskstaSection"
                ],
                "preprocess_fn": [
                    "None",
                    "List[cirq.Qid]",
                    "str"
                ],
                "knn_kw": [
                    "None",
                    "bytes",
                    "bool",
                    "Optional[dict]"
                ],
                "ax": [
                    "None",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "fig_kw": [
                    "None",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "image_size": [
                    "Tuple[int]",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "zoom_lb": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "zoom_ub": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "ProtoSelect.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernel_distance": [
                    "List[int]",
                    "int",
                    "bool",
                    "list"
                ],
                "eps": [
                    "Optional[int]",
                    "int",
                    "Tuple[int, int]",
                    "Union[Tuple[int, int], int]",
                    "float"
                ],
                "lambda_penalty": [
                    "None",
                    "float",
                    "str",
                    "Tuple[int]",
                    "numpy.ndarray",
                    "bool",
                    "List[int]"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "bytearray",
                    "bool",
                    "float"
                ],
                "preprocess_fn": [
                    "None",
                    "bool",
                    "Tuple[numpy.dtype]",
                    "float"
                ],
                "verbose": [
                    "bool",
                    "float",
                    "int",
                    "Optional[numpy.array]",
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "ProtoSelect.fit": {
            "name": "fit",
            "location": 80,
            "return": [
                "ProtoSelect",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "Optional[Tuple]",
                    "int",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "y": [
                    "Optional[Tuple]",
                    "int",
                    "Optional[numpy.ndarray]",
                    "Optional[numpy.array]",
                    "numpy.ndarray"
                ],
                "Z": [
                    "None",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Optional[float]"
                ]
            }
        },
        "ProtoSelect.summarise": {
            "name": "summarise",
            "location": 142,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "num_prototypes": [
                    "int",
                    "raiden.utils.Locksroot",
                    "List",
                    "Tuple[int,int]",
                    "raiden.utils.Signature"
                ]
            }
        },
        "ProtoSelect._build_summary": {
            "name": "_build_summary",
            "location": 222,
            "return": [
                "Explanation",
                "int",
                "bool",
                "cmk.utils.type_defs.EventRule",
                "bytes",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "protos": [
                    "List[int]",
                    "Union[float, str]",
                    "Optional[int]",
                    "List[str]"
                ]
            }
        }
    },
    "alibi-master/alibi/prototypes/__init__.py": {},
    "alibi-master/alibi/prototypes/tests/test_protoselect.py": {
        "test_protoselect": {
            "name": "test_protoselect",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "n_classes": [
                    "int",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "ft_factor": [
                    "int",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "kernel_distance": [
                    "Callable",
                    "numpy.array",
                    "List[Any]",
                    "numpy.ndarray",
                    "float",
                    "None",
                    "Mapping",
                    "Optional[List[Any]]",
                    "Mapping[str,Tuple[float,float,float]]",
                    "int",
                    "Optional[int]"
                ],
                "num_prototypes": [
                    "int",
                    "Tuple"
                ],
                "eps": [
                    "Callable",
                    "numpy.array",
                    "List[Any]",
                    "numpy.ndarray",
                    "float",
                    "None",
                    "Mapping",
                    "Optional[List[Any]]",
                    "Mapping[str,Tuple[float,float,float]]",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "test_cv_protoselect_euclidean": {
            "name": "test_cv_protoselect_euclidean",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "n_classes": [
                    "float",
                    "int",
                    "str",
                    "raiden.utils.BlockNumber",
                    "bool"
                ],
                "use_protos": [
                    "bool",
                    "str",
                    "List",
                    "None",
                    "Optional[int]",
                    "List[str]",
                    "Union[str,List[str]]",
                    "int"
                ],
                "use_valset": [
                    "bool",
                    "str",
                    "List[str]",
                    "Set[str]",
                    "int"
                ],
                "num_prototypes": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]"
                ],
                "eps_grid": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]"
                ],
                "quantiles": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]"
                ],
                "grid_size": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]"
                ],
                "n_splits": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Union[float,numpy.ndarray]"
                ]
            }
        },
        "test_relabeling": {
            "name": "test_relabeling",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "n_samples": [
                    "bool",
                    "Sequence[str]",
                    "float",
                    "numpy.ndarray"
                ],
                "n_classes": [
                    "bool",
                    "Sequence[str]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "test_size_match": {
            "name": "test_size_match",
            "location": 136,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/prototypes/tests/test_utils.py": {
        "test_squared_pairwise_distance": {
            "name": "test_squared_pairwise_distance",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ],
                "ft_size": [
                    "int"
                ]
            }
        },
        "test_GaussianRBF": {
            "name": "test_GaussianRBF",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ],
                "ft_size": [
                    "int"
                ],
                "sigma": [
                    "float",
                    "str",
                    "int",
                    "tuple",
                    "Optional[float]",
                    "Optional[int]"
                ]
            }
        },
        "test_GaussianRBFDistance": {
            "name": "test_GaussianRBFDistance",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ],
                "ft_size": [
                    "int"
                ],
                "sigma": [
                    "float",
                    "str",
                    "int",
                    "tuple",
                    "Optional[float]",
                    "Optional[int]"
                ]
            }
        },
        "test_EuclideanDistance": {
            "name": "test_EuclideanDistance",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "size": [
                    "int",
                    "bool"
                ],
                "ft_size": [
                    "int"
                ]
            }
        },
        "test_batch_compute_kernel_matrix": {
            "name": "test_batch_compute_kernel_matrix",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "size": [
                    "int"
                ],
                "ft_size": [
                    "int"
                ],
                "batch_size": [
                    "int",
                    "Iterable[int]",
                    "bool",
                    "float",
                    "None",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "kernel": [
                    "str",
                    "float",
                    "numpy.ndarray",
                    "None",
                    "Optional[float]",
                    "int",
                    "Optional[int]",
                    "Tuple[Union[int,int]]",
                    "Tuple[int,int]"
                ]
            }
        }
    },
    "alibi-master/alibi/prototypes/tests/__init__.py": {},
    "alibi-master/alibi/tests/conftest.py": {
        "pytest_addoption": {
            "name": "pytest_addoption",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "str"
                ]
            }
        },
        "opt_dep": {
            "name": "opt_dep",
            "location": 9,
            "return": [
                "List[list[int]]",
                "int",
                "str",
                "List[str]",
                "Dict[str,Any]",
                "None",
                "Dict",
                "Callable[[Mapping],T]"
            ],
            "arguments": {
                "request": []
            }
        }
    },
    "alibi-master/alibi/tests/test_dep_management.py": {
        "check_correct_dependencies": {
            "name": "check_correct_dependencies",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "module": [
                    "str",
                    "int"
                ],
                "dependencies": [
                    "str",
                    "List[str]",
                    "Dict",
                    "bool",
                    "fonduer.parser.models.Document"
                ],
                "opt_dep": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_explainer_dependencies": {
            "name": "test_explainer_dependencies",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "opt_dep": [
                    "str",
                    "float"
                ]
            }
        },
        "test_util_dependencies": {
            "name": "test_util_dependencies",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "opt_dep": [
                    "str",
                    "float"
                ]
            }
        },
        "test_dataset_dependencies": {
            "name": "test_dataset_dependencies",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "opt_dep": [
                    "str",
                    "float"
                ]
            }
        },
        "test_confidence_dependencies": {
            "name": "test_confidence_dependencies",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "opt_dep": [
                    "str",
                    "float"
                ]
            }
        },
        "test_tensorflow_model_dependencies": {
            "name": "test_tensorflow_model_dependencies",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "opt_dep": [
                    "str",
                    "float"
                ]
            }
        },
        "test_pytorch_model_dependencies": {
            "name": "test_pytorch_model_dependencies",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "opt_dep": [
                    "str",
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/tests/test_saving.py": {
        "english_spacy_model": {
            "name": "english_spacy_model",
            "location": 32,
            "return": [
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable",
                "Optional[str]",
                "dict"
            ],
            "arguments": {}
        },
        "language_model": {
            "name": "language_model",
            "location": 41,
            "return": [
                "DistilbertBaseUncased",
                "int",
                "str",
                "models.characters.mods_base.Mod"
            ],
            "arguments": {}
        },
        "adult_data": {
            "name": "adult_data",
            "location": 47,
            "return": [
                "dict",
                "str",
                "Dict[int, Dict[int, Any]]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "List[List[str]]"
            ],
            "arguments": {}
        },
        "iris_data": {
            "name": "iris_data",
            "location": 52,
            "return": [
                "dict",
                "str",
                "Dict[int, Dict[int, Any]]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "List[List[str]]"
            ],
            "arguments": {}
        },
        "movie_sentiment_data": {
            "name": "movie_sentiment_data",
            "location": 57,
            "return": [
                "Callable",
                "str",
                "Union[str, Sequence[str]]",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "lr_classifier": {
            "name": "lr_classifier",
            "location": 62,
            "return": [
                "LogisticRegression",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "rf_classifier": {
            "name": "rf_classifier",
            "location": 78,
            "return": [
                "RandomForestClassifier",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "ffn_classifier": {
            "name": "ffn_classifier",
            "location": 95,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "request": []
            }
        },
        "mnist_predictor": {
            "name": "mnist_predictor",
            "location": 108,
            "return": [
                "Callable",
                "int",
                "models.Question",
                "str"
            ],
            "arguments": {}
        },
        "iris_ae": {
            "name": "iris_ae",
            "location": 115,
            "return": [
                "AE",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "iris_data": [
                    "Callable",
                    "Optional[Exception]",
                    "Optional[int]",
                    "Dict[str, Dict[str, float]]"
                ]
            }
        },
        "ale_explainer": {
            "name": "ale_explainer",
            "location": 137,
            "return": [
                "ALE",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "iris_data": [
                    "dict",
                    "str",
                    "app.models.Question",
                    "int"
                ],
                "lr_classifier": [
                    "dict",
                    "str",
                    "app.models.Question",
                    "int"
                ]
            }
        },
        "ig_explainer": {
            "name": "ig_explainer",
            "location": 144,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "iris_data": [
                    "bool",
                    "str"
                ],
                "ffn_classifier": [
                    "int",
                    "allennlp.models.model.Model",
                    "str",
                    "Dict[str, Any]",
                    "bytes"
                ]
            }
        },
        "mnist_segmentation_fn": {
            "name": "mnist_segmentation_fn",
            "location": 149,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "float"
                ],
                "size": [
                    "Tuple[int]",
                    "int",
                    "Tuple[float,float,float,float]",
                    "numpy.ndarray",
                    "str",
                    "float"
                ]
            }
        },
        "ai_explainer": {
            "name": "ai_explainer",
            "location": 158,
            "return": [
                "AnchorImage",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "mnist_predictor": [
                    "str",
                    "bool",
                    "int",
                    "raiden.utils.Tuple[raiden.utils.Tuple[raiden.utils.TokenAddress, raiden.utils.ProportionalFeeAmount], ...]"
                ],
                "request": [
                    "dict"
                ]
            }
        },
        "atext_explainer_nlp": {
            "name": "atext_explainer_nlp",
            "location": 167,
            "return": [
                "AnchorText",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "lr_classifier": [
                    "float",
                    "Tuple[Type[str], Type[bytes]]",
                    "tuple"
                ],
                "english_spacy_model": [
                    "int",
                    "Callable[[T], None]",
                    "type",
                    "Iterable",
                    "list",
                    "bytes"
                ],
                "movie_sentiment_data": [
                    "float",
                    "Tuple[Type[str], Type[bytes]]",
                    "tuple"
                ]
            }
        },
        "atext_explainer_lm": {
            "name": "atext_explainer_lm",
            "location": 178,
            "return": [
                "AnchorText",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "lr_classifier": [
                    "Tuple[Type[str], Type[bytes]]",
                    "tuple",
                    "numpy.dtype",
                    "bool",
                    "Tuple[Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal]"
                ],
                "language_model": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[Sequence[str]]"
                ],
                "movie_sentiment_data": [
                    "Tuple[Type[str], Type[bytes]]",
                    "tuple",
                    "numpy.dtype",
                    "bool",
                    "Tuple[Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal]"
                ]
            }
        },
        "atab_explainer": {
            "name": "atab_explainer",
            "location": 190,
            "return": [
                "AnchorTabular",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "lr_classifier": [
                    "Dict[str, str]",
                    "Dict[str, Type[Any]]",
                    "Dict[str, Any]"
                ],
                "adult_data": [
                    "Optional[str]",
                    "bool",
                    "int"
                ]
            }
        },
        "kshap_explainer": {
            "name": "kshap_explainer",
            "location": 202,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "lr_classifier": [
                    "Dict[str, str]",
                    "Dict[str, Type[Any]]",
                    "Dict[str, Any]"
                ],
                "adult_data": [
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "tree_explainer": {
            "name": "tree_explainer",
            "location": 214,
            "return": [
                "int",
                "models.seat_group.SeatGroup",
                "ticketing.models.ticket_bundle.TicketBundle",
                "str",
                "List[int]"
            ],
            "arguments": {
                "rf_classifier": [
                    "int",
                    "bool",
                    "Optional[bool]",
                    "Callable",
                    "str"
                ],
                "iris_data": [
                    "int",
                    "Dict[str, Any]"
                ]
            }
        },
        "cfrl_explainer": {
            "name": "cfrl_explainer",
            "location": 223,
            "return": [
                "CounterfactualRLTabular",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "rf_classifier": [
                    "numpy.ndarray",
                    "bool",
                    "List[str]",
                    "int",
                    "float"
                ],
                "iris_ae": [
                    "numpy.ndarray",
                    "list",
                    "int",
                    "Sequence[Sequence[float]]",
                    "Iterable[str]",
                    "bool"
                ],
                "iris_data": [
                    "Optional[float]",
                    "float",
                    "Union[int, float]",
                    "int",
                    "List[Tuple[int, int]]"
                ]
            }
        },
        "similarity_explainer": {
            "name": "similarity_explainer",
            "location": 269,
            "return": [
                "GradientSimilarity",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "ffn_classifier": [
                    "int",
                    "bool",
                    "zerver.models.UserProfile",
                    "Optional[int]",
                    "str"
                ],
                "iris_data": [
                    "\"SendRefundTransfer\"",
                    "List[str]",
                    "allennlp.data.dataloader.PyTorchDataLoader"
                ]
            }
        },
        "test_save_ALE": {
            "name": "test_save_ALE",
            "location": 282,
            "return": [
                "None"
            ],
            "arguments": {
                "ale_explainer": [
                    "bytes",
                    "Tuple[int, int]"
                ],
                "lr_classifier": [
                    "str"
                ],
                "iris_data": [
                    "bytes",
                    "str",
                    "core.models.Grouping",
                    "cmk.utils.type_defs.ServiceName",
                    "List[List[str]]"
                ]
            }
        },
        "test_save_IG": {
            "name": "test_save_IG",
            "location": 306,
            "return": [
                "None"
            ],
            "arguments": {
                "ig_explainer": [
                    "Tuple[int, int]"
                ],
                "ffn_classifier": [
                    "str"
                ],
                "iris_data": []
            }
        },
        "test_save_AnchorImage": {
            "name": "test_save_AnchorImage",
            "location": 327,
            "return": [
                "None"
            ],
            "arguments": {
                "ai_explainer": [
                    "spacy.language.Language"
                ],
                "mnist_predictor": [
                    "str",
                    "Dict[str, Sequence[spacy.tokens.Doc]]"
                ]
            }
        },
        "test_save_AnchorText": {
            "name": "test_save_AnchorText",
            "location": 345,
            "return": [
                "None"
            ],
            "arguments": {
                "atext_explainer": [
                    "Tuple[int, int]",
                    "Tuple[paradigm.models.Base, tests.utils.Kwargs]",
                    "bool"
                ],
                "lr_classifier": [
                    "str",
                    "float",
                    "Callable",
                    "raiden.utils.SecretHash"
                ],
                "movie_sentiment_data": [
                    "dict"
                ]
            }
        },
        "test_save_AnchorTabular": {
            "name": "test_save_AnchorTabular",
            "location": 364,
            "return": [
                "None"
            ],
            "arguments": {
                "atab_explainer": [
                    "Tuple[int, int]",
                    "bool",
                    "Tuple[paradigm.models.Base, tests.utils.Kwargs]"
                ],
                "lr_classifier": [
                    "str",
                    "Callable",
                    "raiden.utils.SecretHash",
                    "int"
                ],
                "adult_data": [
                    "raiden.utils.SecretHash",
                    "dict",
                    "int"
                ]
            }
        },
        "test_save_KernelShap": {
            "name": "test_save_KernelShap",
            "location": 384,
            "return": [
                "None"
            ],
            "arguments": {
                "kshap_explainer": [
                    "Tuple[int, int]",
                    "bool",
                    "Tuple[paradigm.models.Base, tests.utils.Kwargs]"
                ],
                "lr_classifier": [
                    "str",
                    "Callable",
                    "raiden.utils.SecretHash",
                    "int"
                ],
                "adult_data": [
                    "raiden.utils.SecretHash",
                    "dict",
                    "int"
                ]
            }
        },
        "test_save_TreeShap": {
            "name": "test_save_TreeShap",
            "location": 404,
            "return": [
                "None"
            ],
            "arguments": {
                "tree_explainer": [
                    "Union[numpy.ndarray, numpy.void]",
                    "bytes",
                    "str",
                    "utils.ResolveType",
                    "int"
                ],
                "rf_classifier": [
                    "str",
                    "bool",
                    "Set[str]"
                ],
                "iris_data": [
                    "List[Dict[str, Any]]",
                    "Optional[Dict[str, Any]]",
                    "int",
                    "bool",
                    "Dict[str, str]",
                    "str",
                    "dict",
                    "Optional[str]"
                ]
            }
        },
        "test_save_cfrl": {
            "name": "test_save_cfrl",
            "location": 424,
            "return": [
                "None"
            ],
            "arguments": {
                "cfrl_explainer": [
                    "int",
                    "List[int]",
                    "bytes",
                    "zerver.models.Realm",
                    "str"
                ],
                "rf_classifier": [
                    "Sequence[str]",
                    "int",
                    "numpy.ndarray"
                ],
                "iris_data": [
                    "bytes",
                    "str",
                    "core.models.Grouping",
                    "cmk.utils.type_defs.ServiceName",
                    "List[List[str]]"
                ]
            }
        },
        "test_save_SimilartyExplainer": {
            "name": "test_save_SimilartyExplainer",
            "location": 456,
            "return": [
                "None"
            ],
            "arguments": {
                "similarity_explainer": [
                    "Tuple[int, int]",
                    "bool",
                    "Tuple[paradigm.models.Base, tests.utils.Kwargs]"
                ],
                "ffn_classifier": [
                    "str"
                ],
                "iris_data": [
                    "bytes",
                    "str",
                    "core.models.Grouping",
                    "cmk.utils.type_defs.ServiceName",
                    "List[List[str]]"
                ]
            }
        },
        "cfrl_explainer.DecoderList.__init__": {
            "name": "__init__",
            "location": 233,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "decoder": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "cfrl_explainer.DecoderList.call": {
            "name": "call",
            "location": 237,
            "return": [
                "List",
                "int",
                "torch.utils.data.DataLoader",
                "float"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "Callable",
                    "int",
                    "float"
                ]
            }
        }
    },
    "alibi-master/alibi/tests/test_utils.py": {
        "test_argmax_transformer": {
            "name": "test_argmax_transformer",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "monkeypatch": [
                    "str",
                    "type",
                    "Dict[str, Any]",
                    "Type[Any]"
                ],
                "out_dim": [
                    "str",
                    "Type",
                    "Dict[str,Any]",
                    "Type[Any]"
                ],
                "out_type": [
                    "str",
                    "Type",
                    "Dict[str,Any]",
                    "Type[Any]"
                ]
            }
        }
    },
    "alibi-master/alibi/tests/utils.py": {
        "issorted": {
            "name": "issorted",
            "location": 112,
            "return": [
                "Optional[int]",
                "str"
            ],
            "arguments": {
                "arr": [
                    "str",
                    "Optional[Sequence[Any]]",
                    "Callable[[str],str]"
                ],
                "reverse": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "not_raises": {
            "name": "not_raises",
            "location": 124,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "ExpectedException": [
                    "str",
                    "Literal[True]",
                    "Literal[False]"
                ]
            }
        },
        "assert_message_in_logs": {
            "name": "assert_message_in_logs",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "msg": [
                    "int",
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "records": [
                    "bool"
                ]
            }
        },
        "MockPredictor.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "out_dim": [
                    "int",
                    "str",
                    "numpy.random.RandomState"
                ],
                "out_type": [
                    "Text",
                    "Tuple[str]",
                    "Optional[bool]",
                    "str"
                ],
                "model_type": [
                    "str",
                    "None",
                    "bool",
                    "Tuple",
                    "Optional[bool]"
                ],
                "seed": [
                    "int",
                    "None",
                    "float",
                    "bytes",
                    "str",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]",
                    "numpy.random.RandomState",
                    "Union[float,int]"
                ]
            }
        },
        "MockPredictor.__call__": {
            "name": "__call__",
            "location": 42,
            "return": [
                "bool",
                "float",
                "int",
                "Awaitable[Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MockPredictor._generate_probas": {
            "name": "_generate_probas",
            "location": 59,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "sz": [
                    "int",
                    "List[float]",
                    "None"
                ]
            }
        },
        "MockPredictor._generate_labels": {
            "name": "_generate_labels",
            "location": 92,
            "return": [
                "str",
                "dict",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "sz": [
                    "Tuple[int]",
                    "int"
                ]
            }
        },
        "MockPredictor._generate_logits": {
            "name": "_generate_logits",
            "location": 100,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "sz": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "MockPredictor.predict": {
            "name": "predict",
            "location": 108,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/tests/__init__.py": {},
    "alibi-master/alibi/utils/approximation_methods.py": {
        "approximation_parameters": {
            "name": "approximation_parameters",
            "location": 29,
            "return": [
                "Tuple[(Callable[([Any], Any)], Callable[([Any], Any)])]"
            ],
            "arguments": {
                "method": [
                    "str",
                    "Optional[Callable]",
                    "Union[str,Pattern[str]]"
                ]
            }
        },
        "riemann_builders": {
            "name": "riemann_builders",
            "location": 49,
            "return": [
                "Tuple[(Callable[([Any], Any)], Callable[([Any], Any)])]"
            ],
            "arguments": {
                "method": [
                    "str",
                    "Awaitable",
                    "bool",
                    "List[str]",
                    "Tuple[str]"
                ]
            }
        },
        "gauss_legendre_builders": {
            "name": "gauss_legendre_builders",
            "location": 104,
            "return": [
                "Tuple[(Callable[([Any], Any)], Callable[([Any], Any)])]"
            ],
            "arguments": {}
        },
        "riemann_builders.step_sizes": {
            "name": "step_sizes",
            "location": 74,
            "return": [],
            "arguments": {
                "n": []
            }
        },
        "riemann_builders.alphas": {
            "name": "alphas",
            "location": 82,
            "return": [
                "list[]"
            ],
            "arguments": {
                "n": []
            }
        },
        "gauss_legendre_builders.step_sizes": {
            "name": "step_sizes",
            "location": 133,
            "return": [],
            "arguments": {
                "n": []
            }
        },
        "gauss_legendre_builders.alphas": {
            "name": "alphas",
            "location": 138,
            "return": [
                "list[]"
            ],
            "arguments": {
                "n": []
            }
        }
    },
    "alibi-master/alibi/utils/data.py": {
        "gen_category_map": {
            "name": "gen_category_map",
            "location": 32,
            "return": [
                "Dict[(Any, list)]"
            ],
            "arguments": {
                "data": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "categorical_columns": [
                    "int",
                    "None",
                    "Optional[int]",
                    "str",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        },
        "Bunch.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Bunch.__setattr__": {
            "name": "__setattr__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "bool"
                ],
                "value": [
                    "str",
                    "bool"
                ]
            }
        },
        "Bunch.__dir__": {
            "name": "__dir__",
            "location": 22,
            "return": [
                "dict_keys[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Bunch.__getattr__": {
            "name": "__getattr__",
            "location": 25,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "List[str]",
                    "List[Dict[str,Any]]",
                    "List[dict[str,Any]]"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/discretizer.py": {
        "Discretizer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "List[Dict[str,Any]]",
                    "Dict",
                    "List[dict[str,Any]]",
                    "bool",
                    "str",
                    "Dict[str,Any]"
                ],
                "numerical_features": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "None",
                    "int",
                    "numpy.array"
                ],
                "feature_names": [
                    "str",
                    "bool",
                    "Set[str]",
                    "Optional[str]",
                    "None"
                ],
                "percentiles": [
                    "Tuple[int]",
                    "Optional[str]",
                    "bool",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "Discretizer.get_percentiles": {
            "name": "get_percentiles",
            "location": 49,
            "return": [
                "trezor.utils.Writer",
                "str",
                "dict",
                "raiden.utils.Tuple[int, int]",
                "bytes"
            ],
            "arguments": {
                "x": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray"
                ],
                "qts": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "Discretizer.bins": {
            "name": "bins",
            "location": 74,
            "return": [
                "List[np.ndarray]"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "numpy.ndarray",
                    "dict",
                    "utils.types.NDArray[float]"
                ]
            }
        },
        "Discretizer.discretize": {
            "name": "discretize",
            "location": 93,
            "return": [
                "str",
                "bytes",
                "raiden.utils.signer.Signer",
                "int",
                "Dict[str,str]",
                "List[int]",
                "Optional[float]",
                "List[Dict[str,Any]]",
                "Callable[Any,tuple]",
                "float",
                "bool",
                "List"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "List",
                    "int",
                    "str",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/distance.py": {
        "cityblock_batch": {
            "name": "cityblock_batch",
            "location": 6,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray"
                ],
                "y": [
                    "int",
                    "Union[int, float, str]",
                    "Union[str, float]",
                    "str"
                ]
            }
        },
        "mvdm": {
            "name": "mvdm",
            "location": 34,
            "return": [
                "dict"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray",
                    "int"
                ],
                "y": [
                    "numpy.ndarray",
                    "float",
                    "str",
                    "list"
                ],
                "cat_vars": [
                    "Optional[int]",
                    "Optional[float]",
                    "int",
                    "Optional[Tuple]"
                ],
                "alpha": [
                    "int",
                    "float",
                    "Optional[int]",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "abdm": {
            "name": "abdm",
            "location": 88,
            "return": [
                "dict"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray",
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ],
                "cat_vars": [
                    "Optional[int]",
                    "Optional[float]",
                    "int",
                    "List[str]",
                    "numpy.ndarray",
                    "bool"
                ],
                "cat_vars_bin": [
                    "Dict",
                    "bool",
                    "float",
                    "int"
                ]
            }
        },
        "multidim_scaling": {
            "name": "multidim_scaling",
            "location": 163,
            "return": [
                "Tuple[(dict, Union[(tuple, _T1)])]"
            ],
            "arguments": {
                "d_pair": [
                    "dict",
                    "Dict[str, Dict[str, float]]",
                    "Dict[str, Dict[str, Any]]",
                    "Union[AsyncIterable[Any], Iterable[Any]]",
                    "Dict[str, float]"
                ],
                "feature_range": [
                    "Optional[Dict[str, Any]]",
                    "dict",
                    "numpy.ndarray",
                    "Dict[str, str]"
                ],
                "n_components": [
                    "int",
                    "float",
                    "numpy.random.RandomState",
                    "str",
                    "bool",
                    "Sequence"
                ],
                "use_metric": [
                    "bool",
                    "int",
                    "float",
                    "numpy.random.RandomState",
                    "str",
                    "Sequence"
                ],
                "standardize_cat_vars": [
                    "bool",
                    "numpy.random.RandomState",
                    "Iterable[bytes]",
                    "numpy.ndarray"
                ],
                "smooth": [
                    "float",
                    "int"
                ],
                "center": [
                    "bool",
                    "numpy.random.RandomState",
                    "Iterable[bytes]",
                    "numpy.ndarray"
                ],
                "update_feature_range": [
                    "bool",
                    "numpy.random.RandomState",
                    "Iterable[bytes]",
                    "numpy.ndarray"
                ]
            }
        },
        "squared_pairwise_distance": {
            "name": "squared_pairwise_distance",
            "location": 247,
            "return": [
                "numpy.ndarray",
                "Iterable[Any]",
                "str",
                "list"
            ],
            "arguments": {
                "x": [
                    "numpy.ndarray",
                    "int",
                    "nevergrad.common.Callable[[numpy.ndarray], numpy.ndarray]"
                ],
                "y": [
                    "float",
                    "int",
                    "numpy.array",
                    "numpy.ndarray"
                ],
                "a_min": [
                    "float",
                    "int",
                    "List[List[int]]",
                    "Iterable[List[str]]",
                    "Tuple[int]"
                ],
                "a_max": [
                    "float",
                    "int",
                    "List[List[int]]",
                    "Iterable[List[str]]",
                    "Tuple[int]"
                ]
            }
        },
        "batch_compute_kernel_matrix": {
            "name": "batch_compute_kernel_matrix",
            "location": 275,
            "return": [
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "y": [
                    "Optional[int]",
                    "int",
                    "numpy.ndarray"
                ],
                "kernel": [
                    "bool",
                    "int",
                    "list",
                    "float",
                    "str"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "Union[numpy.ndarray,pandas.DataFrame]"
                ],
                "preprocess_fn": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "Optional[Dict]",
                    "Union[None,float,int]",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/distributed.py": {
        "batch": {
            "name": "batch",
            "location": 254,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "X": [
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "batch_size": [
                    "None",
                    "int",
                    "List"
                ],
                "n_batches": [
                    "int",
                    "Dict[str,int]"
                ]
            }
        },
        "default_target_fcn": {
            "name": "default_target_fcn",
            "location": 296,
            "return": [
                "bool",
                "Optional[Any]",
                "str",
                "Callable[..., None]",
                "Optional[int]"
            ],
            "arguments": {
                "actor": [
                    "str",
                    "int",
                    "logging.LogRecord",
                    "list"
                ],
                "instances": [
                    "str",
                    "int",
                    "logging.LogRecord",
                    "list"
                ],
                "kwargs": [
                    "None"
                ]
            }
        },
        "concatenate_minibatches": {
            "name": "concatenate_minibatches",
            "location": 330,
            "return": [
                "str",
                "int",
                "numpy.ndarray"
            ],
            "arguments": {
                "minibatch_results": [
                    "bool",
                    "FrozenSet[int]",
                    "str"
                ]
            }
        },
        "_array_list_concatenator": {
            "name": "_array_list_concatenator",
            "location": 360,
            "return": [
                "list"
            ],
            "arguments": {
                "minibatch_results": [
                    "list",
                    "List[Union[int, float]]",
                    "List[Tuple[str, int]]",
                    "List[str]",
                    "str"
                ]
            }
        },
        "invert_permutation": {
            "name": "invert_permutation",
            "location": 371,
            "return": [
                "str",
                "float"
            ],
            "arguments": {
                "p": [
                    "Collection[int]",
                    "numpy.ndarray"
                ]
            }
        },
        "order_result": {
            "name": "order_result",
            "location": 391,
            "return": [
                "list"
            ],
            "arguments": {
                "unordered_result": [
                    "List[str]",
                    "int",
                    "Optional[Union[str, Any]]",
                    "Callable"
                ]
            }
        },
        "ActorPool.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "actors": [
                    "str",
                    "Optional[list]",
                    "int"
                ]
            }
        },
        "ActorPool.map": {
            "name": "map",
            "location": 44,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "List[str]",
                    "str",
                    "Callable",
                    "T"
                ],
                "values": [
                    "float",
                    "bool",
                    "T",
                    "Sequence",
                    "int"
                ],
                "chunksize": [
                    "int",
                    "float",
                    "bool",
                    "T",
                    "Sequence"
                ]
            }
        },
        "ActorPool.map_unordered": {
            "name": "map_unordered",
            "location": 77,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "List[str]",
                    "str",
                    "Callable",
                    "T"
                ],
                "values": [
                    "float",
                    "bool",
                    "T",
                    "Sequence",
                    "int"
                ],
                "chunksize": [
                    "int",
                    "float",
                    "bool",
                    "T",
                    "Sequence"
                ]
            }
        },
        "ActorPool.submit": {
            "name": "submit",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "Callable[..., bool]",
                    "Sequence[Tuple[str, str]]",
                    "bool",
                    "list"
                ],
                "value": [
                    "Callable[..., bool]",
                    "Sequence[Tuple[str, str]]",
                    "bool",
                    "list"
                ]
            }
        },
        "ActorPool.has_next": {
            "name": "has_next",
            "location": 144,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ActorPool.get_next": {
            "name": "get_next",
            "location": 165,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "timeout": [
                    "Sequence[Callable]",
                    "None"
                ]
            }
        },
        "ActorPool.get_next_unordered": {
            "name": "get_next_unordered",
            "location": 203,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "timeout": [
                    "None",
                    "int",
                    "List[Dict[str,Any]]"
                ]
            }
        },
        "ActorPool._return_actor": {
            "name": "_return_actor",
            "location": 242,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "actor": [
                    "str"
                ]
            }
        },
        "ActorPool._chunk": {
            "name": "_chunk",
            "location": 248,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "values": [
                    "str",
                    "float",
                    "List[int]",
                    "List[bytes]",
                    "numpy.ndarray",
                    "tuple",
                    "list",
                    "int",
                    "bool"
                ],
                "chunksize": [
                    "str",
                    "float",
                    "List[int]",
                    "List[bytes]",
                    "numpy.ndarray",
                    "tuple",
                    "list",
                    "int",
                    "bool"
                ]
            }
        },
        "DistributedExplainer.__init__": {
            "name": "__init__",
            "location": 428,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "distributed_opts": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "Tuple[float, float]"
                ],
                "explainer_type": [
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "explainer_init_args": [
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "explainer_init_kwargs": [
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "concatenate_results": [
                    "bool",
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "return_generator": [
                    "bool",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "DistributedExplainer.__getattr__": {
            "name": "__getattr__",
            "location": 514,
            "return": [
                "numpy.ndarray",
                "int",
                "bool",
                "str",
                "Tuple[int, int]"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[str]"
                ]
            }
        },
        "DistributedExplainer.actor_index": {
            "name": "actor_index",
            "location": 559,
            "return": [],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "int",
                    "bytes",
                    "float",
                    "Union[str, bytes]"
                ]
            }
        },
        "DistributedExplainer.set_actor_index": {
            "name": "set_actor_index",
            "location": 565,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "bool",
                    "Union[str, bytes]"
                ]
            }
        },
        "DistributedExplainer.return_attribute": {
            "name": "return_attribute",
            "location": 572,
            "return": [
                "bool",
                "str",
                "Tuple[bool, str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "dict",
                    "Set[str]"
                ]
            }
        },
        "DistributedExplainer.create_parallel_pool": {
            "name": "create_parallel_pool",
            "location": 585,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "explainer_type": [
                    "float",
                    "numpy.ndarray",
                    "str",
                    "Callable[[str], str]",
                    "Dict[str, Any]",
                    "int"
                ],
                "explainer_init_args": [
                    "bool",
                    "Callable[[], Awaitable[Any]]",
                    "List[int]"
                ],
                "explainer_init_kwargs": [
                    "bool",
                    "Callable[[], Awaitable[Any]]",
                    "List[int]"
                ]
            }
        },
        "DistributedExplainer.get_explanation": {
            "name": "get_explanation",
            "location": 598,
            "return": [
                "List",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "PoolCollection.__init__": {
            "name": "__init__",
            "location": 650,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "distributed_opts": [
                    "int",
                    "bool",
                    "Optional[float]"
                ],
                "explainer_type": [
                    "List[str]",
                    "str",
                    "Optional[str]",
                    "bool",
                    "Set[str]"
                ],
                "explainer_init_args": [
                    "int",
                    "str",
                    "Sequence[T]",
                    "Tuple[int, int]"
                ],
                "explainer_init_kwargs": [
                    "str",
                    "bool"
                ]
            }
        },
        "PoolCollection.remote_explainer_index": {
            "name": "remote_explainer_index",
            "location": 720,
            "return": [],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "float",
                    "bool",
                    "Union[int, float]"
                ]
            }
        },
        "PoolCollection.__getattr__": {
            "name": "__getattr__",
            "location": 726,
            "return": [
                "numpy.ndarray",
                "int",
                "bool",
                "str",
                "Tuple[int, int]"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[str]"
                ]
            }
        },
        "PoolCollection.__getitem__": {
            "name": "__getitem__",
            "location": 740,
            "return": [
                "bytes",
                "int",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "List[int]",
                    "List[OrderedDict]",
                    "List['cirq.Qid']",
                    "list"
                ]
            }
        },
        "PoolCollection.create_explainer_handles": {
            "name": "create_explainer_handles",
            "location": 750,
            "return": [
                "list"
            ],
            "arguments": {
                "distributed_opts": [
                    "List[str]",
                    "Optional[str]",
                    "str"
                ],
                "explainer_type": [
                    "List[str]",
                    "Optional[str]",
                    "str"
                ],
                "explainer_init_args": [
                    "str",
                    "bool",
                    "List[numpy.ndarray]",
                    "numpy.ndarray",
                    "List[str]"
                ],
                "explainer_init_kwargs": [
                    "bool",
                    "List[int]",
                    "float"
                ]
            }
        },
        "PoolCollection.get_explanation": {
            "name": "get_explanation",
            "location": 778,
            "return": [
                "Optional[str]",
                "Optional[List[str]]",
                "Callable[[], None]",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "dict"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/distributions.py": {
        "kl_bernoulli": {
            "name": "kl_bernoulli",
            "location": 4,
            "return": [
                "str",
                "List[Dict]",
                "int",
                "numpy.ndarray",
                "Mapping[str, Any]",
                "Union[slice, List[slice], List[int]]",
                "List[Tuple[float, str]]"
            ],
            "arguments": {
                "p": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ],
                "q": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/download.py": {
        "spacy_model": {
            "name": "spacy_model",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "Text",
                    "str",
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/frameworks.py": {},
    "alibi-master/alibi/utils/gradients.py": {
        "perturb": {
            "name": "perturb",
            "location": 5,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "X": [
                    "float",
                    "numpy.ndarray",
                    "numpy.array"
                ],
                "eps": [
                    "float",
                    "numpy.ndarray",
                    "int",
                    "str",
                    "T"
                ],
                "proba": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "List",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "num_grad_batch": {
            "name": "num_grad_batch",
            "location": 40,
            "return": [
                "int",
                "numpy.ndarray",
                "str",
                "deque"
            ],
            "arguments": {
                "func": [
                    "int"
                ],
                "X": [
                    "int"
                ],
                "args": [
                    "tuple[]"
                ],
                "eps": [
                    "float",
                    "Union[float,numpy.ndarray]",
                    "Iterable[T]",
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/kernel.py": {
        "GaussianRBF.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sigma": [
                    "Optional[Callable]",
                    "Dict",
                    "None",
                    "str",
                    "Callable"
                ]
            }
        },
        "GaussianRBF.sigma": {
            "name": "sigma",
            "location": 34,
            "return": [
                "str",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianRBF.__call__": {
            "name": "__call__",
            "location": 37,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "Sequence[Any]"
                ],
                "y": [
                    "Sequence[Any]",
                    "numpy.ndarray"
                ],
                "infer_sigma": [
                    "bool",
                    "float",
                    "str",
                    "numpy.ndarray",
                    "Callable",
                    "Awaitable[T]",
                    "Container"
                ]
            }
        },
        "GaussianRBFDistance.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sigma": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ]
            }
        },
        "GaussianRBFDistance.__call__": {
            "name": "__call__",
            "location": 89,
            "return": [
                "float",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray"
                ],
                "y": [
                    "float",
                    "numpy.ndarray"
                ],
                "infer_sigma": [
                    "bool",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "EuclideanDistance.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EuclideanDistance.__call__": {
            "name": "__call__",
            "location": 102,
            "return": [
                "int",
                "Callable",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Sequence[Any]",
                    "str"
                ],
                "y": [
                    "Sequence[Any]",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/lang_model.py": {
        "LanguageModel.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_path": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "LanguageModel.from_disk": {
            "name": "from_disk",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": []
            }
        },
        "LanguageModel.to_disk": {
            "name": "to_disk",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": []
            }
        },
        "LanguageModel.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token": []
            }
        },
        "LanguageModel.select_word": {
            "name": "select_word",
            "location": 126,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "tokenized_text": [],
                "start_idx": [],
                "punctuation": []
            }
        },
        "LanguageModel.is_stop_word": {
            "name": "is_stop_word",
            "location": 167,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokenized_text": [],
                "start_idx": [],
                "punctuation": [],
                "stopwords": []
            }
        },
        "LanguageModel.is_punctuation": {
            "name": "is_punctuation",
            "location": 199,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [],
                "punctuation": []
            }
        },
        "LanguageModel.mask": {
            "name": "mask",
            "location": 228,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LanguageModel.mask_id": {
            "name": "mask_id",
            "location": 235,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LanguageModel.max_num_tokens": {
            "name": "max_num_tokens",
            "location": 242,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "LanguageModel.head_tail_split": {
            "name": "head_tail_split",
            "location": 248,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "text": []
            }
        },
        "LanguageModel.predict_batch_lm": {
            "name": "predict_batch_lm",
            "location": 297,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "x": [],
                "vocab_size": [],
                "batch_size": []
            }
        },
        "DistilbertBaseUncased.__init__": {
            "name": "__init__",
            "location": 342,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "DistilbertBaseUncased.mask": {
            "name": "mask",
            "location": 354,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "DistilbertBaseUncased.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 357,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "token": []
            }
        },
        "BertBaseUncased.__init__": {
            "name": "__init__",
            "location": 364,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "BertBaseUncased.mask": {
            "name": "mask",
            "location": 376,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BertBaseUncased.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 379,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "token": []
            }
        },
        "RobertaBase.__init__": {
            "name": "__init__",
            "location": 386,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "preloading": [
                    "bool"
                ]
            }
        },
        "RobertaBase.mask": {
            "name": "mask",
            "location": 398,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RobertaBase.is_subword_prefix": {
            "name": "is_subword_prefix",
            "location": 401,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": []
            }
        }
    },
    "alibi-master/alibi/utils/mapping.py": {
        "ohe_to_ord_shape": {
            "name": "ohe_to_ord_shape",
            "location": 6,
            "return": [
                "Union[(Tuple[(Any, Any)], _T0)]"
            ],
            "arguments": {
                "shape": [
                    "Optional[int]",
                    "int",
                    "Dict[int, Dict[int, Any]]",
                    "bool"
                ],
                "cat_vars": [
                    "Dict",
                    "Dict[str,Any]",
                    "str",
                    "Optional[Dict[str,Any]]"
                ],
                "is_ohe": [
                    "bool",
                    "Dict[str,Any]",
                    "str",
                    "Dict[str,str]"
                ]
            }
        },
        "ord_to_num": {
            "name": "ord_to_num",
            "location": 34,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "data": [
                    "Dict",
                    "int",
                    "numpy.ndarray"
                ],
                "dist": [
                    "Dict[str,Any]",
                    "Dict",
                    "Dict[str,float]",
                    "str"
                ]
            }
        },
        "num_to_ord": {
            "name": "num_to_ord",
            "location": 62,
            "return": [
                "List[str]",
                "int",
                "numpy.ndarray"
            ],
            "arguments": {
                "data": [
                    "List[str]",
                    "str",
                    "bytes",
                    "Dict[str,Any]"
                ],
                "dist": [
                    "Dict[str,Any]",
                    "Dict",
                    "Dict[str,float]",
                    "str"
                ]
            }
        },
        "ord_to_ohe": {
            "name": "ord_to_ohe",
            "location": 86,
            "return": [
                "Tuple[(Any, Dict[(int, Any)])]"
            ],
            "arguments": {
                "X_ord": [
                    "numpy.ndarray",
                    "Optional[Union[int, slice]]",
                    "float"
                ],
                "cat_vars_ord": [
                    "str",
                    "Dict[str, Any]",
                    "Iterator[Tuple[Any]]",
                    "int"
                ]
            }
        },
        "ohe_to_ord": {
            "name": "ohe_to_ord",
            "location": 124,
            "return": [
                "Tuple[(Any, Dict[(int, Any)])]"
            ],
            "arguments": {
                "X_ohe": [
                    "Tuple[Union[int,int]]",
                    "float",
                    "str",
                    "Tuple[int,int]",
                    "Optional[str]"
                ],
                "cat_vars_ohe": [
                    "str",
                    "Dict[str, Any]",
                    "Iterator[Tuple[Any]]",
                    "int"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/missing_optional_dependency.py": {
        "import_optional": {
            "name": "import_optional",
            "location": 73,
            "return": [
                "str",
                "frozenset",
                "Dict",
                "Set[str]",
                "bool",
                "Dict[str,Any]",
                "int",
                "Dict[Type,str]",
                "Optional[int]",
                "MissingDependency"
            ],
            "arguments": {
                "module_name": [
                    "str",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "names": [
                    "str",
                    "Optional[str]",
                    "Optional[Iterable[str]]",
                    "Optional[Pattern]",
                    "Optional[Dict[Hashable,Any]]",
                    "Optional[Set[str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "MissingDependency.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "object_name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "err": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "missing_dependency": [
                    "Text",
                    "bool",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "MissingDependency.err_msg": {
            "name": "err_msg",
            "location": 58,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MissingDependency.__getattr__": {
            "name": "__getattr__",
            "location": 64,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "Union[float,int]",
                    "float",
                    "int"
                ]
            }
        },
        "MissingDependency.__call__": {
            "name": "__call__",
            "location": 68,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/utils/tf.py": {
        "argmin_grad": {
            "name": "argmin_grad",
            "location": 5,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ],
                "y": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "one_hot_grad": {
            "name": "one_hot_grad",
            "location": 17,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ],
                "y": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "argmax_grad": {
            "name": "argmax_grad",
            "location": 28,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "round_grad": {
            "name": "round_grad",
            "location": 39,
            "return": [
                "Tuple",
                "bool",
                "float",
                "Optional[Any]"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "argmin_grad.grad": {
            "name": "grad",
            "location": 9,
            "return": [
                "tuple[None]"
            ],
            "arguments": {
                "dy": []
            }
        },
        "one_hot_grad.grad": {
            "name": "grad",
            "location": 20,
            "return": [
                "tuple[None]"
            ],
            "arguments": {
                "dy": []
            }
        },
        "argmax_grad.grad": {
            "name": "grad",
            "location": 31,
            "return": [
                "tuple[None]"
            ],
            "arguments": {
                "dy": []
            }
        },
        "round_grad.grad": {
            "name": "grad",
            "location": 42,
            "return": [
                "Tuple[None]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "dy": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/visualization.py": {
        "_prepare_image": {
            "name": "_prepare_image",
            "location": 30,
            "return": [
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "attr_visual": [
                    "str",
                    "Dict[str, Any]",
                    "int",
                    "List[str]",
                    "bytes"
                ]
            }
        },
        "_normalize_scale": {
            "name": "_normalize_scale",
            "location": 34,
            "return": [
                "str",
                "Iterable[int]",
                "bool",
                "MutableMapping[str, Any]",
                "int"
            ],
            "arguments": {
                "attr": [
                    "str",
                    "Hashable"
                ],
                "scale_factor": [
                    "str",
                    "float",
                    "int"
                ]
            }
        },
        "_cumulative_sum_threshold": {
            "name": "_cumulative_sum_threshold",
            "location": 45,
            "return": [
                "str",
                "Optional[int]",
                "Optional[str]",
                "Callable",
                "numpy.ndarray"
            ],
            "arguments": {
                "values": [
                    "int",
                    "bytes",
                    "numpy.ndarray",
                    "str",
                    "Callable",
                    "Tuple[int, int, int]",
                    "Sequence[Any]"
                ],
                "percentile": [
                    "str",
                    "T",
                    "Optional[str]",
                    "int",
                    "bool"
                ]
            }
        },
        "_normalize_image_attr": {
            "name": "_normalize_image_attr",
            "location": 56,
            "return": [
                "str",
                "bool",
                "float"
            ],
            "arguments": {
                "attr": [
                    "str",
                    "Sequence[object]",
                    "Dict[str, Any]"
                ],
                "sign": [
                    "str"
                ],
                "outlier_perc": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ]
            }
        },
        "visualize_image_attr": {
            "name": "visualize_image_attr",
            "location": 79,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "attr": [
                    "str",
                    "Tuple[List[Any], int]",
                    "Optional[str]"
                ],
                "original_image": [
                    "None",
                    "str",
                    "T",
                    "Optional[T]",
                    "Optional[bytes]"
                ],
                "method": [
                    "Text",
                    "str",
                    "bool",
                    "Tuple[Any,str]"
                ],
                "sign": [
                    "Text",
                    "str",
                    "Tuple[Dict[str,Any],int]",
                    "Tuple[List[Any],int]",
                    "int",
                    "Optional[str]",
                    "Optional[bool]"
                ],
                "plt_fig_axis": [
                    "None",
                    "Optional[str]",
                    "bool",
                    "Optional[Union[Any,Any]]",
                    "str"
                ],
                "outlier_perc": [
                    "int",
                    "str",
                    "Tuple[List[Any],int]",
                    "Optional[str]"
                ],
                "cmap": [
                    "None",
                    "Optional[float]",
                    "Union[List,Dict,None]",
                    "Optional[str]"
                ],
                "alpha_overlay": [
                    "float",
                    "str",
                    "int",
                    "bytes",
                    "Optional[str]"
                ],
                "show_colorbar": [
                    "bool",
                    "List[Dict[str,Any]]",
                    "str",
                    "List[str]",
                    "int",
                    "Sequence[str]",
                    "T"
                ],
                "title": [
                    "None",
                    "str",
                    "Optional[str]",
                    "bool",
                    "Callable"
                ],
                "fig_size": [
                    "Tuple[int]",
                    "float",
                    "str",
                    "bytes",
                    "int"
                ],
                "use_pyplot": [
                    "bool",
                    "List[Dict[str,Any]]",
                    "str",
                    "List[str]",
                    "int",
                    "Sequence[str]",
                    "T"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/wrappers.py": {
        "methdispatch": {
            "name": "methdispatch",
            "location": 39,
            "return": [
                "Callable"
            ],
            "arguments": {
                "func": [
                    "Callable",
                    "Callable[...,None]"
                ]
            }
        },
        "Predictor.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "clf": [
                    "int",
                    "float",
                    "bool"
                ],
                "preprocessor": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ]
            }
        },
        "Predictor.__call__": {
            "name": "__call__",
            "location": 17,
            "return": [
                "str",
                "Tuple[float, float]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "ArgmaxTransformer.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predictor": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ArgmaxTransformer.__call__": {
            "name": "__call__",
            "location": 34,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "str",
                    "Callable",
                    "Container",
                    "numpy.ndarray",
                    "collections.abc.Awaitable[T]",
                    "Awaitable[T]"
                ]
            }
        },
        "methdispatch.wrapper": {
            "name": "wrapper",
            "location": 54,
            "return": [
                "bool",
                "numpy.ndarray",
                "List[Dict[str, Any]]"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/utils/__init__.py": {},
    "alibi-master/alibi/utils/tests/mocked_opt_dep.py": {
        "mocked_function_without_required_deps": {
            "name": "mocked_function_without_required_deps",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "MockedClassWithoutRequiredDeps.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_data.py": {
        "test_get_category_map": {
            "name": "test_get_category_map",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "categorical_columns": [
                    "str",
                    "Optional[List[str]]",
                    "int",
                    "List[str]",
                    "Tuple[int]",
                    "Optional[float]",
                    "None",
                    "float"
                ],
                "df": [
                    "float",
                    "str",
                    "List[int]",
                    "bool",
                    "Callable[VT,bool]",
                    "VT",
                    "Callable[[VT],bool]"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_distance.py": {
        "random_matrix": {
            "name": "random_matrix",
            "location": 13,
            "return": [
                "int",
                "float",
                "Callable",
                "str",
                "Tuple[Union[Literal,Literal,Literal]]"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_cityblock_batch": {
            "name": "test_cityblock_batch",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "random_matrix": [
                    "str",
                    "int",
                    "List[str]",
                    "Type"
                ]
            }
        },
        "cats_and_labels": {
            "name": "cats_and_labels",
            "location": 39,
            "return": [
                "Tuple[Union[bool,tuple[Union[Any,str]],frozenset,Callable[,None],list[tuple[Union[str,Any,str]]],dict[str,Any],dict,str,set[str],list[dict[str,Any]]]]",
                "str",
                "bool"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]",
                    "Optional[Dict[str,Any]]",
                    "Dict",
                    "None"
                ]
            }
        },
        "test_abdm_mvdm": {
            "name": "test_abdm_mvdm",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "cats_and_labels": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_multidim_scaling": {
            "name": "test_multidim_scaling",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "cats_and_labels": [
                    "str",
                    "bool",
                    "List[str]"
                ],
                "rng": [
                    "Callable"
                ],
                "update_rng": [
                    "Iterable[Any]",
                    "str",
                    "raiden.utils.List[raiden.raiden_service.RaidenService]"
                ],
                "center": [
                    "Iterable[Any]",
                    "str",
                    "raiden.utils.List[raiden.raiden_service.RaidenService]"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_distributed.py": {
        "data_generator": {
            "name": "data_generator",
            "location": 47,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "request": [
                    "Dict[str, Any]"
                ]
            }
        },
        "kwargs_factory": {
            "name": "kwargs_factory",
            "location": 56,
            "return": [
                "List[dict]"
            ],
            "arguments": {
                "keys": [
                    "str",
                    "dict"
                ],
                "values": [
                    "str",
                    "dict"
                ]
            }
        },
        "distributed_opts_id": {
            "name": "distributed_opts_id",
            "location": 92,
            "return": [
                "str"
            ],
            "arguments": {
                "params": [
                    "int",
                    "str"
                ]
            }
        },
        "data_generator_id": {
            "name": "data_generator_id",
            "location": 104,
            "return": [
                "str"
            ],
            "arguments": {
                "params": [
                    "Tuple['cirq.Qid']",
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_distributed_explainer_init": {
            "name": "test_distributed_explainer_init",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "expln_args": [],
                "expln_kwargs": [],
                "distributed_opts": [
                    "Dict[str, Any]"
                ]
            }
        },
        "test_distributed_explainer_get_explanation": {
            "name": "test_distributed_explainer_get_explanation",
            "location": 174,
            "return": [
                "None"
            ],
            "arguments": {
                "data_generator": [
                    "int",
                    "bool",
                    "torch.utils.data.DataLoader",
                    "numpy.array"
                ],
                "expln_args": [
                    "Callable",
                    "List[str]",
                    "Dict[str, Any]"
                ],
                "expln_kwargs": [
                    "Callable",
                    "List[str]",
                    "Dict[str, Any]"
                ],
                "distributed_opts": [
                    "int",
                    "numpy.ndarray",
                    "bytes",
                    "raiden.utils.Locksroot"
                ],
                "return_generator": [
                    "Callable",
                    "List[str]",
                    "Dict[str, Any]"
                ],
                "concatenate_results": [
                    "Callable",
                    "List[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "permutation_generator": {
            "name": "permutation_generator",
            "location": 231,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "request": []
            }
        },
        "test_invert_permutation": {
            "name": "test_invert_permutation",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {
                "permutation_generator": [
                    "List[numpy.ndarray]",
                    "numpy.ndarray",
                    "str"
                ]
            }
        },
        "test_pool_collection_init": {
            "name": "test_pool_collection_init",
            "location": 272,
            "return": [
                "None"
            ],
            "arguments": {
                "expln_args": [],
                "expln_kwargs": [
                    "int"
                ],
                "distributed_opts": [
                    "Sequence[str]",
                    "float",
                    "int"
                ],
                "concatenate_results": [
                    "Dict[str, Any]"
                ]
            }
        },
        "test_pool_collection_get_explanation": {
            "name": "test_pool_collection_get_explanation",
            "location": 335,
            "return": [
                "None"
            ],
            "arguments": {
                "data_generator": [
                    "int",
                    "list",
                    "raiden.utils.List[raiden.transfer.mediated_transfer.state.MediationPairState]",
                    "str"
                ],
                "expln_args": [
                    "str",
                    "dict",
                    "Callable"
                ],
                "expln_kwargs": [
                    "str",
                    "dict",
                    "Callable"
                ],
                "distributed_opts": []
            }
        },
        "test_concatenate_minibatches": {
            "name": "test_concatenate_minibatches",
            "location": 375,
            "return": [
                "None"
            ],
            "arguments": {
                "data_generator": [
                    "int",
                    "str"
                ],
                "n_minibatches": [
                    "int",
                    "tuple",
                    "Tuple[str, str, str, str, str, str, str, str, str, str, str, str]",
                    "list"
                ],
                "repetitions": [
                    "int",
                    "str"
                ],
                "n_features": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "MockExplainer.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sleep_time": [
                    "int",
                    "float"
                ],
                "multiplier": [
                    "int",
                    "float"
                ]
            }
        },
        "MockExplainer.get_explanation": {
            "name": "get_explanation",
            "location": 26,
            "return": [
                "Tuple",
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "list",
                    "List[tuple]",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ]
            }
        },
        "MockExplainer.return_attribute": {
            "name": "return_attribute",
            "location": 38,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_gradients.py": {
        "logistic_iris": {
            "name": "logistic_iris",
            "location": 10,
            "return": [
                "Tuple[Union[list[str],int,str,tuple[Union[Literal,Any]],list,dict[str,Any],DefaultDict]]",
                "str",
                "utils.Node"
            ],
            "arguments": {}
        },
        "test_get_batch_num_gradients_cityblock": {
            "name": "test_get_batch_num_gradients_cityblock",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "shape": [
                    "int"
                ],
                "batch_size": [
                    "int",
                    "str"
                ]
            }
        },
        "test_get_batch_num_gradients_logistic_iris": {
            "name": "test_get_batch_num_gradients_logistic_iris",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "logistic_iris": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_import_optional.py": {
        "TestImportOptional.setup_method": {
            "name": "setup_method",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.teardown_method": {
            "name": "teardown_method",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_module": {
            "name": "test_import_optional_module",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_names": {
            "name": "test_import_optional_names",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_module_missing": {
            "name": "test_import_optional_module_missing",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestImportOptional.test_import_optional_names_missing": {
            "name": "test_import_optional_names_missing",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "alibi-master/alibi/utils/tests/test_mapping.py": {
        "test_mapping_fn": {
            "name": "test_mapping_fn",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "alibi-master/alibi/utils/tests/__init__.py": {},
    "alibi-master/doc/source/conf.py": {},
    "alibi-master/testing/test_notebooks.py": {
        "test_notebook_execution": {
            "name": "test_notebook_execution",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "notebook": [
                    "pathlib.Path"
                ]
            }
        }
    }
}
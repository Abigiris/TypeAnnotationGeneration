{
    "allennlp-dureader-master/setup.py": {},
    "allennlp-dureader-master/allennlp/run.py": {},
    "allennlp-dureader-master/allennlp/version.py": {},
    "allennlp-dureader-master/allennlp/__init__.py": {},
    "allennlp-dureader-master/allennlp/commands/dry_run.py": {
        "dry_run_from_args": {
            "name": "dry_run_from_args",
            "location": 74,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "dry_run_from_params": {
            "name": "dry_run_from_params",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "params": [
                    "dict[, ]",
                    "str",
                    "IO",
                    "dict"
                ],
                "serialization_dir": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "verbosely_create_vocabulary": {
            "name": "verbosely_create_vocabulary",
            "location": 125,
            "return": [
                "List[List[str]]",
                "Vocabulary"
            ],
            "arguments": {
                "vocab_params": [
                    "int",
                    "Optional[int]"
                ],
                "instances": [
                    "List[allennlp.data.Instance]",
                    "int",
                    "float",
                    "List[int]"
                ]
            }
        },
        "DryRun.add_subparser": {
            "name": "add_subparser",
            "location": 49,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/elmo.py": {
        "empty_embedding": {
            "name": "empty_embedding",
            "location": 103,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "elmo_command": {
            "name": "elmo_command",
            "location": 303,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "Elmo.add_subparser": {
            "name": "add_subparser",
            "location": 70,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        },
        "ElmoEmbedder.__init__": {
            "name": "__init__",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "typing.Text",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "weight_file": [
                    "typing.Text",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "cuda_device": [
                    "int",
                    "bool"
                ]
            }
        },
        "ElmoEmbedder.batch_to_ids": {
            "name": "batch_to_ids",
            "location": 130,
            "return": [
                "str",
                "Iterable[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "int",
                    "float",
                    "str",
                    "List[int]",
                    "List[List[str]]"
                ]
            }
        },
        "ElmoEmbedder.batch_to_embeddings": {
            "name": "batch_to_embeddings",
            "location": 157,
            "return": [
                "tuple[]",
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "List[List[str]]",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "ElmoEmbedder.embed_sentence": {
            "name": "embed_sentence",
            "location": 187,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "ElmoEmbedder.embed_batch": {
            "name": "embed_batch",
            "location": 203,
            "return": [
                "list[]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "Union[Tuple, torch.Size]",
                    "torch.distributions.Distribution",
                    "torch.Tensor",
                    "list",
                    "int",
                    "List[List[Any]]"
                ]
            }
        },
        "ElmoEmbedder.embed_sentences": {
            "name": "embed_sentences",
            "location": 234,
            "return": [
                "typing.Iterable[numpy.ndarray]",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "int",
                    "Iterable[List[str]]",
                    "Tuple[int]",
                    "torch.Tensor"
                ],
                "batch_size": [
                    "int",
                    "Iterable[List[str]]",
                    "Tuple[int]",
                    "torch.Tensor"
                ]
            }
        },
        "ElmoEmbedder.embed_file": {
            "name": "embed_file",
            "location": 254,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_file": [
                    "str",
                    "tuple",
                    "Tuple[str, str]",
                    "Callable",
                    "set"
                ],
                "output_file_path": [
                    "str",
                    "dict"
                ],
                "output_format": [
                    "typing.Text",
                    "str",
                    "float",
                    "bool",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/evaluate.py": {
        "evaluate": {
            "name": "evaluate",
            "location": 82,
            "return": [
                "int",
                "bool",
                "str",
                "Optional[bool]",
                "Optional[BaseException]"
            ],
            "arguments": {
                "model": [
                    "Dict[str, Any]",
                    "allennlp.models.model.Model",
                    "model.batcher.QABatch",
                    "tensorflow.keras.Model",
                    "str"
                ],
                "instances": [
                    "int",
                    "peewee.Model",
                    "bool",
                    "core.models.DepositClaim"
                ],
                "data_iterator": [
                    "int",
                    "peewee.Model",
                    "bool",
                    "core.models.DepositClaim"
                ],
                "cuda_device": [
                    "int",
                    "None",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "evaluate_from_args": {
            "name": "evaluate_from_args",
            "location": 100,
            "return": [
                "str",
                "int",
                "django.db.models.QuerySet"
            ],
            "arguments": {
                "args": []
            }
        },
        "Evaluate.add_subparser": {
            "name": "add_subparser",
            "location": 50,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/fine_tune.py": {
        "fine_tune_model_from_args": {
            "name": "fine_tune_model_from_args",
            "location": 67,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "fine_tune_model_from_file_paths": {
            "name": "fine_tune_model_from_file_paths",
            "location": 78,
            "return": [
                "str",
                "bool",
                "salon.models.Stylist",
                "bytes"
            ],
            "arguments": {
                "model_archive_path": [
                    "str",
                    "bool",
                    "list",
                    "list[]",
                    "List[str]",
                    "list[str]"
                ],
                "config_file": [
                    "str",
                    "TextIO",
                    "typing.TextIO"
                ],
                "serialization_dir": [
                    "str",
                    "bool",
                    "Dict[str, str]",
                    "dict[str, str]"
                ],
                "overrides": [
                    "typing.Text",
                    "str",
                    "TextIO"
                ],
                "file_friendly_logging": [
                    "bool",
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "fine_tune_model": {
            "name": "fine_tune_model",
            "location": 113,
            "return": [
                "list[src.main.core.models.area.Area]",
                "allennlp.models.model.Model",
                "dict[str, typing.Any]",
                "float",
                "List[app.models.Question]",
                "app.models.Question"
            ],
            "arguments": {
                "model": [
                    "list[src.main.core.models.area.Area]",
                    "dict[str, typing.Any]",
                    "allennlp.models.model.Model",
                    "core.models.Recipe",
                    "timeview.gui.model.Panel",
                    "timeview.gui.model.View",
                    "salon.models.StylistService",
                    "List[src.main.core.models.area.Area]",
                    "model.predictor.PredictorModel",
                    "Dict[str, Any]"
                ],
                "params": [
                    "allennlp.common.Params",
                    "Optional[Dict]",
                    "List[str]",
                    "allennlp.common.params.Params",
                    "Dict[str, Any]",
                    "dict"
                ],
                "serialization_dir": [
                    "str",
                    "None",
                    "typing.Iterable[str]",
                    "allennlp.common.Params",
                    "Optional[str]",
                    "Union[str, os.PathLike]",
                    "Iterable[str]"
                ],
                "file_friendly_logging": [
                    "bool",
                    "Optional[str]",
                    "int",
                    "str"
                ]
            }
        },
        "FineTune.add_subparser": {
            "name": "add_subparser",
            "location": 28,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/make_vocab.py": {
        "make_vocab_from_args": {
            "name": "make_vocab_from_args",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "make_vocab_from_params": {
            "name": "make_vocab_from_params",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "params": []
            }
        },
        "MakeVocab.add_subparser": {
            "name": "add_subparser",
            "location": 39,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/predict.py": {
        "_get_predictor": {
            "name": "_get_predictor",
            "location": 101,
            "return": [
                "zerver.models.UserProfile",
                "int",
                "bytes"
            ],
            "arguments": {
                "args": []
            }
        },
        "_run": {
            "name": "_run",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "predictor": [
                    "allennlp.service.predictors.Predictor",
                    "str",
                    "int",
                    "List[str]",
                    "float",
                    "Optional[str]",
                    "Union[int, str]"
                ],
                "input_file": [
                    "list[str]",
                    "str",
                    "bool",
                    "IO",
                    "Optional[IO]",
                    "int",
                    "List[str]"
                ],
                "output_file": [
                    "bool",
                    "typing.IO",
                    "IO",
                    "str",
                    "None",
                    "Optional[IO]",
                    "list[str]",
                    "int",
                    "List[str]"
                ],
                "batch_size": [
                    "int",
                    "str",
                    "bool"
                ],
                "print_to_console": [
                    "bool",
                    "typing.IO",
                    "IO",
                    "str",
                    "None",
                    "Optional[IO]",
                    "list[str]",
                    "int",
                    "List[str]"
                ],
                "cuda_device": [
                    "bool",
                    "typing.IO",
                    "IO",
                    "str",
                    "None",
                    "Optional[IO]",
                    "list[str]",
                    "int",
                    "List[str]"
                ]
            }
        },
        "_predict": {
            "name": "_predict",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "Predict.add_subparser": {
            "name": "add_subparser",
            "location": 66,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        },
        "_run._run_predictor": {
            "name": "_run_predictor",
            "location": 125,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "batch_data": [
                    "Dict[str, Any]",
                    "bytes",
                    "Optional[Dict]",
                    "Optional[Dict[str, Any]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/serve.py": {
        "_serve": {
            "name": "_serve",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "Serve.add_subparser": {
            "name": "add_subparser",
            "location": 60,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/subcommand.py": {
        "Subcommand.add_subparser": {
            "name": "add_subparser",
            "location": 16,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "argparse._SubParsersAction"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/train.py": {
        "train_model_from_args": {
            "name": "train_model_from_args",
            "location": 91,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "train_model_from_file": {
            "name": "train_model_from_file",
            "location": 102,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "parameter_filename": [
                    "str",
                    "bool"
                ],
                "serialization_dir": [
                    "bool",
                    "str",
                    "Optional[str]"
                ],
                "overrides": [
                    "typing.Text",
                    "str",
                    "bool"
                ],
                "file_friendly_logging": [
                    "bool",
                    "str",
                    "Optional[str]"
                ],
                "recover": [
                    "bool",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "datasets_from_params": {
            "name": "datasets_from_params",
            "location": 132,
            "return": [
                "dict[typing.Text, ]",
                "float",
                "Sequence[float]",
                "Tuple[int, int]",
                "tuple"
            ],
            "arguments": {
                "params": [
                    "logging.LogRecord",
                    "Union[object, type]"
                ]
            }
        },
        "create_serialization_dir": {
            "name": "create_serialization_dir",
            "location": 164,
            "return": [
                "None",
                "str",
                "Dict[str, Any]",
                "Union[tuple, list]"
            ],
            "arguments": {
                "params": [
                    "str",
                    "dict",
                    "Dict[str, str]",
                    "bool",
                    "TextIO"
                ],
                "serialization_dir": [
                    "str",
                    "Union[str, os.PathLike]"
                ],
                "recover": [
                    "bool",
                    "zerver.models.Realm",
                    "str"
                ]
            }
        },
        "train_model": {
            "name": "train_model",
            "location": 226,
            "return": [
                "allennlp.models.model.Model",
                "List[app.models.Question]",
                "app.models.Question"
            ],
            "arguments": {
                "params": [
                    "allennlp.common.Params",
                    "bytes",
                    "Optional[Callable[[List, bool], None]]",
                    "bool"
                ],
                "serialization_dir": [
                    "str",
                    "bool"
                ],
                "file_friendly_logging": [
                    "bool",
                    "str",
                    "Dict[str, bytes]",
                    "Dict[str, 'LabwareDefinition']"
                ],
                "recover": [
                    "bool",
                    "str"
                ]
            }
        },
        "Train.add_subparser": {
            "name": "add_subparser",
            "location": 58,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/commands/__init__.py": {
        "main": {
            "name": "main",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "prog": [
                    "str",
                    "None",
                    "List[str]",
                    "list[str]"
                ],
                "subcommand_overrides": [
                    "dict[, ]",
                    "str",
                    "List[str]",
                    "bool",
                    "int",
                    "Optional[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/checks.py": {
        "log_pytorch_version_info": {
            "name": "log_pytorch_version_info",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "check_dimensions_match": {
            "name": "check_dimensions_match",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "dimension_1": [
                    "int"
                ],
                "dimension_2": [
                    "int"
                ],
                "dim_1_name": [
                    "str"
                ],
                "dim_2_name": [
                    "str"
                ]
            }
        },
        "ConfigurationError.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ConfigurationError.__str__": {
            "name": "__str__",
            "location": 20,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/file_utils.py": {
        "url_to_filename": {
            "name": "url_to_filename",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "url": [
                    "str"
                ],
                "etag": [
                    "str"
                ]
            }
        },
        "filename_to_url": {
            "name": "filename_to_url",
            "location": 40,
            "return": [
                "Tuple[(str, str)]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "cached_path": {
            "name": "cached_path",
            "location": 56,
            "return": [
                "str"
            ],
            "arguments": {
                "url_or_filename": [
                    "str"
                ],
                "cache_dir": [
                    "str"
                ]
            }
        },
        "get_from_cache": {
            "name": "get_from_cache",
            "location": 83,
            "return": [
                "str"
            ],
            "arguments": {
                "url": [
                    "str"
                ],
                "cache_dir": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/params.py": {
        "pop_choice": {
            "name": "pop_choice",
            "location": 295,
            "return": [],
            "arguments": {
                "params": [
                    "Dict[(str, Any)]"
                ],
                "key": [
                    "str"
                ],
                "choices": [
                    "list"
                ],
                "default_to_first_choice": [
                    "bool"
                ],
                "history": [
                    "str"
                ]
            }
        },
        "_replace_none": {
            "name": "_replace_none",
            "location": 314,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "dictionary": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "Params.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "Dict[(str, Any)]"
                ],
                "history": [
                    "str"
                ],
                "loading_from_archive": [
                    "bool"
                ],
                "files_to_archive": [
                    "Dict[(str, str)]"
                ]
            }
        },
        "Params.add_file_to_archive": {
            "name": "add_file_to_archive",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Params.pop": {
            "name": "pop",
            "location": 85,
            "return": [],
            "arguments": {
                "self": [],
                "key": [],
                "default": []
            }
        },
        "Params.pop_int": {
            "name": "pop_int",
            "location": 104,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": []
            }
        },
        "Params.pop_float": {
            "name": "pop_float",
            "location": 114,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": []
            }
        },
        "Params.pop_bool": {
            "name": "pop_bool",
            "location": 124,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "default": []
            }
        },
        "Params.get": {
            "name": "get",
            "location": 141,
            "return": [],
            "arguments": {
                "self": [],
                "key": [],
                "default": []
            }
        },
        "Params.pop_choice": {
            "name": "pop_choice",
            "location": 155,
            "return": [],
            "arguments": {
                "self": [],
                "key": [
                    "str"
                ],
                "choices": [
                    "list"
                ],
                "default_to_first_choice": [
                    "bool"
                ]
            }
        },
        "Params.as_dict": {
            "name": "as_dict",
            "location": 187,
            "return": [],
            "arguments": {
                "self": [],
                "quiet": [
                    "bool"
                ]
            }
        },
        "Params.as_flat_dict": {
            "name": "as_flat_dict",
            "location": 215,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Params.duplicate": {
            "name": "duplicate",
            "location": 232,
            "return": [
                "Params"
            ],
            "arguments": {
                "self": [
                    "_TParams"
                ]
            }
        },
        "Params.assert_empty": {
            "name": "assert_empty",
            "location": 239,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "class_name": [
                    "str"
                ]
            }
        },
        "Params.__getitem__": {
            "name": "__getitem__",
            "location": 249,
            "return": [],
            "arguments": {
                "self": [],
                "key": []
            }
        },
        "Params.__setitem__": {
            "name": "__setitem__",
            "location": 255,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [],
                "value": []
            }
        },
        "Params.__delitem__": {
            "name": "__delitem__",
            "location": 258,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "key": []
            }
        },
        "Params.__iter__": {
            "name": "__iter__",
            "location": 261,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Params.__len__": {
            "name": "__len__",
            "location": 264,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Params._check_is_dict": {
            "name": "_check_is_dict",
            "location": 267,
            "return": [
                "Params",
                "dict[, ]",
                "list[]"
            ],
            "arguments": {
                "self": [],
                "new_history": [],
                "value": []
            }
        },
        "Params.from_file": {
            "name": "from_file",
            "location": 279,
            "return": [
                "Params"
            ],
            "arguments": {
                "params_file": [
                    "str"
                ],
                "params_overrides": [
                    "str"
                ]
            }
        },
        "Params.as_dict.log_recursively": {
            "name": "log_recursively",
            "location": 200,
            "return": [
                "None"
            ],
            "arguments": {
                "parameters": [],
                "history": []
            }
        },
        "Params.as_flat_dict.recurse": {
            "name": "recurse",
            "location": 221,
            "return": [
                "None"
            ],
            "arguments": {
                "parameters": [],
                "path": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/registrable.py": {
        "Registrable.register": {
            "name": "register",
            "location": 41,
            "return": [
                "bool",
                "float",
                "int",
                "Optional[float]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "Type[T]",
                    "typing.Type"
                ],
                "name": [
                    "str",
                    "bool",
                    "Type[T]",
                    "typing.Type"
                ]
            }
        },
        "Registrable.by_name": {
            "name": "by_name",
            "location": 54,
            "return": [
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "name": [
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "Registrable.list_available": {
            "name": "list_available",
            "location": 60,
            "return": [
                "list[]",
                "list[typing.Union[str,dict[str, typing.Any],tuple[],int,tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]],list[list[str]],dict[str, dict[str, typing.Any]]]]",
                "List[str]",
                "Set[str]",
                "str",
                "Dict[str, str]",
                "Optional[List[str]]",
                "Mapping[str, str]",
                "tuple"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "Registrable.register.add_subclass_to_registry": {
            "name": "add_subclass_to_registry",
            "location": 43,
            "return": [
                "str",
                "Tuple[int, int]"
            ],
            "arguments": {
                "subclass": [
                    "Type[T]",
                    "str",
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/squad_eval.py": {
        "normalize_answer": {
            "name": "normalize_answer",
            "location": 12,
            "return": [
                "str"
            ],
            "arguments": {
                "s": [
                    "str"
                ]
            }
        },
        "f1_score": {
            "name": "f1_score",
            "location": 30,
            "return": [
                "Union[(float, int)]"
            ],
            "arguments": {
                "prediction": [
                    "str",
                    "float",
                    "Optional[str]",
                    "None",
                    "list",
                    "list[]",
                    "List[str]",
                    "list[str]"
                ],
                "ground_truth": [
                    "str",
                    "float",
                    "bytes",
                    "list",
                    "list[]"
                ]
            }
        },
        "exact_match_score": {
            "name": "exact_match_score",
            "location": 43,
            "return": [
                "bool",
                "str",
                "Callable[[str], bool]",
                "re.Match[str]"
            ],
            "arguments": {
                "prediction": [
                    "Callable[[T], bool]",
                    "typing.Callable[T, bool]",
                    "Iterable[T]",
                    "typing.Iterable[T]"
                ],
                "ground_truth": [
                    "Callable[[T], bool]",
                    "typing.Callable[T, bool]",
                    "Iterable[T]",
                    "typing.Iterable[T]"
                ]
            }
        },
        "metric_max_over_ground_truths": {
            "name": "metric_max_over_ground_truths",
            "location": 47,
            "return": [
                "list[list[]]",
                "bool",
                "str",
                "Union[str, Pattern]",
                "int",
                "Optional[int]",
                "List[str]"
            ],
            "arguments": {
                "metric_fn": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "prediction": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "ground_truths": [
                    "str",
                    "int",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "evaluate": {
            "name": "evaluate",
            "location": 55,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "int",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "predictions": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "normalize_answer.remove_articles": {
            "name": "remove_articles",
            "location": 14,
            "return": [
                "str"
            ],
            "arguments": {
                "text": [
                    "str",
                    "int"
                ]
            }
        },
        "normalize_answer.white_space_fix": {
            "name": "white_space_fix",
            "location": 17,
            "return": [
                "str",
                "bool",
                "List[str]",
                "Exception"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        },
        "normalize_answer.remove_punc": {
            "name": "remove_punc",
            "location": 20,
            "return": [
                "str",
                "list",
                "List[str]",
                "Optional[dict]",
                "int",
                "List[Dict[str, Any]]",
                "frozenset"
            ],
            "arguments": {
                "text": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "normalize_answer.lower": {
            "name": "lower",
            "location": 24,
            "return": [
                "str"
            ],
            "arguments": {
                "text": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/tee_logger.py": {
        "replace_cr_with_newline": {
            "name": "replace_cr_with_newline",
            "location": 8,
            "return": [
                "str"
            ],
            "arguments": {
                "message": [
                    "str"
                ]
            }
        },
        "TeeLogger.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str"
                ],
                "terminal": [
                    "TextIO"
                ],
                "file_friendly_terminal_output": [
                    "bool"
                ]
            }
        },
        "TeeLogger.write": {
            "name": "write",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "bytes",
                    "str",
                    "Callable[[bytes], bytes]",
                    "typing.Callable[bytes, bytes]"
                ]
            }
        },
        "TeeLogger.flush": {
            "name": "flush",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/tqdm.py": {
        "Tqdm.set_default_mininterval": {
            "name": "set_default_mininterval",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "float"
                ]
            }
        },
        "Tqdm.set_slower_interval": {
            "name": "set_slower_interval",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "use_slower_interval": [
                    "bool"
                ]
            }
        },
        "Tqdm.tqdm": {
            "name": "tqdm",
            "location": 30,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {}
        }
    },
    "allennlp-dureader-master/allennlp/common/util.py": {
        "sanitize": {
            "name": "sanitize",
            "location": 31,
            "return": [
                "str",
                "dict[, ]",
                "int",
                "list[]",
                "Tuple[float, float, float]",
                "typing.Text"
            ],
            "arguments": {
                "x": [
                    "int",
                    "Iterable[T]",
                    "numpy.ndarray"
                ]
            }
        },
        "group_by_count": {
            "name": "group_by_count",
            "location": 61,
            "return": [
                "List[list]"
            ],
            "arguments": {
                "iterable": [
                    "list"
                ],
                "count": [
                    "int"
                ],
                "default_value": [
                    "list",
                    "int",
                    "List[str]"
                ]
            }
        },
        "lazy_groups_of": {
            "name": "lazy_groups_of",
            "location": 77,
            "return": [
                "Iterator[List[A]]"
            ],
            "arguments": {
                "iterator": [
                    "Iterator[A]"
                ],
                "group_size": [
                    "int"
                ]
            }
        },
        "pad_sequence_to_length": {
            "name": "pad_sequence_to_length",
            "location": 84,
            "return": [
                "list"
            ],
            "arguments": {
                "sequence": [
                    "list"
                ],
                "desired_length": [
                    "int"
                ],
                "default_value": [
                    "Callable[([], Any)]"
                ],
                "padding_on_right": [
                    "bool"
                ]
            }
        },
        "add_noise_to_dict_values": {
            "name": "add_noise_to_dict_values",
            "location": 128,
            "return": [
                "Dict[(A, float)]"
            ],
            "arguments": {
                "dictionary": [
                    "Dict[(A, float)]"
                ],
                "noise_param": [
                    "float"
                ]
            }
        },
        "namespace_match": {
            "name": "namespace_match",
            "location": 142,
            "return": [
                "bool"
            ],
            "arguments": {
                "pattern": [
                    "str"
                ],
                "namespace": [
                    "str"
                ]
            }
        },
        "prepare_environment": {
            "name": "prepare_environment",
            "location": 155,
            "return": [
                "None"
            ],
            "arguments": {
                "params": [
                    "allennlp.common.params.Params"
                ]
            }
        },
        "prepare_global_logging": {
            "name": "prepare_global_logging",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "serialization_dir": [
                    "str"
                ],
                "file_friendly_logging": [
                    "bool"
                ]
            }
        },
        "get_spacy_model": {
            "name": "get_spacy_model",
            "location": 218,
            "return": [
                "bytes",
                "dict",
                "Dict[str, Any]",
                "Callable"
            ],
            "arguments": {
                "spacy_model_name": [
                    "str"
                ],
                "pos_tags": [
                    "bool"
                ],
                "parse": [
                    "bool"
                ],
                "ner": [
                    "bool"
                ]
            }
        },
        "import_submodules": {
            "name": "import_submodules",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {
                "package_name": [
                    "str"
                ]
            }
        },
        "peak_memory_mb": {
            "name": "peak_memory_mb",
            "location": 260,
            "return": [
                "float"
            ],
            "arguments": {}
        },
        "gpu_memory_mb": {
            "name": "gpu_memory_mb",
            "location": 285,
            "return": [
                "Dict[(int, int)]"
            ],
            "arguments": {}
        },
        "ensure_list": {
            "name": "ensure_list",
            "location": 314,
            "return": [
                "List[A]"
            ],
            "arguments": {
                "iterable": [
                    "Iterable[A]"
                ]
            }
        },
        "is_lazy": {
            "name": "is_lazy",
            "location": 324,
            "return": [
                "bool"
            ],
            "arguments": {
                "iterable": [
                    "Iterable[A]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/__init__.py": {},
    "allennlp-dureader-master/allennlp/common/testing/model_test_case.py": {
        "ModelTestCase.set_up_model": {
            "name": "set_up_model",
            "location": 20,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "param_file": [
                    "str",
                    "Callable[[float], None]"
                ],
                "dataset_file": [
                    "int",
                    "apps.common.coininfo.CoinInfo",
                    "str",
                    "List[str]",
                    "TextIO",
                    "tuple",
                    "Tuple[int, int]",
                    "bool",
                    "float"
                ]
            }
        },
        "ModelTestCase.ensure_model_can_train_save_and_load": {
            "name": "ensure_model_can_train_save_and_load",
            "location": 37,
            "return": [
                "bool",
                "str",
                "torch.optim.Optimizer",
                "Model"
            ],
            "arguments": {
                "self": [],
                "param_file": [
                    "str"
                ],
                "tolerance": [
                    "List[Dict[str, str]]",
                    "list",
                    "str",
                    "int",
                    "bool"
                ],
                "cuda_device": [
                    "str",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "ModelTestCase.assert_fields_equal": {
            "name": "assert_fields_equal",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field1": [
                    "str",
                    "Type['Model']"
                ],
                "field2": [
                    "str",
                    "bool"
                ],
                "name": [
                    "str",
                    "type",
                    "Optional[str]"
                ],
                "tolerance": [
                    "str",
                    "type",
                    "Optional[str]"
                ]
            }
        },
        "ModelTestCase.check_model_computes_gradients_correctly": {
            "name": "check_model_computes_gradients_correctly",
            "location": 132,
            "return": [
                ""
            ],
            "arguments": {
                "model": [
                    "torch.nn.Module",
                    "allennlp.models.model.Model",
                    "List[Dict]"
                ],
                "model_batch": [
                    "Type[T]",
                    "Model",
                    "models.cf_recommend_models.ICfRecommendationModel",
                    "List[Tuple[int, int, float]]",
                    "allennlp.models.Model",
                    "Type[abilian.core.models.Model]"
                ]
            }
        },
        "ModelTestCase.ensure_batch_predictions_are_consistent": {
            "name": "ensure_batch_predictions_are_consistent",
            "location": 155,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/testing/test_case.py": {
        "AllenNlpTestCase.setUp": {
            "name": "setUp",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AllenNlpTestCase.tearDown": {
            "name": "tearDown",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/common/testing/__init__.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/build.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/__init__.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/_ext/__init__.py": {},
    "allennlp-dureader-master/allennlp/custom_extensions/_ext/highway_lstm_layer/__init__.py": {
        "_import_symbols": {
            "name": "_import_symbols",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "locals": [
                    "str",
                    "bool",
                    "List[str]",
                    "list[str]",
                    "Optional[int]",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset.py": {
        "Batch.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "Pattern",
                    "typing.Pattern"
                ]
            }
        },
        "Batch._check_types": {
            "name": "_check_types",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 45,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.as_tensor_dict": {
            "name": "as_tensor_dict",
            "location": 70,
            "return": [
                "dict[typing.Union[tuple[typing.Union[str,list[]]],tuple[typing.Union[str,list[typing.Callable[, ]]]],tuple[typing.Union[str,list[dict[, ]]]]], ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "None",
                    "int",
                    "Optional[int]",
                    "bool"
                ],
                "cuda_device": [
                    "int",
                    "dict",
                    "Dict[str, Any]",
                    "Optional[str]"
                ],
                "for_training": [
                    "bool",
                    "dict",
                    "Dict[str, Any]",
                    "int",
                    "Optional[str]"
                ],
                "verbose": [
                    "bool",
                    "Dict[str, int]",
                    "int",
                    "str"
                ]
            }
        },
        "Batch.__iter__": {
            "name": "__iter__",
            "location": 158,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Batch.index_instances": {
            "name": "index_instances",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/instance.py": {
        "Instance.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fields": [
                    "int",
                    "List[int]",
                    "str",
                    "list[int]",
                    "frozenset",
                    "dict",
                    "dict[, ]",
                    "AbstractSet[str]",
                    "typing.AbstractSet"
                ]
            }
        },
        "Instance.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "dict[str, dict[str, int]]",
                    "str",
                    "Dict[str, Dict[str, int]]",
                    "Dict[str, Any]",
                    "allennlp.data.vocabulary.Vocabulary"
                ]
            }
        },
        "Instance.index_fields": {
            "name": "index_fields",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "dict[str, dict[str, int]]",
                    "str",
                    "allennlp.data.vocabulary.Vocabulary",
                    "Dict[str, Dict[str, int]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Instance.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 52,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Instance.as_tensor_dict": {
            "name": "as_tensor_dict",
            "location": 62,
            "return": [
                "dict[, ]",
                "bool",
                "dict",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "int",
                    "None",
                    "str",
                    "Optional[str]",
                    "float"
                ],
                "cuda_device": [
                    "int",
                    "dict",
                    "bool",
                    "list"
                ],
                "for_training": [
                    "bool",
                    "dict",
                    "int",
                    "list"
                ]
            }
        },
        "Instance.__str__": {
            "name": "__str__",
            "location": 83,
            "return": [
                "str",
                "int",
                "dict",
                "Iterable[str]",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/vocabulary.py": {
        "_read_pretrained_words": {
            "name": "_read_pretrained_words",
            "location": 94,
            "return": [
                "set[]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str",
                    "bool",
                    "List[int]"
                ]
            }
        },
        "_NamespaceDependentDefaultDict.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "non_padded_namespaces": [
                    "bool",
                    "str",
                    "bytes"
                ],
                "padded_function": [
                    "bool",
                    "str",
                    "bytes"
                ],
                "non_padded_function": [
                    "bool",
                    "str",
                    "bytes"
                ]
            }
        },
        "_NamespaceDependentDefaultDict.__missing__": {
            "name": "__missing__",
            "location": 72,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "int",
                    "bytes"
                ]
            }
        },
        "_TokenToIndexDefaultDict.__init__": {
            "name": "__init__",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "non_padded_namespaces": [
                    "bool",
                    "Optional[str]",
                    "app.domain.common.TimeWindow"
                ],
                "padding_token": [
                    "bool",
                    "Optional[str]",
                    "app.domain.common.TimeWindow"
                ],
                "oov_token": [
                    "bool",
                    "Optional[str]",
                    "app.domain.common.TimeWindow"
                ]
            }
        },
        "_IndexToTokenDefaultDict.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "non_padded_namespaces": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ],
                "padding_token": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ],
                "oov_token": [
                    "Dict[str, Any]",
                    "str",
                    "dict"
                ]
            }
        },
        "Vocabulary.__init__": {
            "name": "__init__",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "None",
                    "Optional[int]",
                    "Optional[Dict[Any, Any]]",
                    "Optional[static_frame.core.util.DepthLevelSpecifier]",
                    "Optional[float]",
                    "Optional[str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[List[str]]"
                ],
                "min_count": [
                    "None",
                    "int",
                    "dict",
                    "List[str]",
                    "Dict[str, int]"
                ],
                "max_vocab_size": [
                    "None",
                    "int",
                    "Union[int, Dict[str, int]]",
                    "Dict[str, int]",
                    "float",
                    "Iterable[str]"
                ],
                "non_padded_namespaces": [
                    "tuple[typing.Text]",
                    "Optional[bool]",
                    "List[str]"
                ],
                "pretrained_files": [
                    "None",
                    "bool",
                    "str"
                ],
                "only_include_pretrained_words": [
                    "bool",
                    "str"
                ]
            }
        },
        "Vocabulary.save_to_files": {
            "name": "save_to_files",
            "location": 207,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "directory": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Vocabulary.from_files": {
            "name": "from_files",
            "location": 234,
            "return": [
                "str",
                "Vocabulary"
            ],
            "arguments": {
                "cls": [
                    "Iterable[str]",
                    "bool",
                    "str",
                    "Iterable",
                    "Set[str]"
                ],
                "directory": [
                    "str",
                    "Mapping[str, str]"
                ]
            }
        },
        "Vocabulary.set_from_file": {
            "name": "set_from_file",
            "location": 263,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "is_padded": [
                    "bool",
                    "IO",
                    "int",
                    "Tuple[int, int, int]",
                    "str"
                ],
                "oov_token": [
                    "str",
                    "bool"
                ],
                "namespace": [
                    "typing.Text",
                    "Optional[bool]",
                    "bool",
                    "str",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "Vocabulary.from_instances": {
            "name": "from_instances",
            "location": 316,
            "return": [
                "dict",
                "Vocabulary"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "int"
                ],
                "instances": [
                    "Iterable['adi.Instance']",
                    "bool",
                    "int",
                    "Exception"
                ],
                "min_count": [
                    "None",
                    "Dict[str, int]",
                    "Iterable[str]",
                    "Union[int, Dict[str, int]]",
                    "Dict[str, List[str]]",
                    "bool",
                    "Optional[Dict[str, str]]",
                    "int",
                    "float"
                ],
                "max_vocab_size": [
                    "None",
                    "Dict[str, int]",
                    "Iterable[str]",
                    "Union[int, Dict[str, int]]",
                    "Dict[str, List[str]]",
                    "bool",
                    "Optional[Dict[str, str]]",
                    "int",
                    "float"
                ],
                "non_padded_namespaces": [
                    "tuple[typing.Text]",
                    "Dict[str, int]",
                    "Iterable[str]",
                    "Union[int, Dict[str, int]]",
                    "Dict[str, List[str]]",
                    "bool",
                    "Optional[Dict[str, str]]",
                    "int",
                    "float"
                ],
                "pretrained_files": [
                    "None",
                    "Dict[str, int]",
                    "Iterable[str]",
                    "Union[int, Dict[str, int]]",
                    "Dict[str, List[str]]",
                    "bool",
                    "Optional[Dict[str, str]]",
                    "int",
                    "float"
                ],
                "only_include_pretrained_words": [
                    "bool",
                    "Dict[str, int]",
                    "Iterable[str]",
                    "Union[int, Dict[str, int]]",
                    "Dict[str, List[str]]",
                    "Optional[Dict[str, str]]",
                    "int",
                    "float"
                ]
            }
        },
        "Vocabulary.from_params": {
            "name": "from_params",
            "location": 342,
            "return": [
                "IO[bytes]",
                "bool",
                "Callable"
            ],
            "arguments": {
                "cls": [
                    "cdp.util.T_JSON_DICT",
                    "allennlp.data.Vocabulary",
                    "int",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "bool",
                    "Dict[str, Any]",
                    "Callable[..., None]",
                    "int",
                    "Dict[str, str]"
                ],
                "instances": [
                    "None",
                    "int",
                    "bool",
                    "Tuple[List[str], List[str], List[str]]"
                ]
            }
        },
        "Vocabulary.add_token_to_namespace": {
            "name": "add_token_to_namespace",
            "location": 385,
            "return": [
                "int",
                "str",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str",
                    "Union[str, List]"
                ],
                "namespace": [
                    "typing.Text",
                    "List[allennlp.data.tokenizers.Token]",
                    "dict",
                    "int"
                ]
            }
        },
        "Vocabulary.get_index_to_token_vocabulary": {
            "name": "get_index_to_token_vocabulary",
            "location": 401,
            "return": [
                "int",
                "List[str]",
                "Dict[str, Any]",
                "bool",
                "Dict[str, digipathos.data.dataseDataset]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "str",
                    "int",
                    "bool",
                    "list"
                ]
            }
        },
        "Vocabulary.get_token_index": {
            "name": "get_token_index",
            "location": 404,
            "return": [
                "bytes",
                "Optional[str]",
                "Optional[bool]",
                "Dict[str, Dict[str, Any]]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "namespace": [
                    "str",
                    "typing.Text"
                ]
            }
        },
        "Vocabulary.get_token_from_index": {
            "name": "get_token_from_index",
            "location": 415,
            "return": [
                "dict",
                "str",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "dict",
                    "str"
                ],
                "namespace": [
                    "typing.Text",
                    "dict",
                    "str"
                ]
            }
        },
        "Vocabulary.get_vocab_size": {
            "name": "get_vocab_size",
            "location": 418,
            "return": [
                "int",
                "str",
                "bool",
                "Optional[str]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "List[str]",
                    "str",
                    "Callable",
                    "int"
                ]
            }
        },
        "Vocabulary.__eq__": {
            "name": "__eq__",
            "location": 421,
            "return": [
                "bool",
                "Dict[str, Any]",
                "Mapping",
                "Dict[str, Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Vocabulary.__str__": {
            "name": "__str__",
            "location": 426,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/conll2003.py": {
        "_is_divider": {
            "name": "_is_divider",
            "location": 19,
            "return": [
                "bool"
            ],
            "arguments": {
                "line": [
                    "str"
                ]
            }
        },
        "Conll2003DatasetReader.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "bool",
                    "None",
                    "Dict[int, Set[int]]",
                    "str",
                    "List[str]",
                    "dict[int, set[int]]",
                    "Optional[bool]",
                    "list[str]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "dict[str, tuple[typing.Union[str,str,typing.Any]]]"
                ],
                "tag_label": [
                    "typing.Text",
                    "str",
                    "bool"
                ],
                "feature_labels": [
                    "tuple[]",
                    "str",
                    "int",
                    "List[str]",
                    "list",
                    "List[Dict[str, Any]]",
                    "bool"
                ],
                "lazy": [
                    "bool"
                ],
                "coding_scheme": [
                    "str",
                    "typing.Text"
                ]
            }
        },
        "Conll2003DatasetReader._read": {
            "name": "_read",
            "location": 96,
            "return": [
                "typing.Iterable[allennlp.data.instance.Instance]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Conll2003DatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 144,
            "return": [
                "Instance",
                "str",
                "List[str]",
                "list",
                "Mapping[str, Sequence[Any]]",
                "Set[str]",
                "Dict[str, List[str]]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str",
                    "int",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "Conll2003DatasetReader.from_params": {
            "name": "from_params",
            "location": 152,
            "return": [
                "Conll2003DatasetReader"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "dict[, ]",
                    "str",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_reader.py": {
        "_LazyInstances.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "instance_generator": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "_LazyInstances.__iter__": {
            "name": "__iter__",
            "location": 20,
            "return": [
                "int",
                "float",
                "Iterable[str]",
                "list[]",
                "list[typing.Callable[[], bool]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetReader.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "DatasetReader.read": {
            "name": "read",
            "location": 45,
            "return": [
                "List[str]",
                "int",
                "_LazyInstances",
                "list[]",
                "typing.Sequence[list[typing.Any]]",
                "str",
                "float",
                "list[typing.Iterator]",
                "typing.Type",
                "list[typing.Callable[[], typing.Any]]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "DatasetReader._read": {
            "name": "_read",
            "location": 79,
            "return": [
                "typing.Iterable[allennlp.data.instance.Instance]",
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "list",
                    "list[]"
                ]
            }
        },
        "DatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 88,
            "return": [
                "allennlp.data.instance.Instance",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetReader.from_params": {
            "name": "from_params",
            "location": 108,
            "return": [
                "str",
                "List[int]",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict"
                ],
                "params": [
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/language_modeling.py": {
        "LanguageModelingReader.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokens_per_instance": [
                    "List[int]",
                    "str",
                    "List[Dict[str, Any]]",
                    "List[str]",
                    "Dict[type, Any]",
                    "bool"
                ],
                "tokenizer": [
                    "int",
                    "Sequence[int]",
                    "str",
                    "Sequence[T]",
                    "bytes",
                    "List[int]"
                ],
                "token_indexers": [
                    "int",
                    "bytes",
                    "Optional[str]",
                    "dict",
                    "bool"
                ],
                "lazy": [
                    "bool",
                    "int",
                    "Optional[bool]"
                ]
            }
        },
        "LanguageModelingReader._read": {
            "name": "_read",
            "location": 68,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "LanguageModelingReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 93,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str",
                    "Tuple[str, str, str, str, str, str]"
                ]
            }
        },
        "LanguageModelingReader.from_params": {
            "name": "from_params",
            "location": 101,
            "return": [
                "dict"
            ],
            "arguments": {
                "cls": [
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "dict",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/penn_tree_bank.py": {
        "PennTreeBankConstituencySpanDatasetReader.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "None",
                    "bool",
                    "Type[MutableMapping[Any, Any]]",
                    "List[str]"
                ],
                "use_pos_tags": [
                    "bool",
                    "List[Dict[str, Any]]",
                    "Optional[str]",
                    "int",
                    "Iterator[Any]",
                    "Dict[str, object]",
                    "Sequence[sensibility.lexical_analysis.Token]",
                    "Set[VT]"
                ],
                "lazy": [
                    "bool",
                    "float"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader._read": {
            "name": "_read",
            "location": 53,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 69,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[allennlp.data.tokenizers.Token]",
                    "List[List[str]]",
                    "List[str]",
                    "str",
                    "list"
                ],
                "pos_tags": [
                    "None",
                    "List[str]",
                    "bool",
                    "Dict[str, str]",
                    "List[Dict[str, str]]"
                ],
                "gold_tree": [
                    "None",
                    "str",
                    "nltk.tree.Tree",
                    "Optional[str]",
                    "List[str]",
                    "Optional[Dict]",
                    "bool"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader._strip_functional_tags": {
            "name": "_strip_functional_tags",
            "location": 146,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "str",
                    "nltk.tree.Tree"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader._get_gold_spans": {
            "name": "_get_gold_spans",
            "location": 160,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "nltk.tree.Tree",
                    "str",
                    "Optional[Mapping[str, Any]]"
                ],
                "index": [
                    "List[str]",
                    "list",
                    "List[Tuple[str, ...]]",
                    "List[OrderedDict]"
                ],
                "typed_spans": [
                    "str",
                    "float",
                    "int",
                    "List[str]",
                    "Sequence"
                ]
            }
        },
        "PennTreeBankConstituencySpanDatasetReader.from_params": {
            "name": "from_params",
            "location": 223,
            "return": [
                "PennTreeBankConstituencySpanDatasetReader",
                "bytes",
                "Set[str]",
                "int"
            ],
            "arguments": {
                "cls": [
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/semantic_role_labeling.py": {
        "SrlReader.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "bool",
                    "None",
                    "int",
                    "dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "list[str]",
                    "List[str]",
                    "typing.Mapping",
                    "Optional[Mapping[str, Any]]",
                    "Optional[bool]"
                ],
                "domain_identifier": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Optional[str]",
                    "bool"
                ],
                "lazy": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "SrlReader._read": {
            "name": "_read",
            "location": 56,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SrlReader._ontonotes_subset": {
            "name": "_ontonotes_subset",
            "location": 77,
            "return": [
                "typing.Iterable[allennlp.data.dataset_readers.dataset_utils.OntonotesSentence]",
                "typing.Generator[]"
            ],
            "arguments": {
                "ontonotes_reader": [
                    "allennlp.data.dataset_readers.dataset_utils.Ontonotes",
                    "str"
                ],
                "file_path": [
                    "str"
                ],
                "domain_identifier": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Optional[Union[Any, Any]]",
                    "typing.Any"
                ]
            }
        },
        "SrlReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 89,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str",
                    "int",
                    "float",
                    "Optional[str]",
                    "None"
                ],
                "verb_label": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "str",
                    "List[Tuple[int, int]]",
                    "list[tuple[typing.Union[int,int]]]",
                    "Tuple[str, int]",
                    "tuple[typing.Union[str,int]]",
                    "Counter[int]",
                    "typing.Counter"
                ],
                "tags": [
                    "List[str]",
                    "None",
                    "list[str]"
                ]
            }
        },
        "SrlReader.from_params": {
            "name": "from_params",
            "location": 108,
            "return": [
                "dict",
                "SrlReader"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/seq2seq.py": {
        "Seq2SeqDatasetReader.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "source_tokenizer": [
                    "Optional[int]",
                    "None",
                    "bool",
                    "int"
                ],
                "target_tokenizer": [
                    "str",
                    "None",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "source_token_indexers": [
                    "bool",
                    "None",
                    "str",
                    "Optional[str]",
                    "bytes",
                    "Callable[[], str]",
                    "typing.Callable[[], str]",
                    "Optional[Dict]",
                    "dict[, ]"
                ],
                "target_token_indexers": [
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "None",
                    "str",
                    "dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "float",
                    "Optional[str]",
                    "bool",
                    "TextIO",
                    "typing.TextIO"
                ],
                "source_add_start_token": [
                    "bool",
                    "int",
                    "Optional[float]"
                ],
                "lazy": [
                    "bool",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "Seq2SeqDatasetReader._read": {
            "name": "_read",
            "location": 66,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Seq2SeqDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 82,
            "return": [
                "Instance",
                "str",
                "list"
            ],
            "arguments": {
                "self": [],
                "source_string": [
                    "str",
                    "int",
                    "Dict[int, int]",
                    "dict[int, int]"
                ],
                "target_string": [
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        },
        "Seq2SeqDatasetReader.from_params": {
            "name": "from_params",
            "location": 99,
            "return": [
                "Seq2SeqDatasetReader"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "allennlp.common.Params",
                    "Dict[str, Any]",
                    "Union[object, type]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/sequence_tagging.py": {
        "SequenceTaggingDatasetReader.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "word_tag_delimiter": [
                    "typing.Text",
                    "str",
                    "Optional[str]",
                    "bool",
                    "Sequence[str]",
                    "List[str]"
                ],
                "token_delimiter": [
                    "Optional[str]",
                    "None",
                    "bool",
                    "str",
                    "List[str]",
                    "Sequence",
                    "list[str]",
                    "int",
                    "typing.Sequence[]"
                ],
                "token_indexers": [
                    "bool",
                    "None",
                    "str",
                    "List[str]",
                    "Dict[Tuple[str, str], Exception]",
                    "list[str]",
                    "Optional[Dict[str, Any]]",
                    "dict[tuple[typing.Union[str,str]], Exception]",
                    "dict[str, typing.Any]"
                ],
                "lazy": [
                    "bool",
                    "int"
                ]
            }
        },
        "SequenceTaggingDatasetReader._read": {
            "name": "_read",
            "location": 51,
            "return": [
                "",
                "typing.Generator[Instance]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SequenceTaggingDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 75,
            "return": [
                "Instance",
                "str",
                "List[str]",
                "list",
                "Mapping[str, Sequence[Any]]",
                "Set[str]",
                "Dict[str, List[str]]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str",
                    "int",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "SequenceTaggingDatasetReader.from_params": {
            "name": "from_params",
            "location": 83,
            "return": [
                "SequenceTaggingDatasetReader",
                "bytes",
                "Mapping[str, Any]",
                "Dict[str, str]",
                "Dict[int, Dict[int, Any]]"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/snli.py": {
        "SnliReader.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokenizer": [
                    "List[Tuple[int, int]]",
                    "None",
                    "Tuple[int, int]",
                    "list[tuple[typing.Union[int,int]]]",
                    "str",
                    "List[int]",
                    "tuple[typing.Union[int,int]]",
                    "list[int]",
                    "Iterable[str]"
                ],
                "token_indexers": [
                    "bool",
                    "None",
                    "Callable",
                    "int",
                    "typing.Callable[, ]"
                ],
                "lazy": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "SnliReader._read": {
            "name": "_read",
            "location": 43,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SnliReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 64,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "premise": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "Tuple[str, str, str, str, str, str, str]",
                    "tuple[typing.Union[str,str,str,str,str,str,str]]",
                    "list",
                    "list[]"
                ],
                "hypothesis": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "Tuple[str, str, str, str, str, str, str]",
                    "tuple[typing.Union[str,str,str,str,str,str,str]]",
                    "list",
                    "list[]"
                ],
                "label": [
                    "str",
                    "None",
                    "List[str]",
                    "Set[str]",
                    "list[str]",
                    "List[int]",
                    "set[str]",
                    "list[int]"
                ]
            }
        },
        "SnliReader.from_params": {
            "name": "from_params",
            "location": 79,
            "return": [
                "SnliReader",
                "str",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "allennlp.common.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/stanford_sentiment_tree_bank.py": {
        "StanfordSentimentTreeBankDatasetReader.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "bool",
                    "None",
                    "int",
                    "Type[MutableMapping[Any, Any]]",
                    "typing.Type",
                    "Optional[Mapping[str, Any]]",
                    "typing.Mapping",
                    "List[str]",
                    "list[str]",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "dict[str, allennlp.data.token_indexers.TokenIndexer]"
                ],
                "use_subtrees": [
                    "bool",
                    "Optional[str]"
                ],
                "granularity": [
                    "typing.Text",
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "lazy": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "StanfordSentimentTreeBankDatasetReader._read": {
            "name": "_read",
            "location": 68,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "StanfordSentimentTreeBankDatasetReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 87,
            "return": [
                "None",
                "Instance",
                "Union[bool, str]",
                "Union[None, int, str]",
                "Optional[str]",
                "Optional[List[str]]",
                "Optional[Set[str]]",
                "Optional[Union[str, Any]]",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]]",
                    "Tuple[Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal]",
                    "list[str]",
                    "str",
                    "Tuple[Literal, Literal, Literal, Literal, Literal, Literal, Literal, Literal]",
                    "list[tuple[typing.Union[typing.Any,str]]]",
                    "List[str]",
                    "List[Tuple[Any, str]]",
                    "Iterator[str]"
                ],
                "sentiment": [
                    "str",
                    "None",
                    "int",
                    "list",
                    "list[]",
                    "Type[Dict[str, str]]",
                    "List[str]",
                    "typing.Type",
                    "list[str]"
                ]
            }
        },
        "StanfordSentimentTreeBankDatasetReader.from_params": {
            "name": "from_params",
            "location": 134,
            "return": [
                "bool",
                "StanfordSentimentTreeBankDatasetReader"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "bool",
                    "Sequence[int]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/coreference_resolution/conll.py": {
        "canonicalize_clusters": {
            "name": "canonicalize_clusters",
            "location": 19,
            "return": [
                "list[list[]]",
                "List[str]",
                "Dict[int, int]",
                "str",
                "Set[str]",
                "Optional[dict]",
                "list"
            ],
            "arguments": {
                "clusters": [
                    "DefaultDict[int, List[Any]]",
                    "OrderedDict",
                    "str",
                    "int"
                ]
            }
        },
        "ConllCorefReader.__init__": {
            "name": "__init__",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_span_width": [
                    "int"
                ],
                "token_indexers": [
                    "int",
                    "None",
                    "str",
                    "bool"
                ],
                "lazy": [
                    "bool",
                    "float",
                    "Dict[str, str]"
                ]
            }
        },
        "ConllCorefReader._read": {
            "name": "_read",
            "location": 84,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "ConllCorefReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 107,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "list[str]",
                    "List[str]",
                    "int",
                    "float",
                    "Type[Dict[str, dict]]"
                ],
                "gold_clusters": [
                    "Optional[List[Any]]",
                    "None",
                    "Optional[List[str]]",
                    "list[typing.Any]",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "ConllCorefReader.from_params": {
            "name": "from_params",
            "location": 180,
            "return": [
                "str",
                "bool",
                "List[int]",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "typing.Callable[int, None]",
                    "bool",
                    "typing.Sequence[str]",
                    "Callable[[int], None]",
                    "Sequence[str]"
                ],
                "params": [
                    "bool",
                    "dict",
                    "bytes"
                ]
            }
        },
        "ConllCorefReader._normalize_word": {
            "name": "_normalize_word",
            "location": 188,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "word": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/coreference_resolution/winobias.py": {
        "WinobiasReader.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_span_width": [
                    "int"
                ],
                "token_indexers": [
                    "int",
                    "None",
                    "str",
                    "bool"
                ],
                "lazy": [
                    "bool",
                    "float",
                    "Dict[str, str]"
                ]
            }
        },
        "WinobiasReader._read": {
            "name": "_read",
            "location": 61,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "WinobiasReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 98,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "List[str]",
                    "list[str]"
                ],
                "gold_clusters": [
                    "Optional[List[Any]]",
                    "None",
                    "Optional[List[str]]",
                    "list[typing.Any]",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "WinobiasReader.from_params": {
            "name": "from_params",
            "location": 162,
            "return": [
                "str",
                "bool",
                "List[int]",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "typing.Callable[int, None]",
                    "bool",
                    "typing.Sequence[str]",
                    "Callable[[int], None]",
                    "Sequence[str]"
                ],
                "params": [
                    "bool",
                    "dict",
                    "bytes"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/coreference_resolution/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_utils/ontonotes.py": {
        "OntonotesSentence.__init__": {
            "name": "__init__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "document_id": [
                    "str"
                ],
                "sentence_id": [
                    "int"
                ],
                "words": [
                    "List[str]"
                ],
                "pos_tags": [
                    "List[str]"
                ],
                "parse_tree": [],
                "predicate_lemmas": [
                    "List[Optional[str]]"
                ],
                "predicate_framenet_ids": [
                    "List[Optional[str]]"
                ],
                "word_senses": [
                    "List[Optional[float]]"
                ],
                "speakers": [
                    "List[Optional[str]]"
                ],
                "named_entities": [
                    "List[str]"
                ],
                "srl_frames": [
                    "List[Tuple[(str, List[str])]]"
                ],
                "coref_spans": [
                    "Set[Tuple[(int, Tuple[(int, int)])]]"
                ]
            }
        },
        "Ontonotes.dataset_iterator": {
            "name": "dataset_iterator",
            "location": 176,
            "return": [
                "Iterator[OntonotesSentence]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes.dataset_path_iterator": {
            "name": "dataset_path_iterator",
            "location": 184,
            "return": [
                "Iterator[str]"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes.dataset_document_iterator": {
            "name": "dataset_document_iterator",
            "location": 200,
            "return": [
                "Iterator[List[OntonotesSentence]]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes.sentence_iterator": {
            "name": "sentence_iterator",
            "location": 227,
            "return": [
                "Iterator[OntonotesSentence]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Ontonotes._conll_rows_to_sentence": {
            "name": "_conll_rows_to_sentence",
            "location": 235,
            "return": [
                "OntonotesSentence"
            ],
            "arguments": {
                "self": [],
                "conll_rows": [
                    "List[str]"
                ]
            }
        },
        "Ontonotes._process_coref_span_annotations_for_word": {
            "name": "_process_coref_span_annotations_for_word",
            "location": 362,
            "return": [
                "None"
            ],
            "arguments": {
                "label": [
                    "str"
                ],
                "word_index": [
                    "int"
                ],
                "clusters": [
                    "DefaultDict[(int, List[Tuple[(int, int)]])]"
                ],
                "coref_stacks": [
                    "DefaultDict[(int, List[int])]"
                ]
            }
        },
        "Ontonotes._process_span_annotations_for_word": {
            "name": "_process_span_annotations_for_word",
            "location": 411,
            "return": [
                "None"
            ],
            "arguments": {
                "annotations": [
                    "List[str]"
                ],
                "span_labels": [
                    "List[List[str]]"
                ],
                "current_span_labels": [
                    "List[Optional[str]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_utils/span_utils.py": {
        "enumerate_spans": {
            "name": "enumerate_spans",
            "location": 11,
            "return": [
                "List[Tuple[(int, int)]]"
            ],
            "arguments": {
                "sentence": [
                    "List[T]"
                ],
                "offset": [
                    "int"
                ],
                "max_span_width": [
                    "int"
                ],
                "min_span_width": [
                    "int"
                ],
                "filter_function": [
                    "Callable[([List[T]], bool)]"
                ]
            }
        },
        "bio_tags_to_spans": {
            "name": "bio_tags_to_spans",
            "location": 60,
            "return": [
                "List[Tuple[(str, Tuple[(int, int)])]]"
            ],
            "arguments": {
                "tag_sequence": [
                    "List[str]"
                ],
                "classes_to_ignore": [
                    "List[str]"
                ]
            }
        },
        "bioul_tags_to_spans": {
            "name": "bioul_tags_to_spans",
            "location": 132,
            "return": [
                "List[Tuple[(str, Tuple[(int, int)])]]"
            ],
            "arguments": {
                "tag_sequence": [
                    "List[str]"
                ],
                "classes_to_ignore": [
                    "List[str]"
                ]
            }
        },
        "iob1_to_bioul": {
            "name": "iob1_to_bioul",
            "location": 176,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "tag_sequence": [
                    "List[str]"
                ]
            }
        },
        "iob1_to_bioul.replace_label": {
            "name": "replace_label",
            "location": 196,
            "return": [
                "str",
                "Callable[[T], bool]",
                "bool",
                "int"
            ],
            "arguments": {
                "full_label": [
                    "dict",
                    "List[str]",
                    "Dict[int, Dict[str, Any]]",
                    "bool",
                    "Dict[str, Any]",
                    "list"
                ],
                "new_label": [
                    "List[Callable]",
                    "Callable",
                    "dict",
                    "Optional[Callable]"
                ]
            }
        },
        "iob1_to_bioul.pop_replace_append": {
            "name": "pop_replace_append",
            "location": 202,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "in_stack": [
                    "bool",
                    "str"
                ],
                "out_stack": [
                    "list",
                    "Optional[list]",
                    "List[str]",
                    "bool",
                    "Union[str, List[str], Tuple[str, ...]]",
                    "List[T]",
                    "List['Frame']"
                ],
                "new_label": [
                    "str",
                    "dict",
                    "Tuple[str, str, int]",
                    "Tuple[str, str, str]"
                ]
            }
        },
        "iob1_to_bioul.process_stack": {
            "name": "process_stack",
            "location": 209,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "stack": [
                    "Callable",
                    "str",
                    "int"
                ],
                "out_stack": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/dataset_utils/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/squad.py": {
        "SquadReader.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokenizer": [
                    "List[Tuple[int, int]]",
                    "None",
                    "Tuple[int, int]",
                    "list[tuple[typing.Union[int,int]]]",
                    "str",
                    "List[int]",
                    "tuple[typing.Union[int,int]]",
                    "list[int]",
                    "Iterable[str]"
                ],
                "token_indexers": [
                    "bool",
                    "None",
                    "Callable",
                    "int",
                    "typing.Callable[, ]"
                ],
                "lazy": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "SquadReader._read": {
            "name": "_read",
            "location": 48,
            "return": [
                "",
                "typing.Generator[tuple[typing.Union[str,int]]]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SquadReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 75,
            "return": [
                "List[str]",
                "int",
                "float",
                "Type[Dict[str, dict]]"
            ],
            "arguments": {
                "self": [],
                "question_text": [
                    "str",
                    "bool",
                    "range",
                    "Optional[Match[str]]",
                    "typing.Match",
                    "None"
                ],
                "passage_text": [
                    "str",
                    "int",
                    "bool",
                    "logging.Logger",
                    "Optional[Exception]"
                ],
                "char_spans": [
                    "List[List[int]]",
                    "None",
                    "int",
                    "str",
                    "list[list[int]]",
                    "List[str]",
                    "Tuple[str, int]",
                    "list[str]",
                    "tuple[typing.Union[str,int]]"
                ],
                "answer_texts": [
                    "None",
                    "List[allennlp.data.tokenizers.Token]",
                    "list[allennlp.data.tokenizers.Token]",
                    "List[str]",
                    "bool",
                    "list[str]",
                    "str",
                    "List[Tuple[int, int]]",
                    "list[tuple[typing.Union[int,int]]]",
                    "Token",
                    "int"
                ],
                "passage_tokens": [
                    "str",
                    "tuple[typing.Union[str,str]]",
                    "int",
                    "Tuple[str, str]"
                ]
            }
        },
        "SquadReader.from_params": {
            "name": "from_params",
            "location": 111,
            "return": [
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "allennlp.common.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/triviaqa.py": {
        "TriviaQaReader.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "base_tarball_path": [
                    "str"
                ],
                "unfiltered_tarball_path": [
                    "str",
                    "None",
                    "Optional[List[str]]",
                    "list[str]"
                ],
                "tokenizer": [
                    "int",
                    "None",
                    "Tuple[int, int]",
                    "Any",
                    "float",
                    "tuple[typing.Union[int,int]]",
                    "Optional[List[str]]",
                    "typing.Any",
                    "List[Dict[str, Any]]",
                    "list[str]",
                    "list[dict[str, typing.Any]]",
                    "Dict[int, str]",
                    "dict[int, str]"
                ],
                "token_indexers": [
                    "bool",
                    "None",
                    "str",
                    "int",
                    "Optional[Mapping[str, Any]]",
                    "typing.Mapping",
                    "Dict[Tuple[str, str], Exception]",
                    "dict[tuple[typing.Union[str,str]], Exception]"
                ],
                "lazy": [
                    "bool",
                    "str"
                ]
            }
        },
        "TriviaQaReader._read": {
            "name": "_read",
            "location": 66,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "TriviaQaReader.pick_paragraphs": {
            "name": "pick_paragraphs",
            "location": 114,
            "return": [
                "list[str]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "evidence_files": [
                    "list[str]",
                    "str",
                    "List[str]",
                    "list[list[str]]",
                    "List[List[str]]",
                    "bool",
                    "int"
                ],
                "question": [
                    "List[str]",
                    "None",
                    "str",
                    "list[str]",
                    "bool",
                    "List[List[str]]",
                    "list[list[str]]",
                    "int"
                ],
                "answer_texts": [
                    "List[str]",
                    "None",
                    "str",
                    "list[str]",
                    "bool",
                    "List[List[str]]",
                    "list[list[str]]",
                    "int"
                ]
            }
        },
        "TriviaQaReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 137,
            "return": [
                "Set[Tuple[str, str]]",
                "str",
                "bool",
                "dict",
                "Tuple[str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str, str]"
            ],
            "arguments": {
                "self": [],
                "question_text": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None",
                    "float",
                    "bool"
                ],
                "passage_text": [
                    "bool",
                    "str"
                ],
                "token_spans": [
                    "List[str]",
                    "None",
                    "bool",
                    "List[Tuple[int, int]]",
                    "list[str]",
                    "list[tuple[typing.Union[int,int]]]"
                ],
                "answer_texts": [
                    "List[str]",
                    "None",
                    "bool",
                    "List[Tuple[int, int]]",
                    "list[str]",
                    "list[tuple[typing.Union[int,int]]]"
                ],
                "question_tokens": [
                    "bool",
                    "str",
                    "None"
                ],
                "passage_tokens": [
                    "bool",
                    "str",
                    "None"
                ]
            }
        },
        "TriviaQaReader.from_params": {
            "name": "from_params",
            "location": 157,
            "return": [
                "bool",
                "Mapping[str, Any]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "dict",
                    "dict[, ]"
                ],
                "params": [
                    "dict[str, str]",
                    "Dict[str, str]",
                    "list[str]",
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/util.py": {
        "normalize_text": {
            "name": "normalize_text",
            "location": 22,
            "return": [
                "str"
            ],
            "arguments": {
                "text": []
            }
        },
        "char_span_to_token_span": {
            "name": "char_span_to_token_span",
            "location": 34,
            "return": [
                "tuple[typing.Union[tuple[int],bool]]"
            ],
            "arguments": {
                "token_offsets": [],
                "character_span": []
            }
        },
        "find_valid_answer_spans": {
            "name": "find_valid_answer_spans",
            "location": 95,
            "return": [
                "list[tuple[]]"
            ],
            "arguments": {
                "passage_tokens": [],
                "answer_texts": []
            }
        },
        "make_reading_comprehension_instance": {
            "name": "make_reading_comprehension_instance",
            "location": 136,
            "return": [
                "Instance"
            ],
            "arguments": {
                "question_tokens": [],
                "passage_tokens": [],
                "token_indexers": [],
                "passage_text": [],
                "token_spans": [],
                "answer_texts": [
                    "None"
                ],
                "additional_metadata": [
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/dataset_readers/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/fields/array_field.py": {
        "ArrayField.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "array": [
                    "int",
                    "str",
                    "float",
                    "Union[str, float]",
                    "list[str]",
                    "List[str]",
                    "bool"
                ],
                "padding_value": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "ArrayField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 22,
            "return": [
                "str",
                "dict[typing.Text, ]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayField.as_tensor": {
            "name": "as_tensor",
            "location": 27,
            "return": [
                "Variable",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Sequence[Sequence[float]]",
                    "list",
                    "List[int]",
                    "List[Tuple[int, int]]"
                ],
                "cuda_device": [
                    "int",
                    "numpy.ndarray",
                    "Mapping[str, Tuple[float, float, float]]",
                    "float",
                    "numpy.array"
                ],
                "for_training": [
                    "bool",
                    "int",
                    "Optional[Union[int, float]]",
                    "Optional[str]",
                    "str",
                    "allennlp.modules.similarity_functions.SimilarityFunction"
                ]
            }
        },
        "ArrayField.empty_field": {
            "name": "empty_field",
            "location": 47,
            "return": [
                "ArrayField",
                "str",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayField.__str__": {
            "name": "__str__",
            "location": 53,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/field.py": {
        "Field.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "dict[str, dict[str, int]]",
                    "bool",
                    "Dict[str, Dict[str, int]]",
                    "int"
                ]
            }
        },
        "Field.index": {
            "name": "index",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "Field.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 60,
            "return": [
                "typing.Dict[builtins.str, builtins.int]",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.as_tensor": {
            "name": "as_tensor",
            "location": 71,
            "return": [
                "DataArray",
                "None"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "bool",
                    "str",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "bool",
                    "Dict[str, int]",
                    "str"
                ],
                "for_training": [
                    "bool",
                    "Dict[str, int]",
                    "int",
                    "str"
                ]
            }
        },
        "Field.empty_field": {
            "name": "empty_field",
            "location": 96,
            "return": [
                "'Field'",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.batch_tensors": {
            "name": "batch_tensors",
            "location": 109,
            "return": [
                "torch.FloatTensor",
                "str",
                "List[allennlp.data.iterators.data_iterator.TensorDict]",
                "List[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "tensor_list": [
                    "int",
                    "List[Dict[str, torch.Tensor]]",
                    "float",
                    "list[dict[str, torch.Tensor]]",
                    "List[List[T]]",
                    "list[list[T]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/index_field.py": {
        "IndexField.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "list",
                    "list[]"
                ],
                "sequence_field": [
                    "int",
                    "typing.Iterable[typing.Union[int,str]]",
                    "bytes",
                    "Iterable[str]",
                    "typing.Callable[, ]",
                    "Iterable[Union[int, str]]",
                    "apps.common.coininfo.CoinInfo",
                    "Callable"
                ]
            }
        },
        "IndexField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 40,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "IndexField.as_tensor": {
            "name": "as_tensor",
            "location": 44,
            "return": [
                "Variable",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "bool",
                    "str",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Mapping[str, Tuple[float, float, float]]",
                    "float"
                ],
                "for_training": [
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "float"
                ]
            }
        },
        "IndexField.empty_field": {
            "name": "empty_field",
            "location": 53,
            "return": [
                "IndexField",
                "bool",
                "List[str]",
                "int",
                "type",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "IndexField.__str__": {
            "name": "__str__",
            "location": 56,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/label_field.py": {
        "LabelField.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "Union[str, int]",
                    "int",
                    "typing.Callable[str,str, None]",
                    "Callable[[str, str], None]",
                    "typing.Sequence[typing.Union[str,int]]",
                    "bool",
                    "typing.Iterable[]",
                    "Sequence[Union[str, int]]",
                    "Iterable",
                    "Tuple[str, str]"
                ],
                "label_namespace": [
                    "typing.Text",
                    "bool",
                    "str",
                    "Optional[Callable]",
                    "Dict[str, str]",
                    "List[int]"
                ],
                "skip_indexing": [
                    "bool",
                    "str",
                    "allennlp.data.vocabulary.Vocabulary",
                    "Iterable[str]",
                    "List[allennlp.data.tokenizers.token.Token]"
                ]
            }
        },
        "LabelField._maybe_warn_for_namespace": {
            "name": "_maybe_warn_for_namespace",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label_namespace": []
            }
        },
        "LabelField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 76,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "int",
                    "float",
                    "typing.Iterable[typing.Iterable[T]]",
                    "Iterable[Iterable[T]]",
                    "tuple",
                    "Tuple[str, str, str]"
                ]
            }
        },
        "LabelField.index": {
            "name": "index",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "LabelField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 86,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelField.as_tensor": {
            "name": "as_tensor",
            "location": 90,
            "return": [
                "Variable",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "bool",
                    "str",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Mapping[str, Tuple[float, float, float]]",
                    "float"
                ],
                "for_training": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "LabelField.empty_field": {
            "name": "empty_field",
            "location": 99,
            "return": [
                "LabelField",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelField.__str__": {
            "name": "__str__",
            "location": 102,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/list_field.py": {
        "ListField.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_list": [
                    "str",
                    "dict[, ]",
                    "dict",
                    "tracim.models.data.Content",
                    "Iterable"
                ]
            }
        },
        "ListField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "dict[str, dict[str, int]]",
                    "str",
                    "Dict[str, Dict[str, int]]",
                    "Dict[str, Any]",
                    "allennlp.data.vocabulary.Vocabulary"
                ]
            }
        },
        "ListField.index": {
            "name": "index",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "dict[str, typing.Any]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "deoplete.util.UserContext",
                    "Dict[str, Any]"
                ]
            }
        },
        "ListField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 45,
            "return": [
                "dict[typing.Text, int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListField.sequence_length": {
            "name": "sequence_length",
            "location": 64,
            "return": [
                "int",
                "List[str]",
                "Dict[str, Any]",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListField.as_tensor": {
            "name": "as_tensor",
            "location": 68,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "List[str]",
                    "list"
                ],
                "cuda_device": [
                    "int",
                    "Field"
                ],
                "for_training": [
                    "bool",
                    "Field",
                    "int"
                ]
            }
        },
        "ListField.empty_field": {
            "name": "empty_field",
            "location": 85,
            "return": [
                "ListField",
                "str",
                "List[T]",
                "List[Dict]",
                "Optional[Type]",
                "List[str]",
                "list",
                "List[type]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListField.batch_tensors": {
            "name": "batch_tensors",
            "location": 96,
            "return": [
                "str",
                "List[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "tensor_list": [
                    "Union[str, List[str]]",
                    "Union[Sequence[int], Sequence[dict]]",
                    "str",
                    "list[str]",
                    "typing.Sequence[int]",
                    "typing.Sequence[dict[, ]]"
                ]
            }
        },
        "ListField.__str__": {
            "name": "__str__",
            "location": 100,
            "return": [
                "str",
                "Iterable[str]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/metadata_field.py": {
        "MetadataField.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metadata": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MetadataField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 31,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetadataField.as_tensor": {
            "name": "as_tensor",
            "location": 35,
            "return": [
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "bool",
                    "str",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "bool",
                    "Dict[str, int]",
                    "str"
                ],
                "for_training": [
                    "bool",
                    "Dict[str, int]",
                    "int",
                    "str"
                ]
            }
        },
        "MetadataField.empty_field": {
            "name": "empty_field",
            "location": 43,
            "return": [
                "MetadataField",
                "Optional[str]",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetadataField.batch_tensors": {
            "name": "batch_tensors",
            "location": 48,
            "return": [
                "list[str]",
                "List[Dict]",
                "typing.Type",
                "List[str]",
                "dict[, ]",
                "bool",
                "str",
                "List[int]",
                "List[List[Any]]",
                "float"
            ],
            "arguments": {
                "cls": [
                    "List[str]",
                    "list[str]",
                    "Type",
                    "bool",
                    "typing.Type",
                    "dict",
                    "dict[, ]"
                ],
                "tensor_list": [
                    "List[str]",
                    "list[str]",
                    "Type",
                    "bool",
                    "typing.Type",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "MetadataField.__str__": {
            "name": "__str__",
            "location": 52,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/multilabel_field.py": {
        "MultiLabelField.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "str",
                    "Sequence[Union[str, int]]",
                    "int",
                    "Optional[\"InventoryMode\"]",
                    "bool"
                ],
                "label_namespace": [
                    "typing.Text",
                    "str",
                    "int",
                    "Dict[str, str]"
                ],
                "skip_indexing": [
                    "bool",
                    "int",
                    "str",
                    "list"
                ],
                "num_labels": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "bool",
                    "Optional[str]",
                    "Optional[float]"
                ]
            }
        },
        "MultiLabelField._maybe_warn_for_namespace": {
            "name": "_maybe_warn_for_namespace",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label_namespace": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "MultiLabelField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 92,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "int",
                    "float",
                    "typing.Iterable[typing.Iterable[T]]",
                    "Iterable[Iterable[T]]",
                    "tuple",
                    "Tuple[str, str, str]"
                ]
            }
        },
        "MultiLabelField.index": {
            "name": "index",
            "location": 98,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "list[str]",
                    "List[str]",
                    "list[int]",
                    "bool",
                    "None",
                    "List[int]",
                    "Optional[int]"
                ]
            }
        },
        "MultiLabelField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 106,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiLabelField.as_tensor": {
            "name": "as_tensor",
            "location": 110,
            "return": [
                "Variable",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "bool",
                    "str",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Mapping[str, Tuple[float, float, float]]",
                    "float"
                ],
                "for_training": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "MultiLabelField.empty_field": {
            "name": "empty_field",
            "location": 124,
            "return": [
                "MultiLabelField",
                "int",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiLabelField.__str__": {
            "name": "__str__",
            "location": 127,
            "return": [
                "typing.Text",
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/sequence_field.py": {
        "SequenceField.sequence_length": {
            "name": "sequence_length",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/sequence_label_field.py": {
        "SequenceLabelField.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "List[str]",
                    "bool",
                    "Union[List[str], List[int]]",
                    "List[int]",
                    "str",
                    "int",
                    "Set[str]"
                ],
                "sequence_field": [
                    "allennlp.data.fields.sequence_field.SequenceField",
                    "str",
                    "Union[List[str], List[int]]",
                    "bytes",
                    "dict",
                    "bool",
                    "int",
                    "Sequence[T]"
                ],
                "label_namespace": [
                    "typing.Text",
                    "Set[str]",
                    "Dict[str, str]",
                    "float",
                    "Optional[str]",
                    "str",
                    "bool"
                ]
            }
        },
        "SequenceLabelField._maybe_warn_for_namespace": {
            "name": "_maybe_warn_for_namespace",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label_namespace": []
            }
        },
        "SequenceLabelField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "int",
                    "float",
                    "typing.Iterable[typing.Iterable[T]]",
                    "Iterable[Iterable[T]]",
                    "tuple",
                    "Tuple[str, str, str]"
                ]
            }
        },
        "SequenceLabelField.index": {
            "name": "index",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "thonny.common.CommandToBackend"
                ]
            }
        },
        "SequenceLabelField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 92,
            "return": [
                "dict[typing.Text, ]",
                "int",
                "float",
                "bool",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabelField.as_tensor": {
            "name": "as_tensor",
            "location": 96,
            "return": [
                "Variable",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "int",
                    "bool"
                ],
                "cuda_device": [
                    "int",
                    "Mapping[str, Tuple[float, float, float]]",
                    "float"
                ],
                "for_training": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "SequenceLabelField.empty_field": {
            "name": "empty_field",
            "location": 106,
            "return": [
                "SequenceLabelField",
                "bool",
                "Dict[str, Any]",
                "str",
                "util.LetterSuffixStyle",
                "Dict[int, str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceLabelField.__str__": {
            "name": "__str__",
            "location": 112,
            "return": [
                "typing.Text",
                "str",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/span_field.py": {
        "SpanField.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "span_start": [
                    "int",
                    "str"
                ],
                "span_end": [
                    "int",
                    "str",
                    "Optional[int]"
                ],
                "sequence_field": [
                    "str",
                    "int",
                    "list[str]",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "SpanField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 46,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanField.as_tensor": {
            "name": "as_tensor",
            "location": 51,
            "return": [
                "Variable",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "bool",
                    "str",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Mapping[str, Tuple[float, float, float]]",
                    "float"
                ],
                "for_training": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "SpanField.empty_field": {
            "name": "empty_field",
            "location": 60,
            "return": [
                "SpanField",
                "bool",
                "List[str]",
                "int",
                "type",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanField.__str__": {
            "name": "__str__",
            "location": 63,
            "return": [
                "typing.Text",
                "str",
                "Callable[[Dict], None]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/text_field.py": {
        "TextField.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str",
                    "list[tuple[typing.Union[int,int]]]",
                    "List[Tuple[int, int]]",
                    "bytes",
                    "list[str]",
                    "Union[List[str], List[int]]",
                    "list[int]",
                    "List[str]",
                    "dict[, ]",
                    "int",
                    "list[list[str]]",
                    "dict",
                    "List[List[str]]"
                ],
                "token_indexers": [
                    "str",
                    "int",
                    "Optional[Callable]",
                    "typing.Callable[, ]",
                    "bool",
                    "None",
                    "Sequence",
                    "typing.Sequence[]"
                ]
            }
        },
        "TextField.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "counter": [
                    "dict[str, dict[str, int]]",
                    "int",
                    "Dict[str, Dict[str, int]]",
                    "str",
                    "list[str]",
                    "List[str]",
                    "typing.Callable[int, None]",
                    "Callable[[int], None]",
                    "bool"
                ]
            }
        },
        "TextField.index": {
            "name": "index",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "bool",
                    "List[str]",
                    "list[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "TextField.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 62,
            "return": [
                "dict[typing.Union[typing.Text,list[list[]]], int]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextField.sequence_length": {
            "name": "sequence_length",
            "location": 100,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextField.as_tensor": {
            "name": "as_tensor",
            "location": 104,
            "return": [
                "dict[, Variable]",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "padding_lengths": [
                    "str",
                    "int",
                    "float"
                ],
                "cuda_device": [
                    "int",
                    "str",
                    "List[str]",
                    "Dict[str, str]",
                    "bool"
                ],
                "for_training": [
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "float"
                ]
            }
        },
        "TextField.empty_field": {
            "name": "empty_field",
            "location": 125,
            "return": [
                "TextField",
                "str",
                "Type[BaseException]",
                "Type[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextField.batch_tensors": {
            "name": "batch_tensors",
            "location": 134,
            "return": [
                "int",
                "Tuple[Any, Any, Any]",
                "torch.FloatTensor",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor_list": [
                    "int",
                    "List[Dict[str, torch.Tensor]]",
                    "float",
                    "list[dict[str, torch.Tensor]]",
                    "List[List[T]]",
                    "list[list[T]]"
                ]
            }
        },
        "TextField.__str__": {
            "name": "__str__",
            "location": 140,
            "return": [
                "typing.Text",
                "str",
                "bool",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/fields/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/iterators/adaptive_iterator.py": {
        "AdaptiveIterator.__init__": {
            "name": "__init__",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "adaptive_memory_usage_constant": [
                    "float",
                    "bool",
                    "int"
                ],
                "padding_memory_scaling": [
                    "float",
                    "bool",
                    "int"
                ],
                "maximum_batch_size": [
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "Optional[int]",
                    "bool",
                    "float"
                ],
                "biggest_batch_first": [
                    "bool",
                    "Optional[int]",
                    "int",
                    "Dict[Tuple[int, int], int]",
                    "float"
                ],
                "batch_size": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Dict[Tuple[int, int], int]",
                    "float",
                    "bool"
                ],
                "sorting_keys": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Dict[Tuple[int, int], int]",
                    "float",
                    "bool"
                ],
                "padding_noise": [
                    "float",
                    "Optional[int]",
                    "int",
                    "Dict[Tuple[int, int], int]",
                    "bool"
                ],
                "instances_per_epoch": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Dict[Tuple[int, int], int]",
                    "float",
                    "bool"
                ],
                "max_instances_in_memory": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Dict[Tuple[int, int], int]",
                    "float",
                    "bool"
                ]
            }
        },
        "AdaptiveIterator.get_num_batches": {
            "name": "get_num_batches",
            "location": 105,
            "return": [
                "int",
                "bytes",
                "str",
                "float",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "int",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "AdaptiveIterator._create_batches": {
            "name": "_create_batches",
            "location": 114,
            "return": [
                "typing.Iterable[allennlp.data.dataset.Batch]",
                "typing.Generator[]",
                "typing.Generator[typing.Generator[Batch]]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "list",
                    "Sequence[Tuple[str, Any]]",
                    "List[Dict[str, str]]",
                    "str",
                    "List[str]",
                    "Iterable[float]"
                ],
                "shuffle": [
                    "float",
                    "int"
                ]
            }
        },
        "AdaptiveIterator._adaptive_grouping": {
            "name": "_adaptive_grouping",
            "location": 132,
            "return": [
                "list[list[]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "AdaptiveIterator.from_params": {
            "name": "from_params",
            "location": 155,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "bool",
                    "Optional[List[str]]",
                    "Dict[str, Dict[Any, int]]",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/basic_iterator.py": {
        "BasicIterator.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "bool",
                    "Union[Tuple[int, int], int]"
                ],
                "instances_per_epoch": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "bool"
                ],
                "max_instances_in_memory": [
                    "int",
                    "None",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "BasicIterator.get_num_batches": {
            "name": "get_num_batches",
            "location": 46,
            "return": [
                "int",
                "str",
                "bytes",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "str",
                    "int",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "BasicIterator._take_instances": {
            "name": "_take_instances",
            "location": 56,
            "return": [
                "typing.Iterator[allennlp.data.instance.Instance]",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "dict",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, str]",
                    "dict[str, str]"
                ],
                "max_instances": [
                    "Optional[int]",
                    "str",
                    "None",
                    "int"
                ]
            }
        },
        "BasicIterator._memory_sized_lists": {
            "name": "_memory_sized_lists",
            "location": 87,
            "return": [
                "typing.Iterable[typing.List[allennlp.data.instance.Instance]]",
                "typing.Generator[]",
                "typing.Generator[list[]]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "float"
                ]
            }
        },
        "BasicIterator._create_batches": {
            "name": "_create_batches",
            "location": 124,
            "return": [
                "typing.Iterable[allennlp.data.dataset.Batch]",
                "typing.Generator[Batch]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "list[]",
                    "list",
                    "typing.Sequence[tuple[typing.Union[str,typing.Any]]]",
                    "str",
                    "Sequence[Tuple[str, Any]]",
                    "list[dict[str, str]]",
                    "List[Dict[str, str]]",
                    "list[str]",
                    "List[str]",
                    "Iterable[float]"
                ],
                "shuffle": [
                    "bool",
                    "float",
                    "allennlp.data.dataseDataset"
                ]
            }
        },
        "BasicIterator.from_params": {
            "name": "from_params",
            "location": 135,
            "return": [
                "str",
                "bool",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bytes",
                    "float"
                ],
                "params": [
                    "dict",
                    "MutableMapping[str, Any]",
                    "bytes",
                    "Optional[Exception]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/bucket_iterator.py": {
        "BucketIterator.__init__": {
            "name": "__init__",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sorting_keys": [
                    "bool",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "tuple[bytes]",
                    "Tuple[bytes]",
                    "tuple[typing.Union[str,int]]",
                    "Tuple[str, int]",
                    "list[str]",
                    "int",
                    "List[str]"
                ],
                "padding_noise": [
                    "float",
                    "int"
                ],
                "biggest_batch_first": [
                    "bool",
                    "float",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Tuple[str, int]"
                ],
                "instances_per_epoch": [
                    "int",
                    "None",
                    "bool",
                    "Tuple[str, int]",
                    "tuple[typing.Union[str,int]]"
                ],
                "max_instances_in_memory": [
                    "int",
                    "None",
                    "bool",
                    "Tuple[str, int]",
                    "tuple[typing.Union[str,int]]"
                ]
            }
        },
        "BucketIterator._create_batches": {
            "name": "_create_batches",
            "location": 77,
            "return": [
                "typing.Iterable[allennlp.data.dataset.Batch]",
                "typing.Generator[list[int]]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "list[]",
                    "list",
                    "typing.Sequence[tuple[typing.Union[str,typing.Any]]]",
                    "str",
                    "Sequence[Tuple[str, Any]]",
                    "list[dict[str, str]]",
                    "List[Dict[str, str]]",
                    "list[str]",
                    "List[str]",
                    "Iterable[float]"
                ],
                "shuffle": [
                    "int",
                    "str",
                    "list[]",
                    "bool",
                    "list",
                    "allennlp.data.Dataset"
                ]
            }
        },
        "BucketIterator._sort_by_padding": {
            "name": "_sort_by_padding",
            "location": 100,
            "return": [
                "list[typing.Union[list[],allennlp.data.instance.Instance]]",
                "bool",
                "str",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "list[allennlp.data.instance.Instance]",
                    "bytes",
                    "List[allennlp.data.instance.Instance]",
                    "bool",
                    "str"
                ],
                "sorting_keys": [
                    "bytes",
                    "str",
                    "dict",
                    "dict[, ]"
                ],
                "padding_noise": [
                    "float",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "BucketIterator.from_params": {
            "name": "from_params",
            "location": 127,
            "return": [
                "Iterator[Tuple[Any, Any]]",
                "dict",
                "bytes",
                "str",
                "Exception",
                "Iterable[Any]"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "params": [
                    "Dict[str, Any]",
                    "cdp.util.T_JSON_DICT",
                    "allennlp.data.Vocabulary",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/data_iterator.py": {
        "DataIterator.__call__": {
            "name": "__call__",
            "location": 22,
            "return": [
                "typing.Generator[typing.Dict[builtins.str, typing.Union[numpy.ndarray, typing.Dict[builtins.str, numpy.ndarray]]], None, None]",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "bool",
                    "typing.Iterator",
                    "Iterator[numpy.ndarray]",
                    "int"
                ],
                "num_epochs": [
                    "int",
                    "None",
                    "Optional[int]",
                    "List[\"Issue\"]",
                    "list[I]",
                    "Optional[float]",
                    "float"
                ],
                "shuffle": [
                    "bool",
                    "Iterator[numpy.ndarray]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "bool",
                    "Iterator[numpy.ndarray]"
                ],
                "for_training": [
                    "bool",
                    "Iterator[numpy.ndarray]",
                    "int"
                ]
            }
        },
        "DataIterator.get_num_batches": {
            "name": "get_num_batches",
            "location": 61,
            "return": [
                "builtins.int",
                "None"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "bool",
                    "str",
                    "typing.Iterable[allennlp.data.instance.Instance]",
                    "allennlp.data.dataseDataset",
                    "Iterable[allennlp.data.instance.Instance]"
                ]
            }
        },
        "DataIterator._yield_one_epoch": {
            "name": "_yield_one_epoch",
            "location": 69,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "str",
                    "int",
                    "allennlp.data.dataset_readers.dataset_reader.DatasetReader"
                ],
                "shuffle": [
                    "int",
                    "str",
                    "None",
                    "bool",
                    "Optional[int]"
                ],
                "cuda_device": [
                    "bool",
                    "dict[int, int]",
                    "int",
                    "dict[str, dict[str, typing.Any]]",
                    "Dict[int, int]",
                    "None",
                    "Dict[str, Dict[str, Any]]",
                    "Optional[int]"
                ],
                "for_training": [
                    "bool",
                    "dict[int, int]",
                    "int",
                    "dict[str, dict[str, typing.Any]]",
                    "Dict[int, int]",
                    "None",
                    "Dict[str, Dict[str, Any]]",
                    "Optional[int]"
                ]
            }
        },
        "DataIterator._create_batches": {
            "name": "_create_batches",
            "location": 81,
            "return": [
                "typing.Iterable[allennlp.data.dataset.Batch]",
                "None"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "str",
                    "bool",
                    "typing.Iterator",
                    "float",
                    "Iterator[str]",
                    "Iterable[allennlp.data.Instance]"
                ],
                "shuffle": [
                    "str",
                    "bool",
                    "typing.Iterator",
                    "float",
                    "Iterator[str]",
                    "Iterable[allennlp.data.Instance]"
                ]
            }
        },
        "DataIterator.from_params": {
            "name": "from_params",
            "location": 88,
            "return": [
                "bool",
                "str",
                "int",
                "type",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "Mapping[str, Any]",
                    "mypy.types.Instance",
                    "dict"
                ],
                "params": [
                    "typing.Mapping",
                    "Mapping[str, Any]",
                    "dict[, ]",
                    "mypy.types.Instance",
                    "dict"
                ]
            }
        },
        "DataIterator.index_with": {
            "name": "index_with",
            "location": 95,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/iterators/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/tokenizers/character_tokenizer.py": {
        "CharacterTokenizer.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "byte_encoding": [
                    "None"
                ],
                "lowercase_characters": [
                    "bool"
                ],
                "start_tokens": [
                    "None"
                ],
                "end_tokens": [
                    "None"
                ]
            }
        },
        "CharacterTokenizer.batch_tokenize": {
            "name": "batch_tokenize",
            "location": 50,
            "return": [
                "list[]"
            ],
            "arguments": {
                "self": [],
                "texts": []
            }
        },
        "CharacterTokenizer.tokenize": {
            "name": "tokenize",
            "location": 54,
            "return": [
                "list[typing.Union[Token,int]]"
            ],
            "arguments": {
                "self": [],
                "text": []
            }
        },
        "CharacterTokenizer.from_params": {
            "name": "from_params",
            "location": 78,
            "return": [],
            "arguments": {
                "cls": [],
                "params": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/token.py": {
        "Token.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "idx": [
                    "int"
                ],
                "pos": [
                    "str"
                ],
                "tag": [
                    "str"
                ],
                "dep": [
                    "str"
                ],
                "ent_type": [
                    "str"
                ],
                "text_id": [
                    "int"
                ]
            }
        },
        "Token.__str__": {
            "name": "__str__",
            "location": 47,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Token.__repr__": {
            "name": "__repr__",
            "location": 50,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/tokenizer.py": {
        "Tokenizer.batch_tokenize": {
            "name": "batch_tokenize",
            "location": 26,
            "return": [
                "List[List[allennlp.data.tokenizers.token.Token]]"
            ],
            "arguments": {
                "self": [],
                "texts": [
                    "List[str]"
                ]
            }
        },
        "Tokenizer.tokenize": {
            "name": "tokenize",
            "location": 33,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ]
            }
        },
        "Tokenizer.from_params": {
            "name": "from_params",
            "location": 44,
            "return": [
                "Tokenizer"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "Type[T]",
                    "Dict[str, Any]",
                    "Optional[str]"
                ],
                "params": [
                    "int",
                    "Type[T]",
                    "typing.Type",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_filter.py": {
        "WordFilter.filter_words": {
            "name": "filter_words",
            "location": 19,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[allennlp.data.tokenizers.token.Token]"
                ]
            }
        },
        "WordFilter.from_params": {
            "name": "from_params",
            "location": 26,
            "return": [
                "WordFilter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordFilter]"
                ],
                "params": []
            }
        },
        "PassThroughWordFilter.filter_words": {
            "name": "filter_words",
            "location": 38,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[allennlp.data.tokenizers.token.Token]"
                ]
            }
        },
        "StopwordFilter.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "StopwordFilter.filter_words": {
            "name": "filter_words",
            "location": 75,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[allennlp.data.tokenizers.token.Token]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_splitter.py": {
        "WordSplitter.batch_split_words": {
            "name": "batch_split_words",
            "location": 20,
            "return": [
                "List[List[allennlp.data.tokenizers.token.Token]]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[str]"
                ]
            }
        },
        "WordSplitter.split_words": {
            "name": "split_words",
            "location": 29,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "WordSplitter.from_params": {
            "name": "from_params",
            "location": 36,
            "return": [
                "WordSplitter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordSplitter]"
                ],
                "params": []
            }
        },
        "SimpleWordSplitter.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleWordSplitter.split_words": {
            "name": "split_words",
            "location": 58,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "SimpleWordSplitter._can_split": {
            "name": "_can_split",
            "location": 99,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": []
            }
        },
        "SimpleWordSplitter.from_params": {
            "name": "from_params",
            "location": 103,
            "return": [
                "WordSplitter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordSplitter]"
                ],
                "params": []
            }
        },
        "LettersDigitsWordSplitter.split_words": {
            "name": "split_words",
            "location": 115,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "LettersDigitsWordSplitter.from_params": {
            "name": "from_params",
            "location": 122,
            "return": [
                "WordSplitter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordSplitter]"
                ],
                "params": []
            }
        },
        "JustSpacesWordSplitter.split_words": {
            "name": "split_words",
            "location": 139,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "JustSpacesWordSplitter.from_params": {
            "name": "from_params",
            "location": 143,
            "return": [
                "WordSplitter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordSplitter]"
                ],
                "params": []
            }
        },
        "NltkWordSplitter.split_words": {
            "name": "split_words",
            "location": 158,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "NltkWordSplitter.from_params": {
            "name": "from_params",
            "location": 164,
            "return": [
                "WordSplitter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordSplitter]"
                ],
                "params": []
            }
        },
        "SpacyWordSplitter.__init__": {
            "name": "__init__",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "language": [
                    "typing.Text"
                ],
                "pos_tags": [
                    "bool"
                ],
                "parse": [
                    "bool"
                ],
                "ner": [
                    "bool"
                ]
            }
        },
        "SpacyWordSplitter.batch_split_words": {
            "name": "batch_split_words",
            "location": 183,
            "return": [
                "List[List[allennlp.data.tokenizers.token.Token]]"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "List[str]"
                ]
            }
        },
        "SpacyWordSplitter.split_words": {
            "name": "split_words",
            "location": 187,
            "return": [
                "List[allennlp.data.tokenizers.token.Token]"
            ],
            "arguments": {
                "self": [],
                "sentence": [
                    "str"
                ]
            }
        },
        "SpacyWordSplitter.from_params": {
            "name": "from_params",
            "location": 192,
            "return": [
                "WordSplitter"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordSplitter]"
                ],
                "params": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_stemmer.py": {
        "WordStemmer.stem_word": {
            "name": "stem_word",
            "location": 20,
            "return": [
                "allennlp.data.tokenizers.token.Token"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "allennlp.data.tokenizers.token.Token"
                ]
            }
        },
        "WordStemmer.from_params": {
            "name": "from_params",
            "location": 27,
            "return": [
                "WordStemmer"
            ],
            "arguments": {
                "cls": [
                    "Type[_TWordStemmer]"
                ],
                "params": []
            }
        },
        "PassThroughWordStemmer.stem_word": {
            "name": "stem_word",
            "location": 39,
            "return": [
                "allennlp.data.tokenizers.token.Token"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "allennlp.data.tokenizers.token.Token"
                ]
            }
        },
        "PorterStemmer.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PorterStemmer.stem_word": {
            "name": "stem_word",
            "location": 52,
            "return": [
                "allennlp.data.tokenizers.token.Token"
            ],
            "arguments": {
                "self": [],
                "word": [
                    "allennlp.data.tokenizers.token.Token"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/word_tokenizer.py": {
        "WordTokenizer.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "word_splitter": [
                    "str",
                    "None",
                    "int",
                    "List[Dict[str, Any]]",
                    "Optional[Sequence[str]]",
                    "list[dict[str, typing.Any]]",
                    "Tuple[str]",
                    "typing.Sequence[str]",
                    "List[str]",
                    "tuple[str]",
                    "List[int]",
                    "list[str]",
                    "list[int]"
                ],
                "word_filter": [
                    "PassThroughWordFilter",
                    "dict",
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "bool"
                ],
                "word_stemmer": [
                    "PassThroughWordStemmer",
                    "str",
                    "int",
                    "List[Dict[str, Any]]",
                    "Optional[Sequence[str]]",
                    "Tuple[str]",
                    "List[str]",
                    "List[int]"
                ],
                "start_tokens": [
                    "bool",
                    "None",
                    "str",
                    "Optional[str]",
                    "tuple[str]",
                    "int",
                    "tuple[typing.Union[int,int,int]]",
                    "Optional[Tuple[str]]",
                    "Optional[int]",
                    "Tuple[int, int, int]"
                ],
                "end_tokens": [
                    "None",
                    "List[str]",
                    "int",
                    "list[str]",
                    "float",
                    "bool",
                    "Optional[float]",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "WordTokenizer.tokenize": {
            "name": "tokenize",
            "location": 68,
            "return": [
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str",
                    "bytes",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "int",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "WordTokenizer.batch_tokenize": {
            "name": "batch_tokenize",
            "location": 79,
            "return": [
                "list[]",
                "Tuple[Tuple[int, Any]]",
                "Optional[list]",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "texts": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "WordTokenizer._filter_and_stem": {
            "name": "_filter_and_stem",
            "location": 83,
            "return": [
                "list[typing.Union[int,Token]]",
                "float",
                "Callable[[None], bool]",
                "List[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[str]",
                    "list[str]",
                    "str",
                    "tuple",
                    "tuple[]",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "WordTokenizer.from_params": {
            "name": "from_params",
            "location": 93,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "List[dict]",
                    "bool",
                    "list[dict[, ]]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "List[str]",
                    "list[str]",
                    "dict",
                    "dict[, ]"
                ],
                "params": [
                    "dict[str, typing.Any]",
                    "list[str]",
                    "Dict[str, Any]",
                    "List[str]",
                    "bytes",
                    "int",
                    "Optional[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/tokenizers/__init__.py": {},
    "allennlp-dureader-master/allennlp/data/token_indexers/dep_label_indexer.py": {
        "DepLabelIndexer.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "DepLabelIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str",
                    "allennlp.data.tokenizers.token.Token",
                    "list[str]",
                    "List[str]",
                    "typesystem.tokenize.tokens.Token"
                ],
                "counter": [
                    "Callable[[list], None]",
                    "typing.Callable[list[], None]"
                ]
            }
        },
        "DepLabelIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 42,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "list[T]",
                    "int",
                    "allennlp.data.tokenizers.token.Token",
                    "str",
                    "List[spacy.tokens.Token]",
                    "oj.tokens.Token",
                    "spacy.tokens.Token"
                ],
                "vocabulary": [
                    "dict[, ]",
                    "bytes",
                    "allennlp.data.vocabulary.Vocabulary",
                    "dict"
                ]
            }
        },
        "DepLabelIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 47,
            "return": [
                "int",
                "str",
                "tuple",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DepLabelIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 51,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "DepLabelIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 55,
            "return": [
                "int",
                "str",
                "Sequence[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "desired_num_tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "padding_lengths": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ]
            }
        },
        "DepLabelIndexer.from_params": {
            "name": "from_params",
            "location": 62,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "Type['Model']",
                    "typing.Type",
                    "dict",
                    "dict[, ]"
                ],
                "params": [
                    "allennlp.common.Params",
                    "cdp.util.T_JSON_DICT",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/elmo_indexer.py": {
        "_make_bos_eos": {
            "name": "_make_bos_eos",
            "location": 13,
            "return": [
                "str",
                "list[typing.Union[int,str,list[str],float]]"
            ],
            "arguments": {
                "character": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "padding_character": [
                    "int",
                    "str"
                ],
                "beginning_of_word_character": [
                    "int",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "end_of_word_character": [
                    "int",
                    "float"
                ],
                "max_word_length": [
                    "int",
                    "str"
                ]
            }
        },
        "ELMoCharacterMapper.convert_word_to_char_ids": {
            "name": "convert_word_to_char_ids",
            "location": 61,
            "return": [
                "list[]",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "List[List[allennlp.data.tokenizers.token.Token]]",
                "Set[str]"
            ],
            "arguments": {
                "word": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.__init__": {
            "name": "__init__",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 93,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "Dict[str, Dict[str, int]]"
                ],
                "counter": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "Dict[str, Dict[str, int]]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 97,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "Dict[int, str]",
                    "dict[int, str]",
                    "List[spacy.tokens.Token]",
                    "str",
                    "list[T]",
                    "Optional[int]",
                    "int",
                    "None"
                ],
                "vocabulary": [
                    "list[allennlp.data.tokenizers.token.Token]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "set[str]",
                    "int",
                    "allennlp.data.tokenizers.token.Token",
                    "typing.Iterator",
                    "List[allennlp.data.tokenizers.token.Token]",
                    "Set[str]",
                    "bool",
                    "Iterator[str]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 105,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 110,
            "return": [
                "list[]",
                "str",
                "int",
                "tuple",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ELMoTokenCharactersIndexer._default_value_for_padding": {
            "name": "_default_value_for_padding",
            "location": 114,
            "return": [
                "int",
                "str",
                "float",
                "set"
            ],
            "arguments": {}
        },
        "ELMoTokenCharactersIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 118,
            "return": [
                "int",
                "str",
                "Sequence[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "int",
                    "List[int]",
                    "list[int]",
                    "Dict[str, List[int]]",
                    "dict[str, list[int]]"
                ],
                "desired_num_tokens": [
                    "int",
                    "List[int]",
                    "list[int]",
                    "Dict[str, List[int]]",
                    "dict[str, list[int]]"
                ],
                "padding_lengths": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ]
            }
        },
        "ELMoTokenCharactersIndexer.from_params": {
            "name": "from_params",
            "location": 127,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "Type['Model']",
                    "typing.Type",
                    "dict",
                    "dict[, ]"
                ],
                "params": [
                    "allennlp.common.Params",
                    "cdp.util.T_JSON_DICT",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/ner_tag_indexer.py": {
        "NerTagIndexer.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "NerTagIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "list[str]",
                    "Dict[str, Dict[str, int]]",
                    "typing.Counter",
                    "List[str]",
                    "dict[, ]",
                    "Counter",
                    "dict"
                ],
                "counter": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "List[tracim.models.data.Content]",
                    "list[tracim.models.data.Content]",
                    "List[dict]",
                    "list[dict[, ]]"
                ]
            }
        },
        "NerTagIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 38,
            "return": [
                "bool",
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str",
                    "allennlp.data.tokenizers.token.Token",
                    "bool",
                    "dict[, ]",
                    "dict",
                    "list[int]",
                    "List[int]"
                ],
                "vocabulary": []
            }
        },
        "NerTagIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 45,
            "return": [
                "int",
                "str",
                "tuple",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NerTagIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 49,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "NerTagIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 53,
            "return": [
                "int",
                "str",
                "Sequence[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "desired_num_tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "padding_lengths": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ]
            }
        },
        "NerTagIndexer.from_params": {
            "name": "from_params",
            "location": 60,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "Type['Model']",
                    "typing.Type",
                    "dict",
                    "dict[, ]"
                ],
                "params": [
                    "allennlp.common.Params",
                    "cdp.util.T_JSON_DICT",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/pos_tag_indexer.py": {
        "PosTagIndexer.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "int",
                    "bool",
                    "str",
                    "List[List[str]]"
                ],
                "coarse_tags": [
                    "bool",
                    "int",
                    "List[str]"
                ]
            }
        },
        "PosTagIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str",
                    "allennlp.data.tokenizers.token.Token",
                    "typesystem.tokenize.tokens.Token"
                ],
                "counter": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "List[tracim.models.data.Content]",
                    "list[tracim.models.data.Content]",
                    "List[dict]",
                    "list[dict[, ]]"
                ]
            }
        },
        "PosTagIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 49,
            "return": [
                "bool",
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[str, typing.Any]",
                    "int",
                    "allennlp.data.tokenizers.token.Token",
                    "Dict[str, Any]",
                    "as3.scanner.Token"
                ],
                "vocabulary": []
            }
        },
        "PosTagIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 59,
            "return": [
                "int",
                "str",
                "tuple",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PosTagIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 63,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "PosTagIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 67,
            "return": [
                "int",
                "str",
                "Sequence[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "desired_num_tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "padding_lengths": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ]
            }
        },
        "PosTagIndexer.from_params": {
            "name": "from_params",
            "location": 74,
            "return": [
                "str",
                "Optional[str]",
                "Iterable[str]",
                "dict",
                "bool"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "cdp.util.T_JSON_DICT",
                    "Dict[str, Any]",
                    "bool",
                    "Exception",
                    "Optional[Dict[str, int]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/single_id_token_indexer.py": {
        "SingleIdTokenIndexer.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "str",
                    "List[str]",
                    "Sequence"
                ],
                "lowercase_tokens": [
                    "bool",
                    "str",
                    "List[str]",
                    "Sequence"
                ]
            }
        },
        "SingleIdTokenIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "list[Token]",
                    "Dict[str, Dict[str, int]]",
                    "List[Token]"
                ],
                "counter": [
                    "Callable[[list], None]",
                    "typing.Callable[list[], None]"
                ]
            }
        },
        "SingleIdTokenIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 41,
            "return": [
                "str",
                "int",
                "Optional[str]",
                "IO[Any]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "None",
                    "allennlp.data.tokenizers.token.Token",
                    "dict[, ]",
                    "Optional[gcloud.aio.auth.Token]",
                    "dict",
                    "Iterable[as3.scanner.Token]"
                ],
                "vocabulary": [
                    "str",
                    "allennlp.data.tokenizers.token.Token"
                ]
            }
        },
        "SingleIdTokenIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 54,
            "return": [
                "int",
                "str",
                "tuple",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SingleIdTokenIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 58,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "SingleIdTokenIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 62,
            "return": [
                "int",
                "str",
                "Sequence[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "desired_num_tokens": [
                    "List[int]",
                    "int",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "padding_lengths": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ]
            }
        },
        "SingleIdTokenIndexer.from_params": {
            "name": "from_params",
            "location": 69,
            "return": [
                "str",
                "dict",
                "Callable",
                "Union[str, Dict]"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "allennlp.common.Params",
                    "int",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/token_characters_indexer.py": {
        "TokenCharactersIndexer.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "namespace": [
                    "typing.Text",
                    "int",
                    "bool",
                    "float"
                ],
                "character_tokenizer": [
                    "CharacterTokenizer",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "TokenCharactersIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "dict[, ]",
                    "Dict[str, Dict[str, int]]",
                    "None",
                    "Optional[Dict]",
                    "typing.Callable[str,str, str]",
                    "Callable[[str, str], str]",
                    "object"
                ],
                "counter": [
                    "Callable[[list], None]",
                    "typing.Callable[list[], None]"
                ]
            }
        },
        "TokenCharactersIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 49,
            "return": [
                "list[]",
                "str",
                "int",
                "Optional[str]",
                "IO[Any]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[int, str]",
                    "Dict[int, str]",
                    "str",
                    "list[T]",
                    "List[spacy.tokens.Token]",
                    "allennlp.data.tokenizers.token.Token"
                ],
                "vocabulary": [
                    "str",
                    "allennlp.data.tokenizers.token.Token"
                ]
            }
        },
        "TokenCharactersIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 64,
            "return": [
                "dict[typing.Text, int]",
                "str",
                "Optional[str]",
                "Optional[bool]",
                "int",
                "Optional[Dict[str, str]]"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "List[int]",
                    "str"
                ]
            }
        },
        "TokenCharactersIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 68,
            "return": [
                "list[]",
                "str",
                "int",
                "tuple",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenCharactersIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 72,
            "return": [
                "list[list[]]",
                "int",
                "List[str]",
                "Optional[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[int]",
                    "list[int]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]",
                    "list",
                    "list[]",
                    "List[List[int]]",
                    "list[list[int]]"
                ],
                "desired_num_tokens": [
                    "int",
                    "List[List[Any]]",
                    "list[list[typing.Any]]",
                    "Dict[int, Dict[int, Any]]",
                    "dict[int, dict[int, typing.Any]]",
                    "Dict[int, List[Any]]",
                    "dict[int, list[typing.Any]]",
                    "Dict[int, List[int]]",
                    "dict[int, list[int]]",
                    "Dict[int, Dict[int, int]]",
                    "dict[int, dict[int, int]]"
                ],
                "padding_lengths": [
                    "list[int]",
                    "int",
                    "List[int]",
                    "Dict[str, List[int]]",
                    "Dict[int, List[int]]"
                ]
            }
        },
        "TokenCharactersIndexer.from_params": {
            "name": "from_params",
            "location": 96,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [],
                "params": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/token_indexer.py": {
        "TokenIndexer.count_vocab_items": {
            "name": "count_vocab_items",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "Dict[str, Dict[str, int]]"
                ],
                "counter": [
                    "dict[str, dict[str, int]]",
                    "allennlp.data.tokenizers.token.Token",
                    "Dict[str, Dict[str, int]]"
                ]
            }
        },
        "TokenIndexer.token_to_indices": {
            "name": "token_to_indices",
            "location": 33,
            "return": [
                "TokenType",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "list[allennlp.data.tokenizers.token.Token]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "set[str]",
                    "int",
                    "allennlp.data.tokenizers.token.Token",
                    "typing.Iterator",
                    "List[allennlp.data.tokenizers.token.Token]",
                    "Set[str]",
                    "bool",
                    "Iterator[str]"
                ],
                "vocabulary": [
                    "list[allennlp.data.tokenizers.token.Token]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "set[str]",
                    "int",
                    "allennlp.data.tokenizers.token.Token",
                    "typing.Iterator",
                    "List[allennlp.data.tokenizers.token.Token]",
                    "Set[str]",
                    "bool",
                    "Iterator[str]"
                ]
            }
        },
        "TokenIndexer.get_padding_token": {
            "name": "get_padding_token",
            "location": 41,
            "return": [
                "TokenType",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenIndexer.get_padding_lengths": {
            "name": "get_padding_lengths",
            "location": 48,
            "return": [
                "typing.Dict[builtins.str, builtins.int]",
                "None"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "TokenIndexer.pad_token_sequence": {
            "name": "pad_token_sequence",
            "location": 57,
            "return": [
                "typing.List[TokenType]",
                "None"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ],
                "desired_num_tokens": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ],
                "padding_lengths": [
                    "Dict[str, int]",
                    "int",
                    "dict[str, int]"
                ]
            }
        },
        "TokenIndexer.from_params": {
            "name": "from_params",
            "location": 73,
            "return": [
                "str",
                "List[int]",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "Type[T]",
                    "Dict[str, Any]",
                    "Optional[str]"
                ],
                "params": [
                    "int",
                    "Type[T]",
                    "typing.Type",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        },
        "TokenIndexer.dict_from_params": {
            "name": "dict_from_params",
            "location": 78,
            "return": [
                "str",
                "dict[typing.Union[tuple[typing.Union[str,typing.Any]],tuple[bytes]], ]",
                "Dict[str, Any]",
                "None"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "int",
                    "Optional[str]"
                ],
                "params": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "dict[bytes, bytes]",
                    "dict[str, str]",
                    "Dict[str, Any]",
                    "Dict[bytes, bytes]",
                    "Dict[str, str]",
                    "List[T]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/data/token_indexers/__init__.py": {},
    "allennlp-dureader-master/allennlp/dureader/dataloader.py": {
        "BRCDataLoader.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [],
                "batch_size": [
                    "int"
                ],
                "shuffle": [
                    "bool"
                ],
                "sampler": [
                    "None"
                ],
                "batch_sampler": [
                    "None"
                ],
                "num_workers": [
                    "int"
                ],
                "pin_memory": [
                    "bool"
                ],
                "drop_last": [
                    "bool"
                ]
            }
        },
        "BRCDataLoader._collate_fn": {
            "name": "_collate_fn",
            "location": 21,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "batch": []
            }
        },
        "BRCDataLoader._pad_sequence": {
            "name": "_pad_sequence",
            "location": 71,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "sequences": [],
                "pad_length": [],
                "pad_value": [
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/dureader/dataset.py": {
        "display": {
            "name": "display",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "message": []
            }
        },
        "BRCDataset.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "max_p_num": [],
                "max_p_len": [],
                "max_q_len": [],
                "is_train": [],
                "files": [],
                "rank": [
                    "int"
                ],
                "world_size": [
                    "int"
                ],
                "keep_raw": [
                    "bool"
                ]
            }
        },
        "BRCDataset._load_dataset": {
            "name": "_load_dataset",
            "location": 59,
            "return": [],
            "arguments": {
                "self": [],
                "data_path": [],
                "train": [
                    "bool"
                ]
            }
        },
        "BRCDataset.__len__": {
            "name": "__len__",
            "location": 142,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BRCDataset.__getitem__": {
            "name": "__getitem__",
            "location": 145,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "idx": []
            }
        },
        "BRCDataset._one_mini_batch": {
            "name": "_one_mini_batch",
            "location": 185,
            "return": [],
            "arguments": {
                "self": [],
                "data": [],
                "indices": [],
                "pad_id": []
            }
        },
        "BRCDataset._dynamic_padding": {
            "name": "_dynamic_padding",
            "location": 230,
            "return": [
                "Tuple[(_T0, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "batch_data": [
                    "_T0"
                ],
                "pad_id": []
            }
        },
        "BRCDataset.word_iter": {
            "name": "word_iter",
            "location": 242,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "self": [],
                "set_name": [
                    "None"
                ]
            }
        },
        "BRCDataset.convert_to_ids": {
            "name": "convert_to_ids",
            "location": 269,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/dureader/vocab.py": {
        "Vocab.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "bool",
                    "None",
                    "str",
                    "Optional[str]",
                    "Optional[List[str]]",
                    "list[str]"
                ],
                "initial_tokens": [
                    "int",
                    "None",
                    "str",
                    "bool",
                    "Optional[\"Page\"]"
                ],
                "lower": [
                    "bool",
                    "str",
                    "Optional[int]",
                    "List[str]",
                    "int"
                ]
            }
        },
        "Vocab.size": {
            "name": "size",
            "location": 51,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocab.load_from_file": {
            "name": "load_from_file",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "Vocab.get_id": {
            "name": "get_id",
            "location": 69,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str"
                ]
            }
        },
        "Vocab.get_token": {
            "name": "get_token",
            "location": 83,
            "return": [
                "Optional[str]",
                "List[str]",
                "str",
                "Dict[str, Dict[str, str]]",
                "bool",
                "Dict[str, Type[Any]]"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "str",
                    "List[str]",
                    "list[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "Vocab.add": {
            "name": "add",
            "location": 96,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "token": [
                    "str",
                    "bytes"
                ],
                "cnt": [
                    "int",
                    "Optional[Tuple[int, ...]]",
                    "Union[int, numpy.ndarray]",
                    "List[int]",
                    "dict"
                ]
            }
        },
        "Vocab.filter_tokens_by_cnt": {
            "name": "filter_tokens_by_cnt",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "min_cnt": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "Vocab.randomly_init_embeddings": {
            "name": "randomly_init_embeddings",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embed_dim": [
                    "List[int]",
                    "str",
                    "list[int]",
                    "int",
                    "List[List[T]]",
                    "list[list[T]]"
                ]
            }
        },
        "Vocab.load_pretrained_embeddings": {
            "name": "load_pretrained_embeddings",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding_path": [
                    "str"
                ]
            }
        },
        "Vocab.convert_to_ids": {
            "name": "convert_to_ids",
            "location": 174,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Vocab.recover_from_ids": {
            "name": "recover_from_ids",
            "location": 185,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "ids": [
                    "str",
                    "Optional[int]",
                    "bool",
                    "Optional[float]",
                    "float"
                ],
                "stop_id": [
                    "str",
                    "None",
                    "Optional[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/archival.py": {
        "archive_model": {
            "name": "archive_model",
            "location": 35,
            "return": [
                "None",
                "app.models.Article",
                "Iterator[Dict[str, str]]",
                "str"
            ],
            "arguments": {
                "serialization_dir": [
                    "str",
                    "bool"
                ],
                "weights": [
                    "str",
                    "int"
                ],
                "files_to_archive": [
                    "dict[str, str]",
                    "Dict[str, str]",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        },
        "load_archive": {
            "name": "load_archive",
            "location": 86,
            "return": [
                "Archive",
                "str",
                "int",
                "Mapping[str, str]",
                "dict"
            ],
            "arguments": {
                "archive_file": [
                    "str",
                    "int",
                    "bool"
                ],
                "cuda_device": [
                    "int",
                    "str"
                ],
                "overrides": [
                    "typing.Text",
                    "str",
                    "src.pip_shims.models.ShimmedPathCollection"
                ],
                "weights_file": [
                    "str",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/biattentive_classification_network.py": {
        "BiattentiveClassificationNetwork.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Callable[..., Awaitable]",
                    "dict",
                    "int"
                ],
                "text_field_embedder": [
                    "allennlp.modules.Seq2SeqEncoder",
                    "allennlp.modules.FeedForward",
                    "bool"
                ],
                "embedding_dropout": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "pre_encode_feedforward": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "encoder": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "integrator": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "integrator_dropout": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "output_layer": [
                    "int",
                    "allennlp.modules.Seq2SeqEncoder",
                    "bytes",
                    "Type[users.models.CustomUser]",
                    "float"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "regularizer": [
                    "None",
                    "bool",
                    "int",
                    "Tuple[float, float]"
                ]
            }
        },
        "BiattentiveClassificationNetwork.forward": {
            "name": "forward",
            "location": 119,
            "return": [
                "dict[typing.Text, ]",
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[str]",
                    "Union[int, float]",
                    "str",
                    "Dict[str, torch.LongTensor]",
                    "numpy.ndarray",
                    "List[torch.Tensor]",
                    "List[List[allennlp.semparse.domain_languages.NlvrLanguage]]",
                    "List[int]"
                ],
                "label": [
                    "None",
                    "Collection[int]",
                    "torch.LongTensor",
                    "Optional[numpy.ndarray]",
                    "List[Set[int]]"
                ]
            }
        },
        "BiattentiveClassificationNetwork.decode": {
            "name": "decode",
            "location": 190,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "dict"
                ]
            }
        },
        "BiattentiveClassificationNetwork.get_metrics": {
            "name": "get_metrics",
            "location": 203,
            "return": [
                "dict[, ]",
                "bool",
                "dict",
                "Dict[str, Any]",
                "int",
                "multinedb.models.workspace.Workspace"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "BiattentiveClassificationNetwork.from_params": {
            "name": "from_params",
            "location": 207,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Iterable[int]",
                    "allennlp.data.Dataset",
                    "str"
                ],
                "vocab": [
                    "bool",
                    "salon.models.Stylist"
                ],
                "params": [
                    "allennlp.common.Params",
                    "allennlp.common.params.Params",
                    "cdp.util.T_JSON_DICT"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/constituency_parser.py": {
        "SpanConstituencyParser.__init__": {
            "name": "__init__",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Optional[bool]",
                    "bool",
                    "str",
                    "Optional[Dict[str, str]]"
                ],
                "text_field_embedder": [
                    "allennlp.modules.Seq2SeqEncoder",
                    "int",
                    "Optional[int]"
                ],
                "span_extractor": [
                    "List[bool]",
                    "int",
                    "str"
                ],
                "encoder": [
                    "bool",
                    "Optional[float]",
                    "int"
                ],
                "feedforward_layer": [
                    "bool",
                    "None"
                ],
                "pos_tag_embedding": [
                    "None",
                    "bool",
                    "allennlp.modules.Embedding",
                    "Optional[int]",
                    "set",
                    "str",
                    "Iterable"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "regularizer": [
                    "None",
                    "Callable[[Optional, Optional, str], None]",
                    "Optional[bool]",
                    "int",
                    "List[str]"
                ],
                "evalb_directory_path": [
                    "None",
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "SpanConstituencyParser.forward": {
            "name": "forward",
            "location": 125,
            "return": [
                "dict[typing.Text, list[]]",
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "torch.Tensor",
                    "str",
                    "Tuple[int, int]",
                    "int"
                ],
                "spans": [
                    "int",
                    "bool",
                    "List[int]",
                    "bytes"
                ],
                "metadata": [
                    "Sequence[int]",
                    "dict",
                    "Dict[str, Any]"
                ],
                "pos_tags": [
                    "None",
                    "Optional[str]",
                    "Iterable[Any]",
                    "Iterable[float]",
                    "bool"
                ],
                "span_labels": [
                    "torch.LongTensor",
                    "List[Set[int]]",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "SpanConstituencyParser.decode": {
            "name": "decode",
            "location": 236,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "dict",
                    "Dict[str, Any]",
                    "str",
                    "Optional[dict]"
                ]
            }
        },
        "SpanConstituencyParser.construct_trees": {
            "name": "construct_trees",
            "location": 261,
            "return": [
                "list[]",
                "Optional[\"TreeNode\"]",
                "app.models.Question",
                "Optional[Dict[str, Any]]",
                "str",
                "BaseException"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.FloatTensor",
                    "List[List[str]]",
                    "bool",
                    "Optional[float]",
                    "str"
                ],
                "all_spans": [
                    "torch.FloatTensor",
                    "List[List[str]]",
                    "bool",
                    "Optional[float]",
                    "str"
                ],
                "num_spans": [
                    "torch.LongTensor",
                    "int",
                    "float",
                    "Iterable[str]"
                ],
                "sentences": [
                    "torch.FloatTensor",
                    "List[List[str]]",
                    "bool",
                    "Optional[float]",
                    "str"
                ],
                "pos_tags": [
                    "None",
                    "bool",
                    "int",
                    "stiff.models.TokenizedTagging",
                    "List[Tuple[Any, int]]"
                ]
            }
        },
        "SpanConstituencyParser.resolve_overlap_conflicts_greedily": {
            "name": "resolve_overlap_conflicts_greedily",
            "location": 333,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "spans": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "Iterable[str]",
                    "Set[str]"
                ]
            }
        },
        "SpanConstituencyParser.construct_tree_from_spans": {
            "name": "construct_tree_from_spans",
            "location": 387,
            "return": [
                "bytes",
                "float",
                "dict"
            ],
            "arguments": {
                "spans_to_labels": [
                    "List[str]",
                    "Dict[Tuple[int, int], str]",
                    "allennlp.data.Instance",
                    "allennlp.common.util.JsonDict",
                    "bool",
                    "int"
                ],
                "sentence": [
                    "List[str]",
                    "list",
                    "int",
                    "List[pymatgen.util.Vector3Like]",
                    "List[int]",
                    "List[list]",
                    "Dict[str, Dict[str, Any]]",
                    "Tuple[int, int]",
                    "List[Tuple[int, int]]"
                ],
                "pos_tags": [
                    "None",
                    "List[str]",
                    "Dict[Tuple[int, int], str]",
                    "allennlp.data.Instance",
                    "allennlp.common.util.JsonDict",
                    "bool",
                    "int"
                ]
            }
        },
        "SpanConstituencyParser.get_metrics": {
            "name": "get_metrics",
            "location": 452,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "Callable"
                ]
            }
        },
        "SpanConstituencyParser.from_params": {
            "name": "from_params",
            "location": 461,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]"
                ],
                "vocab": [
                    "jumeaux.models.Res2ResAddOnPayload"
                ],
                "params": [
                    "allennlp.common.Params",
                    "cdp.util.T_JSON_DICT",
                    "Dict[str, Any]"
                ]
            }
        },
        "SpanConstituencyParser.construct_tree_from_spans.assemble_subtree": {
            "name": "assemble_subtree",
            "location": 405,
            "return": [
                "list[Tree]",
                "str",
                "nevergrad.common.Any",
                "app.models.Question"
            ],
            "arguments": {
                "start": [
                    "int",
                    "List[str]",
                    "Set[str]",
                    "str"
                ],
                "end": [
                    "int",
                    "Set[str]",
                    "Union[str, list]",
                    "List[str]",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/crf_tagger.py": {
        "CrfTagger.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "None",
                    "int",
                    "Optional[allennlp.nn.RegularizerApplicator]",
                    "typing.Iterable[T]",
                    "Iterable[T]",
                    "allennlp.data.Vocabulary",
                    "allennlp.nn.InitializerApplicator"
                ],
                "text_field_embedder": [
                    "allennlp.modules.Seq2SeqEncoder",
                    "allennlp.modules.FeedForward",
                    "bool",
                    "int"
                ],
                "encoder": [
                    "bool",
                    "str",
                    "Optional[Sequence[str]]",
                    "Optional[Callable]",
                    "allennlp.data.vocabulary.Vocabulary"
                ],
                "label_namespace": [
                    "typing.Text",
                    "allennlp.modules.Seq2SeqEncoder",
                    "bool",
                    "str",
                    "Tuple[int]"
                ],
                "constraint_type": [
                    "None",
                    "Optional[float]",
                    "str",
                    "float",
                    "Optional[str]",
                    "Optional[int]",
                    "int",
                    "bool"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "bool",
                    "int",
                    "float"
                ],
                "regularizer": [
                    "None",
                    "bool",
                    "Optional[allennlp.nn.RegularizerApplicator]",
                    "allennlp.data.vocabulary.Vocabulary"
                ]
            }
        },
        "CrfTagger.forward": {
            "name": "forward",
            "location": 76,
            "return": [
                "dict[typing.Text, typing.Union[str,set[str],list[str],tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]]]]",
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str",
                    "BaseException",
                    "Optional[str]",
                    "bool",
                    "None"
                ],
                "tags": [
                    "torch.LongTensor",
                    "None",
                    "Optional[dict]",
                    "dict[, ]",
                    "Optional[Any]",
                    "typing.Any",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "CrfTagger.decode": {
            "name": "decode",
            "location": 135,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "Dict[str, Any]"
                ]
            }
        },
        "CrfTagger.get_metrics": {
            "name": "get_metrics",
            "location": 150,
            "return": [
                "dict[typing.Union[tuple[typing.Union[str,float]],tuple[typing.Union[str,int]]], typing.Union[tuple[typing.Union[str,float]],tuple[typing.Union[str,int]]]]",
                "List[str]",
                "List[Dict[str, str]]",
                "bool",
                "List[Tuple[Any, ...]]",
                "list",
                "int"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "dict",
                    "Tuple[str]",
                    "str",
                    "Type[T]"
                ]
            }
        },
        "CrfTagger.from_params": {
            "name": "from_params",
            "location": 155,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]",
                    "dict[str, typing.Union[int,bool]]"
                ],
                "vocab": [
                    "bool",
                    "salon.models.Stylist"
                ],
                "params": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]",
                    "allennlp.common.params.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/decomposable_attention.py": {
        "DecomposableAttention.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "Optional[float]",
                    "Callable[[float], float]",
                    "float",
                    "Optional[int]"
                ],
                "text_field_embedder": [
                    "allennlp.modules.FeedForward",
                    "allennlp.modules.Seq2SeqEncoder",
                    "bool",
                    "allennlp.modules.TextFieldEmbedder"
                ],
                "attend_feedforward": [
                    "zerver.models.Realm",
                    "float",
                    "int"
                ],
                "similarity_function": [
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "compare_feedforward": [
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "aggregate_feedforward": [
                    "allennlp.modules.Seq2SeqEncoder",
                    "torch.Tensor",
                    "Union[str, int]"
                ],
                "premise_encoder": [
                    "None",
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "hypothesis_encoder": [
                    "None",
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "regularizer": [
                    "None",
                    "str",
                    "bool",
                    "Optional[float]"
                ]
            }
        },
        "DecomposableAttention.forward": {
            "name": "forward",
            "location": 95,
            "return": [
                "dict[typing.Text, ]",
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "premise": [
                    "dict",
                    "Dict[str, torch.Tensor]",
                    "Optional[torch.Tensor]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "Dict[\"core.Edge\", \"state.State\"]"
                ],
                "hypothesis": [
                    "dict",
                    "Dict[str, torch.Tensor]",
                    "Optional[torch.Tensor]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "Dict[\"core.Edge\", \"state.State\"]"
                ],
                "label": [
                    "None",
                    "jumeaux.models.JudgementAddOnReference",
                    "owlmixin.owlTDict[jumeaux.models.DiffKeys]",
                    "zerver.models.Stream",
                    "bool",
                    "Optional[bool]"
                ]
            }
        },
        "DecomposableAttention.get_metrics": {
            "name": "get_metrics",
            "location": 174,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str",
                    "models.Telegram_Chat",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "DecomposableAttention.from_params": {
            "name": "from_params",
            "location": 180,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]"
                ],
                "vocab": [
                    "bool",
                    "salon.models.Stylist"
                ],
                "params": [
                    "dict",
                    "Optional['models.LTI1p3Provider']",
                    "Dict[str, Any]",
                    "str",
                    "allennlp.common.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/ensemble.py": {
        "Ensemble.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "submodels": [
                    "list[str]",
                    "str",
                    "Optional[List[str]]",
                    "audiopyle.lib.models.file_meta.AudioFileMeta"
                ]
            }
        },
        "Ensemble._load": {
            "name": "_load",
            "location": 34,
            "return": [
                "model.Model",
                "GPy.models.GPRegression",
                "base.Model",
                "model.SockeyeModel",
                "invgp.model.GP",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "None",
                    "allennlp.common.params.Params",
                    "bool",
                    "Optional[str]"
                ],
                "config": [
                    "dict[str, str]",
                    "Dict[str, str]",
                    "dict[, ]",
                    "bool",
                    "Optional[str]",
                    "Optional[Dict]"
                ],
                "serialization_dir": [
                    "str",
                    "int",
                    "None",
                    "allennlp.common.params.Params",
                    "bool",
                    "Optional[str]"
                ],
                "weights_file": [
                    "str",
                    "None",
                    "int",
                    "allennlp.common.params.Params",
                    "bool",
                    "Optional[str]"
                ],
                "cuda_device": [
                    "int",
                    "str",
                    "bool",
                    "Optional[List[Any]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/model.py": {
        "remove_pretrained_embedding_params": {
            "name": "remove_pretrained_embedding_params",
            "location": 277,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "params": [
                    "Mapping",
                    "Dict[str, Type]",
                    "Mapping[str, str]",
                    "Optional[Tuple[str, ...]]",
                    "allennlp.common.JsonDict"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "bool",
                    "float"
                ],
                "regularizer": [
                    "None",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Model.get_regularization_penalty": {
            "name": "get_regularization_penalty",
            "location": 54,
            "return": [
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.get_parameters_for_histogram_tensorboard_logging": {
            "name": "get_parameters_for_histogram_tensorboard_logging",
            "location": 64,
            "return": [
                "list[]",
                "List[str]",
                "Iterable[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.forward": {
            "name": "forward",
            "location": 71,
            "return": [
                "typing.Dict[builtins.str, torch.Tensor]",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.forward_on_instance": {
            "name": "forward_on_instance",
            "location": 112,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "instance": [
                    "Optional[int]",
                    "float",
                    "bool",
                    "torch.LongTensor",
                    "Optional[str]",
                    "str"
                ],
                "cuda_device": [
                    "Optional[int]",
                    "float",
                    "bool",
                    "torch.LongTensor",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "Model.forward_on_instances": {
            "name": "forward_on_instances",
            "location": 122,
            "return": [
                "list[dict[, ]]",
                "List[int]",
                "str"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "bytes",
                    "str",
                    "int"
                ],
                "cuda_device": [
                    "List[dict]",
                    "str"
                ]
            }
        },
        "Model.decode": {
            "name": "decode",
            "location": 160,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "Sequence[T]",
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "Model.get_metrics": {
            "name": "get_metrics",
            "location": 177,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ]
            }
        },
        "Model.from_params": {
            "name": "from_params",
            "location": 193,
            "return": [
                "allennlp.models.model.Model",
                "int",
                "denite.util.UserContext"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "Dict[str, Any]",
                    "bool",
                    "util.freefocus.sql.Task"
                ],
                "vocab": [
                    "cdp.util.T_JSON_DICT",
                    "Dict[str, Any]"
                ],
                "params": [
                    "dict",
                    "Dict[str, Any]",
                    "bool",
                    "util.freefocus.sql.Task"
                ]
            }
        },
        "Model._load": {
            "name": "_load",
            "location": 199,
            "return": [
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Union[str, os.PathLike]",
                    "int",
                    "allennlp.common.params.Params",
                    "bool",
                    "Optional[str]"
                ],
                "config": [
                    "Dict[str, str]",
                    "bool",
                    "Optional[str]",
                    "Optional[Dict]"
                ],
                "serialization_dir": [
                    "str",
                    "Optional[dict]",
                    "Optional[str]",
                    "int"
                ],
                "weights_file": [
                    "None",
                    "str",
                    "bool",
                    "Tuple[int, int]",
                    "Iterable[Any]"
                ],
                "cuda_device": [
                    "int",
                    "TextIO",
                    "Optional[str]",
                    "List[allennlp.data.tokenizers.token.Token]",
                    "str"
                ]
            }
        },
        "Model.load": {
            "name": "load",
            "location": 235,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, str]",
                    "allennlp.common.params.Params",
                    "Iterable[str]",
                    "bool",
                    "Optional[Dict]"
                ],
                "config": [
                    "dict",
                    "allennlp.common.params.Params",
                    "str",
                    "Dict[str, str]"
                ],
                "serialization_dir": [
                    "str",
                    "Dict[str, str]",
                    "allennlp.common.params.Params",
                    "Iterable[str]",
                    "bool",
                    "Optional[Dict]"
                ],
                "weights_file": [
                    "None",
                    "str",
                    "Dict[str, str]",
                    "allennlp.common.params.Params",
                    "Iterable[str]",
                    "bool",
                    "Optional[Dict]"
                ],
                "cuda_device": [
                    "int",
                    "str",
                    "Dict[str, str]",
                    "allennlp.common.params.Params",
                    "Iterable[str]",
                    "bool",
                    "Optional[Dict]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/semantic_role_labeler.py": {
        "write_to_conll_eval_file": {
            "name": "write_to_conll_eval_file",
            "location": 224,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "prediction_file": [
                    "TextIO",
                    "bytes",
                    "str",
                    "int"
                ],
                "gold_file": [
                    "TextIO",
                    "bytes",
                    "str",
                    "int"
                ],
                "verb_index": [
                    "Optional[int]",
                    "bool",
                    "str",
                    "Optional[str]",
                    "float"
                ],
                "sentence": [
                    "bool",
                    "Callable",
                    "str",
                    "Sequence[T]"
                ],
                "prediction": [
                    "str"
                ],
                "gold_labels": [
                    "str",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "convert_bio_tags_to_conll_format": {
            "name": "convert_bio_tags_to_conll_format",
            "location": 269,
            "return": [
                "list[typing.Text]",
                "str",
                "List[str]",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "labels": [
                    "List[str]",
                    "Tuple[int]",
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "SemanticRoleLabeler.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "Optional[int]",
                    "Mapping[str, Tuple[float, float, float]]"
                ],
                "text_field_embedder": [
                    "allennlp.modules.Seq2SeqEncoder",
                    "allennlp.modules.FeedForward"
                ],
                "encoder": [
                    "allennlp.data.Vocabulary",
                    "allennlp.modules.Seq2SeqEncoder",
                    "int",
                    "Optional[allennlp.nn.RegularizerApplicator]",
                    "float"
                ],
                "binary_feature_dim": [
                    "Callable"
                ],
                "embedding_dropout": [
                    "float",
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "regularizer": [
                    "None",
                    "bool",
                    "int",
                    "Tuple[float, float]"
                ],
                "label_smoothing": [
                    "None",
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ]
            }
        },
        "SemanticRoleLabeler.forward": {
            "name": "forward",
            "location": 82,
            "return": [
                "dict[typing.Text, ]",
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "Dict[str, torch.LongTensor]",
                    "Dict[str, torch.Tensor]",
                    "Optional[torch.Tensor]"
                ],
                "verb_indicator": [
                    "List[List[int]]",
                    "str",
                    "List[str]",
                    "torch.IntTensor"
                ],
                "tags": [
                    "None",
                    "Collection[int]",
                    "torch.Tensor",
                    "Union[str, bool]",
                    "torch.LongTensor",
                    "List[Set[int]]"
                ]
            }
        },
        "SemanticRoleLabeler.decode": {
            "name": "decode",
            "location": 151,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "int"
                ]
            }
        },
        "SemanticRoleLabeler.get_metrics": {
            "name": "get_metrics",
            "location": 174,
            "return": [
                "dict[, ]",
                "List[str]",
                "List[Dict[str, str]]",
                "bool",
                "List[Tuple[Any, ...]]",
                "list",
                "int"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "dict",
                    "Tuple[str]",
                    "str",
                    "Type[T]"
                ]
            }
        },
        "SemanticRoleLabeler.get_viterbi_pairwise_potentials": {
            "name": "get_viterbi_pairwise_potentials",
            "location": 180,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabeler.from_params": {
            "name": "from_params",
            "location": 206,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]",
                    "dict"
                ],
                "vocab": [
                    "bool",
                    "salon.models.Stylist"
                ],
                "params": [
                    "allennlp.common.Params",
                    "Dict[str, Any]",
                    "Mapping",
                    "Type['Declared']"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/simple_tagger.py": {
        "SimpleTagger.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "allennlp.data.Vocabulary",
                    "Callable[..., Awaitable]",
                    "str",
                    "Optional[float]",
                    "Dict[str, Set[str]]"
                ],
                "text_field_embedder": [
                    "allennlp.modules.Seq2SeqEncoder",
                    "allennlp.modules.FeedForward",
                    "bool"
                ],
                "encoder": [
                    "allennlp.data.Vocabulary",
                    "allennlp.modules.Seq2SeqEncoder",
                    "int",
                    "Optional[allennlp.nn.RegularizerApplicator]",
                    "float"
                ],
                "initializer": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "regularizer": [
                    "str",
                    "Callable[..., Awaitable]",
                    "bool",
                    "Sequence[str]",
                    "Type[Any]",
                    "Optional[Type[Any]]"
                ]
            }
        },
        "SimpleTagger.forward": {
            "name": "forward",
            "location": 63,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "BinaryIO",
                    "str"
                ],
                "tags": [
                    "torch.LongTensor",
                    "Optional[str]",
                    "str",
                    "Tuple[str, Optional[str]]",
                    "Optional[Any]"
                ]
            }
        },
        "SimpleTagger.decode": {
            "name": "decode",
            "location": 118,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "dict"
                ]
            }
        },
        "SimpleTagger.get_metrics": {
            "name": "get_metrics",
            "location": 139,
            "return": [
                "bool",
                "dict",
                "Dict[str, Any]",
                "int",
                "multinedb.models.workspace.Workspace"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "SimpleTagger.from_params": {
            "name": "from_params",
            "location": 143,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]"
                ],
                "vocab": [
                    "bool",
                    "salon.models.Stylist"
                ],
                "params": [
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/__init__.py": {},
    "allennlp-dureader-master/allennlp/models/coreference_resolution/coref.py": {
        "CoreferenceResolver.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "Callable[..., Awaitable]",
                    "bool",
                    "Sequence[str]",
                    "Type[Any]",
                    "Optional[Type[Any]]"
                ],
                "text_field_embedder": [
                    "int",
                    "float",
                    "bool",
                    "gluonts.model.common.Tensor"
                ],
                "context_layer": [
                    "int",
                    "float",
                    "busboy.model.Stop",
                    "gluonts.model.common.Tensor"
                ],
                "mention_feedforward": [
                    "Optional[float]",
                    "float"
                ],
                "antecedent_feedforward": [
                    "Optional[float]",
                    "float"
                ],
                "feature_size": [
                    "int",
                    "str"
                ],
                "max_span_width": [
                    "int",
                    "str"
                ],
                "spans_per_word": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "max_antecedents": [
                    "int",
                    "torch.Tensor",
                    "Tuple[float, float]"
                ],
                "lexical_dropout": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "initializer": [
                    "bool",
                    "int",
                    "tuple",
                    "Optional[float]"
                ],
                "regularizer": [
                    "str",
                    "Callable[..., Awaitable]",
                    "bool",
                    "Sequence[str]",
                    "Type[Any]",
                    "Optional[Type[Any]]"
                ]
            }
        },
        "CoreferenceResolver.forward": {
            "name": "forward",
            "location": 113,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "spans": [
                    "str",
                    "int",
                    "Tuple[int, int, int]"
                ],
                "span_labels": [
                    "str",
                    "Optional[str]"
                ],
                "metadata": [
                    "str",
                    "tuple",
                    "zerver.models.Realm",
                    "zerver.models.UserProfile"
                ]
            }
        },
        "CoreferenceResolver.decode": {
            "name": "decode",
            "location": 292,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]"
                ]
            }
        },
        "CoreferenceResolver.get_metrics": {
            "name": "get_metrics",
            "location": 370,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "Optional[bool]",
                    "Optional[int]",
                    "List[int]",
                    "int"
                ]
            }
        },
        "CoreferenceResolver._generate_valid_antecedents": {
            "name": "_generate_valid_antecedents",
            "location": 380,
            "return": [
                "bool",
                "Sequence[str]"
            ],
            "arguments": {
                "num_spans_to_keep": [
                    "Optional[int]",
                    "int",
                    "Dict[int, dict]",
                    "float"
                ],
                "max_antecedents": [
                    "Optional[int]",
                    "int",
                    "float",
                    "Dict[int, dict]"
                ],
                "device": [
                    "float"
                ]
            }
        },
        "CoreferenceResolver._compute_span_pair_embeddings": {
            "name": "_compute_span_pair_embeddings",
            "location": 442,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "top_span_embeddings": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "antecedent_embeddings": [
                    "List['cirq.Qid']",
                    "oanda.models.Price",
                    "float"
                ],
                "antecedent_offsets": [
                    "int",
                    "str",
                    "torch.utils.data.DataLoader",
                    "Optional[int]",
                    "float"
                ]
            }
        },
        "CoreferenceResolver._compute_antecedent_gold_labels": {
            "name": "_compute_antecedent_gold_labels",
            "location": 497,
            "return": [
                "int",
                "ajapaik.ajapaik.models.Album",
                "dict",
                "str",
                "list"
            ],
            "arguments": {
                "top_span_labels": [
                    "int",
                    "Hashable",
                    "allennlp.data.vocabulary.Vocabulary"
                ],
                "antecedent_labels": [
                    "bytes",
                    "torch.Tensor"
                ]
            }
        },
        "CoreferenceResolver._compute_coreference_scores": {
            "name": "_compute_coreference_scores",
            "location": 536,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "pairwise_embeddings": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "top_span_mention_scores": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "antecedent_mention_scores": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "antecedent_log_mask": [
                    "torch.FloatTensor",
                    "int",
                    "gluonts.model.common.NPArrayLike",
                    "torch.Tensor",
                    "List[allennlp.data.iterators.data_iterator.TensorDict]"
                ]
            }
        },
        "CoreferenceResolver.from_params": {
            "name": "from_params",
            "location": 586,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]"
                ],
                "vocab": [
                    "bool",
                    "salon.models.Stylist"
                ],
                "params": [
                    "allennlp.common.Params",
                    "allennlp.common.params.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/coreference_resolution/__init__.py": {},
    "allennlp-dureader-master/allennlp/models/encoder_decoders/simple_seq2seq.py": {
        "SimpleSeq2Seq.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "dict",
                    "str"
                ],
                "source_embedder": [
                    "str",
                    "bokeh.models.ColumnDataSource",
                    "fonduer.parser.models.table.Cell"
                ],
                "encoder": [
                    "int",
                    "str",
                    "Optional[str]",
                    "float",
                    "list"
                ],
                "max_decoding_steps": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "List[str]"
                ],
                "target_namespace": [
                    "str",
                    "int",
                    "Dict[str, int]",
                    "autorecurse.gnumake.data.Makefile",
                    "bool"
                ],
                "target_embedding_dim": [
                    "Tuple[int, int]",
                    "int"
                ],
                "attention_function": [
                    "int",
                    "str",
                    "Optional[str]",
                    "float",
                    "list"
                ],
                "scheduled_sampling_ratio": [
                    "int",
                    "str",
                    "Optional[str]",
                    "float",
                    "list"
                ]
            }
        },
        "SimpleSeq2Seq.forward": {
            "name": "forward",
            "location": 108,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "source_tokens": [
                    "int",
                    "Dict[str, Any]",
                    "allennlp.data.Vocabulary",
                    "List[Dict[str, Any]]",
                    "Tuple[str]"
                ],
                "target_tokens": [
                    "Tuple[str]",
                    "Optional[str]",
                    "Dict[str, torch.LongTensor]",
                    "int"
                ]
            }
        },
        "SimpleSeq2Seq._prepare_decode_step_input": {
            "name": "_prepare_decode_step_input",
            "location": 185,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_indices": [
                    "int",
                    "bool",
                    "torch.IntTensor",
                    "Callable",
                    "allennlp.data.iterators.data_iterator.DataIterator"
                ],
                "decoder_hidden_state": [
                    "model.BoundingBox",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "str",
                    "int",
                    "bytes"
                ],
                "encoder_outputs": [
                    "model.BoundingBox",
                    "bytes",
                    "str",
                    "List[Set[int]]",
                    "Optional[Tuple[int, ...]]"
                ],
                "encoder_outputs_mask": [
                    "int",
                    "torch.LongTensor",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray",
                    "List[str]",
                    "List[allennlp.semparse.domain_languages.WikiTablesLanguage]"
                ]
            }
        },
        "SimpleSeq2Seq._get_loss": {
            "name": "_get_loss",
            "location": 230,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "logits": [
                    "str",
                    "bool"
                ],
                "targets": [
                    "str",
                    "Tuple[int, int]",
                    "Callable[[], object]",
                    "models.characters.mods_base.Mod",
                    "int"
                ],
                "target_mask": [
                    "int",
                    "autorecurse.gnumake.data.Makefile",
                    "slice",
                    "str",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "SimpleSeq2Seq.decode": {
            "name": "decode",
            "location": 262,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "output_dict": [
                    "Dict[str, torch.Tensor]",
                    "Callable[..., None]",
                    "magic.models.Deck",
                    "Exception"
                ]
            }
        },
        "SimpleSeq2Seq.from_params": {
            "name": "from_params",
            "location": 287,
            "return": [
                "Dict[str, str]",
                "django.db.models.Field",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "int",
                    "audiopyle.lib.models.compressed_feature.CompressedFeatureDTO"
                ],
                "vocab": [
                    "MutableMapping[str, Any]",
                    "Iterable[allennlp.data.instance.Instance]",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "zam_repondeur.models.Lecture"
                ],
                "params": [
                    "videoarchiver.tvasahi.models.Episode",
                    "salon.models.Stylist",
                    "Optional[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/encoder_decoders/__init__.py": {},
    "allennlp-dureader-master/allennlp/models/reading_comprehension/bidaf.py": {
        "BidirectionalAttentionFlow.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "bool",
                    "int"
                ],
                "text_field_embedder": [
                    "int",
                    "bool",
                    "Optional[float]"
                ],
                "num_highway_layers": [
                    "Optional[bool]",
                    "List[str]",
                    "models.User"
                ],
                "phrase_layer": [
                    "int",
                    "str",
                    "bool",
                    "torch.device",
                    "Optional[str]"
                ],
                "attention_similarity_function": [
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "bool",
                    "Optional[List[Any]]"
                ],
                "modeling_layer": [
                    "Optional[bool]",
                    "Optional[recidiviz.common.constants.state.state_incarceration_period.StateIncarcerationPeriodAdmissionReason]",
                    "List[str]",
                    "models.transaction.EndorsedTX"
                ],
                "span_end_encoder": [
                    "int",
                    "List[int]",
                    "Optional[recidiviz.common.constants.state.state_incarceration_period.StateIncarcerationPeriodAdmissionReason]",
                    "bool",
                    "models.transaction.EndorsedTX"
                ],
                "dropout": [
                    "float",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "bool",
                    "Optional[List[Any]]"
                ],
                "mask_lstms": [
                    "bool",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "Optional[List[Any]]"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "bool",
                    "Optional[List[Any]]"
                ],
                "regularizer": [
                    "None",
                    "bool",
                    "int"
                ]
            }
        },
        "BidirectionalAttentionFlow.forward": {
            "name": "forward",
            "location": 118,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "Dict[str, torch.LongTensor]",
                    "bool",
                    "int",
                    "float"
                ],
                "passage": [
                    "Dict[str, torch.LongTensor]",
                    "bool",
                    "int",
                    "float"
                ],
                "span_start": [
                    "None",
                    "Optional[List[int]]",
                    "torch.device",
                    "torch.IntTensor",
                    "bool",
                    "float"
                ],
                "span_end": [
                    "int",
                    "str",
                    "tuple",
                    "Optional[bool]",
                    "Tuple[int]",
                    "torch.nn.modules.rnn.GRUCell"
                ],
                "metadata": [
                    "None",
                    "List[Dict[str, Any]]",
                    "float",
                    "bool",
                    "nevergrad.common.Optional[nevergrad.common.Any]"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_metrics": {
            "name": "get_metrics",
            "location": 291,
            "return": [
                "dict[typing.Text, ]",
                "bool",
                "Optional[str]",
                "list",
                "int",
                "str",
                "Union[str, int]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "slice",
                    "int",
                    "float"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_best_span": {
            "name": "get_best_span",
            "location": 302,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "span_start_logits": [
                    "torch.Tensor",
                    "torch.autograd.Variable",
                    "int",
                    "float",
                    "apps.common.coininfo.CoinInfo"
                ],
                "span_end_logits": [
                    "torch.Tensor",
                    "int",
                    "torch.autograd.Variable",
                    "List[str]",
                    "List[int]",
                    "float"
                ]
            }
        },
        "BidirectionalAttentionFlow.from_params": {
            "name": "from_params",
            "location": 330,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]",
                    "Optional[str]",
                    "Tuple[Optional[float], Optional[float]]",
                    "Iterable[allennlp.data.instance.Instance]"
                ],
                "vocab": [
                    "bool"
                ],
                "params": [
                    "Mapping[str, object]",
                    "Type",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/reading_comprehension/bidaf_ensemble.py": {
        "ensemble": {
            "name": "ensemble",
            "location": 121,
            "return": [
                "str",
                "int",
                "float",
                "users.models.CustomUser",
                "bool",
                "Optional[bytes]",
                "torch.nn.Module"
            ],
            "arguments": {
                "subresults": [
                    "float",
                    "bool"
                ]
            }
        },
        "BidafEnsemble.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "submodels": [
                    "bool",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Callable[[Any, Any], bool]",
                    "typing.Callable[A, bool]"
                ]
            }
        },
        "BidafEnsemble.forward": {
            "name": "forward",
            "location": 29,
            "return": [
                "list[]",
                "str",
                "list[str]",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "int",
                    "str",
                    "nevergrad.common.Optional[int]",
                    "None"
                ],
                "passage": [
                    "int",
                    "str",
                    "nevergrad.common.Optional[int]",
                    "None"
                ],
                "span_start": [
                    "int",
                    "None",
                    "str",
                    "nevergrad.common.Optional[int]"
                ],
                "span_end": [
                    "int",
                    "None",
                    "str",
                    "nevergrad.common.Optional[int]"
                ],
                "metadata": [
                    "float",
                    "None",
                    "int",
                    "torch.Tensor",
                    "typing.Collection",
                    "Optional[int]",
                    "Collection[int]"
                ]
            }
        },
        "BidafEnsemble.get_metrics": {
            "name": "get_metrics",
            "location": 102,
            "return": [
                "dict[typing.Text, typing.Union[str,float]]",
                "str",
                "IO[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "dict",
                    "str"
                ]
            }
        },
        "BidafEnsemble.from_params": {
            "name": "from_params",
            "location": 110,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "vocab": [
                    "int",
                    "dict[str, typing.Any]",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "str",
                    "bytes"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/reading_comprehension/dureader_bidaf.py": {
        "BidirectionalAttentionFlow.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "bool",
                    "int"
                ],
                "text_field_embedder": [
                    "int",
                    "bool",
                    "Optional[float]"
                ],
                "num_highway_layers": [
                    "Optional[bool]",
                    "List[str]",
                    "models.User"
                ],
                "phrase_layer": [
                    "int",
                    "str",
                    "bool",
                    "torch.device",
                    "Optional[str]"
                ],
                "attention_similarity_function": [
                    "numpy.ndarray",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "bool",
                    "Optional[List[Any]]"
                ],
                "modeling_layer": [
                    "Optional[bool]",
                    "Optional[recidiviz.common.constants.state.state_incarceration_period.StateIncarcerationPeriodAdmissionReason]",
                    "List[str]",
                    "models.transaction.EndorsedTX"
                ],
                "span_end_encoder": [
                    "int",
                    "List[int]",
                    "Optional[recidiviz.common.constants.state.state_incarceration_period.StateIncarcerationPeriodAdmissionReason]",
                    "bool",
                    "models.transaction.EndorsedTX"
                ],
                "dropout": [
                    "float",
                    "numpy.ndarray",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "bool",
                    "Optional[List[Any]]"
                ],
                "mask_lstms": [
                    "bool",
                    "numpy.ndarray",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "Optional[List[Any]]"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "numpy.ndarray",
                    "Callable",
                    "Callable[..., None]",
                    "int",
                    "bool",
                    "Optional[List[Any]]"
                ],
                "regularizer": [
                    "None",
                    "bool",
                    "int"
                ]
            }
        },
        "BidirectionalAttentionFlow.apply_concat_mask_fn": {
            "name": "apply_concat_mask_fn",
            "location": 123,
            "return": [
                "deoplete.util.UserContext",
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "vector": [
                    "int",
                    "nevergrad.common.Optional[int]",
                    "tuple",
                    "str",
                    "float",
                    "Tuple[int]"
                ],
                "mask": [
                    "int",
                    "Optional[int]"
                ],
                "batch_size": [
                    "int",
                    "str",
                    "float",
                    "Sequence"
                ],
                "fn": [
                    "int",
                    "bool",
                    "Tuple[int, int]",
                    "dict",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "BidirectionalAttentionFlow.forward": {
            "name": "forward",
            "location": 152,
            "return": [
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "question": [
                    "Dict[str, torch.LongTensor]",
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "passage": [
                    "Dict[str, torch.LongTensor]",
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "float"
                ],
                "span_start": [
                    "None",
                    "bool",
                    "torch.device",
                    "int"
                ],
                "span_end": [
                    "float",
                    "numpy.ndarray",
                    "str"
                ],
                "metadata": [
                    "None",
                    "bool",
                    "static_frame.core.util.DepthLevelSpecifier",
                    "Callable"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_metrics": {
            "name": "get_metrics",
            "location": 349,
            "return": [
                "dict[typing.Text, ]",
                "bool",
                "Optional[str]",
                "list",
                "int",
                "str",
                "Union[str, int]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "slice",
                    "int",
                    "float"
                ]
            }
        },
        "BidirectionalAttentionFlow.get_best_span": {
            "name": "get_best_span",
            "location": 360,
            "return": [
                "tuple[]",
                "Callable",
                "bool",
                "int"
            ],
            "arguments": {
                "span_start_logits": [
                    "torch.Tensor",
                    "torch.autograd.Variable",
                    "int",
                    "list"
                ],
                "span_end_logits": [
                    "torch.Tensor",
                    "int",
                    "torch.autograd.Variable",
                    "List[str]",
                    "List[int]",
                    "float"
                ]
            }
        },
        "BidirectionalAttentionFlow.from_params": {
            "name": "from_params",
            "location": 388,
            "return": [
                "bool",
                "str",
                "Match[str]",
                "dict",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Union[int, bool]]",
                    "Optional[str]",
                    "Tuple[Optional[float], Optional[float]]",
                    "Iterable[allennlp.data.instance.Instance]"
                ],
                "vocab": [
                    "bool"
                ],
                "params": [
                    "Mapping[str, object]",
                    "Type",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/models/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/alternating_highway_lstm.py": {
        "_AlternatingHighwayLSTMFunction.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "train": [
                    "bool"
                ]
            }
        },
        "_AlternatingHighwayLSTMFunction.forward": {
            "name": "forward",
            "location": 22,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor",
                    "allennlp.state_machines.states.CoverageState",
                    "allennlp.nn.decoding.decoder_step.DecoderStep",
                    "List[int]",
                    "allennlp.state_machines.states.GrammarBasedState",
                    "Optional[dict]",
                    "bytes"
                ],
                "weight": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ],
                "bias": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ],
                "state_accumulator": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ],
                "memory_accumulator": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ],
                "dropout_mask": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ],
                "lengths": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ],
                "gates": [
                    "float",
                    "torch.Tensor",
                    "List[int]",
                    "List[Set[int]]",
                    "int"
                ]
            }
        },
        "_AlternatingHighwayLSTMFunction.backward": {
            "name": "backward",
            "location": 62,
            "return": [
                "tuple[None]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "grad_output": [
                    "bytes",
                    "str",
                    "torch.Tensor"
                ],
                "grad_hy": [
                    "bytes",
                    "str",
                    "torch.Tensor"
                ]
            }
        },
        "AlternatingHighwayLSTM.__init__": {
            "name": "__init__",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ]
            }
        },
        "AlternatingHighwayLSTM.reset_parameters": {
            "name": "reset_parameters",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AlternatingHighwayLSTM.forward": {
            "name": "forward",
            "location": 209,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "Optional[Tuple[int, ...]]"
                ],
                "initial_state": [
                    "BaseException",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/attention.py": {
        "Attention.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "similarity_function": [
                    "allennlp.modules.similarity_functions.similarity_function.SimilarityFunction"
                ],
                "normalize": [
                    "bool"
                ]
            }
        },
        "Attention.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "vector": [
                    "bool",
                    "torch.Tensor",
                    "float",
                    "Optional[torch.Tensor]"
                ],
                "matrix": [
                    "float",
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Optional[List[str]]",
                    "bool"
                ],
                "matrix_mask": [
                    "int",
                    "None",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "Attention.from_params": {
            "name": "from_params",
            "location": 64,
            "return": [
                "Attention"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "dict",
                    "allennlp.common.Params",
                    "Dict[str, Any]",
                    "Type['Model']"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/augmented_lstm.py": {
        "AugmentedLstm.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "go_forward": [
                    "bool"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "use_highway": [
                    "bool"
                ],
                "use_input_projection_bias": [
                    "bool"
                ]
            }
        },
        "AugmentedLstm.reset_parameters": {
            "name": "reset_parameters",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AugmentedLstm.forward": {
            "name": "forward",
            "location": 95,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "Dict[str, Any]",
                    "torch.Tensor"
                ],
                "initial_state": [
                    "Optional[Tuple[(Any, Any)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/conditional_random_field.py": {
        "allowed_transitions": {
            "name": "allowed_transitions",
            "location": 13,
            "return": [
                "List[Tuple[(int, int)]]"
            ],
            "arguments": {
                "constraint_type": [
                    "str"
                ],
                "tokens": [
                    "Dict[(int, str)]"
                ]
            }
        },
        "ConditionalRandomField.__init__": {
            "name": "__init__",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_tags": [
                    "int"
                ],
                "constraints": [
                    "List[Tuple[(int, int)]]"
                ]
            }
        },
        "ConditionalRandomField.reset_parameters": {
            "name": "reset_parameters",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConditionalRandomField._input_likelihood": {
            "name": "_input_likelihood",
            "location": 113,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "torch.Tensor",
                    "float"
                ],
                "mask": [
                    "torch.Tensor",
                    "int"
                ]
            }
        },
        "ConditionalRandomField._joint_likelihood": {
            "name": "_joint_likelihood",
            "location": 153,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "str",
                    "Optional[str]",
                    "torch.Tensor",
                    "int",
                    "bool"
                ],
                "tags": [
                    "Dict[str, Any]",
                    "Mapping",
                    "Optional[str]",
                    "str",
                    "Tuple[List[str], Optional[Any]]",
                    "Union[str, List[str]]"
                ],
                "mask": [
                    "torch.LongTensor",
                    "float"
                ]
            }
        },
        "ConditionalRandomField.forward": {
            "name": "forward",
            "location": 218,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "Optional[bool]",
                    "dict"
                ],
                "tags": [
                    "torch.Tensor",
                    "float",
                    "torch.ByteTensor",
                    "Optional[torch.ByteTensor]",
                    "Iterable[Any]"
                ],
                "mask": [
                    "None",
                    "torch.ByteTensor",
                    "Optional[str]",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "ConditionalRandomField.viterbi_tags": {
            "name": "viterbi_tags",
            "location": 234,
            "return": [
                "List[List[int]]"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "torch.Tensor",
                    "int",
                    "float"
                ],
                "mask": [
                    "torch.Tensor",
                    "str",
                    "Union[str, Exception]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/elmo.py": {
        "Elmo.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str",
                    "Optional[str]",
                    "int",
                    "bool"
                ],
                "weight_file": [
                    "str",
                    "Optional[str]",
                    "int",
                    "bool"
                ],
                "num_output_representations": [
                    "int",
                    "Optional[int]",
                    "str",
                    "float"
                ],
                "requires_grad": [
                    "bool",
                    "str",
                    "List[str]",
                    "Container[str]"
                ],
                "do_layer_norm": [
                    "bool",
                    "float",
                    "int",
                    "bytes",
                    "str",
                    "Type[numpy.number]"
                ],
                "dropout": [
                    "float",
                    "str",
                    "int",
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]",
                    "Optional[str]"
                ],
                "module": [
                    "None",
                    "str",
                    "bool",
                    "int",
                    "Optional[List[str]]",
                    "numpy.ndarray",
                    "Optional[str]"
                ]
            }
        },
        "Elmo.forward": {
            "name": "forward",
            "location": 90,
            "return": [
                "dict[typing.Text, list[]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor",
                    "str",
                    "int"
                ]
            }
        },
        "Elmo.from_params": {
            "name": "from_params",
            "location": 144,
            "return": [
                "str",
                "List[Tuple[str, str]]"
            ],
            "arguments": {
                "cls": [
                    "static_frame.core.util.PathSpecifier"
                ],
                "params": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "_ElmoCharacterEncoder.__init__": {
            "name": "__init__",
            "location": 198,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str",
                    "Union[str, bytes, int]",
                    "Optional[str]"
                ],
                "weight_file": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Callable[[float], None]"
                ],
                "requires_grad": [
                    "bool",
                    "int"
                ]
            }
        },
        "_ElmoCharacterEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 221,
            "return": [
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder.forward": {
            "name": "forward",
            "location": 225,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "numpy.ndarray",
                "dict",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor"
                ]
            }
        },
        "_ElmoCharacterEncoder._load_weights": {
            "name": "_load_weights",
            "location": 298,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_char_embedding": {
            "name": "_load_char_embedding",
            "location": 304,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_cnn_weights": {
            "name": "_load_cnn_weights",
            "location": 318,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_highway": {
            "name": "_load_highway",
            "location": 350,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ElmoCharacterEncoder._load_projection": {
            "name": "_load_projection",
            "location": 379,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ElmoBiLm.__init__": {
            "name": "__init__",
            "location": 412,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "str",
                    "List[str]"
                ],
                "weight_file": [
                    "str",
                    "Container[str]",
                    "List[str]",
                    "bool",
                    "Callable[[int, int], None]"
                ],
                "requires_grad": [
                    "bool",
                    "str",
                    "Container[str]",
                    "Callable[[int, int], None]",
                    "Optional[str]"
                ]
            }
        },
        "_ElmoBiLm.forward": {
            "name": "forward",
            "location": 435,
            "return": [
                "dict[typing.Text, list[]]",
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/elmo_lstm.py": {
        "ElmoLstm.__init__": {
            "name": "__init__",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "cell_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "requires_grad": [
                    "bool"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "memory_cell_clip_value": [
                    "Optional[float]"
                ],
                "state_projection_clip_value": [
                    "Optional[float]"
                ]
            }
        },
        "ElmoLstm.forward": {
            "name": "forward",
            "location": 103,
            "return": [
                "List[int]",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Dict[str, Any]",
                    "str",
                    "Callable"
                ],
                "mask": [
                    "torch.LongTensor",
                    "dict",
                    "Optional[str]",
                    "float"
                ]
            }
        },
        "ElmoLstm._lstm_forward": {
            "name": "_lstm_forward",
            "location": 162,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bool",
                    "torch.nn.utils.rnn.PackedSequence",
                    "torch.Tensor",
                    "bytes",
                    "List[List[int]]"
                ],
                "initial_state": [
                    "Optional[Tuple[(Any, Any)]]"
                ]
            }
        },
        "ElmoLstm.load_weights": {
            "name": "load_weights",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weight_file": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/encoder_base.py": {
        "_EncoderBase.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "stateful": [
                    "bool"
                ]
            }
        },
        "_EncoderBase.sort_and_run_forward": {
            "name": "sort_and_run_forward",
            "location": 33,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "Callable[([Any, Any], Tuple[(Any, Any)])]"
                ],
                "inputs": [
                    "torch.Tensor",
                    "int",
                    "str",
                    "float",
                    "bool",
                    "Optional[List[str]]"
                ],
                "mask": [
                    "torch.Tensor",
                    "int",
                    "str"
                ],
                "hidden_state": [
                    "None",
                    "Optional[str]",
                    "Optional[float]",
                    "Optional[static_frame.core.util.IndexConstructors]"
                ]
            }
        },
        "_EncoderBase._get_initial_states": {
            "name": "_get_initial_states",
            "location": 121,
            "return": [
                "None",
                "Optional[int]",
                "tuple[]",
                "Optional[str]",
                "Optional[Dict]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int"
                ],
                "num_valid": [
                    "int"
                ],
                "sorting_indices": [
                    "raiden.utils.Secret",
                    "raiden.utils.PaymentAmount",
                    "raiden.utils.SecretHash",
                    "raiden.utils.PaymentID",
                    "raiden.utils.BlockTimeout",
                    "raiden.utils.TargetAddress",
                    "raiden.utils.TokenNetworkAddress",
                    "raiden.utils.FeeAmount"
                ]
            }
        },
        "_EncoderBase._update_states": {
            "name": "_update_states",
            "location": 209,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "final_states": [
                    "tuple"
                ],
                "restoration_indices": []
            }
        },
        "_EncoderBase.reset_states": {
            "name": "reset_states",
            "location": 289,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/feedforward.py": {
        "FeedForward.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "hidden_dims": [
                    "Union[(int, Sequence[int])]"
                ],
                "activations": [
                    "Union[(allennlp.nn.activations.Activation, Sequence[allennlp.nn.activations.Activation])]"
                ],
                "dropout": [
                    "Union[(float, Sequence[float])]"
                ]
            }
        },
        "FeedForward.get_output_dim": {
            "name": "get_output_dim",
            "location": 69,
            "return": [
                "Union[(int, Sequence[int])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FeedForward.get_input_dim": {
            "name": "get_input_dim",
            "location": 72,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "FeedForward.forward": {
            "name": "forward",
            "location": 75,
            "return": [
                "str",
                "int",
                "Optional[str]",
                "typing.Pattern",
                "bytes",
                "typing.Callable[, ]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "FeedForward.from_params": {
            "name": "from_params",
            "location": 83,
            "return": [
                "FeedForward"
            ],
            "arguments": {
                "cls": [
                    "Type[_TFeedForward]"
                ],
                "params": [
                    "int",
                    "str",
                    "bool",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/highway.py": {
        "Highway.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "activation": [
                    "Callable[([Any], Any)]"
                ]
            }
        },
        "Highway.forward": {
            "name": "forward",
            "location": 49,
            "return": [
                "int",
                "str",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str",
                    "Callable"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/layer_norm.py": {
        "LayerNorm.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dimension": [
                    "int"
                ],
                "eps": [
                    "float"
                ]
            }
        },
        "LayerNorm.forward": {
            "name": "forward",
            "location": 35,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/lstm_cell_with_projection.py": {
        "LstmCellWithProjection.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "cell_size": [
                    "int"
                ],
                "go_forward": [
                    "bool"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "memory_cell_clip_value": [
                    "Optional[float]"
                ],
                "state_projection_clip_value": [
                    "Optional[float]"
                ]
            }
        },
        "LstmCellWithProjection.reset_parameters": {
            "name": "reset_parameters",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LstmCellWithProjection.forward": {
            "name": "forward",
            "location": 94,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor",
                    "List[deque]"
                ],
                "batch_lengths": [
                    "List[int]"
                ],
                "initial_state": [
                    "Optional[Tuple[(Any, Any)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/matrix_attention.py": {
        "MatrixAttention.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "similarity_function": [
                    "allennlp.modules.similarity_functions.similarity_function.SimilarityFunction"
                ]
            }
        },
        "MatrixAttention.forward": {
            "name": "forward",
            "location": 45,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "matrix_1": [
                    "torch.Tensor",
                    "int",
                    "Optional[torch.Tensor]",
                    "Optional[int]",
                    "bool",
                    "float"
                ],
                "matrix_2": [
                    "torch.Tensor",
                    "int",
                    "Optional[torch.Tensor]",
                    "Optional[int]",
                    "bool",
                    "float"
                ]
            }
        },
        "MatrixAttention.from_params": {
            "name": "from_params",
            "location": 60,
            "return": [
                "MatrixAttention"
            ],
            "arguments": {
                "cls": [
                    "Type[_TMatrixAttention]"
                ],
                "params": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict",
                    "Type['Model']"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/maxout.py": {
        "Maxout.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "output_dims": [
                    "Union[(int, Sequence[int])]"
                ],
                "pool_sizes": [
                    "Union[(int, Sequence[int])]"
                ],
                "dropout": [
                    "Union[(float, Sequence[float])]"
                ]
            }
        },
        "Maxout.get_output_dim": {
            "name": "get_output_dim",
            "location": 69,
            "return": [
                "Union[(int, Sequence[int])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Maxout.get_input_dim": {
            "name": "get_input_dim",
            "location": 72,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Maxout.forward": {
            "name": "forward",
            "location": 75,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "float",
                    "Optional[Union[str, Any]]",
                    "Callable",
                    "str",
                    "list",
                    "Union[int, slice]"
                ]
            }
        },
        "Maxout.from_params": {
            "name": "from_params",
            "location": 92,
            "return": [
                "Maxout"
            ],
            "arguments": {
                "cls": [
                    "Type[_TMaxout]"
                ],
                "params": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/scalar_mix.py": {
        "ScalarMix.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mixture_size": [
                    "int"
                ],
                "do_layer_norm": [
                    "bool"
                ]
            }
        },
        "ScalarMix.forward": {
            "name": "forward",
            "location": 26,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "list"
                ],
                "mask": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "ScalarMix.forward._do_layer_norm": {
            "name": "_do_layer_norm",
            "location": 43,
            "return": [
                "str",
                "Dict[str, int]",
                "float"
            ],
            "arguments": {
                "tensor": [
                    "bool",
                    "float",
                    "str",
                    "Optional[List[str]]",
                    "Optional[str]",
                    "Optional[bool]"
                ],
                "broadcast_mask": [
                    "int",
                    "Optional[float]",
                    "float"
                ],
                "num_elements_not_masked": [
                    "int",
                    "Optional[Sequence[str]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_pruner.py": {
        "SpanPruner.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scorer": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "SpanPruner.forward": {
            "name": "forward",
            "location": 25,
            "return": [
                "tuple[]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "span_embeddings": [
                    "int",
                    "float",
                    "str"
                ],
                "span_mask": [
                    "int",
                    "Union[float, int]",
                    "tuple",
                    "float"
                ],
                "num_spans_to_keep": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "tuple[]",
                    "bool",
                    "tuple"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/stacked_alternating_lstm.py": {
        "StackedAlternatingLstm.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_size": [
                    "int"
                ],
                "hidden_size": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "recurrent_dropout_probability": [
                    "float"
                ],
                "use_highway": [
                    "bool"
                ],
                "use_input_projection_bias": [
                    "bool"
                ]
            }
        },
        "StackedAlternatingLstm.forward": {
            "name": "forward",
            "location": 72,
            "return": [
                "Tuple[(Any, Generator[(Any, Any, None)])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.nn.utils.rnn.PackedSequence",
                    "typing.Any",
                    "str",
                    "Optional[Any]",
                    "None"
                ],
                "initial_state": [
                    "Optional[Tuple[(Any, Any)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/time_distributed.py": {
        "TimeDistributed.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "TimeDistributed.forward": {
            "name": "forward",
            "location": 23,
            "return": [
                "str",
                "int",
                "list[]",
                "Optional[str]",
                "dict[, ]",
                "typing.Iterator",
                "dict[typing.Any, int]",
                "list[str]",
                "list[list[str]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/intra_sentence_attention.py": {
        "IntraSentenceAttentionEncoder.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "bool",
                    "str",
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "projection_dim": [
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "similarity_function": [
                    "str",
                    "DotProductSimilarity"
                ],
                "num_attention_heads": [
                    "int",
                    "Optional[str]",
                    "Optional[int]",
                    "bool",
                    "float"
                ],
                "combination": [
                    "typing.Text",
                    "str",
                    "bool",
                    "Optional[str]",
                    "torch.device"
                ],
                "output_dim": [
                    "Optional[int]",
                    "None",
                    "int",
                    "Dict[str, int]",
                    "dict[str, int]",
                    "Dict[str, str]",
                    "dict[str, str]"
                ]
            }
        },
        "IntraSentenceAttentionEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 86,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntraSentenceAttentionEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 90,
            "return": [
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntraSentenceAttentionEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 94,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "IntraSentenceAttentionEncoder.forward": {
            "name": "forward",
            "location": 98,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "torch.Tensor",
                    "Dict[str, torch.Tensor]",
                    "int"
                ],
                "mask": [
                    "str",
                    "int",
                    "list[int]",
                    "allennlp.models.semantic_parsing.nlvr.nlvr_decoder_state.NlvrDecoderState",
                    "List[int]"
                ]
            }
        },
        "IntraSentenceAttentionEncoder.from_params": {
            "name": "from_params",
            "location": 142,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "allennlp.common.Params"
                ],
                "params": [
                    "Optional[torch.Tensor]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/multi_head_self_attention.py": {
        "MultiHeadSelfAttention.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_heads": [
                    "int",
                    "float",
                    "str"
                ],
                "input_dim": [
                    "int",
                    "float",
                    "Optional[float]",
                    "Optional[torch.nn.Module]"
                ],
                "attention_dim": [
                    "int",
                    "float",
                    "Union[int, float]",
                    "Optional[Union[int, float]]"
                ],
                "values_dim": [
                    "int",
                    "Optional[int]"
                ],
                "output_projection_dim": [
                    "int",
                    "None",
                    "bool"
                ],
                "attention_dropout_prob": [
                    "float",
                    "int",
                    "bool",
                    "Optional[\"GraphLogger\"]"
                ]
            }
        },
        "MultiHeadSelfAttention.get_input_dim": {
            "name": "get_input_dim",
            "location": 72,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttention.get_output_dim": {
            "name": "get_output_dim",
            "location": 75,
            "return": [
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttention.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 79,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttention.forward": {
            "name": "forward",
            "location": 83,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "torch.Tensor",
                    "List[List[int]]",
                    "bytes",
                    "str",
                    "bool",
                    "List[torch.Tensor]"
                ],
                "mask": [
                    "None",
                    "torch.LongTensor",
                    "bytes",
                    "list[int]",
                    "List[int]",
                    "Iterable[bool]"
                ]
            }
        },
        "MultiHeadSelfAttention.from_params": {
            "name": "from_params",
            "location": 156,
            "return": [
                "str",
                "int",
                "bool",
                "MutableMapping[str, Any]",
                "Iterable[int]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "typing.Sequence[str]",
                    "cdp.util.T_JSON_DICT",
                    "bool",
                    "Sequence[str]",
                    "_params.Params"
                ],
                "params": [
                    "common.ControllerData",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/pass_through_encoder.py": {
        "PassThroughEncoder.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "PassThroughEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 19,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PassThroughEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 23,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PassThroughEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 27,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PassThroughEncoder.forward": {
            "name": "forward",
            "location": 31,
            "return": [
                "int",
                "str",
                "Callable",
                "typing.Iterable['Context']"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "mask": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "PassThroughEncoder.from_params": {
            "name": "from_params",
            "location": 39,
            "return": [
                "PassThroughEncoder",
                "str",
                "Callable",
                "Callable[[None, None], bool]"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "allennlp.common.Params",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/pytorch_seq2seq_wrapper.py": {
        "PytorchSeq2SeqWrapper.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "int",
                    "Optional[int]"
                ],
                "stateful": [
                    "bool"
                ]
            }
        },
        "PytorchSeq2SeqWrapper.get_input_dim": {
            "name": "get_input_dim",
            "location": 56,
            "return": [
                "int",
                "Callable",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2SeqWrapper.get_output_dim": {
            "name": "get_output_dim",
            "location": 60,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2SeqWrapper.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 64,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2SeqWrapper.forward": {
            "name": "forward",
            "location": 68,
            "return": [
                "bool",
                "Optional[bytes]",
                "Optional[cmk.utils.type_defs.HostName]",
                "dict",
                "int"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bool",
                    "torch.Tensor"
                ],
                "mask": [
                    "tuple[typing.Union[torch.Tensor,torch.Tensor]]",
                    "torch.IntTensor",
                    "torch.Tensor",
                    "Optional[Tuple[torch.Tensor, torch.Tensor]]",
                    "torch.BoolTensor",
                    "torch.LongTensor"
                ],
                "hidden_state": [
                    "None",
                    "Optional[Tuple[torch.Tensor, torch.Tensor]]",
                    "tuple[typing.Union[torch.Tensor,torch.Tensor]]",
                    "Iterable[Callable]",
                    "dict[\"core.Edge\", S]",
                    "torch.IntTensor",
                    "Dict[\"core.Edge\", \"state.State\"]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/seq2seq_encoder.py": {
        "Seq2SeqEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2SeqEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 23,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2SeqEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 30,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2SeqEncoder.from_params": {
            "name": "from_params",
            "location": 39,
            "return": [
                "Seq2SeqEncoder"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSeq2SeqEncoder]"
                ],
                "params": [
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/stacked_self_attention.py": {
        "StackedSelfAttentionEncoder.__init__": {
            "name": "__init__",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "float",
                    "bool",
                    "None",
                    "Optional[float]"
                ],
                "hidden_dim": [
                    "float",
                    "int"
                ],
                "projection_dim": [
                    "Tuple[int, int]",
                    "int",
                    "tuple[typing.Union[int,int]]",
                    "float"
                ],
                "feedforward_hidden_dim": [
                    "float",
                    "int"
                ],
                "num_layers": [
                    "int",
                    "float"
                ],
                "num_attention_heads": [
                    "Tuple[int, int]",
                    "int",
                    "tuple[typing.Union[int,int]]",
                    "float"
                ],
                "use_positional_encoding": [
                    "bool"
                ],
                "dropout_prob": [
                    "float",
                    "int"
                ],
                "residual_dropout_prob": [
                    "float",
                    "int",
                    "bool"
                ],
                "attention_dropout_prob": [
                    "float",
                    "Tuple[int, int]",
                    "int"
                ]
            }
        },
        "StackedSelfAttentionEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 116,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "StackedSelfAttentionEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 120,
            "return": [
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "StackedSelfAttentionEncoder.is_bidirectional": {
            "name": "is_bidirectional",
            "location": 124,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "StackedSelfAttentionEncoder.forward": {
            "name": "forward",
            "location": 128,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "torch.Tensor",
                    "str",
                    "int"
                ],
                "mask": [
                    "int",
                    "torch.nn.utils.rnn.PackedSequence",
                    "bytes",
                    "list[tuple[typing.Union[int,int]]]",
                    "None",
                    "List[Tuple[int, int]]",
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "StackedSelfAttentionEncoder.from_params": {
            "name": "from_params",
            "location": 157,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "allennlp.data.Vocabulary",
                    "dict",
                    "Optional[bytes]",
                    "List[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2seq_encoders/__init__.py": {
        "_Seq2SeqWrapper.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module_class": [
                    "type"
                ]
            }
        },
        "_Seq2SeqWrapper.__call__": {
            "name": "__call__",
            "location": 69,
            "return": [
                "allennlp.modules.seq2seq_encoders.pytorch_seq2seq_wrapper.PytorchSeq2SeqWrapper"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Seq2SeqWrapper.from_params": {
            "name": "from_params",
            "location": 72,
            "return": [
                "allennlp.modules.seq2seq_encoders.pytorch_seq2seq_wrapper.PytorchSeq2SeqWrapper"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "bool",
                    "Optional[Exception]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/boe_encoder.py": {
        "BagOfEmbeddingsEncoder.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding_dim": [
                    "int",
                    "float",
                    "bool"
                ],
                "averaged": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "BagOfEmbeddingsEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 33,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "BagOfEmbeddingsEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 37,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BagOfEmbeddingsEncoder.forward": {
            "name": "forward",
            "location": 40,
            "return": [
                "int",
                "float",
                "Callable",
                "str",
                "dict[, ]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "torch.Tensor",
                    "Dict[str, torch.Tensor]",
                    "Sequence[Sequence[str]]",
                    "Sequence[Tuple[str, int]]",
                    "Dict[str, torch.LongTensor]"
                ],
                "mask": [
                    "None",
                    "torch.Tensor",
                    "torch.IntTensor",
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "BagOfEmbeddingsEncoder.from_params": {
            "name": "from_params",
            "location": 67,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "allennlp.common.Params",
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/cnn_encoder.py": {
        "CnnEncoder.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding_dim": [],
                "num_filters": [],
                "ngram_filter_sizes": [],
                "conv_layer_activation": [],
                "output_dim": [
                    "None"
                ]
            }
        },
        "CnnEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 79,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CnnEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 83,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "CnnEncoder.forward": {
            "name": "forward",
            "location": 86,
            "return": [],
            "arguments": {
                "self": [],
                "tokens": [],
                "mask": []
            }
        },
        "CnnEncoder.from_params": {
            "name": "from_params",
            "location": 120,
            "return": [],
            "arguments": {
                "cls": [],
                "params": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/pytorch_seq2vec_wrapper.py": {
        "PytorchSeq2VecWrapper.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "PytorchSeq2VecWrapper.get_input_dim": {
            "name": "get_input_dim",
            "location": 49,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2VecWrapper.get_output_dim": {
            "name": "get_output_dim",
            "location": 52,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PytorchSeq2VecWrapper.forward": {
            "name": "forward",
            "location": 59,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "None",
                    "Optional[torch.Tensor]",
                    "dict[str, torch.Tensor]",
                    "int",
                    "Dict[str, torch.Tensor]",
                    "dict[str, torch.LongTensor]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "Dict[str, Any]",
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]"
                ],
                "mask": [
                    "float",
                    "str",
                    "torch.Tensor",
                    "torch.IntTensor",
                    "torch.BoolTensor",
                    "nevergrad.common.Union[str, float]",
                    "gluonts.model.common.Tensor"
                ],
                "hidden_state": [
                    "None",
                    "Optional[torch.Tensor]",
                    "dict[str, torch.Tensor]",
                    "int",
                    "Dict[str, torch.Tensor]",
                    "dict[str, torch.LongTensor]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "Dict[str, Any]",
                    "torch.Tensor",
                    "Dict[str, torch.LongTensor]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/seq2vec_encoder.py": {
        "Seq2VecEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2VecEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 23,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2VecEncoder.from_params": {
            "name": "from_params",
            "location": 31,
            "return": [
                "Seq2VecEncoder"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSeq2VecEncoder]"
                ],
                "params": [
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/seq2vec_encoders/__init__.py": {
        "_Seq2VecWrapper.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module_class": [
                    "type"
                ]
            }
        },
        "_Seq2VecWrapper.__call__": {
            "name": "__call__",
            "location": 61,
            "return": [
                "allennlp.modules.seq2vec_encoders.pytorch_seq2vec_wrapper.PytorchSeq2VecWrapper"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Seq2VecWrapper.from_params": {
            "name": "from_params",
            "location": 64,
            "return": [
                "allennlp.modules.seq2vec_encoders.pytorch_seq2vec_wrapper.PytorchSeq2VecWrapper"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "Optional[Exception]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/bilinear.py": {
        "BilinearSimilarity.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1_dim": [
                    "int",
                    "typing.Collection",
                    "Collection[T]",
                    "list['Node']",
                    "dict[, ]",
                    "torch.nn.Module",
                    "nevergrad.common.Any",
                    "List['Node']",
                    "dict"
                ],
                "tensor_2_dim": [
                    "int",
                    "typing.Collection",
                    "Collection[T]",
                    "list['Node']",
                    "dict[, ]",
                    "torch.nn.Module",
                    "nevergrad.common.Any",
                    "List['Node']",
                    "dict"
                ],
                "activation": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "BilinearSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BilinearSimilarity.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "List[int]",
                "Dict[str, int]",
                "List[dict]"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "tensor_2": [
                    "str",
                    "bool"
                ]
            }
        },
        "BilinearSimilarity.from_params": {
            "name": "from_params",
            "location": 52,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "Tuple[Optional[float], Optional[float]]",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/cosine.py": {
        "CosineSimilarity.forward": {
            "name": "forward",
            "location": 15,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "str",
                    "bytearray",
                    "bool",
                    "float",
                    "Tuple[int, int]"
                ],
                "tensor_2": [
                    "str",
                    "bytearray",
                    "bool",
                    "float",
                    "Tuple[int, int]"
                ]
            }
        },
        "CosineSimilarity.from_params": {
            "name": "from_params",
            "location": 21,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "dict[, ]",
                    "allennlp.common.Params",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/dot_product.py": {
        "DotProductSimilarity.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scale_output": [
                    "bool",
                    "torch.nn.utils.rnn.PackedSequence",
                    "int",
                    "bytes"
                ]
            }
        },
        "DotProductSimilarity.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "Callable"
                ],
                "tensor_2": [
                    "bool",
                    "str"
                ]
            }
        },
        "DotProductSimilarity.from_params": {
            "name": "from_params",
            "location": 34,
            "return": [
                "str",
                "Optional[float]",
                "bool",
                "bytes"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "dict[, ]"
                ],
                "params": [
                    "Dict[str, Any]",
                    "Exception",
                    "dict",
                    "allennlp.common.params.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/linear.py": {
        "LinearSimilarity.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1_dim": [
                    "str",
                    "int",
                    "typing.TextIO",
                    "torch.Tensor",
                    "TextIO"
                ],
                "tensor_2_dim": [
                    "str",
                    "int",
                    "typing.TextIO",
                    "torch.Tensor",
                    "TextIO"
                ],
                "combination": [
                    "typing.Text",
                    "str",
                    "Optional[bool]",
                    "Optional[int]",
                    "List[int]"
                ],
                "activation": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "LinearSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 59,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinearSimilarity.forward": {
            "name": "forward",
            "location": 65,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "tensor_2": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "LinearSimilarity.from_params": {
            "name": "from_params",
            "location": 71,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "defaultdict",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/multiheaded.py": {
        "MultiHeadedSimilarity.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_heads": [
                    "int"
                ],
                "tensor_1_dim": [
                    "int",
                    "Dict[str, Tuple[str, str, Any]]",
                    "dict[str, tuple[typing.Union[str,str,typing.Any]]]",
                    "tuple",
                    "str",
                    "tuple[]",
                    "Optional[Any]",
                    "typing.Any",
                    "bool",
                    "None"
                ],
                "tensor_1_projected_dim": [
                    "int",
                    "None",
                    "Optional[float]",
                    "float"
                ],
                "tensor_2_dim": [
                    "str",
                    "None",
                    "bool",
                    "int",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "list",
                    "list[]"
                ],
                "tensor_2_projected_dim": [
                    "int",
                    "None",
                    "Optional[float]",
                    "float"
                ],
                "internal_similarity": [
                    "DotProductSimilarity",
                    "int",
                    "float",
                    "Optional[List[Any]]",
                    "apps.common.coininfo.CoinInfo"
                ]
            }
        },
        "MultiHeadedSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadedSimilarity.forward": {
            "name": "forward",
            "location": 77,
            "return": [
                "int",
                "torch.FloatTensor",
                "str",
                "List[int]",
                "List[allennlp.data.iterators.data_iterator.TensorDict]",
                "gluonts.model.common.NPArrayLike"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "str",
                    "Iterable[T]",
                    "typing.Iterable[T]"
                ],
                "tensor_2": [
                    "str",
                    "Iterable[T]",
                    "typing.Iterable[T]"
                ]
            }
        },
        "MultiHeadedSimilarity.from_params": {
            "name": "from_params",
            "location": 97,
            "return": [
                "str",
                "int",
                "bool",
                "MutableMapping[str, Any]",
                "Iterable[int]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "int"
                ],
                "params": [
                    "dict",
                    "Optional[bytes]",
                    "bool",
                    "Exception",
                    "Optional[bool]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/mylinear.py": {
        "MyLinearSimilarity.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1_dim": [
                    "str",
                    "int",
                    "typing.TextIO",
                    "torch.Tensor",
                    "TextIO"
                ],
                "tensor_2_dim": [
                    "str",
                    "int",
                    "typing.TextIO",
                    "torch.Tensor",
                    "TextIO"
                ],
                "combination": [
                    "typing.Text",
                    "str",
                    "Optional[bool]",
                    "Optional[int]",
                    "List[int]"
                ],
                "activation": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MyLinearSimilarity.reset_parameters": {
            "name": "reset_parameters",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MyLinearSimilarity.forward": {
            "name": "forward",
            "location": 68,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "int",
                    "float",
                    "str",
                    "list",
                    "list[]"
                ],
                "tensor_2": [
                    "float"
                ]
            }
        },
        "MyLinearSimilarity.from_params": {
            "name": "from_params",
            "location": 90,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "params": [
                    "defaultdict",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/similarity_function.py": {
        "SimilarityFunction.forward": {
            "name": "forward",
            "location": 23,
            "return": [
                "torch.Tensor",
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor_1": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "tensor_2": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "SimilarityFunction.from_params": {
            "name": "from_params",
            "location": 33,
            "return": [
                "SimilarityFunction"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSimilarityFunction]"
                ],
                "params": [
                    "int",
                    "Type[T]",
                    "typing.Type",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/similarity_functions/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/span_extractors/bidirectional_endpoint_span_extractor.py": {
        "BidirectionalEndpointSpanExtractor.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "Optional[int]",
                    "int",
                    "Union[str, float]"
                ],
                "forward_combination": [
                    "List['cirq.Circuit']",
                    "Callable",
                    "int",
                    "Optional[dict]",
                    "Optional[List[Any]]"
                ],
                "backward_combination": [
                    "List['cirq.Circuit']",
                    "Callable",
                    "int",
                    "Optional[dict]",
                    "Optional[List[Any]]"
                ],
                "num_width_embeddings": [
                    "int",
                    "bool",
                    "Optional[float]",
                    "Optional[int]",
                    "str",
                    "Optional[bool]"
                ],
                "span_width_embedding_dim": [
                    "int",
                    "bool",
                    "str",
                    "Optional[bool]"
                ],
                "bucket_widths": [
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "use_sentinels": [
                    "bool"
                ]
            }
        },
        "BidirectionalEndpointSpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 101,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalEndpointSpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 104,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalEndpointSpanExtractor.forward": {
            "name": "forward",
            "location": 116,
            "return": [
                "Tuple[Any, Any, Any]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "str",
                    "Pattern"
                ],
                "span_indices": [
                    "torch.LongTensor",
                    "int",
                    "List[str]",
                    "bytes",
                    "list"
                ],
                "sequence_mask": [
                    "torch.LongTensor",
                    "Optional[str]",
                    "float",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "span_indices_mask": [
                    "apps.common.coininfo.CoinInfo",
                    "str",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "BidirectionalEndpointSpanExtractor.from_params": {
            "name": "from_params",
            "location": 223,
            "return": [
                "str",
                "Callable",
                "Callable[[None, None], bool]"
            ],
            "arguments": {
                "cls": [
                    "cdp.util.T_JSON_DICT",
                    "allennlp.data.Vocabulary",
                    "int",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "bool",
                    "int",
                    "bytes"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/endpoint_span_extractor.py": {
        "EndpointSpanExtractor.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "bool",
                    "Optional[float]",
                    "float"
                ],
                "combination": [
                    "int",
                    "bool",
                    "List[int]",
                    "Optional[dict]",
                    "List[float]",
                    "List[List[int]]"
                ],
                "num_width_embeddings": [
                    "int",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "span_width_embedding_dim": [
                    "Optional[int]",
                    "int",
                    "Optional[bool]",
                    "bool"
                ],
                "bucket_widths": [
                    "int",
                    "float",
                    "Optional[int]",
                    "Tuple[int]",
                    "bool"
                ],
                "use_exclusive_start_indices": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "EndpointSpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 78,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "EndpointSpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 81,
            "return": [
                "str",
                "Iterable",
                "int",
                "IO[str]",
                "Iterable[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EndpointSpanExtractor.forward": {
            "name": "forward",
            "location": 88,
            "return": [
                "Tuple[Any, Any, Any]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "str"
                ],
                "span_indices": [
                    "torch.LongTensor",
                    "int",
                    "List[str]",
                    "bytes",
                    "list"
                ],
                "sequence_mask": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "span_indices_mask": [
                    "apps.common.coininfo.CoinInfo",
                    "str",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "EndpointSpanExtractor.from_params": {
            "name": "from_params",
            "location": 149,
            "return": [
                "str",
                "Callable",
                "Callable[[None, None], bool]"
            ],
            "arguments": {
                "cls": [
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "allennlp.data.Vocabulary",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/self_attentive_span_extractor.py": {
        "SelfAttentiveSpanExtractor.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "SelfAttentiveSpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 39,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SelfAttentiveSpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 42,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SelfAttentiveSpanExtractor.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "str",
                    "int",
                    "torch.Tensor",
                    "float"
                ],
                "span_indices": [
                    "list",
                    "str",
                    "torch.LongTensor"
                ],
                "sequence_mask": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "span_indices_mask": [
                    "torch.LongTensor",
                    "torch.BoolTensor",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "SelfAttentiveSpanExtractor.from_params": {
            "name": "from_params",
            "location": 114,
            "return": [
                "str",
                "Callable",
                "Callable[[None, None], bool]"
            ],
            "arguments": {
                "cls": [
                    "allennlp.common.Params",
                    "dict"
                ],
                "params": [
                    "allennlp.common.Params",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/span_extractor.py": {
        "SpanExtractor.forward": {
            "name": "forward",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "sequence_tensor": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "span_indices": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "sequence_mask": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "span_indices_mask": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "SpanExtractor.get_input_dim": {
            "name": "get_input_dim",
            "location": 56,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanExtractor.get_output_dim": {
            "name": "get_output_dim",
            "location": 62,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanExtractor.from_params": {
            "name": "from_params",
            "location": 70,
            "return": [
                "SpanExtractor"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSpanExtractor]"
                ],
                "params": [
                    "allennlp.common.params.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/span_extractors/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/text_field_embedders/basic_text_field_embedder.py": {
        "BasicTextFieldEmbedder.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_embedders": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "int",
                    "torch.optim.Optimizer",
                    "bool",
                    "bytes"
                ]
            }
        },
        "BasicTextFieldEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 32,
            "return": [
                "int",
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "BasicTextFieldEmbedder.forward": {
            "name": "forward",
            "location": 38,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "text_field_input": [
                    "str",
                    "dict",
                    "defaultdict",
                    "int",
                    "Dict[str, float]",
                    "Iterable[dict]"
                ],
                "num_wrapping_dims": [
                    "int",
                    "float"
                ]
            }
        },
        "BasicTextFieldEmbedder.from_params": {
            "name": "from_params",
            "location": 57,
            "return": [
                "Dict[str, bool]",
                "dict",
                "int",
                "Dict[str, Union[str, int]]",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "vocab": [
                    "dict[, ]",
                    "allennlp.data.Vocabulary",
                    "str",
                    "list[dict[str, typing.Any]]",
                    "dict",
                    "List[Dict[str, Any]]",
                    "dict[str, typing.Any]",
                    "tuple[]",
                    "Dict[str, Any]",
                    "Union[Dict, Tuple]"
                ],
                "params": [
                    "dict[str, typing.Any]",
                    "dict[, ]",
                    "allennlp.common.Params",
                    "Dict[str, Any]",
                    "dict",
                    "allennlp.common.params.Params",
                    "Mapping[str, str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/text_field_embedders/text_field_embedder.py": {
        "TextFieldEmbedder.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "torch.Tensor",
                "None"
            ],
            "arguments": {
                "self": [],
                "text_field_input": [
                    "int",
                    "dict[str, torch.Tensor]",
                    "Dict[str, torch.Tensor]",
                    "bool"
                ],
                "num_wrapping_dims": [
                    "int",
                    "Dict[str, torch.Tensor]",
                    "bool"
                ]
            }
        },
        "TextFieldEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 45,
            "return": [
                "builtins.int",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextFieldEmbedder.from_params": {
            "name": "from_params",
            "location": 54,
            "return": [
                "str",
                "List[int]",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "Type[T]",
                    "Dict[str, Any]",
                    "Optional[str]"
                ],
                "vocab": [
                    "str",
                    "bytes",
                    "allennlp.data.Vocabulary",
                    "torch.optim.Optimizer"
                ],
                "params": [
                    "int",
                    "Type[T]",
                    "typing.Type",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/text_field_embedders/__init__.py": {},
    "allennlp-dureader-master/allennlp/modules/token_embedders/elmo_token_embedder.py": {
        "ElmoTokenEmbedder.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "options_file": [
                    "bool",
                    "str",
                    "List[str]",
                    "float",
                    "list[str]"
                ],
                "weight_file": [
                    "bool",
                    "str",
                    "List[str]",
                    "float",
                    "list[str]"
                ],
                "do_layer_norm": [
                    "bool",
                    "List[str]",
                    "str",
                    "float"
                ],
                "dropout": [
                    "float",
                    "bool",
                    "List[str]",
                    "str"
                ],
                "requires_grad": [
                    "bool",
                    "List[str]",
                    "str",
                    "float"
                ]
            }
        },
        "ElmoTokenEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 46,
            "return": [
                "int",
                "str",
                "Callable",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ElmoTokenEmbedder.forward": {
            "name": "forward",
            "location": 50,
            "return": [
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bytes",
                    "torch.LongTensor",
                    "int",
                    "str",
                    "tuple[typing.Union[int,slice,int,slice]]",
                    "Tuple[Union[int, slice], Union[int, slice]]",
                    "list[]",
                    "list"
                ]
            }
        },
        "ElmoTokenEmbedder.from_params": {
            "name": "from_params",
            "location": 66,
            "return": [
                "bool",
                "Dict[str, Any]",
                "int",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "dict",
                    "dict[, ]"
                ],
                "vocab": [
                    "int",
                    "dict[str, typing.Any]",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/embedding.py": {
        "_read_pretrained_embedding_file": {
            "name": "_read_pretrained_embedding_file",
            "location": 176,
            "return": [
                "str"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str",
                    "int"
                ],
                "embedding_dim": [
                    "str",
                    "int",
                    "allennlp.data.Vocabulary",
                    "float",
                    "bytes"
                ],
                "vocab": [
                    "str",
                    "int",
                    "allennlp.data.Vocabulary",
                    "float",
                    "bytes"
                ],
                "namespace": [
                    "typing.Text",
                    "str",
                    "int",
                    "allennlp.data.Vocabulary",
                    "float",
                    "bytes"
                ]
            }
        },
        "_read_pretrained_word2vec_format_embedding_file": {
            "name": "_read_pretrained_word2vec_format_embedding_file",
            "location": 216,
            "return": [
                "complex",
                "Type[Any]",
                "bool",
                "str",
                "dict",
                "IO"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str"
                ],
                "embedding_dim": [
                    "int",
                    "str",
                    "dict",
                    "torch.Tensor"
                ],
                "vocab": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "bytes",
                    "dict",
                    "torch.Tensor"
                ],
                "namespace": [
                    "typing.Text",
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "bytes",
                    "dict",
                    "torch.Tensor"
                ]
            }
        },
        "_read_pretrained_hdf5_format_embedding_file": {
            "name": "_read_pretrained_hdf5_format_embedding_file",
            "location": 279,
            "return": [
                "str",
                "int",
                "Type[Any]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "embeddings_filename": [
                    "str",
                    "bytes"
                ],
                "embedding_dim": [
                    "int",
                    "str",
                    "allennlp.data.Vocabulary",
                    "Optional[str]"
                ],
                "vocab": [
                    "int",
                    "str",
                    "allennlp.data.Vocabulary",
                    "Optional[str]"
                ],
                "namespace": [
                    "typing.Text",
                    "int",
                    "str",
                    "allennlp.data.Vocabulary",
                    "Optional[str]"
                ]
            }
        },
        "Embedding.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_embeddings": [
                    "int",
                    "float"
                ],
                "embedding_dim": [
                    "int",
                    "Union[int, float]",
                    "numpy.ndarray",
                    "Sequence[int]",
                    "List[int]",
                    "float"
                ],
                "projection_dim": [
                    "None",
                    "str",
                    "int",
                    "bool",
                    "bytes",
                    "tuple"
                ],
                "weight": [
                    "None",
                    "torch.FloatTensor",
                    "int",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "padding_index": [
                    "int",
                    "None"
                ],
                "trainable": [
                    "bool",
                    "int",
                    "Callable",
                    "str"
                ],
                "max_norm": [
                    "None",
                    "float",
                    "int",
                    "str"
                ],
                "norm_type": [
                    "float",
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "scale_grad_by_freq": [
                    "bool",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "sparse": [
                    "bool",
                    "int",
                    "Union[str, float]",
                    "float"
                ]
            }
        },
        "Embedding.get_output_dim": {
            "name": "get_output_dim",
            "location": 106,
            "return": [
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "Embedding.forward": {
            "name": "forward",
            "location": 110,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "torch.Tensor",
                    "dict",
                    "Dict[str, int]",
                    "Optional[torch.Tensor]",
                    "int"
                ]
            }
        },
        "Embedding.from_params": {
            "name": "from_params",
            "location": 130,
            "return": [
                "str",
                "int",
                "bool",
                "MutableMapping[str, Any]",
                "Iterable[int]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "Sequence[str]"
                ],
                "vocab": [
                    "allennlp.data.Vocabulary"
                ],
                "params": [
                    "str",
                    "dict",
                    "Dict[str, Any]",
                    "Type['BaseConfig']"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/token_characters_encoder.py": {
        "TokenCharactersEncoder.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding": [
                    "int",
                    "float",
                    "bool"
                ],
                "encoder": [
                    "int",
                    "float",
                    "bool"
                ],
                "dropout": [
                    "float",
                    "int",
                    "bool"
                ]
            }
        },
        "TokenCharactersEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 31,
            "return": [
                "int",
                "Optional[bytes]",
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenCharactersEncoder.forward": {
            "name": "forward",
            "location": 34,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "token_characters": [
                    "str",
                    "int",
                    "list[int]",
                    "allennlp.models.semantic_parsing.nlvr.nlvr_decoder_state.NlvrDecoderState",
                    "List[int]"
                ]
            }
        },
        "TokenCharactersEncoder.from_params": {
            "name": "from_params",
            "location": 39,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "vocab": [
                    "dict[, ]",
                    "allennlp.common.params.Params",
                    "str",
                    "typing.MutableMapping",
                    "dict",
                    "MutableMapping",
                    "typing.Type",
                    "Type['Declared']"
                ],
                "params": [
                    "allennlp.common.Params",
                    "Union[object, type]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/token_embedder.py": {
        "TokenEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 22,
            "return": [
                "builtins.int",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TokenEmbedder.from_params": {
            "name": "from_params",
            "location": 30,
            "return": [
                "str",
                "List[int]",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict"
                ],
                "vocab": [
                    "str",
                    "bytes",
                    "allennlp.data.Vocabulary",
                    "torch.optim.Optimizer"
                ],
                "params": [
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/modules/token_embedders/__init__.py": {},
    "allennlp-dureader-master/allennlp/nn/activations.py": {
        "Activation.__call__": {
            "name": "__call__",
            "location": 42,
            "return": [
                "torch.autograd.Variable",
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/initializers.py": {
        "uniform_unit_scaling": {
            "name": "uniform_unit_scaling",
            "location": 66,
            "return": [
                "Dict[str, int]",
                "float",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor",
                    "List[allennlp.data.Instance]"
                ],
                "nonlinearity": [
                    "str"
                ]
            }
        },
        "block_orthogonal": {
            "name": "block_orthogonal",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "float"
                ],
                "split_sizes": [
                    "List[int]"
                ],
                "gain": [
                    "float"
                ]
            }
        },
        "_initializer_wrapper": {
            "name": "_initializer_wrapper",
            "location": 156,
            "return": [
                "Type[Initializer]"
            ],
            "arguments": {
                "init_function": [
                    "Callable[(..., None)]"
                ]
            }
        },
        "Initializer.__call__": {
            "name": "__call__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "dict"
                ]
            }
        },
        "Initializer.from_params": {
            "name": "from_params",
            "location": 57,
            "return": [
                "Tuple[bool, str]",
                "str",
                "IO",
                "torch.nn.Module",
                "bool"
            ],
            "arguments": {
                "cls": [
                    "allennlp.data.Vocabulary",
                    "Dict[str, Any]",
                    "str",
                    "type",
                    "List[str]"
                ],
                "params": [
                    "allennlp.common.params.Params"
                ]
            }
        },
        "InitializerApplicator.__init__": {
            "name": "__init__",
            "location": 195,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initializers": [
                    "List[Tuple[(str, Initializer)]]"
                ]
            }
        },
        "InitializerApplicator.__call__": {
            "name": "__call__",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "torch.nn.Module",
                    "allennlp.models.model.Model",
                    "type",
                    "bool"
                ]
            }
        },
        "InitializerApplicator.from_params": {
            "name": "from_params",
            "location": 239,
            "return": [
                "InitializerApplicator"
            ],
            "arguments": {
                "cls": [
                    "Type[_TInitializerApplicator]"
                ],
                "params": [
                    "List[Tuple[(str, allennlp.common.params.Params)]]"
                ]
            }
        },
        "_initializer_wrapper.Init.__init__": {
            "name": "__init__",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_initializer_wrapper.Init.__call__": {
            "name": "__call__",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Callable",
                    "int",
                    "float"
                ]
            }
        },
        "_initializer_wrapper.Init.__repr__": {
            "name": "__repr__",
            "location": 163,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "_initializer_wrapper.Init.from_params": {
            "name": "from_params",
            "location": 166,
            "return": [
                "str",
                "bytes",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "dict"
                ],
                "params": [
                    "str",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/util.py": {
        "batch_tensor_dicts": {
            "name": "batch_tensor_dicts",
            "location": 17,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "tensor_dicts": [
                    "List[Dict[(str, Any)]]"
                ],
                "remove_trailing_dimension": [
                    "bool"
                ]
            }
        },
        "get_lengths_from_binary_sequence_mask": {
            "name": "get_lengths_from_binary_sequence_mask",
            "location": 44,
            "return": [
                "str",
                "torch.Tensor",
                "bytes",
                "int"
            ],
            "arguments": {
                "mask": [
                    "str",
                    "torch.Tensor",
                    "bytes",
                    "int"
                ]
            }
        },
        "sort_batch_by_length": {
            "name": "sort_batch_by_length",
            "location": 63,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "tensor": [
                    "torch.autograd.Variable",
                    "str",
                    "Mapping[str, Sequence[str]]"
                ],
                "sequence_lengths": [
                    "torch.autograd.Variable",
                    "str"
                ]
            }
        },
        "get_final_encoder_states": {
            "name": "get_final_encoder_states",
            "location": 108,
            "return": [
                "IO",
                "Mapping[str, Any]",
                "torch.Tensor",
                "str",
                "int"
            ],
            "arguments": {
                "encoder_outputs": [
                    "bytes",
                    "torch.Tensor",
                    "int",
                    "str"
                ],
                "mask": [
                    "torch.Tensor",
                    "str",
                    "allennlp.common.util.JsonDict",
                    "Type[T]"
                ],
                "bidirectional": [
                    "bool"
                ]
            }
        },
        "get_dropout_mask": {
            "name": "get_dropout_mask",
            "location": 141,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "dropout_probability": [
                    "float"
                ],
                "tensor_for_masking": [
                    "List[float]",
                    "int",
                    "float",
                    "Mapping[str, Tuple[float, float, float]]"
                ]
            }
        },
        "masked_softmax": {
            "name": "masked_softmax",
            "location": 168,
            "return": [
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "vector": [],
                "mask": [
                    "float",
                    "str",
                    "Optional[List[str]]",
                    "Optional[int]",
                    "int"
                ]
            }
        },
        "masked_log_softmax": {
            "name": "masked_log_softmax",
            "location": 190,
            "return": [
                "int",
                "torch.FloatTensor",
                "Iterable[int]",
                "torch.nn.utils.rnn.PackedSequence",
                "float",
                "str"
            ],
            "arguments": {
                "vector": [
                    "set"
                ],
                "mask": [
                    "Optional[float]",
                    "Optional[int]",
                    "torch.Tensor",
                    "Optional[str]"
                ]
            }
        },
        "viterbi_decode": {
            "name": "viterbi_decode",
            "location": 218,
            "return": [
                "Tuple[(List[int], Any)]"
            ],
            "arguments": {
                "tag_sequence": [
                    "torch.Tensor",
                    "Iterable[Tuple[Any, Any]]"
                ],
                "transition_matrix": [
                    "bool",
                    "allennlp.modules.FeedForward",
                    "Optional[bool]",
                    "Iterable[Any]",
                    "Optional[int]",
                    "type"
                ],
                "tag_observations": [
                    "Optional[List[int]]"
                ]
            }
        },
        "get_text_field_mask": {
            "name": "get_text_field_mask",
            "location": 304,
            "return": [
                "dict",
                "int",
                "float",
                "bool"
            ],
            "arguments": {
                "text_field_tensors": [
                    "Dict[(str, Any)]"
                ],
                "num_wrapping_dims": [
                    "int"
                ]
            }
        },
        "_last_dimension_applicator": {
            "name": "_last_dimension_applicator",
            "location": 346,
            "return": [
                "int",
                "Union[int, float, complex]",
                "List[Dict[str, str]]",
                "bool",
                "Mapping[Any, Any]"
            ],
            "arguments": {
                "function_to_apply": [
                    "Callable[([Any, Any], Any)]"
                ],
                "tensor": [
                    "int",
                    "dict",
                    "torch.Tensor",
                    "str",
                    "bytes"
                ],
                "mask": [
                    "None",
                    "Optional[torch.Tensor]",
                    "allennlp.nn.InitializerApplicator",
                    "Optional[float]",
                    "Optional[str]"
                ]
            }
        },
        "last_dim_softmax": {
            "name": "last_dim_softmax",
            "location": 367,
            "return": [
                "Optional[Union[str, Any]]",
                "str",
                "bool"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "str",
                    "int"
                ],
                "mask": [
                    "None",
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "str",
                    "int"
                ]
            }
        },
        "last_dim_log_softmax": {
            "name": "last_dim_log_softmax",
            "location": 376,
            "return": [
                "int",
                "bool",
                "Callable"
            ],
            "arguments": {
                "tensor": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Callable",
                    "Dict[str, Any]",
                    "torch.nn.utils.rnn.PackedSequence",
                    "dict"
                ],
                "mask": [
                    "None",
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Callable",
                    "Dict[str, Any]",
                    "torch.nn.utils.rnn.PackedSequence",
                    "dict"
                ]
            }
        },
        "weighted_sum": {
            "name": "weighted_sum",
            "location": 385,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "matrix": [
                    "int",
                    "Callable",
                    "str"
                ],
                "attention": [
                    "torch.Tensor",
                    "Tuple[int, int]",
                    "float",
                    "str"
                ]
            }
        },
        "sequence_cross_entropy_with_logits": {
            "name": "sequence_cross_entropy_with_logits",
            "location": 424,
            "return": [
                "str",
                "Optional[int]",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "logits": [
                    "int",
                    "Optional[Any]",
                    "Optional[Mapping[str, Any]]",
                    "Optional[List[str]]",
                    "bool",
                    "str"
                ],
                "targets": [
                    "bool",
                    "list",
                    "int"
                ],
                "weights": [
                    "Optional[Any]",
                    "bool",
                    "int"
                ],
                "batch_average": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ]
            }
        },
        "replace_masked_values": {
            "name": "replace_masked_values",
            "location": 496,
            "return": [
                "Dict[str, int]",
                "int",
                "dict"
            ],
            "arguments": {
                "tensor": [
                    "torch.autograd.Variable",
                    "float",
                    "str"
                ],
                "mask": [
                    "str",
                    "Optional[int]",
                    "Dict[str, Any]"
                ],
                "replace_with": [
                    "float"
                ]
            }
        },
        "device_mapping": {
            "name": "device_mapping",
            "location": 511,
            "return": [
                "Callable[([Any, Any], Any)]"
            ],
            "arguments": {
                "cuda_device": [
                    "int"
                ]
            }
        },
        "ones_like": {
            "name": "ones_like",
            "location": 525,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "zeros_like": {
            "name": "zeros_like",
            "location": 533,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "combine_tensors": {
            "name": "combine_tensors",
            "location": 541,
            "return": [
                "int",
                "str",
                "torch.Tensor"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensors": [
                    "list"
                ]
            }
        },
        "_get_combination": {
            "name": "_get_combination",
            "location": 572,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensors": [
                    "list"
                ]
            }
        },
        "get_combined_dim": {
            "name": "get_combined_dim",
            "location": 594,
            "return": [
                "int"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensor_dims": [
                    "List[int]"
                ]
            }
        },
        "_get_combination_dim": {
            "name": "_get_combination_dim",
            "location": 616,
            "return": [
                "int"
            ],
            "arguments": {
                "combination": [
                    "str"
                ],
                "tensor_dims": [
                    "List[int]"
                ]
            }
        },
        "logsumexp": {
            "name": "logsumexp",
            "location": 631,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "bool",
                    "int",
                    "Tuple[int]",
                    "float"
                ],
                "dim": [
                    "int"
                ],
                "keepdim": [
                    "bool"
                ]
            }
        },
        "get_device_of": {
            "name": "get_device_of",
            "location": 655,
            "return": [
                "int"
            ],
            "arguments": {
                "tensor": [
                    "str",
                    "TextIO",
                    "bool"
                ]
            }
        },
        "flatten_and_batch_shift_indices": {
            "name": "flatten_and_batch_shift_indices",
            "location": 664,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "indices": [
                    "int",
                    "torch.Tensor"
                ],
                "sequence_length": [
                    "int"
                ]
            }
        },
        "batched_index_select": {
            "name": "batched_index_select",
            "location": 708,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "target": [],
                "indices": [
                    "str",
                    "int"
                ],
                "flattened_indices": [
                    "int",
                    "None"
                ]
            }
        },
        "flattened_index_select": {
            "name": "flattened_index_select",
            "location": 761,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "target": [
                    "torch.Tensor",
                    "str",
                    "gluonts.model.common.Tensor"
                ],
                "indices": [
                    "int",
                    "torch.LongTensor",
                    "float"
                ]
            }
        },
        "get_range_vector": {
            "name": "get_range_vector",
            "location": 793,
            "return": [
                "Variable",
                "bool",
                "List[Dict[str, Any]]",
                "Union[int, float, complex]"
            ],
            "arguments": {
                "size": [
                    "int"
                ],
                "device": [
                    "int"
                ]
            }
        },
        "bucket_values": {
            "name": "bucket_values",
            "location": 805,
            "return": [
                "Type[T]",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "distances": [
                    "int",
                    "bool",
                    "str"
                ],
                "num_identity_buckets": [
                    "int"
                ],
                "num_total_buckets": [
                    "int"
                ]
            }
        },
        "add_sentence_boundary_token_ids": {
            "name": "add_sentence_boundary_token_ids",
            "location": 844,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "tensor": [
                    "Callable"
                ],
                "mask": [
                    "torch.Tensor",
                    "int",
                    "allennlp.nn.decoding.decoder_step.DecoderStep",
                    "Optional[torch.Tensor]",
                    "Callable",
                    "List[str]"
                ],
                "sentence_begin_token": [
                    "int",
                    "torch.Tensor",
                    "bool",
                    "Iterable[Any]",
                    "List[float]",
                    "Tuple[int, int]",
                    "Sequence[str]"
                ],
                "sentence_end_token": [
                    "bool",
                    "str",
                    "List[allennlp.semparse.domain_languages.WikiTablesLanguage]",
                    "set",
                    "int"
                ]
            }
        },
        "remove_sentence_boundaries": {
            "name": "remove_sentence_boundaries",
            "location": 900,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "tensor": [
                    "bool",
                    "bytes"
                ],
                "mask": [
                    "str"
                ]
            }
        },
        "add_positional_features": {
            "name": "add_positional_features",
            "location": 943,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "tensor": [],
                "min_timescale": [
                    "float"
                ],
                "max_timescale": [
                    "float"
                ]
            }
        },
        "device_mapping.inner_device_mapping": {
            "name": "inner_device_mapping",
            "location": 517,
            "return": [
                "int",
                "Optional[bytearray]",
                "Sequence[float]",
                "List[int]",
                "Set[str]",
                "Tuple[str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "storage": [
                    "str",
                    "bool",
                    "tuple",
                    "torch.Tensor"
                ],
                "location": [
                    "str",
                    "bool",
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/__init__.py": {},
    "allennlp-dureader-master/allennlp/nn/regularizers/regularizer.py": {
        "Regularizer.__call__": {
            "name": "__call__",
            "location": 12,
            "return": [
                "torch.Tensor",
                "None"
            ],
            "arguments": {
                "self": [],
                "parameter": [
                    "torch.Tensor"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/regularizers/regularizers.py": {
        "L1Regularizer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "float",
                    "int",
                    "bool"
                ]
            }
        },
        "L1Regularizer.__call__": {
            "name": "__call__",
            "location": 13,
            "return": [
                "str",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "parameter": [
                    "float",
                    "torch.optim.Optimizer",
                    "typing.Callable[, ]",
                    "int",
                    "Callable",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "L2Regularizer.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "float",
                    "int",
                    "bool"
                ]
            }
        },
        "L2Regularizer.__call__": {
            "name": "__call__",
            "location": 24,
            "return": [
                "str",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "parameter": [
                    "float",
                    "torch.optim.Optimizer",
                    "typing.Callable[, ]",
                    "int",
                    "Callable",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/regularizers/regularizer_applicator.py": {
        "RegularizerApplicator.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "regularizers": [
                    "Sequence[Tuple[(str, allennlp.nn.regularizers.regularizer.Regularizer)]]"
                ]
            }
        },
        "RegularizerApplicator.__call__": {
            "name": "__call__",
            "location": 25,
            "return": [
                "float",
                "Callable",
                "int"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "torch.nn.Module",
                    "allennlp.models.model.Model",
                    "type",
                    "bool"
                ]
            }
        },
        "RegularizerApplicator.from_params": {
            "name": "from_params",
            "location": 44,
            "return": [
                "Optional[RegularizerApplicator]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "dict[str, typing.Any]",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "List[Tuple[(str, allennlp.common.params.Params)]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/nn/regularizers/__init__.py": {},
    "allennlp-dureader-master/allennlp/service/db.py": {
        "DemoDatabase.add_result": {
            "name": "add_result",
            "location": 24,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "headers": [
                    "Dict[(str, Any)]"
                ],
                "model_name": [
                    "str"
                ],
                "inputs": [
                    "Dict[(str, Any)]"
                ],
                "outputs": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "DemoDatabase.get_result": {
            "name": "get_result",
            "location": 35,
            "return": [
                "allennlp.service.permalinks.Permadata"
            ],
            "arguments": {
                "self": [],
                "perma_id": [
                    "int"
                ]
            }
        },
        "DemoDatabase.from_environment": {
            "name": "from_environment",
            "location": 43,
            "return": [
                "Optional[DemoDatabase]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "dict[str, typing.Any]",
                    "cdp.util.T_JSON_DICT",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ]
            }
        },
        "PostgresDemoDatabase.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dbname": [
                    "str"
                ],
                "host": [
                    "str"
                ],
                "port": [
                    "str"
                ],
                "user": [
                    "str"
                ],
                "password": [
                    "str"
                ]
            }
        },
        "PostgresDemoDatabase._connect": {
            "name": "_connect",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PostgresDemoDatabase._health_check": {
            "name": "_health_check",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PostgresDemoDatabase.from_environment": {
            "name": "from_environment",
            "location": 116,
            "return": [
                "Optional[PostgresDemoDatabase]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "dict[str, typing.Any]",
                    "cdp.util.T_JSON_DICT",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ]
            }
        },
        "PostgresDemoDatabase.add_result": {
            "name": "add_result",
            "location": 135,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "headers": [
                    "Dict[(str, Any)]"
                ],
                "model_name": [
                    "str"
                ],
                "inputs": [
                    "Dict[(str, Any)]"
                ],
                "outputs": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "PostgresDemoDatabase.get_result": {
            "name": "get_result",
            "location": 160,
            "return": [
                "Optional[allennlp.service.permalinks.Permadata]"
            ],
            "arguments": {
                "self": [],
                "perma_id": [
                    "int"
                ]
            }
        },
        "InMemoryDemoDatabase.__init__": {
            "name": "__init__",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "InMemoryDemoDatabase.add_result": {
            "name": "add_result",
            "location": 186,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "headers": [
                    "Dict[(str, Any)]"
                ],
                "model_name": [
                    "str"
                ],
                "inputs": [
                    "Dict[(str, Any)]"
                ],
                "outputs": [
                    "Dict[(str, Any)]"
                ]
            }
        },
        "InMemoryDemoDatabase.get_result": {
            "name": "get_result",
            "location": 194,
            "return": [
                "allennlp.service.permalinks.Permadata"
            ],
            "arguments": {
                "self": [],
                "perma_id": [
                    "int"
                ]
            }
        },
        "InMemoryDemoDatabase.from_environment": {
            "name": "from_environment",
            "location": 201,
            "return": [
                "Optional[InMemoryDemoDatabase]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "dict[str, typing.Any]",
                    "cdp.util.T_JSON_DICT",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/permalinks.py": {
        "int_to_slug": {
            "name": "int_to_slug",
            "location": 17,
            "return": [
                "str"
            ],
            "arguments": {
                "i": [
                    "int"
                ]
            }
        },
        "slug_to_int": {
            "name": "slug_to_int",
            "location": 26,
            "return": [
                "Optional[int]"
            ],
            "arguments": {
                "slug": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/server_flask.py": {
        "run": {
            "name": "run",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "port": [
                    "str",
                    "logging.Logger",
                    "Union[str, int]"
                ],
                "trained_models": [
                    "Dict[str, allennlp.service.predictors.DemoModel]",
                    "Mapping[str, Any]",
                    "Dict[str, bool]",
                    "dict",
                    "Optional[Dict[str, str]]",
                    "bool",
                    "Dict[str, Dict[str, str]]",
                    "str",
                    "Optional[Dict]"
                ],
                "static_dir": [
                    "None",
                    "str",
                    "Dict[str, str]",
                    "IO",
                    "List[str]"
                ]
            }
        },
        "make_app": {
            "name": "make_app",
            "location": 74,
            "return": [
                "Flask",
                "flask.Flask",
                "\"App\""
            ],
            "arguments": {
                "build_dir": [
                    "None",
                    "str",
                    "bool",
                    "Dict[str, Any]"
                ],
                "demo_db": [
                    "None",
                    "str",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "ServerError.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "int",
                    "bool",
                    "str"
                ],
                "status_code": [
                    "None",
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "payload": [
                    "None",
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "ServerError.to_dict": {
            "name": "to_dict",
            "location": 45,
            "return": [
                "bytes",
                "dict",
                "Optional[Dict[str, str]]",
                "str",
                "Optional[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "make_app.handle_invalid_usage": {
            "name": "handle_invalid_usage",
            "location": 97,
            "return": [
                "bytes",
                "dict",
                "flask.Response"
            ],
            "arguments": {
                "error": []
            }
        },
        "make_app._caching_prediction": {
            "name": "_caching_prediction",
            "location": 103,
            "return": [
                "django.db.models.QuerySet",
                "Tuple[float, float]"
            ],
            "arguments": {
                "model": [
                    "allennlp.service.predictors.Predictor",
                    "str",
                    "dict",
                    "bytes",
                    "Type"
                ],
                "data": [
                    "allennlp.service.predictors.Predictor",
                    "str",
                    "dict",
                    "bytes",
                    "Type"
                ]
            }
        },
        "make_app.index": {
            "name": "index",
            "location": 110,
            "return": [
                "dict",
                "bytes",
                "bool"
            ],
            "arguments": {}
        },
        "make_app.permadata": {
            "name": "permadata",
            "location": 114,
            "return": [
                "Response",
                "str",
                "dict",
                "Optional[Dict]"
            ],
            "arguments": {}
        },
        "make_app.predict": {
            "name": "predict",
            "location": 153,
            "return": [
                "Response",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "model_name": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "make_app.list_models": {
            "name": "list_models",
            "location": 240,
            "return": [
                "str",
                "os.PathLike",
                "int",
                "flask.Response"
            ],
            "arguments": {}
        },
        "make_app.info": {
            "name": "info",
            "location": 245,
            "return": [
                "str",
                "List[str]",
                "bool"
            ],
            "arguments": {}
        },
        "make_app.return_page": {
            "name": "return_page",
            "location": 269,
            "return": [
                "dict",
                "bool"
            ],
            "arguments": {
                "permalink": [
                    "None",
                    "str",
                    "bool",
                    "int",
                    "float",
                    "django.db.backends.postgresql_psycopg2.schema.DatabaseSchemaEditor"
                ]
            }
        },
        "make_app.static_proxy": {
            "name": "static_proxy",
            "location": 274,
            "return": [
                "dict",
                "Optional[str]",
                "List[int]",
                "Optional[Exception]"
            ],
            "arguments": {
                "path": [
                    "str",
                    "int"
                ]
            }
        },
        "make_app.static_js_proxy": {
            "name": "static_js_proxy",
            "location": 278,
            "return": [
                "List[str]",
                "Optional[str]",
                "dict",
                "\"TopicQuery\"",
                "bytes",
                "starlette.responses.Response"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/server_simple.py": {
        "make_app": {
            "name": "make_app",
            "location": 39,
            "return": [
                "Flask",
                "flask.Flask",
                "\"App\""
            ],
            "arguments": {
                "predictor": [
                    "str",
                    "allennlp.predictors.Predictor",
                    "List[str]",
                    "Optional[bool]"
                ],
                "field_names": [
                    "None",
                    "str",
                    "allennlp.predictors.Predictor",
                    "List[str]",
                    "Optional[bool]"
                ],
                "static_dir": [
                    "None",
                    "str",
                    "allennlp.predictors.Predictor",
                    "List[str]",
                    "Optional[bool]"
                ],
                "sanitizer": [
                    "None",
                    "str",
                    "allennlp.predictors.Predictor",
                    "List[str]",
                    "Optional[bool]"
                ],
                "title": [
                    "typing.Text",
                    "str",
                    "allennlp.predictors.Predictor",
                    "List[str]",
                    "Optional[bool]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "_html": {
            "name": "_html",
            "location": 699,
            "return": [
                "str",
                "Optional[Any]"
            ],
            "arguments": {
                "title": [
                    "str",
                    "tuple"
                ],
                "field_names": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "make_app.handle_invalid_usage": {
            "name": "handle_invalid_usage",
            "location": 74,
            "return": [
                "bytes",
                "dict",
                "flask.Response"
            ],
            "arguments": {
                "error": [
                    "Exception"
                ]
            }
        },
        "make_app.index": {
            "name": "index",
            "location": 80,
            "return": [
                "Response",
                "Callable[[Any], bool]",
                "bool",
                "zam_repondeur.models.Lecture",
                "dict",
                "List[str]"
            ],
            "arguments": {}
        },
        "make_app.predict": {
            "name": "predict",
            "location": 88,
            "return": [
                "Response",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "make_app.static_proxy": {
            "name": "static_proxy",
            "location": 105,
            "return": [
                "str",
                "Optional[str]",
                "Tuple[str, int, Dict[str, str]]",
                "dict",
                "Tuple[str, Optional[int]]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/__init__.py": {},
    "allennlp-dureader-master/allennlp/service/predictors/bidaf.py": {
        "BidafPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 15,
            "return": [
                "tuple[dict[, ]]",
                "Iterable[str]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "bytes",
                    "Iterable",
                    "Optional[bytes]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/constituency_parser.py": {
        "ConstituencyParserPredictor.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ],
                "dataset_reader": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ]
            }
        },
        "ConstituencyParserPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 70,
            "return": [
                "tuple[dict[, ]]",
                "Iterable[str]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "str",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "Dict[str, str]"
                ]
            }
        },
        "ConstituencyParserPredictor.predict_json": {
            "name": "predict_json",
            "location": 80,
            "return": [
                "bool",
                "Dict[str, Any]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "dict[, ]",
                    "bool",
                    "dict",
                    "list[dict[, ]]",
                    "List[dict]",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Optional[int]",
                    "deeplearning.clgen.clgen.Instance"
                ]
            }
        },
        "ConstituencyParserPredictor.predict_batch_json": {
            "name": "predict_batch_json",
            "location": 92,
            "return": [
                "Dict[str, Any]",
                "Union[tuple, list]",
                "str",
                "denite.util.UserContext",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Optional[int]",
                    "deeplearning.clgen.clgen.Instance"
                ]
            }
        },
        "ConstituencyParserPredictor._build_hierplane_tree": {
            "name": "_build_hierplane_tree",
            "location": 104,
            "return": [
                "dict[typing.Text, typing.Union[str,list[]]]",
                "float",
                "dict[typing.Text, typing.Union[dict[typing.Text, list[typing.Text]],str,dict[typing.Text, typing.Union[str,list[]]]]]",
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "tree": [
                    "Optional[str]",
                    "bool",
                    "List[str]",
                    "Callable[[str], str]"
                ],
                "index": [
                    "bool",
                    "tuple[typing.Union[dict[str, str],list[str]]]",
                    "list[]",
                    "int",
                    "Tuple[Dict[str, str], List[str]]",
                    "list",
                    "Optional[int]"
                ],
                "is_root": [
                    "bool",
                    "Tuple[Dict[str, str], List[str]]",
                    "tuple[typing.Union[dict[str, str],list[str]]]",
                    "List[str]",
                    "list[str]",
                    "list",
                    "list[]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/coref.py": {
        "CorefPredictor.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ],
                "dataset_reader": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ]
            }
        },
        "CorefPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 25,
            "return": [
                "tuple[typing.Union[int,str,dict[typing.Text, list[]]]]",
                "Dict[str, Any]",
                "dict",
                "int",
                "Dict[str, str]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "str",
                    "allennlp.common.util.JsonDict",
                    "Dict[str, Any]",
                    "dict",
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/decomposable_attention.py": {
        "DecomposableAttentionPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 15,
            "return": [
                "tuple[dict[, ]]",
                "Iterable[str]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "bytes",
                    "Iterable",
                    "Optional[bytes]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/predictor.py": {
        "Predictor.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "dataset_reader": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ]
            }
        },
        "Predictor.load_line": {
            "name": "load_line",
            "location": 20,
            "return": [
                "str",
                "allennlp.data.vocabulary.Vocabulary"
            ],
            "arguments": {
                "self": [],
                "line": [
                    "str",
                    "bool"
                ]
            }
        },
        "Predictor.dump_line": {
            "name": "dump_line",
            "location": 27,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "outputs": [
                    "list[]",
                    "allennlp.common.util.JsonDict",
                    "dict[, ]",
                    "list",
                    "tuple[typing.Union[str,str,typing.Sequence[str]]]",
                    "dict",
                    "dict[str, typing.Any]",
                    "Tuple[str, str, Sequence[str]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Predictor.predict_json": {
            "name": "predict_json",
            "location": 34,
            "return": [
                "bool",
                "Dict[str, Any]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "dict[, ]",
                    "bool",
                    "dict",
                    "list[dict[, ]]",
                    "List[dict]",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Optional[int]",
                    "deeplearning.clgen.clgen.Instance"
                ]
            }
        },
        "Predictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 40,
            "return": [
                "typing.Tuple[allennlp.data.Instance, allennlp.common.util.JsonDict]",
                "None"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "dict[, ]",
                    "allennlp.common.util.JsonDict",
                    "bool",
                    "dict[str, typing.Any]",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "Predictor.predict_batch_json": {
            "name": "predict_batch_json",
            "location": 48,
            "return": [
                "Dict[str, Any]",
                "Union[tuple, list]",
                "str",
                "denite.util.UserContext",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Optional[int]",
                    "deeplearning.clgen.clgen.Instance"
                ]
            }
        },
        "Predictor._batch_json_to_instances": {
            "name": "_batch_json_to_instances",
            "location": 55,
            "return": [
                "list[]",
                "float",
                "int",
                "Union[bool, None]",
                "simulation.core.common.Resources",
                "str"
            ],
            "arguments": {
                "self": [],
                "json_dicts": [
                    "list[allennlp.common.util.JsonDict]",
                    "List[allennlp.common.util.JsonDict]",
                    "bool",
                    "float",
                    "Iterable[Any]"
                ]
            }
        },
        "Predictor.from_archive": {
            "name": "from_archive",
            "location": 70,
            "return": [
                "str",
                "List[int]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "archive": [
                    "str",
                    "multinedb.models.workspace.Workspace"
                ],
                "predictor_name": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "DemoModel.__init__": {
            "name": "__init__",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "archive_file": [
                    "str",
                    "bool"
                ],
                "predictor_name": [
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "DemoModel.predictor": {
            "name": "predictor",
            "location": 97,
            "return": [
                "str",
                "Dict[str, str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/semantic_role_labeler.py": {
        "SemanticRoleLabelerPredictor.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ],
                "dataset_reader": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ]
            }
        },
        "SemanticRoleLabelerPredictor.make_srl_string": {
            "name": "make_srl_string",
            "location": 22,
            "return": [
                "str",
                "List[str]",
                "int"
            ],
            "arguments": {
                "words": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "bool"
                ],
                "tags": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "bool"
                ]
            }
        },
        "SemanticRoleLabelerPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "dict[, ]",
                    "allennlp.common.util.JsonDict",
                    "bool",
                    "dict[str, typing.Any]",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "SemanticRoleLabelerPredictor._sentence_to_srl_instances": {
            "name": "_sentence_to_srl_instances",
            "location": 48,
            "return": [
                "tuple[typing.Union[list[typing.Union[dict[, ],set[],list[],tuple[int],int,str]],list[dict[typing.Any, typing.Any]],list[dict[typing.Any, str]]]]",
                "Dict[str, Any]",
                "dict",
                "int",
                "Dict[str, str]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "str",
                    "allennlp.common.util.JsonDict",
                    "Dict[str, Any]",
                    "dict",
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "SemanticRoleLabelerPredictor.predict_batch_json": {
            "name": "predict_batch_json",
            "location": 87,
            "return": [
                "Dict[str, Any]",
                "app.models.Article",
                "int",
                "Union[tuple, list]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Union[bytearray, memoryview]",
                    "Dict[str, Any]",
                    "list"
                ],
                "cuda_device": [
                    "int",
                    "List[str]",
                    "x509_pki.models.Certificate"
                ]
            }
        },
        "SemanticRoleLabelerPredictor.predict_json": {
            "name": "predict_json",
            "location": 158,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "str",
                    "typing.Callable[, ]",
                    "int"
                ],
                "cuda_device": [
                    "int",
                    "Optional[int]",
                    "deeplearning.clgen.clgen.Instance"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/sentence_tagger.py": {
        "SentenceTaggerPredictor.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ],
                "dataset_reader": [
                    "allennlp.data.DatasetReader",
                    "allennlp.models.Model"
                ]
            }
        },
        "SentenceTaggerPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 26,
            "return": [
                "tuple[typing.Union[dict[str, dict[str, typing.Any]],str,tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]],dict[typing.Text, list[]]]]",
                "Dict[str, Any]",
                "dict",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "str",
                    "allennlp.common.util.JsonDict",
                    "Dict[str, Any]",
                    "dict",
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/simple_seq2seq.py": {
        "SimpleSeq2SeqPredictor._json_to_instance": {
            "name": "_json_to_instance",
            "location": 14,
            "return": [
                "tuple[dict[, ]]",
                "bool",
                "\"Person\"",
                "Optional[Dict[str, str]]",
                "float"
            ],
            "arguments": {
                "self": [],
                "json_dict": [
                    "str",
                    "bytes",
                    "Dict[str, digipathos.data.dataseDataset]",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/service/predictors/__init__.py": {},
    "allennlp-dureader-master/allennlp/training/learning_rate_schedulers.py": {
        "LearningRateScheduler.from_params": {
            "name": "from_params",
            "location": 26,
            "return": [
                "LearningRateScheduler"
            ],
            "arguments": {
                "cls": [
                    "Type[_TLearningRateScheduler]"
                ],
                "optimizer": [
                    "dict[str, typing.Any]",
                    "torch.optim.Optimizer",
                    "str",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict",
                    "dict[str, dict[str, str]]",
                    "dict[str, str]",
                    "Dict[str, Dict[str, str]]",
                    "Dict[str, str]"
                ],
                "params": [
                    "allennlp.common.params.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/optimizers.py": {
        "Optimizer.from_params": {
            "name": "from_params",
            "location": 36,
            "return": [
                "List[int]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "None",
                    "Callable",
                    "typing.Callable[, ]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]",
                    "List[Tuple[str, Any]]",
                    "list[tuple[typing.Union[str,typing.Any]]]"
                ],
                "model_parameters": [
                    "list"
                ],
                "params": [
                    "Dict[str, Any]",
                    "Exception",
                    "dict[str, typing.Any]",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/trainer.py": {
        "is_sparse": {
            "name": "is_sparse",
            "location": 40,
            "return": [
                "bool",
                "Dict[str, Any]",
                "str",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "tensor": [
                    "str",
                    "torch.Tensor",
                    "float",
                    "bytes",
                    "Tuple['cirq.Qid']"
                ]
            }
        },
        "sparse_clip_norm": {
            "name": "sparse_clip_norm",
            "location": 44,
            "return": [
                "float",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "parameters": [
                    "int",
                    "bool",
                    "T",
                    "Optional[Any]",
                    "torch.LongTensor",
                    "float"
                ],
                "max_norm": [
                    "int",
                    "Union[int, float]",
                    "Optional[int]"
                ],
                "norm_type": [
                    "int"
                ]
            }
        },
        "time_to_str": {
            "name": "time_to_str",
            "location": 114,
            "return": [
                "str"
            ],
            "arguments": {
                "timestamp": [
                    "int",
                    "str",
                    "float",
                    "datetime.datetime"
                ]
            }
        },
        "str_to_time": {
            "name": "str_to_time",
            "location": 124,
            "return": [
                "str",
                "datetime.datetime"
            ],
            "arguments": {
                "time_str": [
                    "str",
                    "bytes"
                ]
            }
        },
        "TensorboardWriter.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_log": [
                    "None",
                    "dict",
                    "bytes",
                    "datetime",
                    "str",
                    "torch.multiprocessing.Queue",
                    "bool",
                    "List[List[str]]"
                ],
                "validation_log": [
                    "None",
                    "dict",
                    "bytes",
                    "datetime",
                    "str",
                    "torch.multiprocessing.Queue",
                    "bool",
                    "List[List[str]]"
                ]
            }
        },
        "TensorboardWriter.add_train_scalar": {
            "name": "add_train_scalar",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "value": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "global_step": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ]
            }
        },
        "TensorboardWriter.add_train_histogram": {
            "name": "add_train_histogram",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[str]"
                ],
                "values": [
                    "str",
                    "TextIO"
                ],
                "global_step": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "TensorboardWriter.add_validation_scalar": {
            "name": "add_validation_scalar",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "value": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "global_step": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ]
            }
        },
        "Trainer.__init__": {
            "name": "__init__",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "optimizer": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "iterator": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "train_dataset": [
                    "Callable[[T], List[T]]",
                    "int",
                    "str",
                    "bytes"
                ],
                "validation_dataset": [
                    "None",
                    "Callable[[T], List[T]]",
                    "int",
                    "str",
                    "bytes"
                ],
                "patience": [
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "validation_metric": [
                    "typing.Text",
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "num_epochs": [
                    "int",
                    "Dict[int, zam_repondeur.services.fetch.an.dossiers.models.TexteRef]",
                    "Optional[int]",
                    "data.Passage"
                ],
                "serialization_dir": [
                    "None",
                    "str",
                    "Union[str, List[str], Tuple[str, ...]]",
                    "models.Movie",
                    "Optional[str]"
                ],
                "num_serialized_models_to_keep": [
                    "None",
                    "int",
                    "datetime.datetime"
                ],
                "keep_serialized_model_every_num_seconds": [
                    "None",
                    "bool",
                    "str",
                    "models.scenes.inventory_scene.InventoryScene",
                    "models.characters.mods_base.Mod"
                ],
                "model_save_interval": [
                    "None",
                    "str",
                    "Union[str, bytes]"
                ],
                "cuda_device": [
                    "int",
                    "Union[int, List]",
                    "Optional[int]",
                    "static_frame.core.util.DepthLevelSpecifier",
                    "slice"
                ],
                "grad_norm": [
                    "None",
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "grad_clipping": [
                    "None",
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "learning_rate_scheduler": [
                    "None",
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "summary_interval": [
                    "int",
                    "bool",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "histogram_interval": [
                    "None",
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ]
            }
        },
        "Trainer._enable_gradient_clipping": {
            "name": "_enable_gradient_clipping",
            "location": 287,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._enable_activation_logging": {
            "name": "_enable_activation_logging",
            "location": 296,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._rescale_gradients": {
            "name": "_rescale_gradients",
            "location": 338,
            "return": [
                "None",
                "float",
                "dict",
                "models.User",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._data_parallel": {
            "name": "_data_parallel",
            "location": 347,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "int",
                "bytes",
                "set"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "str",
                    "int",
                    "bytes",
                    "set"
                ]
            }
        },
        "Trainer._batch_loss": {
            "name": "_batch_loss",
            "location": 363,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "bool",
                    "int",
                    "float",
                    "sensibility.model.lstm.DualLSTMModel"
                ],
                "for_training": [
                    "bool",
                    "Callable[[], bool]",
                    "str",
                    "Optional[type]"
                ]
            }
        },
        "Trainer._get_metrics": {
            "name": "_get_metrics",
            "location": 383,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "total_loss": [
                    "int",
                    "float",
                    "str",
                    "Optional[int]"
                ],
                "batch_num": [
                    "int",
                    "float",
                    "str",
                    "Optional[int]"
                ],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "Trainer._train_epoch": {
            "name": "_train_epoch",
            "location": 393,
            "return": [
                "int",
                "str",
                "bool",
                "Optional[BaseException]",
                "Union[str, Tuple[str, ...]]"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "str",
                    "dict",
                    "Dict[str, str]",
                    "annofabapi.models.TaskPhase"
                ]
            }
        },
        "Trainer._should_stop_early": {
            "name": "_should_stop_early",
            "location": 489,
            "return": [
                "bool",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "metric_history": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "Trainer._parameter_and_gradient_statistics_to_tensorboard": {
            "name": "_parameter_and_gradient_statistics_to_tensorboard",
            "location": 502,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "str",
                    "Mapping[str, Any]",
                    "zerver.models.Realm",
                    "Dict[str, str]"
                ],
                "batch_grad_norm": [
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "Trainer._histograms_to_tensorboard": {
            "name": "_histograms_to_tensorboard",
            "location": 533,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "bool",
                    "str",
                    "Optional[bool]"
                ],
                "histogram_parameters": [
                    "Set[str]",
                    "Dict[str, Any]",
                    "int",
                    "nevergrad.common.Loss",
                    "List[datetime.time]",
                    "Union[float, Sequence[float]]"
                ]
            }
        },
        "Trainer._metrics_to_tensorboard": {
            "name": "_metrics_to_tensorboard",
            "location": 543,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "str",
                    "users.models.CustomUser",
                    "Callable",
                    "dict",
                    "Dict[str, str]"
                ],
                "train_metrics": [
                    "dict",
                    "str",
                    "Union[Dict, str]"
                ],
                "val_metrics": [
                    "None",
                    "bytes",
                    "dict",
                    "jumeaux.models.Res2DictAddOnPayload"
                ]
            }
        },
        "Trainer._metrics_to_console": {
            "name": "_metrics_to_console",
            "location": 563,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_metrics": [
                    "dict",
                    "str",
                    "Union[Dict, str]"
                ],
                "val_metrics": [
                    "None",
                    "Dict[str, Any]",
                    "bool",
                    "dict"
                ]
            }
        },
        "Trainer._update_learning_rate": {
            "name": "_update_learning_rate",
            "location": 588,
            "return": [
                "None",
                "mypy.types.Instance",
                "app.models.Article"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "int"
                ],
                "val_metric": [
                    "None",
                    "Optional[str]",
                    "bool",
                    "Optional[datetime.timedelta]",
                    "Optional[float]",
                    "float",
                    "Optional[Callable]",
                    "Optional[int]"
                ],
                "batch_num_total": [
                    "None",
                    "Optional[str]",
                    "float",
                    "Optional[float]",
                    "Optional[int]",
                    "int",
                    "Optional[bool]"
                ]
            }
        },
        "Trainer._validation_loss": {
            "name": "_validation_loss",
            "location": 613,
            "return": [
                "tuple[int]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.train": {
            "name": "train",
            "location": 643,
            "return": [
                "dict[typing.Text, int]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._description_from_metrics": {
            "name": "_description_from_metrics",
            "location": 730,
            "return": [
                "str",
                "dict",
                "models.Name",
                "Dict[str, List[str]]",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "metrics": [
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "Trainer._save_checkpoint": {
            "name": "_save_checkpoint",
            "location": 734,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "str",
                    "bool",
                    "List[str]",
                    "int"
                ],
                "val_metric_per_epoch": [
                    "bool"
                ],
                "is_best": [
                    "None",
                    "Optional[bool]",
                    "bool",
                    "str"
                ]
            }
        },
        "Trainer._restore_checkpoint": {
            "name": "_restore_checkpoint",
            "location": 788,
            "return": [
                "tuple[typing.Union[int,list[]]]",
                "List[Dict[str, Any]]",
                "bool",
                "db.models.taxon.FillDataLevel",
                "List[List[int]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.from_params": {
            "name": "from_params",
            "location": 875,
            "return": [
                "Trainer",
                "Optional[Any]",
                "bytes",
                "bytearray",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "Optional[str]",
                    "Optional[Dict]",
                    "allennlp.common.params.Params",
                    "Optional[Tuple[Any]]",
                    "bool",
                    "Optional[int]",
                    "Dict[str, Any]",
                    "Union[list, dict]",
                    "dict"
                ],
                "model": [
                    "bool",
                    "allennlp.models.model.Model",
                    "Optional[float]",
                    "kirin.core.model.TripUpdate",
                    "keanu.Model"
                ],
                "serialization_dir": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Iterable[allennlp.data.instance.Instance]",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "str"
                ],
                "iterator": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Iterable[allennlp.data.instance.Instance]",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "str"
                ],
                "train_data": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Iterable[allennlp.data.instance.Instance]",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "str"
                ],
                "validation_data": [
                    "allennlp.data.iterators.data_iterator.DataIterator",
                    "Iterable[allennlp.data.instance.Instance]",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "str"
                ],
                "params": [
                    "bytes",
                    "int",
                    "torch.multiprocessing.Queue",
                    "slice"
                ]
            }
        },
        "Trainer._enable_activation_logging.hook": {
            "name": "hook",
            "location": 311,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "module_": [
                    "str",
                    "MutableSequence[str]",
                    "List[str]"
                ],
                "inputs": [
                    "bool",
                    "str",
                    "List[str]"
                ],
                "outputs": [
                    "List[str]",
                    "type",
                    "int",
                    "Optional[float]",
                    "Sequence[float]"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/__init__.py": {},
    "allennlp-dureader-master/allennlp/training/metrics/average.py": {
        "Average.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Average.__call__": {
            "name": "__call__",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "Dict[str, Any]",
                    "str",
                    "dict[str, typing.Any]",
                    "bool",
                    "List[str]",
                    "list[str]",
                    "tuple",
                    "tuple[]"
                ]
            }
        },
        "Average.get_metric": {
            "name": "get_metric",
            "location": 30,
            "return": [
                "int",
                "str",
                "Type[T]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "Average.reset": {
            "name": "reset",
            "location": 42,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/boolean_accuracy.py": {
        "BooleanAccuracy.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BooleanAccuracy.__call__": {
            "name": "__call__",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "None",
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "gold_labels": [
                    "None",
                    "int",
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "mask": [
                    "Optional[torch.Tensor]",
                    "None"
                ]
            }
        },
        "BooleanAccuracy.get_metric": {
            "name": "get_metric",
            "location": 56,
            "return": [
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "BooleanAccuracy.reset": {
            "name": "reset",
            "location": 68,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/categorical_accuracy.py": {
        "CategoricalAccuracy.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "top_k": [
                    "int",
                    "bool"
                ]
            }
        },
        "CategoricalAccuracy.__call__": {
            "name": "__call__",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "int",
                    "common.MechanismState"
                ],
                "gold_labels": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "int"
                ],
                "mask": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "CategoricalAccuracy.get_metric": {
            "name": "get_metric",
            "location": 65,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "str",
                    "bool"
                ]
            }
        },
        "CategoricalAccuracy.reset": {
            "name": "reset",
            "location": 77,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/conll_coref_scores.py": {
        "ConllCorefScores.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConllCorefScores.__call__": {
            "name": "__call__",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "top_spans": [
                    "float",
                    "Optional[float]",
                    "bool",
                    "None",
                    "numpy.array"
                ],
                "antecedent_indices": [
                    "float",
                    "Optional[float]",
                    "bool",
                    "None",
                    "numpy.array"
                ],
                "predicted_antecedents": [
                    "float",
                    "Optional[float]",
                    "bool",
                    "None",
                    "numpy.array"
                ],
                "metadata_list": [
                    "str",
                    "float",
                    "bool",
                    "raiden.utils.TokenAmount"
                ]
            }
        },
        "ConllCorefScores.get_metric": {
            "name": "get_metric",
            "location": 29,
            "return": [
                "tuple[typing.Union[list[tuple[]],list[float],tuple[typing.Union[typing.Literal,typing.Any]],list[],float,int]]",
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "ConllCorefScores.reset": {
            "name": "reset",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConllCorefScores.get_gold_clusters": {
            "name": "get_gold_clusters",
            "location": 42,
            "return": [
                "tuple[typing.Union[list[tuple[]],dict[, tuple[]]]]",
                "dict",
                "Iterable[int]",
                "str",
                "Iterable[numpy.dtype]",
                "int"
            ],
            "arguments": {
                "gold_clusters": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "ConllCorefScores.get_predicted_clusters": {
            "name": "get_predicted_clusters",
            "location": 51,
            "return": [
                "tuple[typing.Union[list[tuple[]],dict[, tuple[]]]]",
                "numpy.array",
                "str",
                "int",
                "recidiviz.utils.regions.Region",
                "IO[str]"
            ],
            "arguments": {
                "top_spans": [
                    "list[int]",
                    "str",
                    "numpy.ndarray",
                    "List[int]",
                    "float",
                    "bool"
                ],
                "antecedent_indices": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "Sequence[str]"
                ],
                "predicted_antecedents": [
                    "str",
                    "bool"
                ]
            }
        },
        "Scorer.__init__": {
            "name": "__init__",
            "location": 91,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "metric": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "Scorer.update": {
            "name": "update",
            "location": 98,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "predicted": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Optional[float]",
                    "None"
                ],
                "gold": [
                    "int",
                    "float",
                    "str",
                    "typing.Callable[, ]",
                    "Callable",
                    "tuple[str]",
                    "Tuple[str]",
                    "None",
                    "bool",
                    "Optional[str]"
                ],
                "mention_to_predicted": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "dict[str, typing.Any]",
                    "None",
                    "Optional[Dict[str, Any]]",
                    "Union[float, int]"
                ],
                "mention_to_gold": [
                    "int",
                    "float",
                    "str",
                    "typing.Callable[, ]",
                    "Callable",
                    "tuple[str]",
                    "Tuple[str]",
                    "None",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Scorer.get_f1": {
            "name": "get_f1",
            "location": 109,
            "return": [
                "int",
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scorer.get_recall": {
            "name": "get_recall",
            "location": 116,
            "return": [
                "str",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scorer.get_precision": {
            "name": "get_precision",
            "location": 122,
            "return": [
                "str",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scorer.get_prf": {
            "name": "get_prf",
            "location": 128,
            "return": [
                "tuple[]",
                "bool",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scorer.b_cubed": {
            "name": "b_cubed",
            "location": 132,
            "return": [
                "tuple[typing.Union[int,float]]",
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "clusters": [
                    "list[str]",
                    "list[]",
                    "str",
                    "Callable",
                    "List[str]",
                    "list",
                    "bool"
                ],
                "mention_to_gold": [
                    "list[str]",
                    "int",
                    "List[str]",
                    "Set[Optional[str]]",
                    "numpy.ndarray"
                ]
            }
        },
        "Scorer.muc": {
            "name": "muc",
            "location": 154,
            "return": [
                "bool",
                "tuple[int]"
            ],
            "arguments": {
                "clusters": [
                    "dict[int, str]",
                    "str",
                    "bool",
                    "Dict[int, str]",
                    "Iterable['cirq.Operation']",
                    "Counter",
                    "float"
                ],
                "mention_to_gold": [
                    "str",
                    "int",
                    "Set[str]"
                ]
            }
        },
        "Scorer.phi4": {
            "name": "phi4",
            "location": 174,
            "return": [
                "float",
                "bool",
                "int",
                "Tuple[int, int]",
                "tuple",
                "List[str]",
                "Union[List[str], str]"
            ],
            "arguments": {
                "gold_clustering": [
                    "str",
                    "trezor.utils.Writer",
                    "numpy.ndarray",
                    "int"
                ],
                "predicted_clustering": [
                    "str",
                    "trezor.utils.Writer",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "Scorer.ceafe": {
            "name": "ceafe",
            "location": 183,
            "return": [
                "tuple[bool]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "clusters": [
                    "list[str]",
                    "int",
                    "list[int]",
                    "Union[List[str], List[int]]",
                    "List[int]"
                ],
                "gold_clusters": [
                    "List[int]",
                    "str",
                    "list",
                    "int",
                    "List[str]",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/entropy.py": {
        "Entropy.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Entropy.__call__": {
            "name": "__call__",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "int",
                    "Set[str]",
                    "set[str]"
                ],
                "mask": [
                    "int",
                    "None",
                    "allennlp.data.vocabulary.Vocabulary",
                    "T"
                ]
            }
        },
        "Entropy.get_metric": {
            "name": "get_metric",
            "location": 45,
            "return": [
                "int",
                "str",
                "Type[T]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "Entropy.reset": {
            "name": "reset",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/evalb_bracketing_scorer.py": {
        "EvalbBracketingScorer.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "evalb_directory_path": [
                    "str",
                    "bool",
                    "int"
                ],
                "evalb_param_filename": [
                    "typing.Text",
                    "str",
                    "bool"
                ]
            }
        },
        "EvalbBracketingScorer.__call__": {
            "name": "__call__",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "predicted_trees": [
                    "List[nltk.Tree]",
                    "list[nltk.Tree]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "gold_trees": [
                    "List[nltk.Tree]",
                    "list[nltk.Tree]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "EvalbBracketingScorer.get_metric": {
            "name": "get_metric",
            "location": 94,
            "return": [
                "dict[typing.Text, typing.Union[float,int]]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "EvalbBracketingScorer.reset": {
            "name": "reset",
            "location": 109,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/f1_measure.py": {
        "F1Measure.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "positive_label": [
                    "str",
                    "dict",
                    "torch.nn.utils.rnn.PackedSequence"
                ]
            }
        },
        "F1Measure.__call__": {
            "name": "__call__",
            "location": 25,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "gold_labels": [
                    "torch.Tensor",
                    "int"
                ],
                "mask": []
            }
        },
        "F1Measure.get_metric": {
            "name": "get_metric",
            "location": 76,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "str",
                    "bool"
                ]
            }
        },
        "F1Measure.reset": {
            "name": "reset",
            "location": 92,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/mention_recall.py": {
        "MentionRecall.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MentionRecall.__call__": {
            "name": "__call__",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batched_top_spans": [
                    "dict[str, torch.Tensor]",
                    "int",
                    "Dict[str, torch.Tensor]",
                    "torch.Tensor"
                ],
                "batched_metadata": [
                    "dict[str, torch.Tensor]",
                    "int",
                    "Dict[str, torch.Tensor]",
                    "torch.Tensor"
                ]
            }
        },
        "MentionRecall.get_metric": {
            "name": "get_metric",
            "location": 28,
            "return": [
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "MentionRecall.reset": {
            "name": "reset",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/metric.py": {
        "Metric.__call__": {
            "name": "__call__",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "None",
                    "BaseException",
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Optional[torch.BoolTensor]"
                ],
                "gold_labels": [
                    "None",
                    "BaseException",
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Optional[torch.BoolTensor]"
                ],
                "mask": [
                    "None",
                    "BaseException",
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Optional[torch.BoolTensor]"
                ]
            }
        },
        "Metric.get_metric": {
            "name": "get_metric",
            "location": 31,
            "return": [
                "typing.Union[builtins.float, typing.Tuple[builtins.float, ...], typing.Dict[builtins.str, builtins.float]]",
                "None"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str",
                    "dict[, ]",
                    "T",
                    "dict"
                ]
            }
        },
        "Metric.reset": {
            "name": "reset",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Metric.from_params": {
            "name": "from_params",
            "location": 44,
            "return": [
                "Dict[str, Any]",
                "Dict[str, Union[str, Any]]",
                "List[str]",
                "dict",
                "type",
                "Optional[str]"
            ],
            "arguments": {
                "cls": [
                    "Mapping[str, Any]",
                    "dict"
                ],
                "params": [
                    "allennlp.common.Params",
                    "dict",
                    "allennlp.common.params.Params",
                    "Type[T]",
                    "Exception"
                ],
                "vocab": [
                    "str",
                    "None",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "Metric.unwrap_to_tensors": {
            "name": "unwrap_to_tensors",
            "location": 51,
            "return": [
                "typing.Generator[tuple[typing.Union[int,int,str]]]",
                "int",
                "Callable",
                "bool",
                "Tuple[int, int]",
                "Optional[recidiviz.common.constants.state.state_supervision_period.StateSupervisionPeriodSupervisionType]"
            ],
            "arguments": {}
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/span_based_f1_measure.py": {
        "SpanBasedF1Measure.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocabulary": [
                    "str",
                    "bool",
                    "list",
                    "Optional[str]"
                ],
                "tag_namespace": [
                    "str",
                    "bool",
                    "list",
                    "Optional[str]"
                ],
                "ignore_classes": [
                    "List[str]",
                    "str",
                    "Optional[str]"
                ],
                "label_encoding": [
                    "bool",
                    "Optional[str]",
                    "List[str]",
                    "int",
                    "type",
                    "Sequence"
                ]
            }
        },
        "SpanBasedF1Measure.__call__": {
            "name": "__call__",
            "location": 71,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "gold_labels": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "mask": [
                    "Optional[torch.Tensor]",
                    "torch.IntTensor"
                ],
                "prediction_map": [
                    "torch.Tensor",
                    "Optional[torch.Tensor]",
                    "Optional[torch.BoolTensor]"
                ]
            }
        },
        "SpanBasedF1Measure._handle_continued_spans": {
            "name": "_handle_continued_spans",
            "location": 154,
            "return": [
                "str",
                "List[allennlp.data.dataset_readers.dataset_utils.span_utils.TypedStringSpan]",
                "List[str]",
                "List[Dict]",
                "Union[List, Tuple]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "spans": [
                    "List[allennlp.data.dataset_readers.dataset_utils.span_utils.TypedStringSpan]"
                ]
            }
        },
        "SpanBasedF1Measure.get_metric": {
            "name": "get_metric",
            "location": 189,
            "return": [
                "str",
                "set",
                "Set[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "str",
                    "bool"
                ]
            }
        },
        "SpanBasedF1Measure._compute_metrics": {
            "name": "_compute_metrics",
            "location": 229,
            "return": [
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "true_positives": [
                    "int"
                ],
                "false_positives": [
                    "int",
                    "Callable[[int], bool]",
                    "str",
                    "float"
                ],
                "false_negatives": [
                    "int",
                    "Callable[[int], bool]",
                    "str",
                    "float"
                ]
            }
        },
        "SpanBasedF1Measure.reset": {
            "name": "reset",
            "location": 235,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/squad_em_and_f1.py": {
        "SquadEmAndF1.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SquadEmAndF1.__call__": {
            "name": "__call__",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "best_span_string": [
                    "str",
                    "tuple",
                    "tuple[]"
                ],
                "answer_strings": [
                    "str",
                    "tuple",
                    "tuple[]"
                ]
            }
        },
        "SquadEmAndF1.get_metric": {
            "name": "get_metric",
            "location": 42,
            "return": [
                "tuple[int]",
                "str",
                "int",
                "Dict[str, Any]",
                "Callable[[str], T]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str"
                ]
            }
        },
        "SquadEmAndF1.reset": {
            "name": "reset",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SquadEmAndF1.__str__": {
            "name": "__str__",
            "location": 61,
            "return": [
                "typing.Text",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/allennlp/training/metrics/__init__.py": {},
    "allennlp-dureader-master/doc/conf.py": {
        "linkcode_resolve": {
            "name": "linkcode_resolve",
            "location": 199,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "domain": [
                    "int",
                    "str",
                    "T"
                ],
                "info": [
                    "Callable",
                    "Exception",
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/cache_models.py": {},
    "allennlp-dureader-master/scripts/check_docs.py": {
        "documented_modules": {
            "name": "documented_modules",
            "location": 39,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "docs_dir": [
                    "str"
                ],
                "module_regex": [
                    "str"
                ]
            }
        },
        "existing_modules": {
            "name": "existing_modules",
            "location": 51,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "module_glob": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/create_elmo_embeddings_from_vocab.py": {
        "main": {
            "name": "main",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "vocab_path": [
                    "str",
                    "int"
                ],
                "elmo_config_path": [
                    "int",
                    "str"
                ],
                "elmo_weights_path": [
                    "int",
                    "str"
                ],
                "output_dir": [
                    "str",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "Union[int, str]"
                ],
                "device": [
                    "str",
                    "int",
                    "Dict[str, numpy.ndarray]",
                    "dict[str, numpy.ndarray]"
                ],
                "use_custom_oov_token": [
                    "bool",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/inspect_cache.py": {},
    "allennlp-dureader-master/scripts/regenerate_archived_models.py": {
        "generate_archive": {
            "name": "generate_archive",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "config_file": [
                    "str",
                    "int",
                    "dict[str, str]",
                    "bool",
                    "set[]",
                    "Dict[str, str]",
                    "set"
                ],
                "serialization_dir": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "weights_file": [
                    "str",
                    "typing.Text"
                ],
                "archive_name": [
                    "str",
                    "typing.Text"
                ],
                "exist_ok": [
                    "bool",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/train_fixtures.py": {
        "train_fixture": {
            "name": "train_fixture",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "config_prefix": [
                    "str",
                    "Optional[str]",
                    "TextIO",
                    "Dict[str, Any]"
                ]
            }
        },
        "train_fixture_gpu": {
            "name": "train_fixture_gpu",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "config_prefix": [
                    "str",
                    "Optional[str]",
                    "TextIO",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/verify.py": {
        "main": {
            "name": "main",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "checks": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/write_srl_predictions_to_conll_format.py": {
        "main": {
            "name": "main",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "serialization_directory": [
                    "str",
                    "Union[str, bytes]",
                    "bytes"
                ],
                "device": [
                    "str",
                    "ddionrails.studies.models.Study",
                    "_params.Params"
                ]
            }
        }
    },
    "allennlp-dureader-master/scripts/ai2-internal/run_with_beaker.py": {
        "main": {
            "name": "main",
            "location": 21,
            "return": [
                ""
            ],
            "arguments": {
                "param_file": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "extra_beaker_commands": [
                    "BinaryIO",
                    "Iterable[str]",
                    "_params.Params",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/notebooks_test.py": {
        "TestNotebooks.test_vocabulary_tutorial": {
            "name": "test_vocabulary_tutorial",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNotebooks.test_data_pipeline_tutorial": {
            "name": "test_data_pipeline_tutorial",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNotebooks.test_embedding_tokens_tutorial": {
            "name": "test_embedding_tokens_tutorial",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNotebooks.execute_notebook": {
            "name": "execute_notebook",
            "location": 20,
            "return": [
                "bool"
            ],
            "arguments": {
                "notebook_path": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/__init__.py": {},
    "allennlp-dureader-master/tests/commands/dry_run_test.py": {
        "TestDryRun.setUp": {
            "name": "setUp",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDryRun.test_dry_run_doesnt_overwrite_vocab": {
            "name": "test_dry_run_doesnt_overwrite_vocab",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/elmo_test.py": {
        "TestElmoCommand.test_all_embedding_works": {
            "name": "test_all_embedding_works",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_top_embedding_works": {
            "name": "test_top_embedding_works",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_average_embedding_works": {
            "name": "test_average_embedding_works",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_batch_embedding_works": {
            "name": "test_batch_embedding_works",
            "location": 115,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_duplicate_sentences": {
            "name": "test_duplicate_sentences",
            "location": 149,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoCommand.test_empty_sentences_are_filtered": {
            "name": "test_empty_sentences_are_filtered",
            "location": 184,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoEmbedder.test_embeddings_are_as_expected": {
            "name": "test_embeddings_are_as_expected",
            "location": 220,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoEmbedder.test_embed_batch_is_empty_sentence": {
            "name": "test_embed_batch_is_empty_sentence",
            "location": 245,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoEmbedder.test_embed_batch_contains_empty_sentence": {
            "name": "test_embed_batch_contains_empty_sentence",
            "location": 251,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/evaluate_test.py": {
        "TestEvaluate.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEvaluate.test_evaluate_from_args": {
            "name": "test_evaluate_from_args",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/fine_tune_test.py": {
        "TestFineTune.setUp": {
            "name": "setUp",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFineTune.test_fine_tune_model_runs_from_file_paths": {
            "name": "test_fine_tune_model_runs_from_file_paths",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFineTune.test_fine_tune_runs_from_parser_arguments": {
            "name": "test_fine_tune_runs_from_parser_arguments",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFineTune.test_fine_tune_fails_without_required_args": {
            "name": "test_fine_tune_fails_without_required_args",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/main_test.py": {
        "TestMain.test_fails_on_unknown_command": {
            "name": "test_fails_on_unknown_command",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMain.test_subcommand_overrides": {
            "name": "test_subcommand_overrides",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMain.test_other_modules": {
            "name": "test_other_modules",
            "location": 51,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMain.test_subcommand_overrides.do_nothing": {
            "name": "do_nothing",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "_": [
                    "bool",
                    "int",
                    "set"
                ]
            }
        },
        "TestMain.test_subcommand_overrides.FakeEvaluate.add_subparser": {
            "name": "add_subparser",
            "location": 34,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "parser": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/commands/make_vocab_test.py": {
        "TestMakeVocab.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMakeVocab.test_make_vocab_fails_without_vocabulary_key": {
            "name": "test_make_vocab_fails_without_vocabulary_key",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMakeVocab.test_make_vocab_makes_vocab": {
            "name": "test_make_vocab_makes_vocab",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/predict_test.py": {
        "TestPredict.test_add_predict_subparser": {
            "name": "test_add_predict_subparser",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_works_with_known_model": {
            "name": "test_works_with_known_model",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_batch_prediction_works_with_known_model": {
            "name": "test_batch_prediction_works_with_known_model",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_fails_without_required_args": {
            "name": "test_fails_without_required_args",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_can_specify_predictor": {
            "name": "test_can_specify_predictor",
            "location": 125,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_other_modules": {
            "name": "test_other_modules",
            "location": 169,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_alternative_file_formats": {
            "name": "test_alternative_file_formats",
            "location": 227,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPredict.test_can_specify_predictor.Bidaf3Predictor.predict_json": {
            "name": "predict_json",
            "location": 130,
            "return": [
                "deoplete.util.UserContext",
                "bool",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "allennlp.common.util.JsonDict",
                    "str",
                    "Callable",
                    "Callable[[T], T]",
                    "T"
                ],
                "cuda_device": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestPredict.test_alternative_file_formats.BidafCsvPredictor.load_line": {
            "name": "load_line",
            "location": 235,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "line": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "TestPredict.test_alternative_file_formats.BidafCsvPredictor.dump_line": {
            "name": "dump_line",
            "location": 240,
            "return": [
                "str",
                "Optional[str]",
                "Set[str]",
                "Tuple[str, str]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "outputs": [
                    "allennlp.common.util.JsonDict",
                    "List[float]",
                    "bytes",
                    "str",
                    "allennlp.data.token_indexers.token_indexer.IndexedTokenList",
                    "pathlib.Path"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/commands/serve_test.py": {
        "TestServe.test_add_serve": {
            "name": "test_add_serve",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/train_test.py": {
        "TestTrain.test_train_model": {
            "name": "test_train_model",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrain.test_train_with_test_set": {
            "name": "test_train_with_test_set",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrain.test_train_args": {
            "name": "test_train_args",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LazyFakeReader.__init__": {
            "name": "__init__",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LazyFakeReader._read": {
            "name": "_read",
            "location": 104,
            "return": [
                "str",
                "float",
                "int",
                "Union[float, int]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "LazyFakeReader.from_params": {
            "name": "from_params",
            "location": 111,
            "return": [
                "LazyFakeReader",
                "str",
                "Callable",
                "Callable[[None, None], bool]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "dict[str, typing.Any]",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "int",
                    "dict[str, typing.Any]",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ]
            }
        },
        "TestTrainOnLazyDataset.test_train_model": {
            "name": "test_train_model",
            "location": 116,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainOnLazyDataset.test_train_with_test_set": {
            "name": "test_train_with_test_set",
            "location": 145,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/commands/__init__.py": {},
    "allennlp-dureader-master/tests/common/file_utils_test.py": {
        "set_up_glove": {
            "name": "set_up_glove",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "url": [
                    "str",
                    "bool"
                ],
                "byt": [
                    "bytes",
                    "int",
                    "str"
                ],
                "change_etag_every": [
                    "int",
                    "bytes",
                    "str"
                ]
            }
        },
        "set_up_glove.head_callback": {
            "name": "head_callback",
            "location": 26,
            "return": [
                "tuple[typing.Union[int,dict[typing.Text, ],typing.Text]]",
                "dict",
                "int",
                "str",
                "bytes",
                "Dict[str, str]"
            ],
            "arguments": {
                "_": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestFileUtils.setUp": {
            "name": "setUp",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_url_to_filename": {
            "name": "test_url_to_filename",
            "location": 55,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_url_to_filename_with_etags": {
            "name": "test_url_to_filename_with_etags",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_url_to_filename_with_etags_eliminates_quotes": {
            "name": "test_url_to_filename_with_etags_eliminates_quotes",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_get_from_cache": {
            "name": "test_get_from_cache",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFileUtils.test_cached_path": {
            "name": "test_cached_path",
            "location": 130,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/common/params_test.py": {
        "TestParams.test_load_from_file": {
            "name": "test_load_from_file",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_overrides": {
            "name": "test_overrides",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_as_flat_dict": {
            "name": "test_as_flat_dict",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_add_file_to_archive": {
            "name": "test_add_file_to_archive",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestParams.test_add_file_to_archive.A.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "b": [
                    "float",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.A.from_params": {
            "name": "from_params",
            "location": 62,
            "return": [
                "Tuple[float, float]",
                "int",
                "float",
                "Dict[str, List[str]]",
                "AbstractSet[T_co]",
                "MutableSet[T]",
                "Tuple[List[str], List[str], List[str]]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "dict"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "dict",
                    "MutableMapping",
                    "str",
                    "Type['Declared']"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.B.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str"
                ],
                "c": [
                    "str",
                    "List[str]",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.B.from_params": {
            "name": "from_params",
            "location": 72,
            "return": [
                "str",
                "List[int]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]",
                    "Union[int, str]"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "dict"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.C.__init__": {
            "name": "__init__",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "c_file": [
                    "str",
                    "Set[int]",
                    "bool"
                ]
            }
        },
        "TestParams.test_add_file_to_archive.C.from_params": {
            "name": "from_params",
            "location": 86,
            "return": [
                "str",
                "Callable",
                "Dict[str, str]",
                "MutableMapping"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "int"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "str",
                    "int",
                    "TextIO"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/common/registrable_test.py": {
        "TestRegistrable.test_registrable_functionality_works": {
            "name": "test_registrable_functionality_works",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_dataset_readers": {
            "name": "test_registry_has_builtin_dataset_readers",
            "location": 63,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_iterators": {
            "name": "test_registry_has_builtin_iterators",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_tokenizers": {
            "name": "test_registry_has_builtin_tokenizers",
            "location": 74,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_token_indexers": {
            "name": "test_registry_has_builtin_token_indexers",
            "location": 78,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_regularizers": {
            "name": "test_registry_has_builtin_regularizers",
            "location": 82,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_initializers": {
            "name": "test_registry_has_builtin_initializers",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_learning_rate_schedulers": {
            "name": "test_registry_has_builtin_learning_rate_schedulers",
            "location": 104,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_token_embedders": {
            "name": "test_registry_has_builtin_token_embedders",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_text_field_embedders": {
            "name": "test_registry_has_builtin_text_field_embedders",
            "location": 118,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_seq2seq_encoders": {
            "name": "test_registry_has_builtin_seq2seq_encoders",
            "location": 121,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_seq2vec_encoders": {
            "name": "test_registry_has_builtin_seq2vec_encoders",
            "location": 127,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegistrable.test_registry_has_builtin_similarity_functions": {
            "name": "test_registry_has_builtin_similarity_functions",
            "location": 134,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/common/test_util.py": {
        "TestCommonUtils.test_group_by_count": {
            "name": "test_group_by_count",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_lazy_groups_of": {
            "name": "test_lazy_groups_of",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_pad_sequence_to_length": {
            "name": "test_pad_sequence_to_length",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_namespace_match": {
            "name": "test_namespace_match",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_sanitize": {
            "name": "test_sanitize",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCommonUtils.test_import_submodules": {
            "name": "test_import_submodules",
            "location": 42,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/common/__init__.py": {},
    "allennlp-dureader-master/tests/custom_extensions/alternating_highway_lstm_test.py": {
        "TestCustomHighwayLSTM.test_small_model": {
            "name": "test_small_model",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCustomHighwayLSTM.test_large_model": {
            "name": "test_large_model",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCustomHighwayLSTM.test_validation_forward_pass_is_deterministic_in_model_with_dropout": {
            "name": "test_validation_forward_pass_is_deterministic_in_model_with_dropout",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCustomHighwayLSTM.forward_and_backward_outputs_match": {
            "name": "forward_and_backward_outputs_match",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "baseline_model": [
                    "bool",
                    "torch.Tensor",
                    "int",
                    "numpy.ndarray",
                    "Dict[str, torch.Tensor]"
                ],
                "kernel_model": [
                    "int",
                    "str",
                    "IO[str]"
                ],
                "baseline_input": [
                    "float"
                ],
                "kernel_input": [
                    "float"
                ],
                "lengths": [
                    "bool"
                ]
            }
        },
        "TestCustomHighwayLSTM.get_models_and_inputs": {
            "name": "get_models_and_inputs",
            "location": 88,
            "return": [
                "tuple[typing.Union[int,list[],float,list[list[int]],typing.Callable[[], str],Variable]]",
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "batch_size": [
                    "int",
                    "Tuple[int, int]"
                ],
                "input_size": [
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "output_size": [
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "num_layers": [
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "timesteps": [
                    "int",
                    "Tuple[int, int]",
                    "list"
                ],
                "dropout_prob": [
                    "int",
                    "List[str]",
                    "list[str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_test.py": {
        "TestDataset.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_instances_must_have_homogeneous_fields": {
            "name": "test_instances_must_have_homogeneous_fields",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_padding_lengths_uses_max_instance_lengths": {
            "name": "test_padding_lengths_uses_max_instance_lengths",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.test_as_tensor_dict": {
            "name": "test_as_tensor_dict",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDataset.get_instances": {
            "name": "get_instances",
            "location": 50,
            "return": [
                "list[Instance]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/vocabulary_test.py": {
        "TestVocabulary.setUp": {
            "name": "setUp",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_max_vocab_size_single_int": {
            "name": "test_from_dataset_respects_max_vocab_size_single_int",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_min_count": {
            "name": "test_from_dataset_respects_min_count",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_exclusive_embedding_file": {
            "name": "test_from_dataset_respects_exclusive_embedding_file",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_dataset_respects_inclusive_embedding_file": {
            "name": "test_from_dataset_respects_inclusive_embedding_file",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_add_word_to_index_gives_consistent_results": {
            "name": "test_add_word_to_index_gives_consistent_results",
            "location": 98,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_namespaces": {
            "name": "test_namespaces",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_namespace_dependent_default_dict": {
            "name": "test_namespace_dependent_default_dict",
            "location": 135,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_unknown_token": {
            "name": "test_unknown_token",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_set_from_file_reads_padded_files": {
            "name": "test_set_from_file_reads_padded_files",
            "location": 157,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_set_from_file_reads_non_padded_files": {
            "name": "test_set_from_file_reads_non_padded_files",
            "location": 190,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_saving_and_loading": {
            "name": "test_saving_and_loading",
            "location": 213,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_saving_and_loading_works_with_byte_encoding": {
            "name": "test_saving_and_loading_works_with_byte_encoding",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_from_params": {
            "name": "test_from_params",
            "location": 274,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVocabulary.test_vocab_can_print": {
            "name": "test_vocab_can_print",
            "location": 304,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/__init__.py": {},
    "allennlp-dureader-master/tests/data/dataset_readers/conll2003_dataset_reader_test.py": {
        "TestConll2003Reader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "str"
                ],
                "coding_scheme": [
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/language_modeling_dataset_test.py": {
        "TestLanguageModelingDatasetReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "set",
                    "set[]",
                    "Dict[str, Sequence[Any]]",
                    "dict[str, typing.Sequence[typing.Any]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/lazy_dataset_reader_test.py": {
        "LazyDatasetReader.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "instances": [
                    "int",
                    "float",
                    "bool"
                ],
                "lazy": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "LazyDatasetReader._read": {
            "name": "_read",
            "location": 20,
            "return": [
                "typing.Generator[]",
                "int",
                "list",
                "List[Dict]",
                "List[Tuple[int, float]]",
                "List[dict]",
                "List[str]",
                "Iterator[str]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "_": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestLazyDatasetReader.setUp": {
            "name": "setUp",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLazyDatasetReader.test_lazy": {
            "name": "test_lazy",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLazyDatasetReader.test_non_lazy": {
            "name": "test_non_lazy",
            "location": 53,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/penn_tree_bank_reader_test.py": {
        "TestPennTreeBankConstituencySpanReader.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_strip_functional_tags": {
            "name": "test_strip_functional_tags",
            "location": 90,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_get_gold_spans_correctly_extracts_spans": {
            "name": "test_get_gold_spans_correctly_extracts_spans",
            "location": 97,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPennTreeBankConstituencySpanReader.test_get_gold_spans_correctly_extracts_spans_with_nested_labels": {
            "name": "test_get_gold_spans_correctly_extracts_spans_with_nested_labels",
            "location": 106,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/seq2seq_test.py": {
        "TestSeq2SeqDatasetReader.test_default_format": {
            "name": "test_default_format",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "str"
                ]
            }
        },
        "TestSeq2SeqDatasetReader.test_source_add_start_token": {
            "name": "test_source_add_start_token",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/sequence_tagging_test.py": {
        "TestSequenceTaggingDatasetReader.test_default_format": {
            "name": "test_default_format",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "str",
                    "int"
                ]
            }
        },
        "TestSequenceTaggingDatasetReader.test_brown_corpus_format": {
            "name": "test_brown_corpus_format",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/snli_reader_test.py": {
        "TestSnliReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/srl_dataset_reader_test.py": {
        "TestSrlReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSrlReader.test_srl_reader_can_filter_by_domain": {
            "name": "test_srl_reader_can_filter_by_domain",
            "location": 53,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/stanford_sentiment_tree_bank_test.py": {
        "TestStanfordSentimentTreebankReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "List[str]",
                    "bytes",
                    "list[str]"
                ]
            }
        },
        "TestStanfordSentimentTreebankReader.test_use_subtrees": {
            "name": "test_use_subtrees",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_3_class": {
            "name": "test_3_class",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_2_class": {
            "name": "test_2_class",
            "location": 79,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStanfordSentimentTreebankReader.test_from_params": {
            "name": "test_from_params",
            "location": 97,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/__init__.py": {},
    "allennlp-dureader-master/tests/data/dataset_readers/coreference/coref_reader_test.py": {
        "TestCorefReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "int",
                    "str"
                ]
            }
        },
        "TestCorefReader.check_candidate_mentions_are_well_defined": {
            "name": "check_candidate_mentions_are_well_defined",
            "location": 72,
            "return": [
                "list[str]",
                "str",
                "bool",
                "Callable",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "span_starts": [
                    "int",
                    "float",
                    "bool"
                ],
                "span_ends": [
                    "int",
                    "float",
                    "bool"
                ],
                "text": [
                    "int",
                    "float",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/coreference/winobias_reader_test.py": {
        "TestWinobiasReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "int",
                    "str"
                ]
            }
        },
        "TestWinobiasReader.check_candidate_mentions_are_well_defined": {
            "name": "check_candidate_mentions_are_well_defined",
            "location": 52,
            "return": [
                "list[str]",
                "str",
                "bool",
                "Callable",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "span_starts": [
                    "int",
                    "float",
                    "bool"
                ],
                "span_ends": [
                    "int",
                    "float",
                    "bool"
                ],
                "text": [
                    "int",
                    "float",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/dataset_utils/ontonotes_test.py": {
        "TestOntonotes.test_dataset_iterator": {
            "name": "test_dataset_iterator",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestOntonotes.test_dataset_path_iterator": {
            "name": "test_dataset_path_iterator",
            "location": 122,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestOntonotes.test_ontonotes_can_read_conll_file_with_multiple_documents": {
            "name": "test_ontonotes_can_read_conll_file_with_multiple_documents",
            "location": 130,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/dataset_utils/span_utils_test.py": {
        "SpanUtilsTest.test_bio_tags_to_spans_extracts_correct_spans": {
            "name": "test_bio_tags_to_spans_extracts_correct_spans",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_bio_tags_to_spans_ignores_specified_tags": {
            "name": "test_bio_tags_to_spans_ignores_specified_tags",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_enumerate_spans_enumerates_all_spans": {
            "name": "test_enumerate_spans_enumerates_all_spans",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_bioul_tags_to_spans": {
            "name": "test_bioul_tags_to_spans",
            "location": 60,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_iob1_to_bioul": {
            "name": "test_iob1_to_bioul",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanUtilsTest.test_enumerate_spans_enumerates_all_spans.no_prefixed_punctuation": {
            "name": "no_prefixed_punctuation",
            "location": 47,
            "return": [
                "bool",
                "dict",
                "Iterable[str]",
                "as3.scanner.Token"
            ],
            "arguments": {
                "tokens": [
                    "List[allennlp.data.tokenizers.token.Token]",
                    "oj.tokens.Token",
                    "List[str]",
                    "str",
                    "List[List[str]]",
                    "Sequence[Sequence[str]]",
                    "Sequence[str]",
                    "bytes"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/squad_test.py": {
        "TestSquadReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSquadReader.test_can_build_from_params": {
            "name": "test_can_build_from_params",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/triviaqa_test.py": {
        "TestTriviaQaReader.test_read": {
            "name": "test_read",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/util_test.py": {
        "TestReadingComprehensionUtil.test_char_span_to_token_span_handles_easy_cases": {
            "name": "test_char_span_to_token_span_handles_easy_cases",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestReadingComprehensionUtil.test_char_span_to_token_span_handles_hard_cases": {
            "name": "test_char_span_to_token_span_handles_hard_cases",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/dataset_readers/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/tests/data/fields/array_field_test.py": {
        "TestArrayField.test_get_padding_lengths_correctly_returns_ordered_shape": {
            "name": "test_get_padding_lengths_correctly_returns_ordered_shape",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_as_tensor_handles_larger_padding_dimensions": {
            "name": "test_as_tensor_handles_larger_padding_dimensions",
            "location": 18,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_padding_handles_list_fields": {
            "name": "test_padding_handles_list_fields",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_padding_handles_list_fields_with_padding_values": {
            "name": "test_padding_handles_list_fields_with_padding_values",
            "location": 42,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestArrayField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/index_field_test.py": {
        "TestIndexField.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_as_tensor_converts_field_correctly": {
            "name": "test_as_tensor_converts_field_correctly",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_index_field_raises_on_incorrect_label_type": {
            "name": "test_index_field_raises_on_incorrect_label_type",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_index_field_empty_field_works": {
            "name": "test_index_field_empty_field_works",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIndexField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/label_field_test.py": {
        "TestLabelField.test_as_tensor_returns_integer_tensor": {
            "name": "test_as_tensor_returns_integer_tensor",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_can_index_with_vocab": {
            "name": "test_label_field_can_index_with_vocab",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_raises_with_non_integer_labels_and_no_indexing": {
            "name": "test_label_field_raises_with_non_integer_labels_and_no_indexing",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_raises_with_incorrect_label_type": {
            "name": "test_label_field_raises_with_incorrect_label_type",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_label_field_empty_field_works": {
            "name": "test_label_field_empty_field_works",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_class_variables_for_namespace_warnings_work_correctly": {
            "name": "test_class_variables_for_namespace_warnings_work_correctly",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLabelField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/list_field_test.py": {
        "TestListField.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_get_padding_lengths": {
            "name": "test_get_padding_lengths",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_list_field_can_handle_empty_text_fields": {
            "name": "test_list_field_can_handle_empty_text_fields",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_list_field_can_handle_empty_index_fields": {
            "name": "test_list_field_can_handle_empty_index_fields",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_list_field_can_handle_empty_sequence_label_fields": {
            "name": "test_list_field_can_handle_empty_sequence_label_fields",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_all_fields_padded_to_max_length": {
            "name": "test_all_fields_padded_to_max_length",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_nested_list_fields_are_padded_correctly": {
            "name": "test_nested_list_fields_are_padded_correctly",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_fields_can_pad_to_greater_than_max_length": {
            "name": "test_fields_can_pad_to_greater_than_max_length",
            "location": 98,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_as_tensor_can_handle_multiple_token_indexers": {
            "name": "test_as_tensor_can_handle_multiple_token_indexers",
            "location": 116,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_as_tensor_can_handle_multiple_token_indexers_and_empty_fields": {
            "name": "test_as_tensor_can_handle_multiple_token_indexers_and_empty_fields",
            "location": 150,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestListField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 181,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/multilabel_field_test.py": {
        "TestMultiLabelField.test_as_tensor_returns_integer_tensor": {
            "name": "test_as_tensor_returns_integer_tensor",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_can_index_with_vocab": {
            "name": "test_multilabel_field_can_index_with_vocab",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_non_integer_labels_and_no_indexing": {
            "name": "test_multilabel_field_raises_with_non_integer_labels_and_no_indexing",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_no_indexing_and_missing_num_labels": {
            "name": "test_multilabel_field_raises_with_no_indexing_and_missing_num_labels",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_no_indexing_and_wrong_num_labels": {
            "name": "test_multilabel_field_raises_with_no_indexing_and_wrong_num_labels",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_incorrect_label_type": {
            "name": "test_multilabel_field_raises_with_incorrect_label_type",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_raises_with_given_num_labels": {
            "name": "test_multilabel_field_raises_with_given_num_labels",
            "location": 44,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_multilabel_field_empty_field_works": {
            "name": "test_multilabel_field_empty_field_works",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_class_variables_for_namespace_warnings_work_correctly": {
            "name": "test_class_variables_for_namespace_warnings_work_correctly",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiLabelField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/sequence_label_field_test.py": {
        "TestSequenceLabelField.setUp": {
            "name": "setUp",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_tag_length_mismatch_raises": {
            "name": "test_tag_length_mismatch_raises",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_count_vocab_items_correctly_indexes_tags": {
            "name": "test_count_vocab_items_correctly_indexes_tags",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_index_converts_field_correctly": {
            "name": "test_index_converts_field_correctly",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_as_tensor_produces_integer_targets": {
            "name": "test_as_tensor_produces_integer_targets",
            "location": 51,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_sequence_label_field_raises_on_incorrect_type": {
            "name": "test_sequence_label_field_raises_on_incorrect_type",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_class_variables_for_namespace_warnings_work_correctly": {
            "name": "test_class_variables_for_namespace_warnings_work_correctly",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceLabelField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 87,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/span_field_test.py": {
        "TestSpanField.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_as_tensor_converts_span_field_correctly": {
            "name": "test_as_tensor_converts_span_field_correctly",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_span_field_raises_on_incorrect_label_type": {
            "name": "test_span_field_raises_on_incorrect_label_type",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_span_field_raises_on_ill_defined_span": {
            "name": "test_span_field_raises_on_ill_defined_span",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_span_field_raises_if_span_end_is_greater_than_sentence_length": {
            "name": "test_span_field_raises_if_span_end_is_greater_than_sentence_length",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_empty_span_field_works": {
            "name": "test_empty_span_field_works",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/text_field_test.py": {
        "TestTextField.setUp": {
            "name": "setUp",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_field_counts_vocab_items_correctly": {
            "name": "test_field_counts_vocab_items_correctly",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_index_converts_field_correctly": {
            "name": "test_index_converts_field_correctly",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_get_padding_lengths_raises_if_no_indexed_tokens": {
            "name": "test_get_padding_lengths_raises_if_no_indexed_tokens",
            "location": 113,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_padding_lengths_are_computed_correctly": {
            "name": "test_padding_lengths_are_computed_correctly",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_words": {
            "name": "test_as_tensor_handles_words",
            "location": 140,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_longer_lengths": {
            "name": "test_as_tensor_handles_longer_lengths",
            "location": 149,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_characters": {
            "name": "test_as_tensor_handles_characters",
            "location": 159,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_as_tensor_handles_words_and_characters_with_longer_lengths": {
            "name": "test_as_tensor_handles_words_and_characters_with_longer_lengths",
            "location": 173,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTextField.test_printing_doesnt_crash": {
            "name": "test_printing_doesnt_crash",
            "location": 192,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/fields/__init__.py": {},
    "allennlp-dureader-master/tests/data/iterators/adaptive_iterator_test.py": {
        "TestAdaptiveIterator.test_create_batches_groups_correctly": {
            "name": "test_create_batches_groups_correctly",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAdaptiveIterator.test_create_batches_respects_maximum_batch_size": {
            "name": "test_create_batches_respects_maximum_batch_size",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAdaptiveIterator.test_biggest_batch_first_passes_off_to_bucket_iterator": {
            "name": "test_biggest_batch_first_passes_off_to_bucket_iterator",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAdaptiveIterator.test_from_params": {
            "name": "test_from_params",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/iterators/basic_iterator_test.py": {
        "IteratorTest.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IteratorTest.create_instance": {
            "name": "create_instance",
            "location": 41,
            "return": [
                "Instance",
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "self": [],
                "str_tokens": [
                    "str",
                    "dict",
                    "Optional[int]"
                ]
            }
        },
        "IteratorTest.assert_instances_are_correct": {
            "name": "assert_instances_are_correct",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "candidate_instances": [
                    "Tuple['cirq.Qid']"
                ]
            }
        },
        "TestBasicIterator.test_get_num_batches": {
            "name": "test_get_num_batches",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_yield_one_epoch_iterates_over_the_data_once": {
            "name": "test_yield_one_epoch_iterates_over_the_data_once",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_call_iterates_over_data_forever": {
            "name": "test_call_iterates_over_data_forever",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_create_batches_groups_correctly": {
            "name": "test_create_batches_groups_correctly",
            "location": 91,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_few_instances_per_epoch": {
            "name": "test_few_instances_per_epoch",
            "location": 101,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_many_instances_per_epoch": {
            "name": "test_many_instances_per_epoch",
            "location": 121,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_shuffle": {
            "name": "test_shuffle",
            "location": 141,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_max_instances_in_memory": {
            "name": "test_max_instances_in_memory",
            "location": 161,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_multiple_cursors": {
            "name": "test_multiple_cursors",
            "location": 172,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicIterator.test_from_params": {
            "name": "test_from_params",
            "location": 205,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "IteratorTest.setUp.LazyIterable.__iter__": {
            "name": "__iter__",
            "location": 35,
            "return": [
                "typing.Generator[]",
                "tuple",
                "float",
                "Optional[int]",
                "Optional[Iterable[str]]",
                "List[str]",
                "Tuple[str]",
                "Union[List[float], List[int]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/iterators/bucket_iterator_test.py": {
        "TestBucketIterator.test_create_batches_groups_correctly": {
            "name": "test_create_batches_groups_correctly",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBucketIterator.test_create_batches_groups_correctly_with_max_instances": {
            "name": "test_create_batches_groups_correctly_with_max_instances",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBucketIterator.test_biggest_batch_first_works": {
            "name": "test_biggest_batch_first_works",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBucketIterator.test_from_params": {
            "name": "test_from_params",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/iterators/__init__.py": {},
    "allennlp-dureader-master/tests/data/tokenizers/character_tokenizer_test.py": {
        "TestCharacterTokenizer.test_splits_into_characters": {
            "name": "test_splits_into_characters",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCharacterTokenizer.test_batch_tokenization": {
            "name": "test_batch_tokenization",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCharacterTokenizer.test_handles_byte_encoding": {
            "name": "test_handles_byte_encoding",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/tokenizers/word_splitter_test.py": {
        "TestSimpleWordSplitter.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_complex_punctuation": {
            "name": "test_tokenize_handles_complex_punctuation",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_contraction": {
            "name": "test_tokenize_handles_contraction",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_batch_tokenization": {
            "name": "test_batch_tokenization",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_multiple_contraction": {
            "name": "test_tokenize_handles_multiple_contraction",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_final_apostrophe": {
            "name": "test_tokenize_handles_final_apostrophe",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleWordSplitter.test_tokenize_handles_special_cases": {
            "name": "test_tokenize_handles_special_cases",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.setUp": {
            "name": "setUp",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.test_tokenize_handles_complex_punctuation": {
            "name": "test_tokenize_handles_complex_punctuation",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.test_tokenize_handles_unicode_letters": {
            "name": "test_tokenize_handles_unicode_letters",
            "location": 74,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLettersDigitsWordSplitter.test_tokenize_handles_splits_all_punctuation": {
            "name": "test_tokenize_handles_splits_all_punctuation",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.setUp": {
            "name": "setUp",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_complex_punctuation": {
            "name": "test_tokenize_handles_complex_punctuation",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_contraction": {
            "name": "test_tokenize_handles_contraction",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_multiple_contraction": {
            "name": "test_tokenize_handles_multiple_contraction",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_final_apostrophe": {
            "name": "test_tokenize_handles_final_apostrophe",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_removes_whitespace_tokens": {
            "name": "test_tokenize_removes_whitespace_tokens",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpacyWordSplitter.test_tokenize_handles_special_cases": {
            "name": "test_tokenize_handles_special_cases",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/tokenizers/word_tokenizer_test.py": {
        "TestWordTokenizer.test_passes_through_correctly": {
            "name": "test_passes_through_correctly",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestWordTokenizer.test_batch_tokenization": {
            "name": "test_batch_tokenization",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestWordTokenizer.test_stems_and_filters_correctly": {
            "name": "test_stems_and_filters_correctly",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/tokenizers/__init__.py": {},
    "allennlp-dureader-master/tests/data/token_indexers/character_token_indexer_test.py": {
        "CharacterTokenIndexerTest.test_count_vocab_items_respects_casing": {
            "name": "test_count_vocab_items_respects_casing",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CharacterTokenIndexerTest.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CharacterTokenIndexerTest.test_token_to_indices_produces_correct_characters": {
            "name": "test_token_to_indices_produces_correct_characters",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/dep_label_indexer_test.py": {
        "TestDepLabelIndexer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_count_vocab_items_uses_pos_tags": {
            "name": "test_count_vocab_items_uses_pos_tags",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_token_to_indices_uses_pos_tags": {
            "name": "test_token_to_indices_uses_pos_tags",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_padding_functions": {
            "name": "test_padding_functions",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDepLabelIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/elmo_indexer_test.py": {
        "TestELMoTokenCharactersIndexer.test_bos_to_char_ids": {
            "name": "test_bos_to_char_ids",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestELMoTokenCharactersIndexer.test_eos_to_char_ids": {
            "name": "test_eos_to_char_ids",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestELMoTokenCharactersIndexer.test_unicode_to_char_ids": {
            "name": "test_unicode_to_char_ids",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestELMoTokenCharactersIndexer.test_elmo_as_array_produces_token_sequence": {
            "name": "test_elmo_as_array_produces_token_sequence",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/ner_tag_indexer_test.py": {
        "TestNerTagIndexer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_count_vocab_items_uses_ner_tags": {
            "name": "test_count_vocab_items_uses_ner_tags",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_token_to_indices_uses_ner_tags": {
            "name": "test_token_to_indices_uses_ner_tags",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_padding_functions": {
            "name": "test_padding_functions",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNerTagIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/pos_tag_indexer_test.py": {
        "TestPosTagIndexer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_count_vocab_items_uses_pos_tags": {
            "name": "test_count_vocab_items_uses_pos_tags",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_token_to_indices_uses_pos_tags": {
            "name": "test_token_to_indices_uses_pos_tags",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_padding_functions": {
            "name": "test_padding_functions",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPosTagIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/single_id_token_indexer_test.py": {
        "TestSingleIdTokenIndexer.test_count_vocab_items_respects_casing": {
            "name": "test_count_vocab_items_respects_casing",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSingleIdTokenIndexer.test_as_array_produces_token_sequence": {
            "name": "test_as_array_produces_token_sequence",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/data/token_indexers/__init__.py": {},
    "allennlp-dureader-master/tests/models/archival_test.py": {
        "ArchivalTest.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArchivalTest.test_archiving": {
            "name": "test_archiving",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArchivalTest.test_extra_files": {
            "name": "test_extra_files",
            "location": 77,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/biattentive_classification_network_test.py": {
        "BiattentiveClassificationNetworkMaxoutTest.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_maxout_bcn_can_train_save_and_load": {
            "name": "test_maxout_bcn_can_train_save_and_load",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_feedforward_bcn_can_train_save_and_load": {
            "name": "test_feedforward_bcn_can_train_save_and_load",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BiattentiveClassificationNetworkMaxoutTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/constituency_parser_test.py": {
        "SpanConstituencyParserTest.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.tearDown": {
            "name": "tearDown",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_span_parser_can_save_and_load": {
            "name": "test_span_parser_can_save_and_load",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_forward_can_handle_a_single_word_as_input": {
            "name": "test_forward_can_handle_a_single_word_as_input",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_decode_runs": {
            "name": "test_decode_runs",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_resolve_overlap_conflicts_greedily": {
            "name": "test_resolve_overlap_conflicts_greedily",
            "location": 53,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_construct_tree_from_spans": {
            "name": "test_construct_tree_from_spans",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_construct_tree_from_spans_handles_nested_labels": {
            "name": "test_construct_tree_from_spans_handles_nested_labels",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanConstituencyParserTest.test_tree_construction_with_too_few_spans_creates_trees_with_depth_one_word_nodes": {
            "name": "test_tree_construction_with_too_few_spans_creates_trees_with_depth_one_word_nodes",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/crf_tagger_test.py": {
        "CrfTaggerTest.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_simple_tagger_can_train_save_and_load": {
            "name": "test_simple_tagger_can_train_save_and_load",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CrfTaggerTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/decomposable_attention_test.py": {
        "TestDecomposableAttention.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_model_can_train_save_and_load": {
            "name": "test_model_can_train_save_and_load",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_model_load": {
            "name": "test_model_load",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttention.test_mismatched_dimensions_raise_configuration_errors": {
            "name": "test_mismatched_dimensions_raise_configuration_errors",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/semantic_role_labeler_test.py": {
        "SemanticRoleLabelerTest.setUp": {
            "name": "setUp",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_srl_model_can_train_save_and_load": {
            "name": "test_srl_model_can_train_save_and_load",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_decode_runs_correctly": {
            "name": "test_decode_runs_correctly",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_bio_tags_correctly_convert_to_conll_format": {
            "name": "test_bio_tags_correctly_convert_to_conll_format",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_perl_eval_script_can_run_on_printed_conll_files": {
            "name": "test_perl_eval_script_can_run_on_printed_conll_files",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SemanticRoleLabelerTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 71,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/simple_tagger_test.py": {
        "SimpleTaggerTest.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_simple_tagger_can_train_save_and_load": {
            "name": "test_simple_tagger_can_train_save_and_load",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerTest.test_regularization": {
            "name": "test_regularization",
            "location": 44,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerRegularizationTest.setUp": {
            "name": "setUp",
            "location": 67,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleTaggerRegularizationTest.test_regularization": {
            "name": "test_regularization",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/sniff_test.py": {
        "SniffTest.test_config": {
            "name": "test_config",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_machine_comprehension": {
            "name": "test_machine_comprehension",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_semantic_role_labeling": {
            "name": "test_semantic_role_labeling",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_textual_entailment": {
            "name": "test_textual_entailment",
            "location": 67,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_coreference_resolution": {
            "name": "test_coreference_resolution",
            "location": 91,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_ner": {
            "name": "test_ner",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SniffTest.test_constituency_parsing": {
            "name": "test_constituency_parsing",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/__init__.py": {},
    "allennlp-dureader-master/tests/models/coreference_resolution/coref_test.py": {
        "CorefTest.setUp": {
            "name": "setUp",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CorefTest.test_coref_model_can_train_save_and_load": {
            "name": "test_coref_model_can_train_save_and_load",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CorefTest.test_decode": {
            "name": "test_decode",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/encoder_decoders/simple_seq2seq_test.py": {
        "SimpleSeq2SeqWithoutAttentionTest.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithoutAttentionTest.test_encoder_decoder_can_train_save_and_load": {
            "name": "test_encoder_decoder_can_train_save_and_load",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithoutAttentionTest.test_loss_is_computed_correctly": {
            "name": "test_loss_is_computed_correctly",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithoutAttentionTest.test_decode_runs_correctly": {
            "name": "test_decode_runs_correctly",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithAttentionTest.setUp": {
            "name": "setUp",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleSeq2SeqWithAttentionTest.test_encoder_decoder_can_train_save_and_load": {
            "name": "test_encoder_decoder_can_train_save_and_load",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/encoder_decoders/__init__.py": {},
    "allennlp-dureader-master/tests/models/reading_comprehension/bidaf_ensemble_test.py": {
        "BidafEnsembleTest.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidafEnsembleTest.test_ensemble_chooses_highest_average_confidence_2": {
            "name": "test_ensemble_chooses_highest_average_confidence_2",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidafEnsembleTest.test_ensemble_chooses_highest_average_confidence_3": {
            "name": "test_ensemble_chooses_highest_average_confidence_3",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidafEnsembleTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/reading_comprehension/bidaf_test.py": {
        "BidirectionalAttentionFlowTest.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_forward_pass_runs_correctly": {
            "name": "test_forward_pass_runs_correctly",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_model_can_train_save_and_load": {
            "name": "test_model_can_train_save_and_load",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_batch_predictions_are_consistent": {
            "name": "test_batch_predictions_are_consistent",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_get_best_span": {
            "name": "test_get_best_span",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BidirectionalAttentionFlowTest.test_mismatching_dimensions_throws_configuration_error": {
            "name": "test_mismatching_dimensions_throws_configuration_error",
            "location": 113,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/models/reading_comprehension/__init__.py": {},
    "allennlp-dureader-master/tests/modules/attention_test.py": {
        "TestAttention.test_no_mask": {
            "name": "test_no_mask",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_masked": {
            "name": "test_masked",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_batched_no_mask": {
            "name": "test_batched_no_mask",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_batched_masked": {
            "name": "test_batched_masked",
            "location": 51,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_non_normalized_attention_works": {
            "name": "test_non_normalized_attention_works",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAttention.test_can_build_from_params": {
            "name": "test_can_build_from_params",
            "location": 82,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/augmented_lstm_test.py": {
        "TestAugmentedLSTM.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_variable_length_sequences_return_correctly_padded_outputs": {
            "name": "test_variable_length_sequences_return_correctly_padded_outputs",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_variable_length_sequences_run_backward_return_correctly_padded_outputs": {
            "name": "test_variable_length_sequences_run_backward_return_correctly_padded_outputs",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_computes_same_function_as_pytorch_lstm": {
            "name": "test_augmented_lstm_computes_same_function_as_pytorch_lstm",
            "location": 53,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_works_with_highway_connections": {
            "name": "test_augmented_lstm_works_with_highway_connections",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_throws_error_on_non_packed_sequence_input": {
            "name": "test_augmented_lstm_throws_error_on_non_packed_sequence_input",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestAugmentedLSTM.test_augmented_lstm_is_initialized_with_correct_biases": {
            "name": "test_augmented_lstm_is_initialized_with_correct_biases",
            "location": 92,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/conditional_random_field_test.py": {
        "TestConditionalRandomField.setUp": {
            "name": "setUp",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.score": {
            "name": "score",
            "location": 44,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "bool"
                ],
                "tags": [
                    "str",
                    "torch.LongTensor",
                    "Optional[torch.LongTensor]",
                    "Sequence[str]",
                    "Set[str]",
                    "dict"
                ]
            }
        },
        "TestConditionalRandomField.test_forward_works_without_mask": {
            "name": "test_forward_works_without_mask",
            "location": 59,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_forward_works_with_mask": {
            "name": "test_forward_works_with_mask",
            "location": 80,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_viterbi_tags": {
            "name": "test_viterbi_tags",
            "location": 113,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_constrained_viterbi_tags": {
            "name": "test_constrained_viterbi_tags",
            "location": 144,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConditionalRandomField.test_allowed_transitions": {
            "name": "test_allowed_transitions",
            "location": 169,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/elmo_test.py": {
        "ElmoTestCase.setUp": {
            "name": "setUp",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ElmoTestCase._load_sentences_embeddings": {
            "name": "_load_sentences_embeddings",
            "location": 30,
            "return": [
                "tuple[list[list[]]]",
                "str",
                "torch.LongTensor",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoBiLm.test_elmo_bilm": {
            "name": "test_elmo_bilm",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmo.setUp": {
            "name": "setUp",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmo._sentences_to_ids": {
            "name": "_sentences_to_ids",
            "location": 122,
            "return": [
                "numpy.ndarray",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "sentences": [
                    "Callable",
                    "bool",
                    "str"
                ]
            }
        },
        "TestElmo.test_elmo": {
            "name": "test_elmo",
            "location": 138,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmo.test_elmo_4D_input": {
            "name": "test_elmo_4D_input",
            "location": 154,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmo.test_elmo_with_module": {
            "name": "test_elmo_with_module",
            "location": 180,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoRequiresGrad._run_test": {
            "name": "_run_test",
            "location": 197,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "requires_grad": [
                    "bytes",
                    "str",
                    "int"
                ]
            }
        },
        "TestElmoRequiresGrad.test_elmo_requires_grad": {
            "name": "test_elmo_requires_grad",
            "location": 214,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoRequiresGrad.test_elmo_does_not_require_grad": {
            "name": "test_elmo_does_not_require_grad",
            "location": 217,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenRepresentation.test_elmo_token_representation": {
            "name": "test_elmo_token_representation",
            "location": 222,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenRepresentation.test_elmo_token_representation_bos_eos": {
            "name": "test_elmo_token_representation_bos_eos",
            "location": 256,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/encoder_base_test.py": {
        "TestEncoderBase.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEncoderBase.test_non_stateful_states_are_sorted_correctly": {
            "name": "test_non_stateful_states_are_sorted_correctly",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEncoderBase.test_get_initial_states": {
            "name": "test_get_initial_states",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEncoderBase.test_update_states": {
            "name": "test_update_states",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/feedforward_test.py": {
        "TestFeedForward.test_init_checks_hidden_dim_consistency": {
            "name": "test_init_checks_hidden_dim_consistency",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFeedForward.test_init_checks_activation_consistency": {
            "name": "test_init_checks_activation_consistency",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFeedForward.test_forward_gives_correct_output": {
            "name": "test_forward_gives_correct_output",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/highway_test.py": {
        "TestHighway.test_forward_works_on_simple_input": {
            "name": "test_forward_works_on_simple_input",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/lstm_cell_with_projection_test.py": {
        "TestLstmCellWithProjection.test_elmo_lstm_cell_completes_forward_pass": {
            "name": "test_elmo_lstm_cell_completes_forward_pass",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/matrix_attention_test.py": {
        "TestMatrixAttention.test_forward_works_on_simple_input": {
            "name": "test_forward_works_on_simple_input",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMatrixAttention.test_can_build_from_params": {
            "name": "test_can_build_from_params",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/maxout_test.py": {
        "TestMaxout.test_init_checks_output_dims_consistency": {
            "name": "test_init_checks_output_dims_consistency",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMaxout.test_init_checks_pool_sizes_consistency": {
            "name": "test_init_checks_pool_sizes_consistency",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMaxout.test_init_checks_dropout_consistency": {
            "name": "test_init_checks_dropout_consistency",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMaxout.test_forward_gives_correct_output": {
            "name": "test_forward_gives_correct_output",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/scalar_mix_test.py": {
        "TestScalarMix.test_scalar_mix_can_run_forward": {
            "name": "test_scalar_mix_can_run_forward",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestScalarMix.test_scalar_mix_throws_error_on_incorrect_number_of_inputs": {
            "name": "test_scalar_mix_throws_error_on_incorrect_number_of_inputs",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestScalarMix.test_scalar_mix_layer_norm": {
            "name": "test_scalar_mix_layer_norm",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoder_test.py": {
        "TestSeq2SeqEncoder.test_from_params_builders_encoder_correctly": {
            "name": "test_from_params_builders_encoder_correctly",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSeq2SeqEncoder.test_from_params_requires_batch_first": {
            "name": "test_from_params_requires_batch_first",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoder_test.py": {
        "TestSeq2VecEncoder.test_from_params_builders_encoder_correctly": {
            "name": "test_from_params_builders_encoder_correctly",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSeq2VecEncoder.test_from_params_requires_batch_first": {
            "name": "test_from_params_requires_batch_first",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_pruner_test.py": {
        "TestSpanPruner.test_span_pruner_selects_top_scored_spans_and_respects_masking": {
            "name": "test_span_pruner_selects_top_scored_spans_and_respects_masking",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanPruner.test_span_scorer_raises_with_incorrect_scorer_spec": {
            "name": "test_span_scorer_raises_with_incorrect_scorer_spec",
            "location": 42,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSpanPruner.test_span_scorer_works_for_completely_masked_rows": {
            "name": "test_span_scorer_works_for_completely_masked_rows",
            "location": 52,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/stacked_alternating_lstm_test.py": {
        "TestStackedAlternatingLstm.test_stacked_alternating_lstm_completes_forward_pass": {
            "name": "test_stacked_alternating_lstm_completes_forward_pass",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStackedAlternatingLstm.test_lstms_are_interleaved": {
            "name": "test_lstms_are_interleaved",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/stacked_elmo_lstm_test.py": {
        "TestElmoLstmCell.test_elmo_lstm": {
            "name": "test_elmo_lstm",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/time_distributed_test.py": {
        "TestTimeDistributed.test_time_distributed_reshapes_correctly": {
            "name": "test_time_distributed_reshapes_correctly",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTimeDistributed.test_time_distributed_works_with_multiple_inputs": {
            "name": "test_time_distributed_works_with_multiple_inputs",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/__init__.py": {},
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/intra_sentence_attention_test.py": {
        "TestIntraSentenceAttentionEncoder.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIntraSentenceAttentionEncoder.test_constructor_asserts_multi_head_consistency": {
            "name": "test_constructor_asserts_multi_head_consistency",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIntraSentenceAttentionEncoder.test_forward_works_with_simple_attention": {
            "name": "test_forward_works_with_simple_attention",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestIntraSentenceAttentionEncoder.test_forward_works_with_multi_headed_attention": {
            "name": "test_forward_works_with_multi_headed_attention",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/multi_head_self_attention_test.py": {
        "MultiHeadSelfAttentionTest.test_multi_head_self_attention_can_build_from_params": {
            "name": "test_multi_head_self_attention_can_build_from_params",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttentionTest.test_multi_head_self_attention_runs_forward": {
            "name": "test_multi_head_self_attention_runs_forward",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiHeadSelfAttentionTest.test_multi_head_self_attention_respects_masking": {
            "name": "test_multi_head_self_attention_respects_masking",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/pass_through_encoder_test.py": {
        "TestStackedSelfAttention.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStackedSelfAttention.test_pass_through_encoder_passes_through": {
            "name": "test_pass_through_encoder_passes_through",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/pytorch_seq2seq_wrapper_test.py": {
        "TestPytorchSeq2SeqWrapper.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_works_even_with_empty_sequences": {
            "name": "test_forward_works_even_with_empty_sequences",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_pulls_out_correct_tensor_without_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_without_sequence_lengths",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_pulls_out_correct_tensor_with_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_with_sequence_lengths",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_pulls_out_correct_tensor_for_unsorted_batches": {
            "name": "test_forward_pulls_out_correct_tensor_for_unsorted_batches",
            "location": 79,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_forward_does_not_compress_tensors_padded_to_greater_than_the_max_sequence_length": {
            "name": "test_forward_does_not_compress_tensors_padded_to_greater_than_the_max_sequence_length",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_raises_if_batch_first_is_false": {
            "name": "test_wrapper_raises_if_batch_first_is_false",
            "location": 121,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_works_when_passed_state_with_zero_length_sequences": {
            "name": "test_wrapper_works_when_passed_state_with_zero_length_sequences",
            "location": 127,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_can_call_backward_with_zero_length_sequences": {
            "name": "test_wrapper_can_call_backward_with_zero_length_sequences",
            "location": 145,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_stateful": {
            "name": "test_wrapper_stateful",
            "location": 161,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2SeqWrapper.test_wrapper_stateful_single_state_gru": {
            "name": "test_wrapper_stateful_single_state_gru",
            "location": 185,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/stacked_self_attention_test.py": {
        "TestStackedSelfAttention.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStackedSelfAttention.test_stacked_self_attention_can_run_foward": {
            "name": "test_stacked_self_attention_can_run_foward",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2seq_encoders/__init__.py": {},
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/boe_encoder_test.py": {
        "TestBagOfEmbeddingsEncoder.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_forward_does_correct_computation": {
            "name": "test_forward_does_correct_computation",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_forward_does_correct_computation_with_average": {
            "name": "test_forward_does_correct_computation_with_average",
            "location": 44,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBagOfEmbeddingsEncoder.test_forward_does_correct_computation_with_average_no_mask": {
            "name": "test_forward_does_correct_computation_with_average_no_mask",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/cnn_encoder_test.py": {
        "TestCnnEncoder.test_get_dimension_is_correct": {
            "name": "test_get_dimension_is_correct",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCnnEncoder.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCnnEncoder.test_forward_does_correct_computation": {
            "name": "test_forward_does_correct_computation",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCnnEncoder.test_forward_runs_with_larger_input": {
            "name": "test_forward_runs_with_larger_input",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/pytorch_seq2vec_wrapper_test.py": {
        "TestPytorchSeq2VecWrapper.test_get_dimensions_is_correct": {
            "name": "test_get_dimensions_is_correct",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_pulls_out_correct_tensor_without_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_without_sequence_lengths",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_pulls_out_correct_tensor_with_sequence_lengths": {
            "name": "test_forward_pulls_out_correct_tensor_with_sequence_lengths",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_works_even_with_empty_sequences": {
            "name": "test_forward_works_even_with_empty_sequences",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_forward_pulls_out_correct_tensor_with_unsorted_batches": {
            "name": "test_forward_pulls_out_correct_tensor_with_unsorted_batches",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPytorchSeq2VecWrapper.test_wrapper_raises_if_batch_first_is_false": {
            "name": "test_wrapper_raises_if_batch_first_is_false",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/seq2vec_encoders/__init__.py": {},
    "allennlp-dureader-master/tests/modules/similarity_functions/bilinear_test.py": {
        "TestBilinearSimilarityFunction.test_weights_are_correct_sizes": {
            "name": "test_weights_are_correct_sizes",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBilinearSimilarityFunction.test_forward_does_a_bilinear_product": {
            "name": "test_forward_does_a_bilinear_product",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBilinearSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBilinearSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/cosine_test.py": {
        "TestCosineSimilarityFunction.test_forward_does_a_cosine_similarity": {
            "name": "test_forward_does_a_cosine_similarity",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCosineSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestCosineSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/dot_product_test.py": {
        "TestDotProductSimilarityFunction.test_forward_does_a_dot_product": {
            "name": "test_forward_does_a_dot_product",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDotProductSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDotProductSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/linear_test.py": {
        "TestLinearSimilarityFunction.test_weights_are_correct_sizes": {
            "name": "test_weights_are_correct_sizes",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_does_a_weighted_product": {
            "name": "test_forward_does_a_weighted_product",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_higher_order_tensors": {
            "name": "test_forward_works_with_higher_order_tensors",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_multiply_combinations": {
            "name": "test_forward_works_with_multiply_combinations",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_divide_combinations": {
            "name": "test_forward_works_with_divide_combinations",
            "location": 55,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_add_combinations": {
            "name": "test_forward_works_with_add_combinations",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_forward_works_with_subtract_combinations": {
            "name": "test_forward_works_with_subtract_combinations",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestLinearSimilarityFunction.test_can_construct_from_params": {
            "name": "test_can_construct_from_params",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/multiheaded_test.py": {
        "TestMultiHeadedSimilarityFunction.test_weights_are_correct_sizes": {
            "name": "test_weights_are_correct_sizes",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestMultiHeadedSimilarityFunction.test_forward": {
            "name": "test_forward",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/similarity_functions/__init__.py": {},
    "allennlp-dureader-master/tests/modules/span_extractors/bidirectional_endpoint_span_extractor_test.py": {
        "TestBidirectonalEndpointSpanExtractor.test_bidirectional_endpoint_span_extractor_can_build_from_params": {
            "name": "test_bidirectional_endpoint_span_extractor_can_build_from_params",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_raises_on_odd_input_dimension": {
            "name": "test_raises_on_odd_input_dimension",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_correct_sequence_elements_are_embedded": {
            "name": "test_correct_sequence_elements_are_embedded",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_correct_sequence_elements_are_embedded_with_a_masked_sequence": {
            "name": "test_correct_sequence_elements_are_embedded_with_a_masked_sequence",
            "location": 101,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBidirectonalEndpointSpanExtractor.test_forward_raises_with_invalid_indices": {
            "name": "test_forward_raises_with_invalid_indices",
            "location": 178,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_extractors/endpoint_span_extractor_test.py": {
        "TestEndpointSpanExtractor.test_endpoint_span_extractor_can_build_from_params": {
            "name": "test_endpoint_span_extractor_can_build_from_params",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEndpointSpanExtractor.test_correct_sequence_elements_are_embedded": {
            "name": "test_correct_sequence_elements_are_embedded",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEndpointSpanExtractor.test_masked_indices_are_handled_correctly": {
            "name": "test_masked_indices_are_handled_correctly",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEndpointSpanExtractor.test_masked_indices_are_handled_correctly_with_exclusive_indices": {
            "name": "test_masked_indices_are_handled_correctly_with_exclusive_indices",
            "location": 78,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_extractors/self_attentive_span_extractor_test.py": {
        "TestSelfAttentiveSpanExtractor.test_locally_normalised_span_extractor_can_build_from_params": {
            "name": "test_locally_normalised_span_extractor_can_build_from_params",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSelfAttentiveSpanExtractor.test_attention_is_normalised_correctly": {
            "name": "test_attention_is_normalised_correctly",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/span_extractors/__init__.py": {},
    "allennlp-dureader-master/tests/modules/text_field_embedders/basic_text_field_embedder_test.py": {
        "TestBasicTextFieldEmbedder.setUp": {
            "name": "setUp",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_get_output_dim_aggregates_dimension_from_each_embedding": {
            "name": "test_get_output_dim_aggregates_dimension_from_each_embedding",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_forward_asserts_input_field_match": {
            "name": "test_forward_asserts_input_field_match",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_forward_concats_resultant_embeddings": {
            "name": "test_forward_concats_resultant_embeddings",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBasicTextFieldEmbedder.test_forward_works_on_higher_order_input": {
            "name": "test_forward_works_on_higher_order_input",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/text_field_embedders/__init__.py": {},
    "allennlp-dureader-master/tests/modules/token_embedders/elmo_token_embedder_test.py": {
        "TestElmoTokenEmbedder.setUp": {
            "name": "setUp",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenEmbedder.test_tagger_with_elmo_token_embedder_can_train_save_and_load": {
            "name": "test_tagger_with_elmo_token_embedder_can_train_save_and_load",
            "location": 18,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenEmbedder.test_tagger_with_elmo_token_embedder_forward_pass_runs_correctly": {
            "name": "test_tagger_with_elmo_token_embedder_forward_pass_runs_correctly",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestElmoTokenEmbedder.test_file_archiving": {
            "name": "test_file_archiving",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/token_embedders/embedding_test.py": {
        "TestEmbedding.test_get_embedding_layer_uses_correct_embedding_dim": {
            "name": "test_get_embedding_layer_uses_correct_embedding_dim",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_forward_works_with_projection_layer": {
            "name": "test_forward_works_with_projection_layer",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_embedding_layer_actually_initializes_word_vectors_correctly": {
            "name": "test_embedding_layer_actually_initializes_word_vectors_correctly",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_get_embedding_layer_initializes_unseen_words_randomly_not_zero": {
            "name": "test_get_embedding_layer_initializes_unseen_words_randomly_not_zero",
            "location": 67,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_read_hdf5_format_file": {
            "name": "test_read_hdf5_format_file",
            "location": 82,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestEmbedding.test_read_hdf5_raises_on_invalid_shape": {
            "name": "test_read_hdf5_raises_on_invalid_shape",
            "location": 100,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/token_embedders/token_characters_encoder_test.py": {
        "TestTokenCharactersEncoder.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTokenCharactersEncoder.test_get_output_dim_uses_encoder_output_dim": {
            "name": "test_get_output_dim_uses_encoder_output_dim",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTokenCharactersEncoder.test_forward_applies_embedding_then_encoder": {
            "name": "test_forward_applies_embedding_then_encoder",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/modules/token_embedders/__init__.py": {},
    "allennlp-dureader-master/tests/nn/initializers_test.py": {
        "TestInitializers.setUp": {
            "name": "setUp",
            "location": 18,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.tearDown": {
            "name": "tearDown",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_regex_matches_are_initialized_correctly": {
            "name": "test_regex_matches_are_initialized_correctly",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_block_orthogonal_can_initialize": {
            "name": "test_block_orthogonal_can_initialize",
            "location": 55,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_block_orthogonal_raises_on_mismatching_dimensions": {
            "name": "test_block_orthogonal_raises_on_mismatching_dimensions",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_uniform_unit_scaling_can_initialize": {
            "name": "test_uniform_unit_scaling_can_initialize",
            "location": 74,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_block_orthogonal_can_initialize.test_block_is_orthogonal": {
            "name": "test_block_is_orthogonal",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "block": [
                    "bool"
                ]
            }
        },
        "TestInitializers.test_regex_matches_are_initialized_correctly.Net.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestInitializers.test_regex_matches_are_initialized_correctly.Net.forward": {
            "name": "forward",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/nn/regularizers_test.py": {
        "TestRegularizers.test_l1_regularization": {
            "name": "test_l1_regularization",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegularizers.test_l2_regularization": {
            "name": "test_l2_regularization",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegularizers.test_regularizer_applicator_respects_regex_matching": {
            "name": "test_regularizer_applicator_respects_regex_matching",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestRegularizers.test_from_params": {
            "name": "test_from_params",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/nn/util_test.py": {
        "TestNnUtil.test_get_sequence_lengths_from_binary_mask": {
            "name": "test_get_sequence_lengths_from_binary_mask",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_sequence_lengths_converts_to_long_tensor_and_avoids_variable_overflow": {
            "name": "test_get_sequence_lengths_converts_to_long_tensor_and_avoids_variable_overflow",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sort_tensor_by_length": {
            "name": "test_sort_tensor_by_length",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sort_tensor_by_length_raises_on_non_variable_inputs": {
            "name": "test_sort_tensor_by_length_raises_on_non_variable_inputs",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_final_encoder_states": {
            "name": "test_get_final_encoder_states",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_masked_softmax_no_mask": {
            "name": "test_masked_softmax_no_mask",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_masked_softmax_masked": {
            "name": "test_masked_softmax_masked",
            "location": 108,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_masked_log_softmax_masked": {
            "name": "test_masked_log_softmax_masked",
            "location": 187,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_text_field_mask_returns_a_correct_mask": {
            "name": "test_get_text_field_mask_returns_a_correct_mask",
            "location": 220,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_text_field_mask_returns_a_correct_mask_character_only_input": {
            "name": "test_get_text_field_mask_returns_a_correct_mask_character_only_input",
            "location": 229,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_get_text_field_mask_returns_a_correct_mask_list_field": {
            "name": "test_get_text_field_mask_returns_a_correct_mask_list_field",
            "location": 237,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_last_dim_softmax_does_softmax_on_last_dim": {
            "name": "test_last_dim_softmax_does_softmax_on_last_dim",
            "location": 246,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_last_dim_softmax_handles_mask_correctly": {
            "name": "test_last_dim_softmax_handles_mask_correctly",
            "location": 264,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_works_on_simple_input": {
            "name": "test_weighted_sum_works_on_simple_input",
            "location": 283,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_handles_higher_order_input": {
            "name": "test_weighted_sum_handles_higher_order_input",
            "location": 299,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_handles_uneven_higher_order_input": {
            "name": "test_weighted_sum_handles_uneven_higher_order_input",
            "location": 315,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_weighted_sum_handles_3d_attention_with_3d_matrix": {
            "name": "test_weighted_sum_handles_3d_attention_with_3d_matrix",
            "location": 334,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_viterbi_decode": {
            "name": "test_viterbi_decode",
            "location": 351,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sequence_cross_entropy_with_logits_masks_loss_correctly": {
            "name": "test_sequence_cross_entropy_with_logits_masks_loss_correctly",
            "location": 426,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sequence_cross_entropy_with_logits_smooths_labels_correctly": {
            "name": "test_sequence_cross_entropy_with_logits_smooths_labels_correctly",
            "location": 453,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_sequence_cross_entropy_with_logits_averages_batch_correctly": {
            "name": "test_sequence_cross_entropy_with_logits_averages_batch_correctly",
            "location": 472,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_replace_masked_values_replaces_masked_values_with_finite_value": {
            "name": "test_replace_masked_values_replaces_masked_values_with_finite_value",
            "location": 493,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_logsumexp": {
            "name": "test_logsumexp",
            "location": 499,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_flatten_and_batch_shift_indices": {
            "name": "test_flatten_and_batch_shift_indices",
            "location": 517,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_batched_index_select": {
            "name": "test_batched_index_select",
            "location": 531,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_flattened_index_select": {
            "name": "test_flattened_index_select",
            "location": 556,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_bucket_values": {
            "name": "test_bucket_values",
            "location": 584,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_add_sentence_boundary_token_ids_handles_2D_input": {
            "name": "test_add_sentence_boundary_token_ids_handles_2D_input",
            "location": 590,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_add_sentence_boundary_token_ids_handles_3D_input": {
            "name": "test_add_sentence_boundary_token_ids_handles_3D_input",
            "location": 601,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_remove_sentence_boundaries": {
            "name": "test_remove_sentence_boundaries",
            "location": 626,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestNnUtil.test_add_positional_features": {
            "name": "test_add_positional_features",
            "location": 648,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/nn/__init__.py": {},
    "allennlp-dureader-master/tests/service/server_flask_test.py": {
        "CountingPredictor.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CountingPredictor.predict_json": {
            "name": "predict_json",
            "location": 39,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Any]",
                    "Pattern[str]",
                    "typing.Pattern"
                ],
                "cuda_device": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestFlask.setUp": {
            "name": "setUp",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.post_json": {
            "name": "post_json",
            "location": 60,
            "return": [
                "dict",
                "jumeaux.models.Reqs2ReqsAddOnPayload"
            ],
            "arguments": {
                "self": [],
                "endpoint": [
                    "dict",
                    "dict[, ]",
                    "allennlp.common.util.JsonDict",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "dict[str, str]",
                    "Optional[Dict[str, str]]",
                    "None"
                ],
                "data": [
                    "dict",
                    "dict[, ]",
                    "allennlp.common.util.JsonDict",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "dict[str, str]",
                    "Optional[Dict[str, str]]",
                    "None"
                ]
            }
        },
        "TestFlask.tearDown": {
            "name": "tearDown",
            "location": 66,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_list_models": {
            "name": "test_list_models",
            "location": 74,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_unknown_model": {
            "name": "test_unknown_model",
            "location": 79,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_machine_comprehension": {
            "name": "test_machine_comprehension",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_textual_entailment": {
            "name": "test_textual_entailment",
            "location": 95,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_semantic_role_labeling": {
            "name": "test_semantic_role_labeling",
            "location": 103,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_caching": {
            "name": "test_caching",
            "location": 110,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_disable_caching": {
            "name": "test_disable_caching",
            "location": 150,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_missing_static_dir": {
            "name": "test_missing_static_dir",
            "location": 176,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_permalinks_fail_gracefully_with_no_database": {
            "name": "test_permalinks_fail_gracefully_with_no_database",
            "location": 183,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_permalinks_work": {
            "name": "test_permalinks_work",
            "location": 204,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFlask.test_permalinks_work.post": {
            "name": "post",
            "location": 212,
            "return": [
                "dict",
                "jumeaux.models.Reqs2ReqsAddOnPayload"
            ],
            "arguments": {
                "endpoint": [
                    "dict",
                    "allennlp.common.util.JsonDict",
                    "Dict[str, Any]",
                    "Optional[Dict[str, str]]"
                ],
                "data": [
                    "dict",
                    "allennlp.common.util.JsonDict",
                    "Dict[str, Any]",
                    "Optional[Dict[str, str]]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/service/server_simple_test.py": {
        "post_json": {
            "name": "post_json",
            "location": 15,
            "return": [
                "dict",
                "jumeaux.models.Reqs2ReqsAddOnPayload"
            ],
            "arguments": {
                "client": [
                    "str",
                    "int",
                    "flask.testing.FlaskClient",
                    "allennlp.common.util.JsonDict"
                ],
                "endpoint": [
                    "str",
                    "int",
                    "flask.testing.FlaskClient",
                    "allennlp.common.util.JsonDict"
                ],
                "data": [
                    "str",
                    "int",
                    "flask.testing.FlaskClient",
                    "allennlp.common.util.JsonDict"
                ]
            }
        },
        "TestSimpleServer.setUp": {
            "name": "setUp",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.tearDown": {
            "name": "tearDown",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_standard_model": {
            "name": "test_standard_model",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_sanitizer": {
            "name": "test_sanitizer",
            "location": 61,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_static_dir": {
            "name": "test_static_dir",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSimpleServer.test_sanitizer.sanitize": {
            "name": "sanitize",
            "location": 62,
            "return": [
                "dict[, ]",
                "Mapping",
                "Dict[str, Any]",
                "Dict[str, str]",
                "Dict[str, List[Any]]",
                "Dict[str, float]"
            ],
            "arguments": {
                "result": [
                    "allennlp.common.util.JsonDict",
                    "Dict[str, Set[str]]",
                    "dict",
                    "type",
                    "Mapping[Any, Any]",
                    "Union[Dict, List]",
                    "Mapping[str, str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tests/service/__init__.py": {},
    "allennlp-dureader-master/tests/service/predictors/bidaf_test.py": {
        "TestBidafPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBidafPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/constituency_parser_test.py": {
        "TestConstituencyParserPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConstituencyParserPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestConstituencyParserPredictor.test_build_hierplane_tree": {
            "name": "test_build_hierplane_tree",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/coref_test.py": {
        "TestCorefPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/decomposable_attention_test.py": {
        "TestDecomposableAttentionPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestDecomposableAttentionPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/simple_seq2seq_test.py": {
        "TestSimpleSeq2SeqPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/srl_test.py": {
        "TestSrlPredictor.test_uses_named_inputs": {
            "name": "test_uses_named_inputs",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSrlPredictor.test_batch_prediction": {
            "name": "test_batch_prediction",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSrlPredictor.test_prediction_with_no_verbs": {
            "name": "test_prediction_with_no_verbs",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/service/predictors/__init__.py": {},
    "allennlp-dureader-master/tests/training/optimizer_test.py": {
        "TestOptimizer.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestOptimizer.test_optimizer_basic": {
            "name": "test_optimizer_basic",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestOptimizer.test_optimizer_parameter_groups": {
            "name": "test_optimizer_parameter_groups",
            "location": 42,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/trainer_test.py": {
        "TestTrainer.setUp": {
            "name": "setUp",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_run": {
            "name": "test_trainer_can_run",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_run_cuda": {
            "name": "test_trainer_can_run_cuda",
            "location": 73,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_run_multiple_gpu": {
            "name": "test_trainer_can_run_multiple_gpu",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_resume_training": {
            "name": "test_trainer_can_resume_training",
            "location": 89,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_should_stop_early_with_increasing_metric": {
            "name": "test_should_stop_early_with_increasing_metric",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_should_stop_early_with_decreasing_metric": {
            "name": "test_should_stop_early_with_decreasing_metric",
            "location": 116,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_train_driver_raises_on_model_with_no_loss_key": {
            "name": "test_train_driver_raises_on_model_with_no_loss_key",
            "location": 125,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_can_log_histograms": {
            "name": "test_trainer_can_log_histograms",
            "location": 136,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_respects_num_serialized_models_to_keep": {
            "name": "test_trainer_respects_num_serialized_models_to_keep",
            "location": 147,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_respects_keep_serialized_model_every_num_seconds": {
            "name": "test_trainer_respects_keep_serialized_model_every_num_seconds",
            "location": 161,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_saves_models_at_specified_interval": {
            "name": "test_trainer_saves_models_at_specified_interval",
            "location": 192,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSparseClipGrad.test_sparse_clip_grad": {
            "name": "test_sparse_clip_grad",
            "location": 233,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_train_driver_raises_on_model_with_no_loss_key.FakeModel.forward": {
            "name": "forward",
            "location": 128,
            "return": [
                "dict[, ]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTrainer.test_trainer_respects_keep_serialized_model_every_num_seconds.WaitingIterator._create_batches": {
            "name": "_create_batches",
            "location": 170,
            "return": [
                "Optional[int]",
                "int",
                "float",
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/__init__.py": {},
    "allennlp-dureader-master/tests/training/metrics/boolean_accuracy_test.py": {
        "BooleanAccuracyTest.test_accuracy_computation": {
            "name": "test_accuracy_computation",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/categorical_accuracy_test.py": {
        "CategoricalAccuracyTest.test_categorical_accuracy": {
            "name": "test_categorical_accuracy",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy": {
            "name": "test_top_k_categorical_accuracy",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_accumulates_and_resets_correctly": {
            "name": "test_top_k_categorical_accuracy_accumulates_and_resets_correctly",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_respects_mask": {
            "name": "test_top_k_categorical_accuracy_respects_mask",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_works_for_sequences": {
            "name": "test_top_k_categorical_accuracy_works_for_sequences",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalAccuracyTest.test_top_k_categorical_accuracy_catches_exceptions": {
            "name": "test_top_k_categorical_accuracy_catches_exceptions",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/entropy_test.py": {
        "EntropyTest.test_low_entropy_distribution": {
            "name": "test_low_entropy_distribution",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EntropyTest.test_entropy_for_uniform_distribution": {
            "name": "test_entropy_for_uniform_distribution",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EntropyTest.test_masked_case": {
            "name": "test_masked_case",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/evalb_bracketing_scorer_test.py": {
        "EvalbBracketingScorerTest.setUp": {
            "name": "setUp",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.tearDown": {
            "name": "tearDown",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_correctly_scores_identical_trees": {
            "name": "test_evalb_correctly_scores_identical_trees",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_correctly_scores_imperfect_trees": {
            "name": "test_evalb_correctly_scores_imperfect_trees",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_correctly_calculates_bracketing_metrics_over_multiple_trees": {
            "name": "test_evalb_correctly_calculates_bracketing_metrics_over_multiple_trees",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "EvalbBracketingScorerTest.test_evalb_with_terrible_trees_handles_nan_f1": {
            "name": "test_evalb_with_terrible_trees_handles_nan_f1",
            "location": 52,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/f1_measure_test.py": {
        "F1MeasureTest.test_f1_measure_catches_exceptions": {
            "name": "test_f1_measure_catches_exceptions",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "F1MeasureTest.test_f1_measure": {
            "name": "test_f1_measure",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "F1MeasureTest.test_f1_measure_accumulates_and_resets_correctly": {
            "name": "test_f1_measure_accumulates_and_resets_correctly",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "F1MeasureTest.test_f1_measure_works_for_sequences": {
            "name": "test_f1_measure_works_for_sequences",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/span_based_f1_measure_test.py": {
        "SpanBasedF1Test.setUp": {
            "name": "setUp",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_metrics_are_computed_correcly_with_prediction_map": {
            "name": "test_span_metrics_are_computed_correcly_with_prediction_map",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_metrics_are_computed_correctly": {
            "name": "test_span_metrics_are_computed_correctly",
            "location": 110,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_f1_can_build_from_params": {
            "name": "test_span_f1_can_build_from_params",
            "location": 170,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpanBasedF1Test.test_span_f1_matches_perl_script_for_continued_arguments": {
            "name": "test_span_f1_matches_perl_script_for_continued_arguments",
            "location": 176,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tests/training/metrics/__init__.py": {},
    "allennlp-dureader-master/tools/distributed_utils.py": {
        "average_gradients": {
            "name": "average_gradients",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "Union['Contributor', 'Coverage']",
                    "Optional[float]"
                ]
            }
        },
        "broadcast_params": {
            "name": "broadcast_params",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "dict[, ]",
                    "dict",
                    "list[tuple[typing.Union[typing.Any,...]]]",
                    "List[Tuple[Any, ...]]",
                    "typing.Mapping",
                    "Mapping[str, Any]",
                    "dict[str, float]",
                    "Dict[str, float]",
                    "list[]",
                    "list",
                    "Dict[str, Any]"
                ]
            }
        },
        "dist_init": {
            "name": "dist_init",
            "location": 20,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "port": [
                    "MutableMapping",
                    "typing.MutableMapping",
                    "str",
                    "list",
                    "list[]"
                ],
                "backend": [
                    "typing.Text",
                    "int",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/tools/dureader_eval.py": {
        "normalize": {
            "name": "normalize",
            "location": 37,
            "return": [
                "list[str]",
                "str",
                "float"
            ],
            "arguments": {
                "s": [
                    "AnyStr",
                    "Union[bytes, bytearray]",
                    "Iterable[T]",
                    "bool",
                    "str"
                ]
            }
        },
        "data_check": {
            "name": "data_check",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "obj": [
                    "str",
                    "Optional[Callable]",
                    "Tuple[Dict[str, Any], Any]"
                ],
                "task": [
                    "Callable",
                    "int",
                    "Dict[str, str]"
                ]
            }
        },
        "read_file": {
            "name": "read_file",
            "location": 82,
            "return": [
                "dict[, dict[, ]]",
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "file_name": [
                    "Optional[str]",
                    "dict"
                ],
                "task": [
                    "str",
                    "Optional[str]",
                    "float",
                    "Optional[int]",
                    "bool"
                ],
                "is_ref": [
                    "bool",
                    "str",
                    "Mapping[Any, str]"
                ]
            }
        },
        "compute_bleu_rouge": {
            "name": "compute_bleu_rouge",
            "location": 127,
            "return": [
                "dict[typing.Text, ]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "pred_dict": [
                    "dict",
                    "Callable",
                    "Type[\"SerializationDialect\"]",
                    "int",
                    "list"
                ],
                "ref_dict": [
                    "dict",
                    "Callable",
                    "Type[\"SerializationDialect\"]",
                    "int",
                    "list"
                ],
                "bleu_order": [
                    "int",
                    "dict",
                    "bytes"
                ]
            }
        },
        "local_prf": {
            "name": "local_prf",
            "location": 142,
            "return": [
                "tuple[int]",
                "str",
                "tuple[float]",
                "int",
                "List[dict]",
                "raiden.utils.signer.Signer"
            ],
            "arguments": {
                "pred_list": [
                    "list",
                    "List[Tuple[str, int]]",
                    "List[Union[int, float]]",
                    "List[List[int]]",
                    "Dict[str, str]",
                    "int"
                ],
                "ref_list": [
                    "list",
                    "List[Tuple[str, int]]",
                    "List[Union[int, float]]",
                    "Sequence[T]",
                    "int",
                    "str"
                ]
            }
        },
        "compute_prf": {
            "name": "compute_prf",
            "location": 157,
            "return": [
                "dict[typing.Text, typing.Union[float,int]]",
                "dict",
                "List[dict]",
                "bool"
            ],
            "arguments": {
                "pred_dict": [
                    "dict",
                    "Type[T]",
                    "Tuple['cirq.Qid']",
                    "Union[Dict, List]",
                    "raiden.utils.Dict"
                ],
                "ref_dict": [
                    "List[List]",
                    "Dict[int, Dict[str, Any]]",
                    "Type[object]",
                    "Dict[str, Any]",
                    "List[List[str]]",
                    "T"
                ]
            }
        },
        "prepare_prf": {
            "name": "prepare_prf",
            "location": 194,
            "return": [
                "tuple[dict[, ]]",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "pred_dict": [
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, int]",
                    "Dict[str, List[Callable]]"
                ],
                "ref_dict": [
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, int]",
                    "Dict[str, List[Callable]]"
                ]
            }
        },
        "filter_dict": {
            "name": "filter_dict",
            "location": 203,
            "return": [
                "dict[, ]",
                "Callable",
                "cmk.utils.type_defs.EventRule",
                "Dict[str, Any]",
                "argparse.Namespace"
            ],
            "arguments": {
                "result_dict": [
                    "dict",
                    "Dict[str, Any]",
                    "Dict[str, Dict[str, str]]",
                    "Dict[str, float]"
                ],
                "key_tag": [
                    "str",
                    "Tuple[int, int]"
                ]
            }
        },
        "get_metrics": {
            "name": "get_metrics",
            "location": 214,
            "return": [
                "dict[, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "pred_result": [
                    "str"
                ],
                "ref_result": [
                    "str",
                    "List[str]",
                    "list",
                    "Optional[List[str]]",
                    "Optional[str]",
                    "Optional[Dict[str, str]]"
                ],
                "task": [
                    "str",
                    "Dict[str, Any]",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "int"
                ],
                "source": [
                    "str",
                    "Optional[List[str]]",
                    "int",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "prepare_bleu": {
            "name": "prepare_bleu",
            "location": 267,
            "return": [
                "tuple[]",
                "str",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "pred_result": [
                    "Callable",
                    "Callable[[Any], T]",
                    "Callable[[], str]"
                ],
                "ref_result": [
                    "int"
                ],
                "task": [
                    "str",
                    "int",
                    "Union[str, bool]"
                ]
            }
        },
        "get_main_result": {
            "name": "get_main_result",
            "location": 304,
            "return": [
                "str",
                "tuple[list[tuple[list[typing.Text]]]]"
            ],
            "arguments": {
                "qid": [
                    "dict",
                    "Dict[int, dict]",
                    "bytes",
                    "Dict[str, Dict[str, str]]",
                    "Optional[str]"
                ],
                "pred_result": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "ref_result": [
                    "int",
                    "str",
                    "Callable[[T], List[T]]"
                ]
            }
        },
        "get_entity_result": {
            "name": "get_entity_result",
            "location": 329,
            "return": [
                "tuple[None]",
                "Optional[str]",
                "Optional[bool]",
                "Optional[int]",
                "bool"
            ],
            "arguments": {
                "qid": [
                    "int",
                    "Callable",
                    "float"
                ],
                "pred_result": [
                    "dict",
                    "Callable",
                    "Mapping",
                    "Dict[str, Any]",
                    "raiden.utils.Any"
                ],
                "ref_result": [
                    "int",
                    "Callable",
                    "float"
                ]
            }
        },
        "get_desc_result": {
            "name": "get_desc_result",
            "location": 349,
            "return": [
                "tuple[None]",
                "Optional[str]",
                "Optional[int]",
                "str",
                "bool"
            ],
            "arguments": {
                "qid": [
                    "float",
                    "int",
                    "list"
                ],
                "pred_result": [
                    "dict",
                    "Iterable[Any]",
                    "float",
                    "Iterable[int]",
                    "bool"
                ],
                "ref_result": [
                    "float",
                    "int",
                    "list"
                ]
            }
        },
        "get_yesno_result": {
            "name": "get_yesno_result",
            "location": 369,
            "return": [
                "tuple[None]",
                "tuple[]",
                "bool",
                "Optional[int]",
                "Optional[str]",
                "Optional[Literal[\"only_clustered\", \"include_clustered\"]]",
                "dict"
            ],
            "arguments": {
                "qid": [
                    "str",
                    "bool"
                ],
                "pred_result": [
                    "int",
                    "tuple"
                ],
                "ref_result": [
                    "int"
                ]
            }
        },
        "get_all_result": {
            "name": "get_all_result",
            "location": 426,
            "return": [
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "qid": [
                    "str",
                    "raiden.utils.Address",
                    "Dict[str, Any]",
                    "Optional[int]"
                ],
                "pred_result": [
                    "bool",
                    "Awaitable[T]",
                    "float",
                    "raiden.utils.PaymentID",
                    "Optional[cmk.utils.type_defs.HostAddress]"
                ],
                "ref_result": [
                    "str",
                    "raiden.utils.Address",
                    "Dict[str, Any]",
                    "Optional[int]"
                ]
            }
        },
        "format_metrics": {
            "name": "format_metrics",
            "location": 446,
            "return": [
                "dict[typing.Text, typing.Union[str,int,list[]]]",
                "dict[typing.Text, typing.Union[list[dict[typing.Text, typing.Union[typing.Text,float]]],int,typing.Text]]",
                "Dict[str, Any]",
                "dict",
                "Dict[str, bool]",
                "str",
                "int"
            ],
            "arguments": {
                "metrics": [
                    "Dict[str, Any]",
                    "dict",
                    "Dict[int, str]"
                ],
                "task": [
                    "str",
                    "Dict[str, Any]",
                    "Callable[[Dict], None]",
                    "int",
                    "Optional[str]"
                ],
                "err_msg": [
                    "Tuple[List[str], Optional[Any]]",
                    "Optional[Union[Any, Any]]",
                    "Callable",
                    "Optional[Sequence[str]]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 514,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "read_file._open": {
            "name": "_open",
            "location": 99,
            "return": [
                "typing.IO",
                "str",
                "bytes",
                "bool"
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "mode": [
                    "str"
                ],
                "zip_obj": [
                    "None",
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str, str]]",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "get_yesno_result._uniq": {
            "name": "_uniq",
            "location": 384,
            "return": [
                "list[tuple[]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "li": [
                    "Callable",
                    "Coroutine[Any, Any, Any]",
                    "List[str]",
                    "Sequence[str]",
                    "bool"
                ],
                "is_ref": [
                    "Callable",
                    "Coroutine[Any, Any, Any]",
                    "List[str]",
                    "Sequence[str]",
                    "bool"
                ]
            }
        },
        "get_yesno_result._expand_result": {
            "name": "_expand_result",
            "location": 402,
            "return": [
                "int",
                "Type",
                "str",
                "bool"
            ],
            "arguments": {
                "uniq_li": [
                    "Mapping[str, str]",
                    "Dict[str, Type]",
                    "dict"
                ]
            }
        },
        "get_yesno_result._get_yesno_ans": {
            "name": "_get_yesno_ans",
            "location": 409,
            "return": [
                "list[tuple[]]",
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "qid": [
                    "dict",
                    "Dict[str, str]",
                    "Optional[str]",
                    "Dict[str, Any]",
                    "Any"
                ],
                "result_dict": [
                    "dict",
                    "Dict[str, float]"
                ],
                "is_ref": [
                    "bool",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/tools/load_helper.py": {
        "check_keys": {
            "name": "check_keys",
            "location": 5,
            "return": [
                "bool"
            ],
            "arguments": {
                "model": [
                    "dict",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, int]",
                    "dict[str, int]"
                ],
                "pretrained_state_dict": [
                    "dict[, ]",
                    "dict[str, typing.Any]",
                    "dict",
                    "Optional[List[str]]",
                    "str",
                    "Mapping[int, str]",
                    "Dict[str, Any]",
                    "DefaultDict[str, int]"
                ]
            }
        },
        "load_pretrain": {
            "name": "load_pretrain",
            "location": 18,
            "return": [
                "_T0"
            ],
            "arguments": {
                "model": [
                    "_T0"
                ],
                "pretrained_path": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "restore_from": {
            "name": "restore_from",
            "location": 27,
            "return": [
                "Tuple[(_T0, _T1, Any)]"
            ],
            "arguments": {
                "model": [
                    "_T0"
                ],
                "optimizer": [
                    "_T1"
                ],
                "ckpt_path": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "allennlp-dureader-master/tools/log_helper.py": {
        "init_log": {
            "name": "init_log",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "name": [
                    "str",
                    "dict[, ]",
                    "int",
                    "logging.Logger",
                    "tuple[typing.Union[str,int]]",
                    "dict",
                    "Tuple[str, int]",
                    "bool"
                ],
                "filter_by_rank": [
                    "bool",
                    "str",
                    "Callable[[str, Any], None]",
                    "Iterable[str]"
                ],
                "level": [
                    "str",
                    "Tuple[str, int]",
                    "Optional[Sequence[str]]",
                    "dict",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "print_speed": {
            "name": "print_speed",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "i": [
                    "int",
                    "float",
                    "bool",
                    "Callable"
                ],
                "i_time": [
                    "int",
                    "float",
                    "str"
                ],
                "n": [
                    "int",
                    "float",
                    "bool",
                    "Callable"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "allennlp-dureader-master/tools/lr_helper.py": {
        "_IterLRScheduler.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "float",
                    "torch.Tensor"
                ],
                "last_iter": [
                    "int",
                    "List[Dict[str, torch.Tensor]]",
                    "List[List[T]]",
                    "float",
                    "Iterable"
                ]
            }
        },
        "_IterLRScheduler.get_lr": {
            "name": "get_lr",
            "location": 22,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "_IterLRScheduler.step": {
            "name": "step",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "iter": [
                    "Dict[str, Any]",
                    "None",
                    "str",
                    "dict[str, typing.Any]",
                    "Optional[str]",
                    "Type[T]",
                    "typing.Type",
                    "Optional[Callable[[bool], None]]",
                    "typing.Callable[bool, None]"
                ]
            }
        },
        "IterLinearLR.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "bool",
                    "Exception",
                    "str",
                    "Optional[List[str]]",
                    "list[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ],
                "gamma": [
                    "int",
                    "str",
                    "bytes",
                    "bool",
                    "set[str]",
                    "Set[str]",
                    "dict[, ]",
                    "Optional[dict]",
                    "None"
                ],
                "last_iter": [
                    "int",
                    "bool",
                    "Exception",
                    "Optional[List[str]]",
                    "str",
                    "dict"
                ]
            }
        },
        "IterLinearLR.get_lr": {
            "name": "get_lr",
            "location": 46,
            "return": [
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "IterExponentialLR.__init__": {
            "name": "__init__",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "bool",
                    "Exception",
                    "str",
                    "Optional[List[str]]",
                    "list[str]",
                    "int",
                    "None",
                    "dict",
                    "dict[, ]"
                ],
                "gamma": [
                    "int",
                    "str",
                    "bytes",
                    "bool",
                    "set[str]",
                    "Set[str]",
                    "dict[, ]",
                    "Optional[dict]",
                    "None"
                ],
                "last_iter": [
                    "int",
                    "bool",
                    "Exception",
                    "Optional[List[str]]",
                    "str",
                    "dict"
                ]
            }
        },
        "IterExponentialLR.get_lr": {
            "name": "get_lr",
            "location": 64,
            "return": [
                "list"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/tools/parse_anno_json.py": {
        "reader": {
            "name": "reader",
            "location": 5,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "input": []
            }
        },
        "writer": {
            "name": "writer",
            "location": 9,
            "return": [
                "codecs.StreamReaderWriter"
            ],
            "arguments": {
                "output": []
            }
        },
        "add_yesno_answer": {
            "name": "add_yesno_answer",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "input": [],
                "output": []
            }
        },
        "get_segmented_sentences": {
            "name": "get_segmented_sentences",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "input": [],
                "output": []
            }
        }
    },
    "allennlp-dureader-master/tools/train_val.py": {
        "get_rank_world_size": {
            "name": "get_rank_world_size",
            "location": 127,
            "return": [
                "tuple[int]",
                "bool",
                "tuple[]",
                "raiden.utils.Tuple[int, int]",
                "bytes",
                "Optional[float]"
            ],
            "arguments": {
                "args": []
            }
        },
        "construct_allen_vocab_from_du_vocab": {
            "name": "construct_allen_vocab_from_du_vocab",
            "location": 141,
            "return": [
                "int",
                "Sequence[float]",
                "torch.Tensor",
                "Set[str]",
                "Tuple[str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "du_vocab": [
                    "int",
                    "Dict[str, torch.Tensor]",
                    "str",
                    "torch.Tensor"
                ]
            }
        },
        "prepare_du_vocab": {
            "name": "prepare_du_vocab",
            "location": 157,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "vocab_dir": [
                    "str",
                    "Optional[str]",
                    "bool"
                ],
                "trainset": [
                    "List[int]",
                    "List[List[int]]",
                    "int",
                    "List[Dict[str, Any]]",
                    "str",
                    "Tuple[int]",
                    "float"
                ],
                "embed_size": [
                    "int",
                    "str",
                    "Optional[str]",
                    "float"
                ],
                "args": []
            }
        },
        "build_dataloader": {
            "name": "build_dataloader",
            "location": 189,
            "return": [
                "BRCDataLoader",
                "Iterable[allennlp.data.instance.Instance]",
                "bool"
            ],
            "arguments": {
                "files": [
                    "Callable[..., None]",
                    "argparse.Namespace",
                    "Dict[str, str]",
                    "List[str]",
                    "list"
                ],
                "args": [],
                "is_train": [
                    "bool",
                    "Callable[..., None]",
                    "argparse.Namespace",
                    "Dict[str, str]",
                    "List[str]",
                    "list"
                ]
            }
        },
        "warmup": {
            "name": "warmup",
            "location": 200,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model": [
                    "Set[int]",
                    "int"
                ],
                "train_loader": [
                    "models.Payment",
                    "Callable",
                    "str",
                    "int",
                    "logging.LogRecord"
                ],
                "optimizer": [
                    "str",
                    "Optional[str]"
                ],
                "args": []
            }
        },
        "makedirs": {
            "name": "makedirs",
            "location": 215,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dirs": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 219,
            "return": [
                "None",
                "bytes",
                "raiden.utils.Signature",
                "utils.Encoded",
                "raiden.utils.Optional[raiden.utils.Signature]"
            ],
            "arguments": {}
        },
        "train": {
            "name": "train",
            "location": 292,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "train_loader": [
                    "dict",
                    "bytes",
                    "Iterable[int]",
                    "Callable",
                    "Dict[str, Any]"
                ],
                "model": [
                    "allennlp.models.model.Model",
                    "str",
                    "Dict[str, Any]",
                    "Set[int]",
                    "int"
                ],
                "lr_scheduler": [
                    "str",
                    "torch.Tensor",
                    "float"
                ],
                "epoch": [
                    "dict"
                ],
                "args": [],
                "warmup": [
                    "bool",
                    "List[str]",
                    "dict",
                    "numpy.ndarray"
                ]
            }
        },
        "validate": {
            "name": "validate",
            "location": 339,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "val_loader": [
                    "str",
                    "int",
                    "allennlp.data.vocabulary.Vocabulary",
                    "numpy.ndarray"
                ],
                "model": [
                    "int",
                    "str",
                    "db.models.Region"
                ],
                "args": []
            }
        },
        "dump_pred_results": {
            "name": "dump_pred_results",
            "location": 384,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pred_answers": [
                    "List[str]"
                ],
                "output_file": [
                    "str",
                    "Set[str]",
                    "_params.Params"
                ],
                "readable": [
                    "None",
                    "Union[str, List[str], None]",
                    "Set[cmk.utils.type_defs.CheckPluginName]",
                    "list",
                    "bool",
                    "Optional[int]",
                    "List[Tuple]",
                    "Optional[Sequence[str]]",
                    "Dict[cmk.utils.type_defs.HostName, List[cmk.utils.type_defs.HostName]]"
                ]
            }
        },
        "evaluate": {
            "name": "evaluate",
            "location": 394,
            "return": [
                "None",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "pred_answers": [
                    "bool",
                    "str",
                    "int"
                ],
                "ref_answers": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "get_ref_answers": {
            "name": "get_ref_answers",
            "location": 407,
            "return": [
                "list[dict[typing.Text, list[list[]]]]",
                "List[str]",
                "str",
                "Dict[str, Any]",
                "Dict[str, List[Any]]"
            ],
            "arguments": {
                "samples": [
                    "bool",
                    "str",
                    "Optional[List[int]]",
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "get_pred_answers": {
            "name": "get_pred_answers",
            "location": 418,
            "return": [
                "str",
                "Optional[str]",
                "bool"
            ],
            "arguments": {
                "best_spans": [
                    "int",
                    "List[List[str]]",
                    "bool",
                    "torch.Tensor",
                    "raiden.utils.Address",
                    "bytes"
                ],
                "best_scores": [
                    "str",
                    "dict",
                    "trezor.utils.Writer"
                ],
                "samples": [
                    "int",
                    "str",
                    "Optional[str]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "find_best_answer": {
            "name": "find_best_answer",
            "location": 455,
            "return": [
                "tuple[]",
                "str",
                "int"
            ],
            "arguments": {
                "best_spans": [
                    "Optional[int]",
                    "int",
                    "str"
                ],
                "best_scores": [
                    "int",
                    "float",
                    "str",
                    "List[str]",
                    "raiden.utils.PaymentHashInvoice"
                ],
                "batch_size": [
                    "int",
                    "Union[float, int]",
                    "Optional[int]"
                ]
            }
        },
        "get_answer_str": {
            "name": "get_answer_str",
            "location": 482,
            "return": [
                "typing.Text",
                "str",
                "List[str]",
                "bool",
                "bokeh.models.Plot"
            ],
            "arguments": {
                "answer_doc": [
                    "str",
                    "Optional[str]",
                    "Set[str]",
                    "List[str]",
                    "bool"
                ],
                "answer_span": [
                    "str",
                    "List[str]",
                    "Set[str]",
                    "Optional[int]",
                    "bool",
                    "Union[numpy.ndarray, pandas.DataFrame]"
                ],
                "sample": [
                    "str",
                    "int",
                    "float",
                    "Tuple[int, int]"
                ]
            }
        },
        "AverageMeter.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AverageMeter.reset": {
            "name": "reset",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AverageMeter.update": {
            "name": "update",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "val": [
                    "float",
                    "common.linkedlisListNode",
                    "int"
                ],
                "n": [
                    "int",
                    "bool",
                    "list"
                ]
            }
        }
    },
    "allennlp-dureader-master/tools/train_word2vec.py": {},
    "allennlp-dureader-master/tools/ZQ.py": {},
    "allennlp-dureader-master/utils/dureader_eval.py": {
        "normalize": {
            "name": "normalize",
            "location": 37,
            "return": [
                "Union[(List[str], _T0)]"
            ],
            "arguments": {
                "s": [
                    "_T0"
                ]
            }
        },
        "data_check": {
            "name": "data_check",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "obj": [
                    "str",
                    "Optional[Callable]",
                    "Tuple[Dict[str, Any], Any]"
                ],
                "task": [
                    "Callable",
                    "int",
                    "Dict[str, str]"
                ]
            }
        },
        "read_file": {
            "name": "read_file",
            "location": 82,
            "return": [
                "Dict[(Any, Dict[(str, Any)])]"
            ],
            "arguments": {
                "file_name": [
                    "Optional[str]",
                    "dict"
                ],
                "task": [
                    "str",
                    "Optional[str]",
                    "float",
                    "Optional[int]",
                    "bool"
                ],
                "is_ref": [
                    "bool",
                    "str",
                    "Mapping[Any, str]"
                ]
            }
        },
        "compute_bleu_rouge": {
            "name": "compute_bleu_rouge",
            "location": 127,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "pred_dict": [
                    "dict",
                    "Callable",
                    "Type[\"SerializationDialect\"]",
                    "int",
                    "list"
                ],
                "ref_dict": [
                    "dict",
                    "Callable",
                    "Type[\"SerializationDialect\"]",
                    "int",
                    "list"
                ],
                "bleu_order": [
                    "int",
                    "dict",
                    "bytes"
                ]
            }
        },
        "local_prf": {
            "name": "local_prf",
            "location": 142,
            "return": [
                "Tuple[(Union[(float, int)], Union[(float, int)], Union[(float, int)])]"
            ],
            "arguments": {
                "pred_list": [
                    "list",
                    "List[Tuple[str, int]]",
                    "List[Union[int, float]]",
                    "List[List[int]]",
                    "Dict[str, str]",
                    "int"
                ],
                "ref_list": [
                    "list",
                    "List[Tuple[str, int]]",
                    "List[Union[int, float]]",
                    "Sequence[T]",
                    "int",
                    "str"
                ]
            }
        },
        "compute_prf": {
            "name": "compute_prf",
            "location": 157,
            "return": [
                "Dict[(str, Union[(float, int)])]"
            ],
            "arguments": {
                "pred_dict": [
                    "dict",
                    "Type[T]",
                    "Tuple['cirq.Qid']",
                    "Union[Dict, List]"
                ],
                "ref_dict": [
                    "List[List]",
                    "Dict[int, Dict[str, Any]]",
                    "Type[object]",
                    "Dict[str, Any]",
                    "List[List[str]]",
                    "T"
                ]
            }
        },
        "prepare_prf": {
            "name": "prepare_prf",
            "location": 194,
            "return": [
                "Tuple[(dict, dict)]"
            ],
            "arguments": {
                "pred_dict": [
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, int]",
                    "Dict[str, List[Callable]]"
                ],
                "ref_dict": [
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, int]",
                    "Dict[str, List[Callable]]"
                ]
            }
        },
        "filter_dict": {
            "name": "filter_dict",
            "location": 203,
            "return": [
                "dict"
            ],
            "arguments": {
                "result_dict": [
                    "dict",
                    "Dict[str, Any]",
                    "Dict[str, Dict[str, str]]",
                    "Dict[str, float]"
                ],
                "key_tag": [
                    "str",
                    "Tuple[int, int]"
                ]
            }
        },
        "get_metrics": {
            "name": "get_metrics",
            "location": 214,
            "return": [
                "dict"
            ],
            "arguments": {
                "pred_result": [
                    "str"
                ],
                "ref_result": [
                    "str",
                    "List[str]",
                    "list",
                    "Optional[List[str]]",
                    "Optional[str]",
                    "Optional[Dict[str, str]]"
                ],
                "task": [
                    "str",
                    "Dict[str, Any]",
                    "int"
                ],
                "source": [
                    "str",
                    "Optional[List[str]]",
                    "int",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "prepare_bleu": {
            "name": "prepare_bleu",
            "location": 267,
            "return": [
                "Tuple[(dict, dict)]"
            ],
            "arguments": {
                "pred_result": [
                    "Callable",
                    "Callable[[Any], T]",
                    "Callable[[], str]"
                ],
                "ref_result": [
                    "int"
                ],
                "task": [
                    "str",
                    "int",
                    "Union[str, bool]"
                ]
            }
        },
        "get_main_result": {
            "name": "get_main_result",
            "location": 304,
            "return": [
                "Tuple[(List[Tuple[(_T0, Any)]], List[Tuple[(_T0, Any)]])]"
            ],
            "arguments": {
                "qid": [
                    "_T0"
                ],
                "pred_result": [
                    "str",
                    "int",
                    "Optional[str]"
                ],
                "ref_result": [
                    "int",
                    "str",
                    "Callable[[T], List[T]]"
                ]
            }
        },
        "get_entity_result": {
            "name": "get_entity_result",
            "location": 329,
            "return": [
                "Tuple[(Optional[List[Tuple[(_T3, Any)]]], Optional[List[Tuple[(_T3, Any)]]])]"
            ],
            "arguments": {
                "qid": [
                    "int",
                    "Callable",
                    "float"
                ],
                "pred_result": [
                    "dict",
                    "Callable",
                    "Mapping",
                    "Dict[str, Any]"
                ],
                "ref_result": [
                    "int",
                    "Callable",
                    "float"
                ]
            }
        },
        "get_desc_result": {
            "name": "get_desc_result",
            "location": 349,
            "return": [
                "Tuple[(Optional[List[Tuple[(_T3, Any)]]], Optional[List[Tuple[(_T3, Any)]]])]"
            ],
            "arguments": {
                "qid": [
                    "float",
                    "int",
                    "list"
                ],
                "pred_result": [
                    "dict",
                    "Iterable[Any]",
                    "float",
                    "Iterable[int]",
                    "bool"
                ],
                "ref_result": [
                    "float",
                    "int",
                    "list"
                ]
            }
        },
        "get_yesno_result": {
            "name": "get_yesno_result",
            "location": 369,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "qid": [
                    "str",
                    "bool"
                ],
                "pred_result": [
                    "int",
                    "tuple"
                ],
                "ref_result": [
                    "int"
                ]
            }
        },
        "get_all_result": {
            "name": "get_all_result",
            "location": 426,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "qid": [
                    "_T0"
                ],
                "pred_result": [
                    "bool",
                    "Awaitable[T]",
                    "float"
                ],
                "ref_result": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[int]"
                ]
            }
        },
        "format_metrics": {
            "name": "format_metrics",
            "location": 446,
            "return": [
                "Dict[(str, Union[(int, str, List[Dict[(str, Union[(float, str)])]])])]"
            ],
            "arguments": {
                "metrics": [
                    "Dict[str, Any]",
                    "dict",
                    "Dict[int, str]"
                ],
                "task": [
                    "str",
                    "Dict[str, Any]",
                    "Callable[[Dict], None]",
                    "int",
                    "Optional[str]"
                ],
                "err_msg": [
                    "Tuple[List[str], Optional[Any]]",
                    "Optional[Union[Any, Any]]",
                    "Callable",
                    "Optional[Sequence[str]]"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "args": []
            }
        },
        "read_file._open": {
            "name": "_open",
            "location": 99,
            "return": [
                "typing.IO",
                "str",
                "bytes",
                "bool"
            ],
            "arguments": {
                "file_name": [
                    "str"
                ],
                "mode": [
                    "str"
                ],
                "zip_obj": [
                    "None",
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str, str]]",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "get_yesno_result._uniq": {
            "name": "_uniq",
            "location": 384,
            "return": [
                "list[tuple[]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "li": [
                    "Callable",
                    "Coroutine[Any, Any, Any]",
                    "List[str]",
                    "Sequence[str]",
                    "bool"
                ],
                "is_ref": [
                    "Callable",
                    "Coroutine[Any, Any, Any]",
                    "List[str]",
                    "Sequence[str]",
                    "bool"
                ]
            }
        },
        "get_yesno_result._expand_result": {
            "name": "_expand_result",
            "location": 402,
            "return": [
                "int",
                "Type",
                "str",
                "bool"
            ],
            "arguments": {
                "uniq_li": [
                    "Mapping[str, str]",
                    "Dict[str, Type]",
                    "dict"
                ]
            }
        },
        "get_yesno_result._get_yesno_ans": {
            "name": "_get_yesno_ans",
            "location": 409,
            "return": [
                "list[tuple[]]",
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "qid": [
                    "dict",
                    "Dict[str, str]",
                    "Optional[str]",
                    "Dict[str, Any]",
                    "Any"
                ],
                "result_dict": [
                    "dict",
                    "Dict[str, float]"
                ],
                "is_ref": [
                    "bool",
                    "Optional[Dict[str, Any]]",
                    "str",
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "allennlp-dureader-master/utils/filter_passage_by_title_question_f1.py": {
        "to_list": {
            "name": "to_list",
            "location": 5,
            "return": [
                "list"
            ],
            "arguments": {
                "text": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "allennlp-dureader-master/utils/get_vocab.py": {
        "get_vocab": {
            "name": "get_vocab",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "files": [
                    "bool",
                    "str"
                ],
                "vocab_file": [
                    "TextIO",
                    "List[str]",
                    "Optional[int]"
                ]
            }
        }
    },
    "allennlp-dureader-master/utils/preprocess.py": {
        "precision_recall_f1": {
            "name": "precision_recall_f1",
            "location": 29,
            "return": [
                "Tuple[(Union[(float, int)], Union[(float, int)], Union[(float, int)])]"
            ],
            "arguments": {
                "prediction": [
                    "str",
                    "List[int]",
                    "int",
                    "list"
                ],
                "ground_truth": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "recall": {
            "name": "recall",
            "location": 58,
            "return": [
                "Union[(float, int)]"
            ],
            "arguments": {
                "prediction": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "ground_truth": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "f1_score": {
            "name": "f1_score",
            "location": 72,
            "return": [
                "Union[(float, int)]"
            ],
            "arguments": {
                "prediction": [
                    "float",
                    "int",
                    "str"
                ],
                "ground_truth": [
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "metric_max_over_ground_truths": {
            "name": "metric_max_over_ground_truths",
            "location": 86,
            "return": [
                "list[list[]]",
                "bool",
                "str",
                "Union[str, Pattern]",
                "int",
                "Optional[int]",
                "List[str]"
            ],
            "arguments": {
                "metric_fn": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "prediction": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "ground_truths": [
                    "str",
                    "int",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "find_best_question_match": {
            "name": "find_best_question_match",
            "location": 105,
            "return": [
                "Union[(int, Tuple[(int, Any)])]"
            ],
            "arguments": {
                "doc": [
                    "str",
                    "int",
                    "bool"
                ],
                "question": [
                    "str",
                    "int",
                    "bool"
                ],
                "with_score": [
                    "bool",
                    "List[int]",
                    "int",
                    "List[str]"
                ]
            }
        },
        "find_fake_answer": {
            "name": "find_fake_answer",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "sample": [
                    "bool",
                    "str",
                    "float"
                ]
            }
        }
    },
    "allennlp-dureader-master/utils/__init__.py": {},
    "allennlp-dureader-master/utils/bleu_metric/bleu.py": {
        "Bleu.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int"
                ]
            }
        },
        "Bleu.compute_score": {
            "name": "compute_score",
            "location": 21,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "gts": [
                    "Optional[Tuple[str, ...]]",
                    "Iterable",
                    "str",
                    "Dict[str, Set[str]]"
                ],
                "res": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "Bleu.method": {
            "name": "method",
            "location": 46,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/utils/bleu_metric/bleu_scorer.py": {
        "precook": {
            "name": "precook",
            "location": 23,
            "return": [
                "Tuple[(int, collections.defaultdict[(tuple, Any)])]"
            ],
            "arguments": {
                "s": [
                    "str",
                    "int",
                    "List[Tuple[int, int]]"
                ],
                "n": [
                    "int",
                    "dict"
                ],
                "out": [
                    "bool",
                    "int",
                    "str"
                ]
            }
        },
        "cook_refs": {
            "name": "cook_refs",
            "location": 35,
            "return": [
                "Tuple[(Union[(float, int, List[int])], Dict[(tuple, Any)])]"
            ],
            "arguments": {
                "refs": [
                    "str",
                    "bool",
                    "float",
                    "int",
                    "Collection[int]"
                ],
                "eff": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "int",
                    "Collection[int]",
                    "typing.Collection"
                ],
                "n": [
                    "int",
                    "List[int]"
                ]
            }
        },
        "cook_test": {
            "name": "cook_test",
            "location": 60,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "test": [
                    "int",
                    "bytearray",
                    "str"
                ],
                "xxx_todo_changeme": [
                    "bool",
                    "list[str]",
                    "int",
                    "tuple[typing.Union[float,float]]",
                    "List[str]",
                    "Union[float, Tuple[float, float]]"
                ],
                "eff": [
                    "bool",
                    "None",
                    "str",
                    "List[str]",
                    "list[str]"
                ],
                "n": [
                    "int",
                    "bool",
                    "Optional[Any]"
                ]
            }
        },
        "BleuScorer.copy": {
            "name": "copy",
            "location": 92,
            "return": [
                "BleuScorer"
            ],
            "arguments": {
                "self": [
                    "_TBleuScorer"
                ]
            }
        },
        "BleuScorer.__init__": {
            "name": "__init__",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "test": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Callable[..., bool]",
                    "typing.Callable[..., bool]"
                ],
                "refs": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Callable[..., bool]",
                    "typing.Callable[..., bool]"
                ],
                "n": [
                    "int",
                    "float"
                ],
                "special_reflen": [
                    "int",
                    "float",
                    "None"
                ]
            }
        },
        "BleuScorer.cook_append": {
            "name": "cook_append",
            "location": 109,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "test": [
                    "str",
                    "Optional[str]",
                    "float",
                    "None"
                ],
                "refs": [
                    "Optional[Dict[str, str]]",
                    "dict[str, str]",
                    "Optional[str]",
                    "None",
                    "Optional[int]",
                    "str",
                    "slice",
                    "int"
                ]
            }
        },
        "BleuScorer.ratio": {
            "name": "ratio",
            "location": 122,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Type",
                    "dict[, ]",
                    "typing.Type",
                    "dict"
                ]
            }
        },
        "BleuScorer.score_ratio": {
            "name": "score_ratio",
            "location": 126,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "None"
                ]
            }
        },
        "BleuScorer.score_ratio_str": {
            "name": "score_ratio_str",
            "location": 130,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "List[str]",
                    "None",
                    "str",
                    "dict",
                    "bool",
                    "list[str]",
                    "dict[, ]"
                ]
            }
        },
        "BleuScorer.reflen": {
            "name": "reflen",
            "location": 133,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Type",
                    "dict[, ]",
                    "typing.Type",
                    "dict"
                ]
            }
        },
        "BleuScorer.testlen": {
            "name": "testlen",
            "location": 137,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Type",
                    "dict[, ]",
                    "typing.Type",
                    "dict"
                ]
            }
        },
        "BleuScorer.retest": {
            "name": "retest",
            "location": 141,
            "return": [
                "BleuScorer"
            ],
            "arguments": {
                "self": [
                    "_TBleuScorer"
                ],
                "new_test": [
                    "list",
                    "str",
                    "list[]",
                    "bool",
                    "BaseException"
                ]
            }
        },
        "BleuScorer.rescore": {
            "name": "rescore",
            "location": 152,
            "return": [
                "Dict[str, Dict[str, int]]",
                "bool",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "new_test": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ]
            }
        },
        "BleuScorer.size": {
            "name": "size",
            "location": 157,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BleuScorer.__iadd__": {
            "name": "__iadd__",
            "location": 161,
            "return": [
                "BleuScorer"
            ],
            "arguments": {
                "self": [
                    "_TBleuScorer"
                ],
                "other": []
            }
        },
        "BleuScorer.compatible": {
            "name": "compatible",
            "location": 175,
            "return": [
                "bool",
                "str",
                "List[int]",
                "bytearray"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[int, float]",
                    "int",
                    "Tuple[int, int, int]",
                    "float",
                    "Any",
                    "tuple[typing.Union[int,int,int]]",
                    "Union[int, str]",
                    "typing.Any",
                    "str"
                ]
            }
        },
        "BleuScorer.single_reflen": {
            "name": "single_reflen",
            "location": 178,
            "return": [
                "str",
                "Optional[str]",
                "Dict[str, int]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "typing.Text",
                    "float",
                    "List[Exception]",
                    "str",
                    "Optional[float]"
                ]
            }
        },
        "BleuScorer._single_reflen": {
            "name": "_single_reflen",
            "location": 181,
            "return": [
                "int",
                "str",
                "Callable",
                "list[str]",
                "list[tuple[typing.Union[typing.Any,typing.Any,typing.Any]]]",
                "list[]",
                "typing.Collection",
                "float"
            ],
            "arguments": {
                "self": [],
                "reflens": [
                    "str",
                    "Sequence[T]",
                    "list",
                    "bytes",
                    "Union[tuple, list]"
                ],
                "option": [
                    "str",
                    "None",
                    "bool",
                    "IO[str]",
                    "int",
                    "typing.IO",
                    "dict",
                    "dict[, ]",
                    "set",
                    "set[]"
                ],
                "testlen": [
                    "bool",
                    "str",
                    "IO[str]",
                    "int",
                    "dict",
                    "set"
                ]
            }
        },
        "BleuScorer.recompute_score": {
            "name": "recompute_score",
            "location": 194,
            "return": [
                "str",
                "List[Dict[str, Any]]",
                "int"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Type",
                    "dict[, ]",
                    "typing.Type",
                    "dict"
                ],
                "verbose": [
                    "int",
                    "Optional[Dict]",
                    "Type",
                    "bool",
                    "dict"
                ]
            }
        },
        "BleuScorer.compute_score": {
            "name": "compute_score",
            "location": 198,
            "return": [
                "str",
                "typing.Literal",
                "List[int]",
                "int",
                "dict[str, typing.Type]",
                "dict[str, str]",
                "set[]",
                "dict[str, int]"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "dict",
                    "None",
                    "Callable[..., T]",
                    "Union[List[str], Tuple[str, ...]]",
                    "dict[, ]",
                    "Set[int]",
                    "typing.Callable[..., T]",
                    "list[str]",
                    "tuple[typing.Union[str,...]]",
                    "set[int]"
                ],
                "verbose": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        }
    },
    "allennlp-dureader-master/utils/bleu_metric/__init__.py": {},
    "allennlp-dureader-master/utils/rouge_metric/rouge.py": {
        "my_lcs": {
            "name": "my_lcs",
            "location": 13,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "string": [
                    "str",
                    "list"
                ],
                "sub": [
                    "str",
                    "int",
                    "Set[str]",
                    "List[str]",
                    "list"
                ]
            }
        },
        "Rouge.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Rouge.calc_score": {
            "name": "calc_score",
            "location": 45,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "candidate": [
                    "bytes"
                ],
                "refs": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "Rouge.compute_score": {
            "name": "compute_score",
            "location": 77,
            "return": [
                "Tuple[(Any, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "gts": [
                    "dict",
                    "bool",
                    "List[Dict[str, Any]]"
                ],
                "res": [
                    "list[str]",
                    "bool",
                    "Sequence[Any]",
                    "List[str]",
                    "Iterable",
                    "int",
                    "Callable"
                ]
            }
        },
        "Rouge.method": {
            "name": "method",
            "location": 104,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "allennlp-dureader-master/utils/rouge_metric/__init__.py": {}
}
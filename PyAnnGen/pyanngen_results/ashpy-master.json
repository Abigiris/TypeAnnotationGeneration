{
    "ashpy-master/conftest.py": {
        "add_common_namespaces": {
            "name": "add_common_namespaces",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "doctest_namespace": [
                    "raiden.utils.WithdrawAmount"
                ]
            }
        },
        "save_dir": {
            "name": "save_dir",
            "location": 51,
            "return": [
                "",
                "typing.Generator[Path]"
            ],
            "arguments": {}
        },
        "fake_training_fn": {
            "name": "fake_training_fn",
            "location": 115,
            "return": [
                "typing.Callable[, ]",
                "float",
                "str"
            ],
            "arguments": {
                "request": []
            }
        }
    },
    "ashpy-master/setup.py": {},
    "ashpy-master/docs/source/conf.py": {},
    "ashpy-master/examples/classifier.py": {
        "main": {
            "name": "main",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "main.process": {
            "name": "process",
            "location": 37,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "images": [
                    "int"
                ],
                "labels": [
                    "Iterable[str]",
                    "str"
                ]
            }
        }
    },
    "ashpy-master/examples/unet.py": {
        "main": {
            "name": "main",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "ashpy-master/examples/gans/bigan.py": {
        "main": {
            "name": "main",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "main.real_gen": {
            "name": "real_gen",
            "location": 30,
            "return": [
                "",
                "typing.Generator[tuple[typing.Union[tuple[float],tuple[int]]]]"
            ],
            "arguments": {}
        }
    },
    "ashpy-master/examples/gans/mnist.py": {
        "main": {
            "name": "main",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "main.iterator": {
            "name": "iterator",
            "location": 94,
            "return": [
                "",
                "typing.Generator[tuple[]]"
            ],
            "arguments": {}
        }
    },
    "ashpy-master/examples/gans/pix2pix_facades.py": {
        "load": {
            "name": "load",
            "location": 45,
            "return": [
                "tuple[]",
                "str",
                "int",
                "Optional[List[str]]"
            ],
            "arguments": {
                "image_file": [
                    "typing.TextIO",
                    "TextIO",
                    "typing.BinaryIO",
                    "BinaryIO",
                    "pathlib.Path"
                ]
            }
        },
        "resize": {
            "name": "resize",
            "location": 62,
            "return": [
                "tuple[typing.Union[int,str,typing.Pattern,list[]]]",
                "str",
                "int"
            ],
            "arguments": {
                "input_image": [
                    "int"
                ],
                "real_image": [
                    "int"
                ],
                "height": [
                    "int",
                    "bool"
                ],
                "width": [
                    "int",
                    "bool"
                ]
            }
        },
        "random_crop": {
            "name": "random_crop",
            "location": 74,
            "return": [
                "tuple[str]",
                "str",
                "int"
            ],
            "arguments": {
                "input_image": [
                    "int"
                ],
                "real_image": [
                    "int"
                ]
            }
        },
        "normalize": {
            "name": "normalize",
            "location": 84,
            "return": [
                "tuple[typing.Union[float,int]]",
                "str",
                "int"
            ],
            "arguments": {
                "input_image": [],
                "real_image": []
            }
        },
        "load_image_train": {
            "name": "load_image_train",
            "location": 92,
            "return": [
                "tuple[typing.Union[str,dict[, ],tuple[typing.Literal],dict[str, typing.Union[typing.Any,typing.Any]]]]",
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "image_file": [
                    "str",
                    "int",
                    "pathlib.Path",
                    "bool"
                ]
            }
        },
        "random_jitter": {
            "name": "random_jitter",
            "location": 102,
            "return": [
                "tuple[typing.Mapping]",
                "str",
                "int"
            ],
            "arguments": {
                "input_image": [
                    "int"
                ],
                "real_image": [
                    "int"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 118,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "kernel_size": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "learning_rate_d": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "learning_rate_g": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ],
                "g_input_res": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "g_min_res": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "g_initial_filters": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "g_filters_cap": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "use_dropout_encoder": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "use_dropout_decoder": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "d_target_res": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "d_initial_filters": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "d_filters_cap": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "use_dropout_discriminator": [
                    "bool",
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "dataset_name": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "resolution": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "epochs": [
                    "int",
                    "str",
                    "bool",
                    "float"
                ],
                "dropout_prob": [
                    "float",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "l1_loss_weight": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "gan_loss_weight": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "use_attention_d": [
                    "bool",
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "use_attention_g": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "channels": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "gan_loss_type": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        }
    },
    "ashpy-master/examples/gans/pix2pix_facades_multi_gpu.py": {
        "main": {
            "name": "main",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "kernel_size": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "learning_rate_d": [
                    "float",
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "learning_rate_g": [
                    "float",
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "g_input_res": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "g_min_res": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "g_initial_filters": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "g_filters_cap": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "use_dropout_encoder": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "use_dropout_decoder": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "d_target_res": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "d_initial_filters": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "d_filters_cap": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "use_dropout_discriminator": [
                    "bool",
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "dataset_name": [
                    "typing.Text",
                    "str",
                    "List[str]",
                    "Set[str]",
                    "List[Tuple[str, str]]",
                    "Tuple[str, Any, Any]",
                    "Tuple[str]"
                ],
                "resolution": [
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "epochs": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "dropout_prob": [
                    "float",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "l1_loss_weight": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "gan_loss_weight": [
                    "int",
                    "str",
                    "List[int]",
                    "bool"
                ],
                "use_attention_d": [
                    "bool",
                    "int",
                    "List[str]",
                    "List[float]",
                    "float"
                ],
                "use_attention_g": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "channels": [
                    "int",
                    "List[str]",
                    "Optional[int]"
                ],
                "gan_loss_type": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/ashtypes.py": {},
    "ashpy-master/src/ashpy/modes.py": {},
    "ashpy-master/src/ashpy/__init__.py": {},
    "ashpy-master/src/ashpy/callbacks/callback.py": {
        "Callback.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": []
            }
        },
        "Callback.name": {
            "name": "name",
            "location": 68,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Callback.on_event": {
            "name": "on_event",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [],
                "context": []
            }
        },
        "Callback.on_train_start": {
            "name": "on_train_start",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Callback.on_train_end": {
            "name": "on_train_end",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Callback.on_epoch_start": {
            "name": "on_epoch_start",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Callback.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Callback.on_batch_start": {
            "name": "on_batch_start",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Callback.on_batch_end": {
            "name": "on_batch_end",
            "location": 144,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Callback.on_exception": {
            "name": "on_exception",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        }
    },
    "ashpy-master/src/ashpy/callbacks/classifier.py": {
        "LogClassifierCallback.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "dict",
                    "bool",
                    "int"
                ],
                "name": [
                    "typing.Text",
                    "dict",
                    "bool",
                    "int"
                ],
                "event_freq": [
                    "int",
                    "dict",
                    "bool"
                ]
            }
        },
        "LogClassifierCallback._log_fn": {
            "name": "_log_fn",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "context": [
                    "Type[BaseException]",
                    "typing.Type",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/callbacks/counter_callback.py": {
        "CounterCallback.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "List[str]",
                    "bool",
                    "list[str]",
                    "str",
                    "list",
                    "list[]"
                ],
                "fn": [
                    "bool",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "dict",
                    "None",
                    "list",
                    "list[]"
                ],
                "name": [
                    "str",
                    "bool",
                    "Optional[Union[int, Any]]",
                    "typing.Any",
                    "None"
                ],
                "event_freq": [
                    "int",
                    "bool",
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "CounterCallback.on_event": {
            "name": "on_event",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "str",
                    "threading.Event",
                    "Event",
                    "events.Event",
                    "raiden_libs.events.Event",
                    "edp.journal.Event"
                ],
                "context": [
                    "float",
                    "bool",
                    "threading.Event",
                    "dict[str, typing.Any]",
                    "\"Step\"",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/callbacks/events.py": {},
    "ashpy-master/src/ashpy/callbacks/gan.py": {
        "LogImageGANCallback.__init__": {
            "name": "__init__",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "int",
                    "ashpy.callbacks.events.Event",
                    "str",
                    "List[List[int]]"
                ],
                "name": [
                    "typing.Text",
                    "int",
                    "ashpy.callbacks.events.Event",
                    "str",
                    "List[List[int]]"
                ],
                "event_freq": [
                    "int",
                    "ashpy.callbacks.events.Event",
                    "str",
                    "List[List[int]]"
                ]
            }
        },
        "LogImageGANCallback._log_fn": {
            "name": "_log_fn",
            "location": 139,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "str",
                    "ashpy.contexts.GANContext",
                    "typing.Callable[, ]",
                    "bool",
                    "ashpy.contexts.GANEncoderContext",
                    "Callable",
                    "tensorflow.Variable"
                ]
            }
        },
        "LogImageGANEncoderCallback.__init__": {
            "name": "__init__",
            "location": 250,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "int",
                    "str",
                    "ashpy.callbacks.events.Event",
                    "bool"
                ],
                "name": [
                    "typing.Text",
                    "int",
                    "str",
                    "ashpy.callbacks.events.Event",
                    "bool"
                ],
                "event_freq": [
                    "int",
                    "str",
                    "ashpy.callbacks.events.Event",
                    "bool"
                ]
            }
        },
        "LogImageGANEncoderCallback._log_fn": {
            "name": "_log_fn",
            "location": 269,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "str",
                    "ashpy.contexts.GANEncoderContext",
                    "typing.Callable[, ]",
                    "BaseException",
                    "ashpy.contexts.GANContext",
                    "Callable"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/callbacks/save_callback.py": {
        "SaveFormat.name": {
            "name": "name",
            "location": 41,
            "return": [
                "typing.Text",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SaveFormat._initialize_dirs": {
            "name": "_initialize_dirs",
            "location": 50,
            "return": [
                "str",
                "pathlib.Path",
                "path.Path",
                "List[str]"
            ],
            "arguments": {
                "save_dir": [
                    "str",
                    "pathlib.Path",
                    "Union[pathlib.Path, str]"
                ],
                "save_format": [
                    "str",
                    "pathlib.Path",
                    "Union[pathlib.Path, str]"
                ],
                "save_sub_format": [
                    "str",
                    "bool"
                ]
            }
        },
        "SaveFormat.save": {
            "name": "save",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "tensorflow.keras.models.Model",
                    "None",
                    "Optional[str]",
                    "pathlib.Path"
                ],
                "save_dir": [
                    "str",
                    "bool",
                    "pathlib.Path",
                    "Union[pathlib.Path, str]"
                ],
                "save_sub_format": [
                    "str",
                    "pathlib.Path",
                    "bool",
                    "Union[pathlib.Path, str]"
                ]
            }
        },
        "SaveCallback.__init__": {
            "name": "__init__",
            "location": 144,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "save_dir": [
                    "dict[, ]",
                    "dict",
                    "int",
                    "str",
                    "pathlib.Path",
                    "None",
                    "Optional[str]"
                ],
                "models": [
                    "str",
                    "dict[str, typing.Any]",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict",
                    "int",
                    "Optional[int]",
                    "bool"
                ],
                "event": [
                    "edp.journal.Event",
                    "Optional[dict]",
                    "Dict[str, str]",
                    "Optional[Dict[str, Any]]"
                ],
                "event_freq": [
                    "int",
                    "edp.journal.Event",
                    "Optional[dict]",
                    "Dict[str, str]",
                    "Optional[Dict[str, Any]]"
                ],
                "max_to_keep": [
                    "int",
                    "bool"
                ],
                "save_format": [
                    "bool",
                    "Dict[str, Any]",
                    "tkinter.Event",
                    "int",
                    "str"
                ],
                "save_sub_format": [
                    "Dict[str, Any]",
                    "dict",
                    "List[aw_core.Event]"
                ],
                "verbose": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "Optional[int]",
                    "bool"
                ],
                "name": [
                    "typing.Text",
                    "edp.journal.Event",
                    "Optional[dict]",
                    "Dict[str, str]",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "SaveCallback._check_compatibility": {
            "name": "_check_compatibility",
            "location": 201,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SaveCallback._cleanup": {
            "name": "_cleanup",
            "location": 221,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SaveCallback._save_weights_fn": {
            "name": "_save_weights_fn",
            "location": 238,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "step": [
                    "str",
                    "int",
                    "float",
                    "typing.IO",
                    "Union[str, IO[bytes]]",
                    "pypi2nix.path.Path"
                ]
            }
        },
        "SaveCallback.save_weights_fn": {
            "name": "save_weights_fn",
            "location": 272,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "int",
                    "dict",
                    "str",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/callbacks/__init__.py": {},
    "ashpy-master/src/ashpy/contexts/classifier.py": {
        "ClassifierContext.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "classifier_model": [
                    "Optional[Any]",
                    "None",
                    "Union[float, Tuple[float, float]]",
                    "bool",
                    "typing.Any",
                    "float",
                    "tuple[typing.Union[float,float]]"
                ],
                "loss": [
                    "Optional[Any]",
                    "None",
                    "Union[float, Tuple[float, float]]",
                    "bool",
                    "typing.Any",
                    "float",
                    "tuple[typing.Union[float,float]]"
                ],
                "dataset": [
                    "None",
                    "tuple[ashpy.metrics.Metric]",
                    "tensorflow.Variable",
                    "bool",
                    "str",
                    "tensorflow.train.Checkpoint",
                    "Tuple[ashpy.metrics.Metric]",
                    "ashpy.modes.LogEvalMode",
                    "tensorflow.data.Dataset",
                    "int",
                    "Optional[str]"
                ],
                "metrics": [
                    "None",
                    "tuple[ashpy.metrics.Metric]",
                    "tensorflow.Variable",
                    "bool",
                    "str",
                    "tensorflow.train.Checkpoint",
                    "Tuple[ashpy.metrics.Metric]",
                    "ashpy.modes.LogEvalMode",
                    "tensorflow.data.Dataset",
                    "int",
                    "Optional[str]"
                ],
                "log_eval_mode": [
                    "tensorflow.Variable",
                    "tensorflow.train.Checkpoint",
                    "Tuple[ashpy.metrics.Metric]",
                    "ashpy.modes.LogEvalMode",
                    "tensorflow.data.Dataset",
                    "bool",
                    "int",
                    "Optional[str]",
                    "str"
                ],
                "global_step": [
                    "tensorflow.Variable",
                    "tensorflow.train.Checkpoint",
                    "Tuple[ashpy.metrics.Metric]",
                    "ashpy.modes.LogEvalMode",
                    "tensorflow.data.Dataset",
                    "bool",
                    "int",
                    "Optional[str]",
                    "str"
                ],
                "checkpoint": [
                    "None",
                    "tuple[ashpy.metrics.Metric]",
                    "tensorflow.Variable",
                    "bool",
                    "str",
                    "tensorflow.train.Checkpoint",
                    "Tuple[ashpy.metrics.Metric]",
                    "ashpy.modes.LogEvalMode",
                    "tensorflow.data.Dataset",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "ClassifierContext.loss": {
            "name": "loss",
            "location": 73,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ClassifierContext.classifier_model": {
            "name": "classifier_model",
            "location": 78,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ClassifierContext.validation_set": {
            "name": "validation_set",
            "location": 100,
            "return": [
                "None",
                "set[str]",
                "float",
                "dict[, ]",
                "str"
            ],
            "arguments": {
                "self": [],
                "_validation_set": [
                    "tensorflow.data.Dataset",
                    "List[str]",
                    "float"
                ]
            }
        },
        "ClassifierContext.training_set": {
            "name": "training_set",
            "location": 122,
            "return": [
                "None",
                "set[str]",
                "float",
                "dict[, ]",
                "str"
            ],
            "arguments": {
                "self": [],
                "_training_set": [
                    "tensorflow.data.Dataset",
                    "List[str]",
                    "float"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/contexts/context.py": {
        "Context.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metrics": [
                    "bool",
                    "None",
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "dataset": [
                    "bool",
                    "None",
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "log_eval_mode": [
                    "int",
                    "bool",
                    "Optional[str]",
                    "Dict[str, str]"
                ],
                "global_step": [
                    "bool",
                    "int",
                    "List[str]"
                ],
                "checkpoint": [
                    "bool",
                    "None",
                    "int",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "Context.log_eval_mode": {
            "name": "log_eval_mode",
            "location": 67,
            "return": [
                "str",
                "Sequence",
                "Optional[Dict]",
                "Optional[Any]",
                "Tuple[int, int]",
                "tuple",
                "Union[str, Dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Context.dataset": {
            "name": "dataset",
            "location": 89,
            "return": [
                "",
                "str",
                "dict[str, typing.Any]",
                "dict[, ]",
                "int"
            ],
            "arguments": {
                "self": [],
                "_dataset": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Context.metrics": {
            "name": "metrics",
            "location": 100,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Context.global_step": {
            "name": "global_step",
            "location": 111,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Context.exception": {
            "name": "exception",
            "location": 127,
            "return": [
                "None",
                "OSError",
                "float",
                "bool",
                "typing.Final",
                "dict[, ]",
                "str"
            ],
            "arguments": {
                "self": [],
                "exception": [
                    "int",
                    "List[Exception]",
                    "float"
                ]
            }
        },
        "Context.current_batch": {
            "name": "current_batch",
            "location": 137,
            "return": [
                "None",
                "typing.Pattern",
                "str"
            ],
            "arguments": {
                "self": [],
                "_current_batch": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/contexts/gan.py": {
        "GANContext.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "bool",
                    "None",
                    "str",
                    "int"
                ],
                "generator_model": [
                    "str",
                    "None",
                    "bool",
                    "Callable",
                    "typing.Callable[, ]",
                    "int"
                ],
                "discriminator_model": [
                    "str",
                    "None",
                    "bool",
                    "Callable",
                    "typing.Callable[, ]",
                    "int"
                ],
                "generator_loss": [
                    "str",
                    "None",
                    "bool",
                    "Callable",
                    "typing.Callable[, ]",
                    "int"
                ],
                "discriminator_loss": [
                    "str",
                    "None",
                    "bool",
                    "Callable",
                    "typing.Callable[, ]",
                    "int"
                ],
                "metrics": [
                    "bool",
                    "None",
                    "str",
                    "int"
                ],
                "log_eval_mode": [
                    "bool",
                    "str",
                    "int"
                ],
                "global_step": [
                    "bool",
                    "str",
                    "int"
                ],
                "checkpoint": [
                    "bool",
                    "None",
                    "str",
                    "int"
                ]
            }
        },
        "GANContext.generator_model": {
            "name": "generator_model",
            "location": 79,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GANContext.discriminator_model": {
            "name": "discriminator_model",
            "location": 90,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GANContext.generator_loss": {
            "name": "generator_loss",
            "location": 101,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GANContext.discriminator_loss": {
            "name": "discriminator_loss",
            "location": 106,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GANContext.fake_samples": {
            "name": "fake_samples",
            "location": 116,
            "return": [
                "",
                "str",
                "dict[str, typing.Any]",
                "dict[, ]",
                "int"
            ],
            "arguments": {
                "self": [],
                "_fake_samples": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "GANContext.generator_inputs": {
            "name": "generator_inputs",
            "location": 126,
            "return": [
                "",
                "str",
                "dict[str, typing.Any]",
                "dict[, ]",
                "int"
            ],
            "arguments": {
                "self": [],
                "_generator_inputs": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "GANEncoderContext.__init__": {
            "name": "__init__",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "str",
                    "None",
                    "Optional[str]"
                ],
                "generator_model": [
                    "str",
                    "None",
                    "Optional[str]"
                ],
                "discriminator_model": [
                    "str",
                    "None",
                    "Optional[str]"
                ],
                "encoder_model": [
                    "bool",
                    "None",
                    "str",
                    "int",
                    "tuple",
                    "tuple[]"
                ],
                "generator_loss": [
                    "str",
                    "None",
                    "Optional[str]"
                ],
                "discriminator_loss": [
                    "str",
                    "None",
                    "Optional[str]"
                ],
                "encoder_loss": [
                    "bool",
                    "None",
                    "str",
                    "int",
                    "tuple",
                    "tuple[]"
                ],
                "metrics": [
                    "str",
                    "None",
                    "Optional[str]"
                ],
                "log_eval_mode": [
                    "str",
                    "Optional[str]"
                ],
                "global_step": [
                    "str",
                    "Optional[str]"
                ],
                "checkpoint": [
                    "str",
                    "None",
                    "Optional[str]"
                ]
            }
        },
        "GANEncoderContext.encoder_model": {
            "name": "encoder_model",
            "location": 190,
            "return": [
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "GANEncoderContext.encoder_loss": {
            "name": "encoder_loss",
            "location": 201,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GANEncoderContext.generator_of_encoder": {
            "name": "generator_of_encoder",
            "location": 211,
            "return": [
                "",
                "str",
                "int",
                "set[int]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "_generator_of_encoder": [
                    "int",
                    "bool",
                    "Optional[Callable]",
                    "Union[str, List[str]]"
                ]
            }
        },
        "GANEncoderContext.encoder_inputs": {
            "name": "encoder_inputs",
            "location": 221,
            "return": [
                "",
                "str",
                "dict[str, typing.Any]",
                "dict[, ]",
                "int"
            ],
            "arguments": {
                "self": [],
                "_encoder_inputs": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/contexts/__init__.py": {},
    "ashpy-master/src/ashpy/datasets/__init__.py": {
        "wrap": {
            "name": "wrap",
            "location": 18,
            "return": [
                "int",
                "str",
                "Callable",
                "typing.Callable[, ]"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/keras/losses.py": {
        "L1.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "L1.reduction": {
            "name": "reduction",
            "location": 34,
            "return": [
                "None",
                "int",
                "str",
                "set[str]",
                "dict[str, list[str]]",
                "float"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "List[float]",
                    "T",
                    "Union[bool, Any]",
                    "float"
                ]
            }
        },
        "L1.call": {
            "name": "call",
            "location": 44,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int",
                    "tensorflow.Tensor"
                ],
                "y": [
                    "float",
                    "int",
                    "tensorflow.Tensor"
                ]
            }
        },
        "DMinMax.__init__": {
            "name": "__init__",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "from_logits": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ]
            }
        },
        "DMinMax.reduction": {
            "name": "reduction",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "dict",
                    "bool",
                    "T"
                ]
            }
        },
        "DMinMax.call": {
            "name": "call",
            "location": 96,
            "return": [
                "float",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "d_real": [
                    "typing.TextIO",
                    "int",
                    "TextIO",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]",
                    "bool"
                ],
                "d_fake": [
                    "typing.TextIO",
                    "int",
                    "TextIO",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]",
                    "bool"
                ]
            }
        },
        "DLeastSquare.__init__": {
            "name": "__init__",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DLeastSquare.reduction": {
            "name": "reduction",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "dict",
                    "bool",
                    "T"
                ]
            }
        },
        "DLeastSquare.call": {
            "name": "call",
            "location": 170,
            "return": [
                "float",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "d_real": [
                    "typing.TextIO",
                    "int",
                    "TextIO",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]",
                    "bool"
                ],
                "d_fake": [
                    "typing.TextIO",
                    "int",
                    "TextIO",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]",
                    "bool"
                ]
            }
        },
        "DHingeLoss.__init__": {
            "name": "__init__",
            "location": 213,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DHingeLoss.reduction": {
            "name": "reduction",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "int",
                    "bool",
                    "T",
                    "bytes"
                ]
            }
        },
        "DHingeLoss.call": {
            "name": "call",
            "location": 240,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "d_real": [
                    "typing.TextIO",
                    "int",
                    "TextIO",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]",
                    "bool"
                ],
                "d_fake": [
                    "typing.TextIO",
                    "int",
                    "TextIO",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]",
                    "bool"
                ]
            }
        },
        "GHingeLoss.__init__": {
            "name": "__init__",
            "location": 282,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GHingeLoss.reduction": {
            "name": "reduction",
            "location": 293,
            "return": [
                "None",
                "int",
                "str",
                "set[str]",
                "dict[str, list[str]]",
                "float"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "List[float]",
                    "T",
                    "Union[bool, Any]",
                    "float"
                ]
            }
        },
        "GHingeLoss.call": {
            "name": "call",
            "location": 303,
            "return": [
                "int",
                "dict",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "d_real": [
                    "typing.Callable[, ]",
                    "tensorflow.Tensor",
                    "int",
                    "dict[str, typing.Any]",
                    "Callable",
                    "Dict[str, Any]",
                    "list[tensorflow.Tensor]",
                    "List[tensorflow.Tensor]"
                ],
                "d_fake": [
                    "int",
                    "tensorflow.Tensor",
                    "Callable",
                    "Dict[str, Any]",
                    "List[tensorflow.Tensor]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/keras/__init__.py": {},
    "ashpy-master/src/ashpy/layers/attention.py": {
        "Attention.__init__": {
            "name": "__init__",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "int"
                ]
            }
        },
        "Attention.call": {
            "name": "call",
            "location": 121,
            "return": [
                "str",
                "Union[bool, List[bool]]",
                "bool",
                "Set[int]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "int",
                    "FrozenSet[int]",
                    "float",
                    "frozenset"
                ],
                "training": [
                    "bool"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/layers/instance_normalization.py": {
        "InstanceNormalization.__init__": {
            "name": "__init__",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "eps": [
                    "float"
                ],
                "beta_initializer": [
                    "str"
                ],
                "gamma_initializer": [
                    "str"
                ]
            }
        },
        "InstanceNormalization.build": {
            "name": "build",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_shape": [
                    "Tuple[int]"
                ]
            }
        },
        "InstanceNormalization.call": {
            "name": "call",
            "location": 112,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "float",
                    "tensorflow.Tensor"
                ],
                "training": [
                    "bool"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/layers/__init__.py": {},
    "ashpy-master/src/ashpy/losses/classifier.py": {
        "ClassifierLoss.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "bool",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Callable[[Any, Any], bool]",
                    "typing.Callable[Any,Any, bool]"
                ]
            }
        },
        "ClassifierLoss.call": {
            "name": "call",
            "location": 42,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "int",
                    "bytes",
                    "Optional[str]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/losses/executor.py": {
        "Executor.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "None",
                    "Optional[bool]",
                    "bool",
                    "str",
                    "Optional[float]",
                    "float",
                    "tensorflow.keras.losses.Loss"
                ]
            }
        },
        "Executor.weight": {
            "name": "weight",
            "location": 53,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Executor.fn": {
            "name": "fn",
            "location": 67,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Executor.reduce_loss": {
            "name": "reduce_loss",
            "location": 78,
            "return": [
                "Callable"
            ],
            "arguments": {
                "call_fn": [
                    "Callable"
                ]
            }
        },
        "Executor.global_batch_size": {
            "name": "global_batch_size",
            "location": 115,
            "return": [
                "None",
                "int",
                "dict[str, int]"
            ],
            "arguments": {
                "self": [],
                "global_batch_size": [
                    "int",
                    "float",
                    "Optional[int]"
                ]
            }
        },
        "Executor.call": {
            "name": "call",
            "location": 131,
            "return": [
                "tensorflow.Tensor",
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "Executor.__call__": {
            "name": "__call__",
            "location": 144,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "str"
                ]
            }
        },
        "Executor.__add__": {
            "name": "__add__",
            "location": 158,
            "return": [
                "SumExecutor"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "float",
                    "SupportsInt"
                ]
            }
        },
        "Executor.__mul__": {
            "name": "__mul__",
            "location": 168,
            "return": [
                "Executor"
            ],
            "arguments": {
                "self": [
                    "_TExecutor"
                ],
                "other": [
                    "str",
                    "int",
                    "T"
                ]
            }
        },
        "Executor.__rmul__": {
            "name": "__rmul__",
            "location": 188,
            "return": [
                "Executor"
            ],
            "arguments": {
                "self": [
                    "_TExecutor"
                ],
                "other": [
                    "float",
                    "int",
                    "List[str]",
                    "str"
                ]
            }
        },
        "SumExecutor.__init__": {
            "name": "__init__",
            "location": 201,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "executors": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "SumExecutor.executors": {
            "name": "executors",
            "location": 218,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SumExecutor.global_batch_size": {
            "name": "global_batch_size",
            "location": 223,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "global_batch_size": [
                    "int",
                    "float",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "Iterable[int]"
                ]
            }
        },
        "SumExecutor.call": {
            "name": "call",
            "location": 230,
            "return": [
                "bool",
                "Dict[str, Any]",
                "float",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SumExecutor.__add__": {
            "name": "__add__",
            "location": 241,
            "return": [
                "SumExecutor"
            ],
            "arguments": {
                "self": [
                    "_TSumExecutor"
                ],
                "other": [
                    "Union[(Executor, _TSumExecutor)]"
                ]
            }
        },
        "Executor.reduce_loss._reduce": {
            "name": "_reduce",
            "location": 93,
            "return": [
                "Optional[int]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/src/ashpy/losses/gan.py": {
        "get_adversarial_loss_discriminator": {
            "name": "get_adversarial_loss_discriminator",
            "location": 652,
            "return": [
                "DiscriminatorMinMax",
                "DiscriminatorLSGAN",
                "DiscriminatorHingeLoss"
            ],
            "arguments": {
                "adversarial_loss_type": []
            }
        },
        "get_adversarial_loss_generator": {
            "name": "get_adversarial_loss_generator",
            "location": 678,
            "return": [
                "GeneratorBCE",
                "GeneratorLSGAN",
                "GeneratorHingeLoss"
            ],
            "arguments": {
                "adversarial_loss_type": []
            }
        },
        "GANExecutor.call": {
            "name": "call",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "str",
                    "bool"
                ]
            }
        },
        "GANExecutor.get_discriminator_inputs": {
            "name": "get_discriminator_inputs",
            "location": 62,
            "return": [
                "bool",
                "dict[str, typing.Any]",
                "list[typing.Union[bool,dict[str, typing.Any],str,dict[, ]]]"
            ],
            "arguments": {
                "context": [],
                "fake_or_real": [
                    "bool",
                    "dict[str, typing.Any]"
                ],
                "condition": [
                    "str",
                    "dict[, ]",
                    "bool"
                ],
                "training": [
                    "bool",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "GeneratorAdversarialLoss.__init__": {
            "name": "__init__",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "loss_fn": [
                    "None",
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ]
            }
        },
        "GeneratorAdversarialLoss.call": {
            "name": "call",
            "location": 129,
            "return": [],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "GeneratorBCE.__init__": {
            "name": "__init__",
            "location": 188,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "from_logits": [
                    "bool"
                ]
            }
        },
        "GeneratorLSGAN.__init__": {
            "name": "__init__",
            "location": 209,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneratorL1.__init__": {
            "name": "__init__",
            "location": 226,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneratorL1.call": {
            "name": "call",
            "location": 231,
            "return": [
                "typing.Type",
                "str",
                "float",
                "tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]]"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "dict[, ]"
                ]
            }
        },
        "GeneratorHingeLoss.__init__": {
            "name": "__init__",
            "location": 257,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FeatureMatchingLoss.__init__": {
            "name": "__init__",
            "location": 291,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FeatureMatchingLoss.call": {
            "name": "call",
            "location": 296,
            "return": [],
            "arguments": {
                "self": [],
                "context": [
                    "typing.Any",
                    "int"
                ]
            }
        },
        "CategoricalCrossEntropy.__init__": {
            "name": "__init__",
            "location": 356,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalCrossEntropy.call": {
            "name": "call",
            "location": 362,
            "return": [
                "dict[str, typing.Any]",
                "list[int]",
                "dict[str, str]",
                "dict[str, int]",
                "dict[, ]",
                "str"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "dict[, ]"
                ]
            }
        },
        "Pix2PixLoss.__init__": {
            "name": "__init__",
            "location": 396,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "l1_loss_weight": [
                    "float"
                ],
                "adversarial_loss_weight": [
                    "float"
                ],
                "feature_matching_weight": [
                    "float"
                ],
                "adversarial_loss_type": [],
                "use_feature_matching_loss": [
                    "bool"
                ]
            }
        },
        "Pix2PixLossSemantic.__init__": {
            "name": "__init__",
            "location": 447,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cross_entropy_weight": [
                    "float"
                ],
                "adversarial_loss_weight": [
                    "float"
                ],
                "feature_matching_weight": [
                    "float"
                ],
                "adversarial_loss_type": [],
                "use_feature_matching_loss": [
                    "bool"
                ]
            }
        },
        "EncoderBCE.__init__": {
            "name": "__init__",
            "location": 489,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "from_logits": [
                    "bool"
                ]
            }
        },
        "EncoderBCE.call": {
            "name": "call",
            "location": 494,
            "return": [],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "DiscriminatorAdversarialLoss.__init__": {
            "name": "__init__",
            "location": 518,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "loss_fn": [
                    "None",
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ]
            }
        },
        "DiscriminatorAdversarialLoss.call": {
            "name": "call",
            "location": 530,
            "return": [],
            "arguments": {
                "self": [],
                "context": [
                    "typing.Any",
                    "int"
                ]
            }
        },
        "DiscriminatorMinMax.__init__": {
            "name": "__init__",
            "location": 591,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "from_logits": [
                    "bool"
                ],
                "label_smoothing": [
                    "float"
                ]
            }
        },
        "DiscriminatorLSGAN.__init__": {
            "name": "__init__",
            "location": 626,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DiscriminatorHingeLoss.__init__": {
            "name": "__init__",
            "location": 641,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/src/ashpy/losses/__init__.py": {},
    "ashpy-master/src/ashpy/metrics/classifier.py": {
        "ClassifierLoss.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text",
                    "Union[pathlib.Path, str]",
                    "Callable",
                    "str"
                ],
                "model_selection_operator": [
                    "Union[pathlib.Path, str]",
                    "None",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "logdir": [
                    "str",
                    "Union[pathlib.Path, str]",
                    "typing.Callable[, ]",
                    "Callable"
                ]
            }
        },
        "ClassifierLoss.update_state": {
            "name": "update_state",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "ClassifierMetric.__init__": {
            "name": "__init__",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metric": [
                    "tensorflow.keras.metrics.Metric",
                    "str",
                    "Union[pathlib.Path, str]",
                    "typing.Callable[, ]",
                    "Callable",
                    "list[str]",
                    "Union[str, List[str], Tuple[str, ...]]",
                    "tuple[typing.Union[str,...]]",
                    "Union[int, List]",
                    "int",
                    "list[]"
                ],
                "model_selection_operator": [
                    "tensorflow.keras.metrics.Metric",
                    "None",
                    "Union[pathlib.Path, str]",
                    "str",
                    "Callable",
                    "Union[str, List[str], Tuple[str, ...]]",
                    "typing.Callable[, ]",
                    "Union[int, List]",
                    "list[str]",
                    "tuple[typing.Union[str,...]]",
                    "int",
                    "list[]"
                ],
                "logdir": [
                    "tensorflow.keras.metrics.Metric",
                    "str",
                    "Union[pathlib.Path, str]",
                    "typing.Callable[, ]",
                    "Callable",
                    "list[str]",
                    "Union[str, List[str], Tuple[str, ...]]",
                    "tuple[typing.Union[str,...]]",
                    "Union[int, List]",
                    "int",
                    "list[]"
                ],
                "processing_predictions": [
                    "Optional[str]",
                    "None",
                    "int",
                    "Optional[float]",
                    "str",
                    "float",
                    "Optional[int]"
                ]
            }
        },
        "ClassifierMetric.update_state": {
            "name": "update_state",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "bool",
                    "str",
                    "tensorflow.Tensor"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/metrics/gan.py": {
        "DiscriminatorLoss.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text"
                ],
                "model_selection_operator": [
                    "None",
                    "str",
                    "typing.Callable[, ]"
                ],
                "logdir": [
                    "str",
                    "typing.Callable[, ]"
                ]
            }
        },
        "DiscriminatorLoss.update_state": {
            "name": "update_state",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "GeneratorLoss.__init__": {
            "name": "__init__",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text"
                ],
                "model_selection_operator": [
                    "None",
                    "str",
                    "typing.Callable[, ]"
                ],
                "logdir": [
                    "str",
                    "typing.Callable[, ]"
                ]
            }
        },
        "GeneratorLoss.update_state": {
            "name": "update_state",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "EncoderLoss.__init__": {
            "name": "__init__",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text"
                ],
                "model_selection_operator": [
                    "None",
                    "str",
                    "typing.Callable[, ]"
                ],
                "logdir": [
                    "str",
                    "typing.Callable[, ]"
                ]
            }
        },
        "EncoderLoss.update_state": {
            "name": "update_state",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "InceptionScore.__init__": {
            "name": "__init__",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inception": [
                    "str",
                    "bool"
                ],
                "name": [
                    "typing.Text"
                ],
                "model_selection_operator": [],
                "logdir": [
                    "str",
                    "typing.Callable[, ]"
                ]
            }
        },
        "InceptionScore.update_state": {
            "name": "update_state",
            "location": 288,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "InceptionScore.inception_score": {
            "name": "inception_score",
            "location": 332,
            "return": [
                "int",
                "dict[, ]",
                "list[int]",
                "list[list[int]]",
                "str"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "int",
                    "float"
                ]
            }
        },
        "InceptionScore.get_or_train_inception": {
            "name": "get_or_train_inception",
            "location": 357,
            "return": [],
            "arguments": {
                "dataset": [
                    "int",
                    "str"
                ],
                "name": [
                    "str",
                    "dict[str, typing.Any]",
                    "dict[, ]"
                ],
                "num_classes": [
                    "str",
                    "list[typing.Any]",
                    "None"
                ],
                "epochs": [
                    "int",
                    "str"
                ],
                "fine_tuning": [
                    "bool"
                ],
                "loss_fn": [
                    "str",
                    "typing.Type"
                ],
                "optimizer": [
                    "str",
                    "typing.Type"
                ],
                "logdir": [
                    "bool"
                ]
            }
        },
        "EncodingAccuracy.__init__": {
            "name": "__init__",
            "location": 435,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "classifier": [
                    "str",
                    "bool"
                ],
                "name": [
                    "typing.Text"
                ],
                "model_selection_operator": [
                    "None",
                    "str",
                    "typing.Callable[, ]"
                ],
                "logdir": [
                    "str",
                    "typing.Callable[, ]",
                    "None"
                ]
            }
        },
        "EncodingAccuracy.update_state": {
            "name": "update_state",
            "location": 472,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "str",
                    "None",
                    "typing.Callable[str, None]"
                ]
            }
        },
        "EncodingAccuracy.update_state._gen": {
            "name": "_gen",
            "location": 486,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "real_xy": [],
                "_": []
            }
        }
    },
    "ashpy-master/src/ashpy/metrics/metric.py": {
        "Metric.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [],
                "metric": [],
                "model_selection_operator": [
                    "None"
                ],
                "logdir": []
            }
        },
        "Metric.model_selection": {
            "name": "model_selection",
            "location": 74,
            "return": [
                "Path",
                "None"
            ],
            "arguments": {
                "self": [],
                "checkpoint": [],
                "global_step": []
            }
        },
        "Metric._update_logdir": {
            "name": "_update_logdir",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Metric.name": {
            "name": "name",
            "location": 127,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.sanitized_name": {
            "name": "sanitized_name",
            "location": 132,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.metric": {
            "name": "metric",
            "location": 142,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.model_selection_operator": {
            "name": "model_selection_operator",
            "location": 147,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.logdir": {
            "name": "logdir",
            "location": 157,
            "return": [],
            "arguments": {
                "self": [],
                "logdir": []
            }
        },
        "Metric.best_folder": {
            "name": "best_folder",
            "location": 163,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.best_model_sel_file": {
            "name": "best_model_sel_file",
            "location": 168,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.json_read": {
            "name": "json_read",
            "location": 173,
            "return": [],
            "arguments": {
                "filename": []
            }
        },
        "Metric.json_write": {
            "name": "json_write",
            "location": 194,
            "return": [
                "None"
            ],
            "arguments": {
                "filename": [],
                "what_to_write": []
            }
        },
        "Metric.update_state": {
            "name": "update_state",
            "location": 216,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": []
            }
        },
        "Metric.result": {
            "name": "result",
            "location": 226,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Metric.log": {
            "name": "log",
            "location": 236,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "step": []
            }
        },
        "Metric.reset_states": {
            "name": "reset_states",
            "location": 246,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/src/ashpy/metrics/sliced_wasserstein.py": {
        "batch_to_space": {
            "name": "batch_to_space",
            "location": 49,
            "return": [],
            "arguments": {}
        },
        "_to_float": {
            "name": "_to_float",
            "location": 60,
            "return": [],
            "arguments": {
                "tensor": [
                    "float",
                    "dict[str, numpy.ndarray]",
                    "dict[, ]",
                    "str",
                    "int"
                ]
            }
        },
        "laplacian_pyramid": {
            "name": "laplacian_pyramid",
            "location": 64,
            "return": [
                "list"
            ],
            "arguments": {
                "batch": [
                    "int",
                    "tuple[typing.Union[int,int]]"
                ],
                "num_levels": [
                    "int"
                ]
            }
        },
        "_batch_to_patches": {
            "name": "_batch_to_patches",
            "location": 111,
            "return": [
                "float"
            ],
            "arguments": {
                "batch": [
                    "int",
                    "str",
                    "float"
                ],
                "patches_per_image": [
                    "bool"
                ],
                "patch_size": [
                    "bool"
                ]
            }
        },
        "_normalize_patches": {
            "name": "_normalize_patches",
            "location": 146,
            "return": [],
            "arguments": {
                "patches": [
                    "float",
                    "bool",
                    "str"
                ]
            }
        },
        "_sort_rows": {
            "name": "_sort_rows",
            "location": 164,
            "return": [],
            "arguments": {
                "matrix": [
                    "int",
                    "bytes",
                    "float"
                ],
                "num_rows": [
                    "float",
                    "str",
                    "None",
                    "int",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "_sliced_wasserstein": {
            "name": "_sliced_wasserstein",
            "location": 181,
            "return": [],
            "arguments": {
                "a": [
                    "int",
                    "None",
                    "float",
                    "str"
                ],
                "b": [
                    "int"
                ],
                "random_sampling_count": [
                    "int",
                    "str"
                ],
                "random_projection_dim": [
                    "int",
                    "float",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "_sliced_wasserstein_svd": {
            "name": "_sliced_wasserstein_svd",
            "location": 214,
            "return": [],
            "arguments": {
                "a": [
                    "float",
                    "int",
                    "str"
                ],
                "b": [
                    "str",
                    "list[str]",
                    "None"
                ]
            }
        },
        "sliced_wasserstein_distance": {
            "name": "sliced_wasserstein_distance",
            "location": 240,
            "return": [
                "List[Tuple[(Any, Any)]]"
            ],
            "arguments": {
                "real_images": [
                    "None",
                    "tuple[typing.Union[int,int]]",
                    "int"
                ],
                "fake_images": [
                    "int",
                    "tuple[typing.Union[numpy.ndarray,float]]"
                ],
                "resolution_min": [
                    "int"
                ],
                "patches_per_image": [
                    "int"
                ],
                "patch_size": [
                    "int"
                ],
                "random_sampling_count": [
                    "int"
                ],
                "random_projection_dim": [
                    "int"
                ],
                "use_svd": [
                    "bool"
                ]
            }
        },
        "laplacian_pyramid.spatial_conv": {
            "name": "spatial_conv",
            "location": 78,
            "return": [],
            "arguments": {
                "batch": [],
                "gain": []
            }
        },
        "laplacian_pyramid.pyr_down": {
            "name": "pyr_down",
            "location": 93,
            "return": [],
            "arguments": {
                "batch": []
            }
        },
        "laplacian_pyramid.pyr_up": {
            "name": "pyr_up",
            "location": 96,
            "return": [],
            "arguments": {
                "batch": []
            }
        },
        "_batch_to_patches.py_func_random_patches": {
            "name": "py_func_random_patches",
            "location": 125,
            "return": [],
            "arguments": {
                "batch": []
            }
        }
    },
    "ashpy-master/src/ashpy/metrics/sliced_wasserstein_metric.py": {
        "SingleSWD.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_selection_operator": [
                    "str",
                    "int",
                    "Callable",
                    "Union[pathlib.Path, str]"
                ],
                "logdir": [
                    "str",
                    "int",
                    "typing.Callable[, ]",
                    "Callable",
                    "Union[pathlib.Path, str]"
                ],
                "level_of_pyramid": [
                    "int",
                    "str",
                    "Callable",
                    "Union[pathlib.Path, str]"
                ],
                "real_or_fake": [
                    "typing.Text",
                    "str",
                    "int",
                    "Callable",
                    "Union[pathlib.Path, str]"
                ]
            }
        },
        "SingleSWD.update_state": {
            "name": "update_state",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "bool",
                    "ashpy.contexts.GANContext",
                    "typing.Sequence[int]",
                    "str",
                    "ashpy.contexts.Context",
                    "Sequence[int]"
                ],
                "score": [
                    "int",
                    "str",
                    "pathlib.Path",
                    "bytes",
                    "bool"
                ]
            }
        },
        "SlicedWassersteinDistance.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text",
                    "Union[pathlib.Path, str]",
                    "Callable",
                    "str"
                ],
                "model_selection_operator": [
                    "Union[pathlib.Path, str]",
                    "Callable",
                    "str"
                ],
                "logdir": [
                    "str",
                    "Union[pathlib.Path, str]",
                    "typing.Callable[, ]",
                    "Callable"
                ],
                "resolution": [
                    "int",
                    "float",
                    "list",
                    "Optional[str]",
                    "List[int]",
                    "Union[Callable, str]"
                ],
                "resolution_min": [
                    "int",
                    "str",
                    "tuple",
                    "float"
                ],
                "patches_per_image": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Tuple[int, int]",
                    "str",
                    "bytes"
                ],
                "patch_size": [
                    "int",
                    "str",
                    "Optional[dict]",
                    "dict",
                    "float",
                    "FrozenSet[Any]"
                ],
                "random_sampling_count": [
                    "int",
                    "bytes",
                    "str"
                ],
                "random_projection_dim": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]",
                    "dict",
                    "bytes"
                ],
                "use_svd": [
                    "bool",
                    "str",
                    "Optional[bool]"
                ]
            }
        },
        "SlicedWassersteinDistance.logdir": {
            "name": "logdir",
            "location": 166,
            "return": [
                "None",
                "str",
                "dict[str, typing.Any]",
                "dict[, ]",
                "int"
            ],
            "arguments": {
                "self": [],
                "logdir": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "SlicedWassersteinDistance.update_state": {
            "name": "update_state",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "ashpy.contexts.GANContext",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "SlicedWassersteinDistance.model_selection": {
            "name": "model_selection",
            "location": 223,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "checkpoint": [
                    "typing.Callable[, ]",
                    "tensorflow.train.Checkpoint",
                    "str",
                    "tensorflow.Variable",
                    "None",
                    "Callable",
                    "typing.Type",
                    "Optional[str]",
                    "Type"
                ],
                "global_step": [
                    "typing.Callable[, ]",
                    "tensorflow.train.Checkpoint",
                    "str",
                    "tensorflow.Variable",
                    "None",
                    "Callable",
                    "typing.Type",
                    "Optional[str]",
                    "Type"
                ]
            }
        },
        "SlicedWassersteinDistance.log": {
            "name": "log",
            "location": 232,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "step": [
                    "str",
                    "bool",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ]
            }
        },
        "SlicedWassersteinDistance.reset_states": {
            "name": "reset_states",
            "location": 241,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/src/ashpy/metrics/ssim_multiscale.py": {
        "SSIM_Multiscale.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text",
                    "Union[pathlib.Path, str]",
                    "Callable",
                    "str"
                ],
                "model_selection_operator": [
                    "Union[pathlib.Path, str]",
                    "Callable",
                    "str"
                ],
                "logdir": [
                    "str",
                    "Union[pathlib.Path, str]",
                    "typing.Callable[, ]",
                    "Callable"
                ],
                "max_val": [
                    "float",
                    "int",
                    "Union[float, int]"
                ],
                "power_factors": [
                    "None",
                    "Optional[int]",
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "typing.Callable[, ]",
                    "Callable",
                    "Optional[bool]"
                ],
                "filter_size": [
                    "int",
                    "bool",
                    "str",
                    "Optional[float]"
                ],
                "filter_sigma": [
                    "float",
                    "Sequence",
                    "bool",
                    "str",
                    "int",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "k1": [
                    "float",
                    "Sequence",
                    "bool",
                    "str",
                    "int",
                    "Optional[int]",
                    "Optional[str]"
                ],
                "k2": [
                    "float",
                    "Sequence",
                    "bool",
                    "str",
                    "int",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        },
        "SSIM_Multiscale.update_state": {
            "name": "update_state",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "ashpy.contexts.GANContext",
                    "int"
                ]
            }
        },
        "SSIM_Multiscale.split_batch": {
            "name": "split_batch",
            "location": 140,
            "return": [
                "tuple[]",
                "bool",
                "str"
            ],
            "arguments": {
                "batch": [
                    "int",
                    "tensorflow.Tensor",
                    "dict",
                    "float"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/metrics/__init__.py": {},
    "ashpy-master/src/ashpy/models/gans.py": {},
    "ashpy-master/src/ashpy/models/__init__.py": {},
    "ashpy-master/src/ashpy/models/convolutional/autoencoders.py": {
        "Autoencoder.__init__": {
            "name": "__init__",
            "location": 52,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_spec_input_res": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "layer_spec_target_res": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "kernel_size": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "initial_filters": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "filters_cap": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "encoding_dimension": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "channels": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ]
            }
        },
        "Autoencoder.call": {
            "name": "call",
            "location": 99,
            "return": [
                "tuple[typing.Union[str,bool,list[int],list[]]]",
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "typing.Callable[, ]",
                    "float"
                ],
                "training": [
                    "bool",
                    "str",
                    "zerver.models.Realm"
                ]
            }
        },
        "FCNNAutoencoder.__init__": {
            "name": "__init__",
            "location": 144,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_spec_input_res": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "layer_spec_target_res": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "kernel_size": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "initial_filters": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "filters_cap": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "encoding_dimension": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ],
                "channels": [
                    "float",
                    "int",
                    "Dict[str, Tuple[str, int, int]]",
                    "dict[str, tuple[typing.Union[str,int,int]]]"
                ]
            }
        },
        "FCNNAutoencoder.call": {
            "name": "call",
            "location": 191,
            "return": [
                "tuple[typing.Union[str,bool,list[int],list[]]]",
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "typing.Callable[, ]",
                    "float"
                ],
                "training": [
                    "bool",
                    "str",
                    "zerver.models.Realm"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/decoders.py": {
        "Decoder.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_spec_input_res": [
                    "int",
                    "bool"
                ],
                "layer_spec_target_res": [
                    "int",
                    "bool"
                ],
                "kernel_size": [
                    "int",
                    "List[float]",
                    "list[float]",
                    "List[str]",
                    "list[str]",
                    "Tuple[int, int, int]",
                    "tuple[typing.Union[int,int,int]]"
                ],
                "initial_filters": [
                    "str",
                    "int",
                    "zerver.models.UserProfile",
                    "float",
                    "Dict[str, Dict[str, Any]]",
                    "contests.models.User",
                    "bool"
                ],
                "filters_cap": [
                    "int",
                    "str",
                    "zerver.models.UserProfile",
                    "models.User",
                    "contests.models.User",
                    "bool",
                    "Dict[str, Dict[str, Any]]",
                    "Union[server.models.User, int]"
                ],
                "channels": [
                    "float",
                    "int",
                    "list",
                    "list[]",
                    "List[Callable[[List], None]]",
                    "list[typing.Callable[list[], None]]"
                ],
                "use_dropout": [
                    "bool"
                ],
                "dropout_prob": [
                    "float",
                    "bool",
                    "Tuple[float, float, float, float]",
                    "bytes"
                ],
                "non_linearity": [
                    "float",
                    "bool",
                    "Tuple[float, float, float, float]",
                    "bytes"
                ]
            }
        },
        "Decoder._add_initial_block": {
            "name": "_add_initial_block",
            "location": 145,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "initial_filters": [
                    "int",
                    "list",
                    "List[str]"
                ],
                "input_res": [
                    "list[]",
                    "int",
                    "list[str]",
                    "list",
                    "List[str]"
                ]
            }
        },
        "Decoder._add_building_block": {
            "name": "_add_building_block",
            "location": 164,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "int",
                    "str",
                    "List[Tuple[str, str]]",
                    "list[tuple[typing.Union[str,str]]]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]",
                    "list",
                    "list[]"
                ]
            }
        },
        "Decoder._add_final_block": {
            "name": "_add_final_block",
            "location": 189,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "channels": [
                    "int",
                    "float"
                ]
            }
        },
        "FCNNDecoder.__init__": {
            "name": "__init__",
            "location": 233,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_spec_input_res": [
                    "int",
                    "list[str]",
                    "str",
                    "List[str]",
                    "None",
                    "Optional[int]",
                    "Union[None, int]"
                ],
                "layer_spec_target_res": [
                    "int",
                    "list[str]",
                    "str",
                    "List[str]",
                    "None",
                    "Optional[int]",
                    "Union[None, int]"
                ],
                "kernel_size": [
                    "int",
                    "bytes",
                    "str",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None",
                    "Dict[str, str]",
                    "dict[str, str]"
                ],
                "initial_filters": [
                    "int",
                    "list[str]",
                    "str",
                    "List[str]",
                    "None",
                    "Optional[int]",
                    "Union[None, int]"
                ],
                "filters_cap": [
                    "int",
                    "list[str]",
                    "str",
                    "List[str]",
                    "None",
                    "Optional[int]",
                    "Union[None, int]"
                ],
                "channels": [
                    "int",
                    "list[str]",
                    "str",
                    "List[str]",
                    "None",
                    "Optional[int]",
                    "Union[None, int]"
                ],
                "use_dropout": [
                    "bool",
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "Union[None, int]",
                    "str"
                ],
                "dropout_prob": [
                    "float",
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "Union[None, int]",
                    "str"
                ],
                "non_linearity": [
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "Union[None, int]",
                    "str"
                ]
            }
        },
        "FCNNDecoder._add_initial_block": {
            "name": "_add_initial_block",
            "location": 259,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "initial_filters": [
                    "int",
                    "Optional[int]",
                    "float",
                    "None",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "input_res": [
                    "str",
                    "bool",
                    "list[C]",
                    "List['cirq.Circuit']",
                    "Optional[str]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/discriminators.py": {
        "PatchDiscriminator.__init__": {
            "name": "__init__",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "int"
                ],
                "min_res": [
                    "int"
                ],
                "kernel_size": [
                    "int"
                ],
                "initial_filters": [
                    "int"
                ],
                "filters_cap": [
                    "int"
                ],
                "use_dropout": [
                    "bool"
                ],
                "dropout_prob": [
                    "float"
                ],
                "non_linearity": [
                    "type"
                ],
                "normalization_layer": [
                    "type"
                ],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "PatchDiscriminator._add_final_block": {
            "name": "_add_final_block",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "output_shape": [
                    "list[str]",
                    "dict[, ]"
                ]
            }
        },
        "PatchDiscriminator.call": {
            "name": "call",
            "location": 135,
            "return": [],
            "arguments": {
                "self": [],
                "inputs": [],
                "training": [
                    "bool"
                ],
                "return_features": [
                    "bool"
                ]
            }
        },
        "PatchDiscriminator._add_building_block": {
            "name": "_add_building_block",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "list[tuple[typing.Union[int,int]]]",
                    "tuple[typing.Union[int,int]]",
                    "list[]",
                    "bool"
                ],
                "use_bn": [
                    "bool"
                ]
            }
        },
        "MultiScaleDiscriminator.__init__": {
            "name": "__init__",
            "location": 223,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "int"
                ],
                "min_res": [
                    "int"
                ],
                "kernel_size": [
                    "int"
                ],
                "initial_filters": [
                    "int"
                ],
                "filters_cap": [
                    "int"
                ],
                "use_dropout": [
                    "bool"
                ],
                "dropout_prob": [
                    "float"
                ],
                "non_linearity": [
                    "type"
                ],
                "normalization_layer": [
                    "type"
                ],
                "use_attention": [
                    "bool"
                ],
                "n_discriminators": [
                    "int"
                ]
            }
        },
        "MultiScaleDiscriminator.build_discriminator": {
            "name": "build_discriminator",
            "location": 286,
            "return": [
                "ashpy.models.convolutional.encoders.Encoder"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "int",
                    "str",
                    "float",
                    "list[]"
                ]
            }
        },
        "MultiScaleDiscriminator.call": {
            "name": "call",
            "location": 309,
            "return": [
                "Union[(list, Tuple[(list, list)])]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "dict[str, typing.Any]"
                ],
                "training": [
                    "bool"
                ],
                "return_features": [
                    "bool"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/encoders.py": {
        "Encoder.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_spec_input_res": [
                    "str",
                    "int",
                    "list[str]",
                    "topicdb.core.models.collaborationmode.CollaborationMode",
                    "List[str]"
                ],
                "layer_spec_target_res": [
                    "str",
                    "int",
                    "list[str]",
                    "topicdb.core.models.collaborationmode.CollaborationMode",
                    "List[str]"
                ],
                "kernel_size": [
                    "int",
                    "List[float]",
                    "list[float]",
                    "List[str]",
                    "list[str]",
                    "Tuple[int, int, int]",
                    "tuple[typing.Union[int,int,int]]"
                ],
                "initial_filters": [
                    "int",
                    "str",
                    "zerver.models.UserProfile",
                    "models.User",
                    "contests.models.User",
                    "bool",
                    "Dict[str, Dict[str, Any]]",
                    "Union[server.models.User, int]"
                ],
                "filters_cap": [
                    "int",
                    "str",
                    "zerver.models.UserProfile",
                    "models.User",
                    "contests.models.User",
                    "bool",
                    "Dict[str, Dict[str, Any]]",
                    "Union[server.models.User, int]"
                ],
                "output_shape": [
                    "int",
                    "Optional[int]",
                    "None",
                    "List[bytes]",
                    "list[bytes]",
                    "tuple",
                    "tuple[]"
                ],
                "use_dropout": [
                    "bool"
                ],
                "dropout_prob": [
                    "float",
                    "bool",
                    "Tuple[float, float, float, float]",
                    "bytes"
                ],
                "non_linearity": [
                    "float",
                    "bool",
                    "Tuple[float, float, float, float]",
                    "bytes"
                ]
            }
        },
        "Encoder._add_building_block": {
            "name": "_add_building_block",
            "location": 129,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "list",
                    "list[]",
                    "Tuple[int, int]",
                    "int",
                    "tuple[typing.Union[int,int]]",
                    "Sequence[Any]",
                    "typing.Sequence[typing.Any]"
                ]
            }
        },
        "Encoder._add_final_block": {
            "name": "_add_final_block",
            "location": 151,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_shape": [
                    "List[str]",
                    "list[str]",
                    "Callable",
                    "str",
                    "typing.Callable[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "FCNNEncoder.__init__": {
            "name": "__init__",
            "location": 191,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_spec_input_res": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "layer_spec_target_res": [
                    "int",
                    "float",
                    "Union[float, int]",
                    "tuple[]",
                    "bool",
                    "tuple"
                ],
                "kernel_size": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "initial_filters": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "filters_cap": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "encoding_dimension": [
                    "str",
                    "Optional[int]",
                    "int",
                    "Dict[str, str]",
                    "None",
                    "dict[str, str]"
                ]
            }
        },
        "FCNNEncoder._add_final_block": {
            "name": "_add_final_block",
            "location": 232,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "output_shape": [
                    "List[str]",
                    "list[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/interfaces.py": {
        "Conv2DInterface.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Conv2DInterface._get_layer_spec": {
            "name": "_get_layer_spec",
            "location": 38,
            "return": [
                "",
                "typing.Generator[typing.Union[dict[, ],dict[str, typing.Union[float,str]],dict[str, typing.Union[int,str]]]]"
            ],
            "arguments": {
                "initial_filers": [
                    "int",
                    "str",
                    "Optional[str]",
                    "bool",
                    "Callable[..., None]",
                    "BinaryIO"
                ],
                "filters_cap": [
                    "dict[str, str]",
                    "numpy.ndarray",
                    "str",
                    "Exception",
                    "Dict[str, str]",
                    "bool",
                    "typing.Callable[dict[, ], None]",
                    "Callable[[dict], None]",
                    "tuple[bool]",
                    "Tuple[bool]"
                ],
                "input_res": [
                    "int",
                    "bytes",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None"
                ],
                "target_res": [
                    "int",
                    "None",
                    "Optional[int]",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "Conv2DInterface.call": {
            "name": "call",
            "location": 127,
            "return": [
                "Callable",
                "int",
                "tuple[typing.Union[list[str],int,str,list[Exception],list[typing.Union[list[str],int]]]]",
                "float",
                "list[str]",
                "str",
                "list[Exception]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "List[Exception]",
                    "list[Exception]"
                ],
                "training": [
                    "bool",
                    "Callable",
                    "Set[str]",
                    "Dict[str, Any]"
                ],
                "return_features": [
                    "bool",
                    "dict",
                    "Exception",
                    "List[Dict[str, Any]]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/pix2pixhd.py": {
        "LocalEnhancer.__init__": {
            "name": "__init__",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "int"
                ],
                "min_res": [
                    "int"
                ],
                "initial_filters": [
                    "int"
                ],
                "filters_cap": [
                    "int"
                ],
                "channels": [
                    "int"
                ],
                "normalization_layer": [
                    "type"
                ],
                "non_linearity": [
                    "type"
                ],
                "num_resnet_blocks_global": [
                    "int"
                ],
                "num_resnet_blocks_local": [
                    "int"
                ],
                "kernel_size_resnet": [
                    "int"
                ],
                "kernel_size_front_back": [
                    "int"
                ],
                "num_internal_resnet_blocks": [
                    "int"
                ]
            }
        },
        "LocalEnhancer.call": {
            "name": "call",
            "location": 171,
            "return": [
                "float",
                "int",
                "complex",
                "list[list[int]]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int"
                ],
                "training": [
                    "bool"
                ]
            }
        },
        "ResNetBlock.__init__": {
            "name": "__init__",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "int"
                ],
                "normalization_layer": [
                    "type"
                ],
                "non_linearity": [
                    "type"
                ],
                "kernel_size": [
                    "int"
                ],
                "num_blocks": [
                    "int"
                ]
            }
        },
        "ResNetBlock.call": {
            "name": "call",
            "location": 269,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "int"
                ],
                "training": [
                    "bool"
                ]
            }
        },
        "GlobalGenerator.__init__": {
            "name": "__init__",
            "location": 300,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "int"
                ],
                "min_res": [
                    "int"
                ],
                "initial_filters": [
                    "int"
                ],
                "filters_cap": [
                    "int"
                ],
                "channels": [
                    "int"
                ],
                "normalization_layer": [
                    "type"
                ],
                "non_linearity": [
                    "type"
                ],
                "num_resnet_blocks": [
                    "int"
                ],
                "kernel_size_resnet": [
                    "int"
                ],
                "kernel_size_front_back": [
                    "int"
                ],
                "num_internal_resnet_blocks": [
                    "int"
                ]
            }
        },
        "GlobalGenerator.call": {
            "name": "call",
            "location": 411,
            "return": [
                "Tuple[(Any, _T0)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "_T0"
                ],
                "training": [
                    "bool"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/unet.py": {
        "FUNet": {
            "name": "FUNet",
            "location": 313,
            "return": [],
            "arguments": {
                "input_res": [
                    "int",
                    "float"
                ],
                "min_res": [
                    "int",
                    "None"
                ],
                "kernel_size": [
                    "int"
                ],
                "initial_filters": [
                    "int",
                    "None"
                ],
                "filters_cap": [
                    "int",
                    "None"
                ],
                "channels": [
                    "int",
                    "float",
                    "dict[str, tuple[typing.Union[str,int,int]]]",
                    "None",
                    "list[]"
                ],
                "input_channels": [
                    "int"
                ],
                "use_dropout_encoder": [
                    "bool"
                ],
                "use_dropout_decoder": [
                    "bool"
                ],
                "dropout_prob": [
                    "float"
                ],
                "encoder_non_linearity": [],
                "decoder_non_linearity": [],
                "last_activation": [],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "UNet.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "str",
                    "int",
                    "None"
                ],
                "min_res": [
                    "str",
                    "int",
                    "None"
                ],
                "kernel_size": [
                    "int",
                    "tuple[typing.Union[int,int]]",
                    "float"
                ],
                "initial_filters": [
                    "str",
                    "int",
                    "None"
                ],
                "filters_cap": [
                    "str",
                    "int",
                    "None"
                ],
                "channels": [
                    "int",
                    "float",
                    "dict[str, tuple[typing.Union[str,int,int]]]",
                    "dict[, ]",
                    "None"
                ],
                "use_dropout_encoder": [
                    "bool"
                ],
                "use_dropout_decoder": [
                    "bool"
                ],
                "dropout_prob": [
                    "float"
                ],
                "encoder_non_linearity": [],
                "decoder_non_linearity": [],
                "normalization_layer": [],
                "last_activation": [],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "UNet._get_block": {
            "name": "_get_block",
            "location": 155,
            "return": [
                "list[Attention]"
            ],
            "arguments": {
                "self": [],
                "filters": [
                    "int",
                    "None",
                    "str"
                ],
                "conv_layer": [
                    "None",
                    "int",
                    "float",
                    "str"
                ],
                "use_bn": [
                    "bool"
                ],
                "use_dropout": [
                    "bool"
                ],
                "non_linearity": [],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "UNet.get_encoder_block": {
            "name": "get_encoder_block",
            "location": 194,
            "return": [],
            "arguments": {
                "self": [],
                "filters": [
                    "bool",
                    "float",
                    "str",
                    "None"
                ],
                "use_bn": [
                    "bool"
                ],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "UNet.get_decoder_block": {
            "name": "get_decoder_block",
            "location": 216,
            "return": [],
            "arguments": {
                "self": [],
                "filters": [
                    "bool",
                    "float",
                    "None",
                    "str"
                ],
                "use_bn": [
                    "bool"
                ],
                "use_dropout": [
                    "bool"
                ],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "UNet.call": {
            "name": "call",
            "location": 244,
            "return": [
                "float",
                "int",
                "list[list[int]]",
                "dict[str, int]",
                "tuple[typing.Union[int,int]]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "typing.Callable[, ]",
                    "int",
                    "float"
                ],
                "training": [
                    "bool"
                ]
            }
        },
        "SUNet.__init__": {
            "name": "__init__",
            "location": 280,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_res": [
                    "bool",
                    "None",
                    "float"
                ],
                "min_res": [
                    "bool",
                    "None",
                    "float"
                ],
                "kernel_size": [
                    "bool",
                    "None",
                    "float"
                ],
                "initial_filters": [
                    "bool",
                    "None",
                    "float"
                ],
                "filters_cap": [
                    "bool",
                    "None",
                    "float"
                ],
                "channels": [
                    "bool",
                    "None",
                    "float"
                ],
                "use_dropout_encoder": [
                    "bool"
                ],
                "use_dropout_decoder": [
                    "bool"
                ],
                "dropout_prob": [
                    "float"
                ],
                "encoder_non_linearity": [],
                "decoder_non_linearity": [],
                "use_attention": [
                    "bool"
                ]
            }
        },
        "FUNet.get_block": {
            "name": "get_block",
            "location": 337,
            "return": [
                "list[Attention]"
            ],
            "arguments": {
                "kernel_size": [],
                "filters": [],
                "conv_layer": [],
                "use_bn": [],
                "use_dropout": [],
                "non_linearity": [],
                "use_attention": [],
                "dropout_probability": []
            }
        }
    },
    "ashpy-master/src/ashpy/models/convolutional/__init__.py": {},
    "ashpy-master/src/ashpy/models/fc/autoencoders.py": {
        "Autoencoder.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_units": [
                    "str",
                    "bool",
                    "int",
                    "Optional[\"Address\"]"
                ],
                "encoding_dimension": [
                    "str",
                    "int"
                ],
                "output_shape": [
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "str",
                    "typing.Iterable[float]",
                    "Iterable[float]",
                    "List[int]"
                ]
            }
        },
        "Autoencoder.call": {
            "name": "call",
            "location": 65,
            "return": [
                "tuple[typing.Union[str,bool,list[int],list[]]]",
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "typing.Callable[, ]",
                    "float"
                ],
                "training": [
                    "bool",
                    "str",
                    "zerver.models.Realm"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/fc/decoders.py": {
        "Decoder.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_units": [
                    "str",
                    "bool",
                    "int"
                ],
                "output_shape": [
                    "str",
                    "bool",
                    "list[]",
                    "list",
                    "Iterable[str]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/fc/encoders.py": {
        "Encoder.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "hidden_units": [
                    "str",
                    "bool",
                    "int"
                ],
                "output_shape": [
                    "str",
                    "bool",
                    "list[]",
                    "list",
                    "Iterable[str]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/fc/interfaces.py": {
        "FCInterface.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FCInterface.call": {
            "name": "call",
            "location": 40,
            "return": [
                "Callable",
                "int",
                "str",
                "float",
                "list[tuple[typing.Union[str,bool]]]",
                "typing.Callable[, ]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Callable",
                    "int",
                    "typing.Callable[, ]",
                    "float"
                ],
                "training": [
                    "bool",
                    "Union",
                    "BaseException",
                    "Callable"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/models/fc/__init__.py": {},
    "ashpy-master/src/ashpy/restorers/classifier.py": {
        "ClassifierRestorer.restore_model": {
            "name": "restore_model",
            "location": 27,
            "return": [
                "set[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "set[int]",
                    "int",
                    "tensorflow.keras.Model",
                    "Set[int]"
                ]
            }
        },
        "ClassifierRestorer.restore_optimizer": {
            "name": "restore_optimizer",
            "location": 50,
            "return": [
                "str",
                "int",
                "dict[, ]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/restorers/gan.py": {
        "AdversarialRestorer.restore_generator": {
            "name": "restore_generator",
            "location": 27,
            "return": [
                "set[int]",
                "int",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "set[int]",
                    "int",
                    "tensorflow.keras.Model",
                    "Set[int]"
                ]
            }
        },
        "AdversarialRestorer.restore_discriminator": {
            "name": "restore_discriminator",
            "location": 50,
            "return": [
                "set[int]",
                "int",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "set[int]",
                    "int",
                    "tensorflow.keras.Model",
                    "Set[int]"
                ]
            }
        },
        "AdversarialRestorer.restore_generator_optimizer": {
            "name": "restore_generator_optimizer",
            "location": 73,
            "return": [
                "str",
                "int",
                "dict[, ]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "AdversarialRestorer.restore_discriminator_optimizer": {
            "name": "restore_discriminator_optimizer",
            "location": 90,
            "return": [
                "str",
                "int",
                "dict[, ]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "AdversarialEncoderRestorer.restore_encoder": {
            "name": "restore_encoder",
            "location": 113,
            "return": [
                "set[int]",
                "int",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "set[int]",
                    "int",
                    "tensorflow.keras.Model",
                    "Set[int]"
                ]
            }
        },
        "AdversarialEncoderRestorer.restore_encoder_optimizer": {
            "name": "restore_encoder_optimizer",
            "location": 136,
            "return": [
                "str",
                "int",
                "dict[, ]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "optimizer": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/restorers/restorer.py": {
        "Restorer.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "logdir": [
                    "str",
                    "cerulean.Path",
                    "bool",
                    "list[str]",
                    "Union[pathlib.Path, str]",
                    "None",
                    "Optional[List[str]]"
                ],
                "ckpts_dir": [
                    "bool",
                    "str"
                ],
                "expect_partial": [
                    "bool",
                    "Callable",
                    "str"
                ]
            }
        },
        "Restorer.checkpoint_map": {
            "name": "checkpoint_map",
            "location": 77,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Restorer._restore_checkpoint": {
            "name": "_restore_checkpoint",
            "location": 90,
            "return": [
                "str",
                "List[Dict[str, Any]]",
                "dict",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "checkpoint": [
                    "bytes"
                ],
                "partial": [
                    "bool",
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict"
                ]
            }
        },
        "Restorer._validate_placeholder": {
            "name": "_validate_placeholder",
            "location": 104,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "placeholder": [
                    "list[]",
                    "list",
                    "bool",
                    "typing.Type",
                    "str",
                    "Type[BaseException]",
                    "Type"
                ],
                "placeholder_type": [
                    "list[]",
                    "list",
                    "bool",
                    "typing.Type",
                    "str",
                    "Type[BaseException]",
                    "Type"
                ]
            }
        },
        "Restorer._check_model_construction": {
            "name": "_check_model_construction",
            "location": 114,
            "return": [
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "restored_model": [
                    "tensorflow.keras.Model"
                ]
            }
        },
        "Restorer.restore_object": {
            "name": "restore_object",
            "location": 134,
            "return": [
                "int",
                "str",
                "list[typing.Optional[str]]",
                "List[Dict[str, Any]]",
                "dict",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "placeholder": [
                    "int",
                    "str"
                ],
                "object_ckpt_id": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "Restorer.get_global_step": {
            "name": "get_global_step",
            "location": 158,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Restorer.get_steps_per_epoch": {
            "name": "get_steps_per_epoch",
            "location": 168,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Restorer.restore_callback": {
            "name": "restore_callback",
            "location": 178,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "callback": [
                    "str",
                    "int"
                ],
                "callback_ckpt_id": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "Restorer._read_human_checkpoint_map": {
            "name": "_read_human_checkpoint_map",
            "location": 186,
            "return": [
                "int",
                "bool",
                "Optional[float]",
                "Dict[str, str]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/src/ashpy/restorers/__init__.py": {},
    "ashpy-master/src/ashpy/trainers/classifier.py": {
        "ClassifierTrainer.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "bool",
                    "None"
                ],
                "optimizer": [
                    "bool",
                    "None"
                ],
                "loss": [],
                "epochs": [
                    "int",
                    "list[ashpy.callbacks.Callback]",
                    "None",
                    "str"
                ],
                "metrics": [
                    "None",
                    "bool"
                ],
                "callbacks": [
                    "None",
                    "int",
                    "list[ashpy.callbacks.Callback]",
                    "str"
                ],
                "logdir": [
                    "int",
                    "list[ashpy.callbacks.Callback]",
                    "None",
                    "str"
                ],
                "global_step": [
                    "None",
                    "bool",
                    "float",
                    "str",
                    "bytes"
                ]
            }
        },
        "ClassifierTrainer._build_and_restore_models": {
            "name": "_build_and_restore_models",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": []
            }
        },
        "ClassifierTrainer.train_step": {
            "name": "train_step",
            "location": 171,
            "return": [],
            "arguments": {
                "self": [],
                "features": [
                    "dict[str, typing.Any]",
                    "bool"
                ],
                "labels": [
                    "dict[str, typing.Any]",
                    "bool"
                ]
            }
        },
        "ClassifierTrainer._train_step": {
            "name": "_train_step",
            "location": 193,
            "return": [],
            "arguments": {
                "self": [],
                "example": []
            }
        },
        "ClassifierTrainer.call": {
            "name": "call",
            "location": 200,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "training_set": [
                    "int",
                    "None"
                ],
                "validation_set": [
                    "bool",
                    "str",
                    "dict[, ]"
                ],
                "log_freq": [
                    "int"
                ],
                "measure_performance_freq": [
                    "int"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/trainers/gan.py": {
        "AdversarialTrainer.__init__": {
            "name": "__init__",
            "location": 133,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "generator": [
                    "int",
                    "float"
                ],
                "discriminator": [
                    "int",
                    "float"
                ],
                "generator_optimizer": [
                    "int",
                    "float"
                ],
                "discriminator_optimizer": [
                    "int",
                    "float"
                ],
                "generator_loss": [
                    "str",
                    "None"
                ],
                "discriminator_loss": [
                    "str",
                    "None"
                ],
                "epochs": [
                    "int",
                    "list[ashpy.callbacks.Callback]",
                    "None",
                    "str"
                ],
                "metrics": [
                    "None",
                    "str",
                    "bytes"
                ],
                "callbacks": [
                    "None",
                    "int",
                    "list[ashpy.callbacks.Callback]",
                    "str"
                ],
                "logdir": [
                    "int",
                    "list[ashpy.callbacks.Callback]",
                    "None",
                    "str"
                ],
                "log_eval_mode": [],
                "global_step": [
                    "None",
                    "list[ashpy.callbacks.Callback]",
                    "str",
                    "int"
                ]
            }
        },
        "AdversarialTrainer._build_and_restore_models": {
            "name": "_build_and_restore_models",
            "location": 233,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": []
            }
        },
        "AdversarialTrainer.train_step": {
            "name": "train_step",
            "location": 243,
            "return": [
                "tuple[typing.Union[str,list[str],dict[, ],typing.Final]]"
            ],
            "arguments": {
                "self": [],
                "real_xy": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ],
                "g_inputs": [
                    "str",
                    "int",
                    "typing.Callable[, ]"
                ]
            }
        },
        "AdversarialTrainer._train_step": {
            "name": "_train_step",
            "location": 295,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "example": [
                    "str",
                    "tuple[]",
                    "list[str]"
                ]
            }
        },
        "AdversarialTrainer.call": {
            "name": "call",
            "location": 310,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "bool"
                ],
                "log_freq": [
                    "int"
                ],
                "measure_performance_freq": [
                    "int"
                ]
            }
        },
        "EncoderTrainer.__init__": {
            "name": "__init__",
            "location": 496,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "generator": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "discriminator": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "encoder": [
                    "int",
                    "float"
                ],
                "generator_optimizer": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "discriminator_optimizer": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "encoder_optimizer": [
                    "int",
                    "float"
                ],
                "generator_loss": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "discriminator_loss": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "encoder_loss": [
                    "list[str]",
                    "None"
                ],
                "epochs": [
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "metrics": [
                    "list[]"
                ],
                "callbacks": [
                    "None",
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ],
                "logdir": [
                    "str",
                    "bool",
                    "list[]",
                    "dict[, ]"
                ],
                "log_eval_mode": [],
                "global_step": [
                    "None",
                    "bool",
                    "dict[str, typing.Any]",
                    "typing.Callable[A, bool]"
                ]
            }
        },
        "EncoderTrainer._build_and_restore_models": {
            "name": "_build_and_restore_models",
            "location": 592,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": []
            }
        },
        "EncoderTrainer.train_step": {
            "name": "train_step",
            "location": 603,
            "return": [
                "tuple[typing.Union[str,int]]"
            ],
            "arguments": {
                "self": [],
                "real_xy": [
                    "int",
                    "typing.Callable[, ]",
                    "str"
                ],
                "g_inputs": [
                    "str",
                    "int",
                    "typing.Callable[, ]"
                ]
            }
        },
        "EncoderTrainer._train_step": {
            "name": "_train_step",
            "location": 658,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "example": [
                    "str",
                    "tuple[]",
                    "list[str]"
                ]
            }
        },
        "EncoderTrainer.call": {
            "name": "call",
            "location": 675,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "bool"
                ],
                "log_freq": [
                    "int"
                ],
                "measure_performance_freq": [
                    "int"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/trainers/trainer.py": {
        "Trainer.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epochs": [
                    "bool",
                    "float",
                    "tuple[typing.Union[float,float]]",
                    "list[str]",
                    "typing.Callable[str, bool]"
                ],
                "example_dim": [
                    "bool",
                    "float",
                    "tuple[typing.Union[float,float]]",
                    "list[str]",
                    "typing.Callable[str, bool]"
                ],
                "logdir": [
                    "str",
                    "int",
                    "list[str]",
                    "None"
                ],
                "log_eval_mode": [],
                "global_step": [
                    "None",
                    "float"
                ],
                "metrics": [
                    "None",
                    "bool",
                    "typing.Any",
                    "typing.Type",
                    "tuple[typing.Union[str,str]]",
                    "str"
                ],
                "callbacks": [
                    "None",
                    "typing.Any",
                    "bool",
                    "typing.Type"
                ]
            }
        },
        "Trainer.context": {
            "name": "context",
            "location": 149,
            "return": [
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "_context": []
            }
        },
        "Trainer._generate_checkpoint_map": {
            "name": "_generate_checkpoint_map",
            "location": 159,
            "return": [
                "dict[, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._write_checkpoint_map": {
            "name": "_write_checkpoint_map",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "typing.Sequence[str]",
                    "None",
                    "list[]",
                    "list[str]"
                ]
            }
        },
        "Trainer._check_name_collision": {
            "name": "_check_name_collision",
            "location": 168,
            "return": [
                "None"
            ],
            "arguments": {
                "objects": [
                    "list[]",
                    "str"
                ],
                "obj_type": [
                    "str"
                ]
            }
        },
        "Trainer._validate_metrics": {
            "name": "_validate_metrics",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._validate_callbacks": {
            "name": "_validate_callbacks",
            "location": 181,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._update_metrics": {
            "name": "_update_metrics",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metrics": [
                    "str"
                ]
            }
        },
        "Trainer._update_checkpoint": {
            "name": "_update_checkpoint",
            "location": 192,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ckpt_dict": [
                    "dict[, ]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "Trainer._update_global_batch_size": {
            "name": "_update_global_batch_size",
            "location": 203,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [],
                "executors": [
                    "None",
                    "int",
                    "typing.Collection",
                    "typing.Deque"
                ]
            }
        },
        "Trainer._reduce": {
            "name": "_reduce",
            "location": 239,
            "return": [],
            "arguments": {
                "self": [],
                "per_replica_tensor": [
                    "float",
                    "None"
                ],
                "reduce_op": [
                    "float",
                    "None"
                ]
            }
        },
        "Trainer._restore_or_init": {
            "name": "_restore_or_init",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._save": {
            "name": "_save",
            "location": 272,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._current_epoch": {
            "name": "_current_epoch",
            "location": 280,
            "return": [
                "int",
                "list[int]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._log_metrics_and_reset": {
            "name": "_log_metrics_and_reset",
            "location": 295,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.measure_metrics": {
            "name": "measure_metrics",
            "location": 303,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.model_selection": {
            "name": "model_selection",
            "location": 308,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._measure_performance_if_needed": {
            "name": "_measure_performance_if_needed",
            "location": 321,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "example": [
                    "int",
                    "list[str]",
                    "float"
                ],
                "measure_performance_freq": [
                    "int"
                ]
            }
        },
        "Trainer._measure_performance": {
            "name": "_measure_performance",
            "location": 344,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._dataset_from_example": {
            "name": "_dataset_from_example",
            "location": 350,
            "return": [],
            "arguments": {
                "self": [],
                "example": [
                    "typing.Mapping",
                    "bytearray"
                ],
                "dims": [
                    "float",
                    "typing.Sequence[float]",
                    "tuple[typing.Union[int,int]]",
                    "tuple[]"
                ]
            }
        },
        "Trainer.local_example": {
            "name": "local_example",
            "location": 361,
            "return": [
                "tuple[tuple[]]"
            ],
            "arguments": {
                "self": [],
                "example": [
                    "list[list[int]]",
                    "str"
                ],
                "dims": [
                    "str"
                ]
            }
        },
        "Trainer._build_and_restore_models": {
            "name": "_build_and_restore_models",
            "location": 395,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "bool",
                    "list[dict[str, typing.Any]]",
                    "str",
                    "list[]"
                ]
            }
        },
        "Trainer.call": {
            "name": "call",
            "location": 399,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer.__call__": {
            "name": "__call__",
            "location": 402,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_train_start": {
            "name": "_on_train_start",
            "location": 412,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_train_end": {
            "name": "_on_train_end",
            "location": 417,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_epoch_start": {
            "name": "_on_epoch_start",
            "location": 423,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_epoch_end": {
            "name": "_on_epoch_end",
            "location": 429,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_batch_start": {
            "name": "_on_batch_start",
            "location": 439,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_batch_end": {
            "name": "_on_batch_end",
            "location": 444,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._on_exception": {
            "name": "_on_exception",
            "location": 449,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/src/ashpy/trainers/__init__.py": {},
    "ashpy-master/src/ashpy/utils/utils.py": {
        "validate_objects": {
            "name": "validate_objects",
            "location": 21,
            "return": [
                "bool"
            ],
            "arguments": {
                "elements": [
                    "list"
                ],
                "element_class": [
                    "type"
                ]
            }
        },
        "log": {
            "name": "log",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "out": [
                    "str",
                    "bool",
                    "int"
                ],
                "step": [
                    "str",
                    "typing.Callable[str, int]",
                    "tensorflow.Variable",
                    "Callable[[str], int]",
                    "tensorflow.Tensor"
                ]
            }
        }
    },
    "ashpy-master/src/ashpy/utils/__init__.py": {},
    "ashpy-master/tests/test_losses.py": {
        "test_losses": {
            "name": "test_losses",
            "location": 28,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "loss_type": [
                    "str"
                ],
                "tmpdir": [
                    "str",
                    "bool",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "ashpy-master/tests/test_metrics.py": {
        "cleanup": {
            "name": "cleanup",
            "location": 36,
            "return": [
                "",
                "typing.Generator[typing.Text]"
            ],
            "arguments": {}
        },
        "get_metric_data": {
            "name": "get_metric_data",
            "location": 46,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "metric": [
                    "str",
                    "pathlib.Path"
                ],
                "tmpdir": [
                    "str",
                    "bool",
                    "list[str]",
                    "List[str]",
                    "pathlib.Path"
                ]
            }
        },
        "test_metrics_log": {
            "name": "test_metrics_log",
            "location": 61,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "pathlib.Path",
                    "path.Path"
                ],
                "tmpdir": [
                    "tests.setup.SetupTest"
                ],
                "cleanup": [
                    "tests.basilisp.helpers.CompileFn",
                    "tests.setup.SetupTest"
                ]
            }
        },
        "test_metrics_names_collision": {
            "name": "test_metrics_names_collision",
            "location": 106,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str",
                    "tests.basilisp.helpers.CompileFn",
                    "pathlib.Path",
                    "cli_ui.tests.MessageRecorder"
                ]
            }
        },
        "test_metrics_on_restart": {
            "name": "test_metrics_on_restart",
            "location": 127,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "str",
                    "float",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ],
                "tmpdir": [
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_metric_precision": {
            "name": "test_metric_precision",
            "location": 152,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "pathlib.Path",
                    "path.Path"
                ],
                "tmpdir": [
                    "pathlib.Path",
                    "path.Path"
                ],
                "capsys": [
                    "Mapping[str, Any]",
                    "str"
                ]
            }
        },
        "test_metric_precision.FakeMetric.__init__": {
            "name": "__init__",
            "location": 169,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "typing.Text",
                    "str",
                    "Optional[bool]",
                    "Optional[Any]"
                ],
                "model_selection_operator": [
                    "str",
                    "Optional[bool]",
                    "Optional[Any]"
                ]
            }
        },
        "test_metric_precision.FakeMetric.update_state": {
            "name": "update_state",
            "location": 189,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "context": [
                    "ashpy.contexts.GANContext",
                    "ashpy.contexts.Context",
                    "bool",
                    "Sequence[int]",
                    "str"
                ]
            }
        }
    },
    "ashpy-master/tests/test_restorers.py": {
        "_check_models_weights": {
            "name": "_check_models_weights",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "trained": [
                    "int",
                    "str"
                ],
                "restored": [
                    "bool",
                    "str",
                    "typing.Mapping",
                    "None"
                ],
                "i": [
                    "int"
                ]
            }
        },
        "_test_restore_object": {
            "name": "_test_restore_object",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "restorer": [],
                "placeholder": [
                    "str",
                    "bytes"
                ],
                "ckpt_id": [],
                "capsys": [
                    "int",
                    "str",
                    "bytearray"
                ]
            }
        },
        "_check_log": {
            "name": "_check_log",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "restorer": [
                    "str",
                    "list[str]"
                ],
                "ckpt_id": [
                    "str",
                    "list[str]"
                ],
                "capsys": []
            }
        },
        "test_restore_model": {
            "name": "test_restore_model",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "str"
                ],
                "capsys": [],
                "tmpdir": []
            }
        },
        "test_restore_common_variables": {
            "name": "test_restore_common_variables",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "fake_training_fn": [],
                "capsys": [],
                "tmpdir": []
            }
        },
        "test_restore_callbacks": {
            "name": "test_restore_callbacks",
            "location": 160,
            "return": [
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "str",
                    "float"
                ],
                "capsys": [
                    "int"
                ],
                "tmpdir": [
                    "bytes"
                ]
            }
        },
        "test_read_checkpoint_map": {
            "name": "test_read_checkpoint_map",
            "location": 184,
            "return": [
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "str",
                    "float"
                ],
                "tmpdir": [
                    "bytes"
                ]
            }
        },
        "_test_convenience_model_restorer": {
            "name": "_test_convenience_model_restorer",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {
                "restorer": [
                    "int",
                    "str",
                    "None",
                    "float",
                    "tuple[typing.Union[int,str]]"
                ],
                "convenience_method": [
                    "str",
                    "None"
                ],
                "placeholder_model": [
                    "str",
                    "int",
                    "dict[int, tuple[typing.Union[str,str,str,str]]]",
                    "list[str]",
                    "None"
                ],
                "trained_model": [
                    "str",
                    "bool",
                    "list[dict[str, str]]"
                ],
                "ckpt_id": [
                    "int",
                    "str",
                    "None",
                    "float",
                    "tuple[typing.Union[int,str]]"
                ],
                "capsys": [
                    "int",
                    "str",
                    "None",
                    "float",
                    "tuple[typing.Union[int,str]]"
                ]
            }
        },
        "_test_convenience_optimizer_restorer": {
            "name": "_test_convenience_optimizer_restorer",
            "location": 219,
            "return": [
                "None"
            ],
            "arguments": {
                "restorer": [
                    "int",
                    "str",
                    "list[tensorflow.Tensor]",
                    "None"
                ],
                "convenience_method": [
                    "int",
                    "list[float]",
                    "str"
                ],
                "placeholder_optimizer": [
                    "int",
                    "list[float]",
                    "str"
                ],
                "ckpt_id": [
                    "int",
                    "str",
                    "list[tensorflow.Tensor]",
                    "None"
                ],
                "capsys": [
                    "int",
                    "str",
                    "list[tensorflow.Tensor]",
                    "None"
                ]
            }
        },
        "test_convenience_restorer": {
            "name": "test_convenience_restorer",
            "location": 231,
            "return": [
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "bool",
                    "float"
                ],
                "capsys": [],
                "tmpdir": [
                    "int"
                ]
            }
        },
        "test_failings": {
            "name": "test_failings",
            "location": 346,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": []
            }
        }
    },
    "ashpy-master/tests/test_trainers.py": {
        "test_correct_trainer_restoration_on_restart": {
            "name": "test_correct_trainer_restoration_on_restart",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "tests.e2e.Helper"
                ],
                "tmpdir": [
                    "bytes",
                    "pathlib.Path",
                    "tests.basilisp.helpers.CompileFn"
                ]
            }
        },
        "test_generate_human_ckpt_dict": {
            "name": "test_generate_human_ckpt_dict",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "fake_training_fn": [
                    "pathlib.Path"
                ],
                "tmpdir": [
                    "pathlib.Path"
                ]
            }
        }
    },
    "ashpy-master/tests/__init__.py": {},
    "ashpy-master/tests/callbacks/test_callbacks.py": {
        "test_callbacks": {
            "name": "test_callbacks",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str",
                    "float",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        }
    },
    "ashpy-master/tests/callbacks/test_counter_callback.py": {
        "_models": {
            "name": "_models",
            "location": 36,
            "return": [
                "tuple[typing.Union[float,int]]",
                "Callable",
                "Optional[str]",
                "Type"
            ],
            "arguments": {}
        },
        "test_counter_callback_multiple_events": {
            "name": "test_counter_callback_multiple_events",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_counter_callback": {
            "name": "test_counter_callback",
            "location": 76,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "_models": [
                    "str",
                    "int",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ],
                "tmpdir": [
                    "str",
                    "int",
                    "tests.basilisp.helpers.CompileFn",
                    "tests.async_mock.Mock"
                ]
            }
        },
        "FakeCounterCallback.__init__": {
            "name": "__init__",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FakeCounterCallback.on_event": {
            "name": "on_event",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "typing.Mapping",
                    "Mapping[str, Any]",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "list[E]",
                    "Event",
                    "List[aw_core.Event]"
                ],
                "context": [
                    "dict[, ]",
                    "dict",
                    "dict[str, typing.Any]",
                    "list[E]",
                    "leabra7.events.Event",
                    "events.Event",
                    "Dict[str, Any]",
                    "List[aw_core.models.Event]",
                    "cmk.utils.type_defs.HostAddress"
                ]
            }
        }
    },
    "ashpy-master/tests/callbacks/test_custom_callback.py": {
        "get_n_events_from_epochs": {
            "name": "get_n_events_from_epochs",
            "location": 43,
            "return": [
                "int",
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "event": [
                    "bool",
                    "ashpy.callbacks.events.Event",
                    "None",
                    "list[typing.Optional[str]]",
                    "int",
                    "Optional[int]",
                    "List[Optional[str]]"
                ],
                "epochs": [
                    "int",
                    "bytes"
                ],
                "dataset_size": [
                    "int",
                    "bytes"
                ],
                "batch_size": [
                    "int",
                    "bytes"
                ]
            }
        },
        "test_custom_callbacks": {
            "name": "test_custom_callbacks",
            "location": 59,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "int"
                ],
                "event": [
                    "int",
                    "asyncio.Event"
                ]
            }
        },
        "MCallback.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "str",
                    "dict[str, typing.Any]",
                    "threading.Event",
                    "Event",
                    "events.Event",
                    "Dict[str, Any]",
                    "raiden_libs.events.Event"
                ]
            }
        },
        "MCallback.on_event": {
            "name": "on_event",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "event": [
                    "str",
                    "threading.Event",
                    "Event",
                    "events.Event",
                    "raiden_libs.events.Event",
                    "edp.journal.Event"
                ],
                "context": [
                    "bool",
                    "str",
                    "Event",
                    "dict[, ]",
                    "dict[str, typing.Any]",
                    "ashpy.contexts.Context",
                    "ashpy.callbacks.events.Event",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "ashpy-master/tests/callbacks/test_save_callback.py": {
        "test_save_callback_compatible": {
            "name": "test_save_callback_compatible",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str",
                    "tuple[typing.Union[str,str,str]]",
                    "Tuple[str, str, str]",
                    "pathlib.Path"
                ],
                "save_format_and_sub_format": [
                    "str",
                    "bool",
                    "int",
                    "zerver.models.Realm"
                ],
                "save_dir": [
                    "str",
                    "typing.Iterable[str]",
                    "pathlib.Path",
                    "Iterable[str]",
                    "Tuple[str, str, str]"
                ]
            }
        },
        "test_save_callback_incompatible": {
            "name": "test_save_callback_incompatible",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str",
                    "tuple[typing.Union[str,str,str]]",
                    "Tuple[str, str, str]",
                    "pathlib.Path"
                ],
                "save_format_and_sub_format": [
                    "str",
                    "bool",
                    "int",
                    "zerver.models.Realm"
                ],
                "save_dir": [
                    "str",
                    "pathlib.Path"
                ]
            }
        },
        "_test_save_callback_helper": {
            "name": "_test_save_callback_helper",
            "location": 73,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "bool",
                    "str",
                    "tests.test_util.aiohttp.AiohttpClientMocker",
                    "cli_ui.tests.MessageRecorder"
                ],
                "save_format": [
                    "str",
                    "models.characters.ai_base.AI",
                    "cmk.utils.type_defs.UserId"
                ],
                "save_sub_format": [
                    "str",
                    "models.characters.ai_base.AI",
                    "cmk.utils.type_defs.UserId"
                ],
                "save_dir": [
                    "str",
                    "models.characters.ai_base.AI",
                    "cmk.utils.type_defs.UserId"
                ]
            }
        },
        "test_save_callback_type_error": {
            "name": "test_save_callback_type_error",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "save_dir": [
                    "str",
                    "bool",
                    "pathlib.Path",
                    "list[str]",
                    "List[str]"
                ]
            }
        }
    },
    "ashpy-master/tests/callbacks/__init__.py": {},
    "ashpy-master/tests/utils/fake_datasets.py": {
        "fake_autoencoder_datasest": {
            "name": "fake_autoencoder_datasest",
            "location": 20,
            "return": [
                "int",
                "str",
                "Callable",
                "dict[int, int]"
            ],
            "arguments": {
                "dataset_size": [
                    "int"
                ],
                "image_resolution": [
                    "int",
                    "tuple[int]"
                ],
                "channels": [
                    "int"
                ],
                "batch_size": [
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "fake_adversarial_dataset": {
            "name": "fake_adversarial_dataset",
            "location": 45,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "image_resolution": [
                    "int",
                    "tuple[int]"
                ],
                "epochs": [
                    "int",
                    "bool",
                    "str",
                    "Iterable[Any]"
                ],
                "dataset_size": [
                    "int"
                ],
                "batch_size": [
                    "int",
                    "tuple",
                    "str",
                    "float"
                ],
                "latent_dim": [
                    "int",
                    "bool",
                    "float"
                ],
                "channels": [
                    "int"
                ]
            }
        }
    },
    "ashpy-master/tests/utils/fake_models.py": {
        "conv_autoencoder": {
            "name": "conv_autoencoder",
            "location": 22,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "layer_spec_input_res": [
                    "tuple[int]",
                    "int",
                    "float",
                    "bool"
                ],
                "layer_spec_target_res": [
                    "tuple[int]",
                    "int",
                    "float",
                    "bool"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "bool"
                ],
                "initial_filters": [
                    "int",
                    "float",
                    "bool"
                ],
                "filters_cap": [
                    "int",
                    "float",
                    "bool"
                ],
                "encoding_dimension": [
                    "int",
                    "float",
                    "bool"
                ],
                "channels": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "basic_dcgan": {
            "name": "basic_dcgan",
            "location": 49,
            "return": [
                "Tuple[(Union[(ashpy.models.convolutional.decoders.Decoder, _T10)], Union[(ashpy.models.convolutional.encoders.Encoder, _T11)])]"
            ],
            "arguments": {
                "image_resolution": [
                    "tuple[int]",
                    "int",
                    "bool",
                    "float"
                ],
                "layer_spec_input_res": [
                    "tuple[int]",
                    "int",
                    "bool",
                    "float"
                ],
                "layer_spec_target_res": [
                    "tuple[int]",
                    "int",
                    "bool",
                    "float"
                ],
                "kernel_size": [
                    "tuple[int]",
                    "int",
                    "bool",
                    "float"
                ],
                "initial_filters_g": [
                    "int",
                    "bool",
                    "float"
                ],
                "initial_filters_d": [
                    "float",
                    "int"
                ],
                "filters_cap_g": [
                    "int",
                    "bool",
                    "float"
                ],
                "filters_cap_d": [
                    "float",
                    "int"
                ],
                "output_shape": [
                    "float",
                    "int"
                ],
                "channels": [
                    "int",
                    "bool",
                    "float"
                ],
                "generator": [
                    "10"
                ],
                "discriminator": [
                    "11"
                ]
            }
        }
    },
    "ashpy-master/tests/utils/fake_training_loop.py": {
        "FakeClassifierTraining.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "logdir": [
                    "typing.Text",
                    "bytes",
                    "str",
                    "bool",
                    "Optional[dict]",
                    "float",
                    "int"
                ],
                "optimizer": [
                    "bytes",
                    "str",
                    "bool",
                    "float",
                    "Optional[dict]",
                    "dict[, ]",
                    "None",
                    "int"
                ],
                "metrics": [
                    "list[]",
                    "bytes",
                    "str",
                    "bool",
                    "Optional[dict]",
                    "float",
                    "int"
                ],
                "epochs": [
                    "int",
                    "bytes",
                    "str",
                    "bool",
                    "Optional[dict]",
                    "float"
                ],
                "dataset_size": [
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "image_resolution": [
                    "tuple[int]",
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "Optional[int]",
                    "str",
                    "bool"
                ],
                "layer_spec_input_res": [
                    "tuple[int]",
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "layer_spec_target_res": [
                    "tuple[int]",
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "kernel_size": [
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "initial_filters": [
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "filters_cap": [
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "encoding_dimension": [
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "channels": [
                    "int",
                    "Dict[str, int]",
                    "Optional[object]",
                    "float",
                    "Optional[Callable]"
                ],
                "measure_performance_freq": [
                    "int",
                    "bytes",
                    "str",
                    "bool",
                    "Optional[dict]",
                    "float"
                ]
            }
        },
        "FakeClassifierTraining.build_trainer": {
            "name": "build_trainer",
            "location": 99,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FakeClassifierTraining.__call__": {
            "name": "__call__",
            "location": 109,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FakeAdversarialTraining.__init__": {
            "name": "__init__",
            "location": 122,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "logdir": [
                    "typing.Text",
                    "float",
                    "bool",
                    "int"
                ],
                "kernel_size": [
                    "tuple[int]",
                    "float",
                    "list",
                    "List[int]"
                ],
                "metrics": [
                    "None",
                    "str",
                    "bool",
                    "Optional[str]",
                    "list[str]",
                    "Optional[int]",
                    "Union[None, int]",
                    "Optional[List[str]]",
                    "int",
                    "List[str]"
                ],
                "callbacks": [
                    "None",
                    "str",
                    "bool",
                    "Optional[str]",
                    "list[str]",
                    "Optional[int]",
                    "Union[None, int]",
                    "Optional[List[str]]",
                    "int",
                    "List[str]"
                ],
                "epochs": [
                    "int",
                    "Tuple[int, int]",
                    "Callable"
                ],
                "dataset_size": [
                    "int",
                    "Tuple[int, int]",
                    "List[int]",
                    "List[float]",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "Tuple[int, int]",
                    "List[int]",
                    "List[float]",
                    "float"
                ],
                "generator_loss": [
                    "GeneratorBCE",
                    "float",
                    "bool",
                    "int"
                ],
                "discriminator_loss": [
                    "DiscriminatorMinMax",
                    "float",
                    "bool",
                    "int"
                ],
                "image_resolution": [
                    "tuple[int]",
                    "float",
                    "list",
                    "List[int]"
                ],
                "layer_spec_input_res": [
                    "tuple[int]",
                    "float",
                    "list",
                    "List[int]"
                ],
                "layer_spec_target_res": [
                    "tuple[int]",
                    "float",
                    "list",
                    "List[int]"
                ],
                "channels": [
                    "int",
                    "float",
                    "list",
                    "List[int]"
                ],
                "output_shape": [
                    "int",
                    "float",
                    "list",
                    "List[int]"
                ],
                "latent_dim": [
                    "int",
                    "Tuple[int, int]",
                    "List[int]",
                    "List[float]",
                    "float"
                ],
                "measure_performance_freq": [
                    "int",
                    "float",
                    "bool"
                ],
                "generator": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.Balance"
                ],
                "discriminator": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "raiden.utils.PaymentWithFeeAmount",
                    "raiden.utils.Balance"
                ]
            }
        },
        "FakeAdversarialTraining.__call__": {
            "name": "__call__",
            "location": 192,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FakeAdversarialTraining.build_trainer": {
            "name": "build_trainer",
            "location": 198,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "ashpy-master/tests/utils/__init__.py": {}
}
{
    "classic_cs_problems_python-master/CH1_small_problems/calculating_pi.py": {
        "calculate_pi": {
            "name": "calculate_pi",
            "location": 1,
            "return": [
                "float"
            ],
            "arguments": {
                "n_terms": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib1.py": {
        "fib1": {
            "name": "fib1",
            "location": 3,
            "return": [
                "str",
                "int",
                "dict"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib2.py": {
        "fib2": {
            "name": "fib2",
            "location": 3,
            "return": [
                "int",
                "str",
                "bool"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib3.py": {
        "fib3": {
            "name": "fib3",
            "location": 14,
            "return": [
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib4.py": {
        "fib4": {
            "name": "fib4",
            "location": 7,
            "return": [
                "int",
                "str",
                "bool"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib5.py": {
        "fib5": {
            "name": "fib5",
            "location": 8,
            "return": [
                "Union[(int, _T0)]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib6.py": {
        "fib6": {
            "name": "fib6",
            "location": 6,
            "return": [
                "Generator[(int, Any, None)]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/hanoi.py": {
        "hanoi": {
            "name": "hanoi",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "begin": [
                    "List[float]",
                    "int"
                ],
                "end": [
                    "int",
                    "List[float]"
                ],
                "temp": [
                    "int",
                    "str",
                    "FrozenSet[int]",
                    "frozenset"
                ],
                "n": [
                    "int",
                    "FrozenSet[int]",
                    "str"
                ]
            }
        },
        "Stack.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.push": {
            "name": "push",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "str",
                    "List[Deque]",
                    "Callable",
                    "T",
                    "List[deque]"
                ]
            }
        },
        "Stack.pop": {
            "name": "pop",
            "location": 13,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__repr__": {
            "name": "__repr__",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/trivial_compression.py": {
        "CompressedGene.__init__": {
            "name": "__init__",
            "location": 2,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "gene": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "CompressedGene._compress": {
            "name": "_compress",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "gene": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "CompressedGene.decompress": {
            "name": "decompress",
            "location": 20,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompressedGene.__str__": {
            "name": "__str__",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/unbreakable_encryption.py": {
        "random_key": {
            "name": "random_key",
            "location": 5,
            "return": [
                "int"
            ],
            "arguments": {
                "length": [
                    "int",
                    "str",
                    "bytes",
                    "bool"
                ]
            }
        },
        "encrypt": {
            "name": "encrypt",
            "location": 12,
            "return": [
                "Tuple[(int, int)]"
            ],
            "arguments": {
                "original": [
                    "str",
                    "Dict",
                    "bytes"
                ]
            }
        },
        "decrypt": {
            "name": "decrypt",
            "location": 20,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "key1": [
                    "int",
                    "str",
                    "Union[str,int]",
                    "KT"
                ],
                "key2": [
                    "int",
                    "str",
                    "Union[str,int]",
                    "KT"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/dna_search.py": {
        "string_to_gene": {
            "name": "string_to_gene",
            "location": 12,
            "return": [
                "List[Tuple[(Any, Any, Any)]]"
            ],
            "arguments": {
                "s": [
                    "str",
                    "int"
                ]
            }
        },
        "linear_contains": {
            "name": "linear_contains",
            "location": 26,
            "return": [
                "bool"
            ],
            "arguments": {
                "gene": [
                    "str",
                    "Callable"
                ],
                "key_codon": [
                    "str",
                    "int"
                ]
            }
        },
        "binary_contains": {
            "name": "binary_contains",
            "location": 43,
            "return": [
                "bool"
            ],
            "arguments": {
                "gene": [
                    "int",
                    "KT",
                    "str"
                ],
                "key_codon": [
                    "str",
                    "int",
                    "slice"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/generic_search.py": {
        "linear_contains": {
            "name": "linear_contains",
            "location": 21,
            "return": [
                "bool"
            ],
            "arguments": {
                "iterable": [
                    "str",
                    "Callable"
                ],
                "key": [
                    "str",
                    "T",
                    "int",
                    "None",
                    "Optional[str]"
                ]
            }
        },
        "binary_contains": {
            "name": "binary_contains",
            "location": 48,
            "return": [
                "bool"
            ],
            "arguments": {
                "sequence": [
                    "int",
                    "float"
                ],
                "key": [
                    "str",
                    "Sequence[str]",
                    "bytes",
                    "int"
                ]
            }
        },
        "dfs": {
            "name": "dfs",
            "location": 133,
            "return": [
                "Optional[Node]"
            ],
            "arguments": {
                "initial": [
                    "Set[T]",
                    "bool",
                    "T"
                ],
                "goal_test": [
                    "Callable[[T],bool]",
                    "str",
                    "Callable[T,bool]",
                    "bytes",
                    "Dict"
                ],
                "successors": [
                    "Callable[T,list[T]]",
                    "int",
                    "Callable[[T],List[T]]",
                    "Dict[str,Any]",
                    "bool"
                ]
            }
        },
        "bfs": {
            "name": "bfs",
            "location": 158,
            "return": [
                "List",
                "str",
                "Optional[str]",
                "None",
                "bool",
                "Optional[BaseException]",
                "Dict"
            ],
            "arguments": {
                "initial": [
                    "Set[T]",
                    "bool",
                    "T"
                ],
                "goal_test": [
                    "Callable[[T],bool]",
                    "str",
                    "Callable[T,bool]",
                    "bytes",
                    "Dict"
                ],
                "successors": [
                    "Callable[T,list[T]]",
                    "int",
                    "Callable[[T],List[T]]",
                    "Dict[str,Any]",
                    "bool"
                ]
            }
        },
        "astar": {
            "name": "astar",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "initial": [
                    "bool",
                    "T",
                    "Dict[str,Any]",
                    "Any",
                    "Optional[Union[Any,Any]]",
                    "None"
                ],
                "goal_test": [
                    "Callable[[T],bool]",
                    "str",
                    "Callable[T,bool]",
                    "bytes",
                    "Dict"
                ],
                "successors": [
                    "Callable[T,list[T]]",
                    "int",
                    "Callable[[T],List[T]]",
                    "Dict[str,Any]",
                    "bool"
                ],
                "heuristic": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None"
                ]
            }
        },
        "node_to_path": {
            "name": "node_to_path",
            "location": 212,
            "return": [
                "list"
            ],
            "arguments": {
                "node": [
                    "Dict[str,Any]",
                    "List[str]"
                ]
            }
        },
        "Comparable.__eq__": {
            "name": "__eq__",
            "location": 32,
            "return": [
                "bool",
                "None"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "List[str]",
                    "SupportsFloat",
                    "int",
                    "Union[int,float]",
                    "float",
                    "AbstractSet[T]",
                    "AbstractSet"
                ]
            }
        },
        "Comparable.__lt__": {
            "name": "__lt__",
            "location": 35,
            "return": [
                "bool",
                "None"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "List[str]",
                    "SupportsFloat",
                    "int",
                    "Union[int,float]",
                    "float",
                    "AbstractSet[T]",
                    "AbstractSet"
                ]
            }
        },
        "Comparable.__gt__": {
            "name": "__gt__",
            "location": 38,
            "return": [
                "bool",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "T",
                    "Tuple[int, int]"
                ]
            }
        },
        "Comparable.__le__": {
            "name": "__le__",
            "location": 41,
            "return": [
                "bool",
                "Dict[str,Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "T",
                    "Tuple[int, int]"
                ]
            }
        },
        "Comparable.__ge__": {
            "name": "__ge__",
            "location": 44,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "List[str]",
                    "float",
                    "str",
                    "int"
                ]
            }
        },
        "Stack.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.empty": {
            "name": "empty",
            "location": 67,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.push": {
            "name": "push",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "str",
                    "List[Deque]",
                    "Callable",
                    "T",
                    "List[deque]"
                ]
            }
        },
        "Stack.pop": {
            "name": "pop",
            "location": 73,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__repr__": {
            "name": "__repr__",
            "location": 76,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__init__": {
            "name": "__init__",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.empty": {
            "name": "empty",
            "location": 85,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.push": {
            "name": "push",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "str",
                    "List[Deque]",
                    "Callable",
                    "T",
                    "List[deque]"
                ]
            }
        },
        "Queue.pop": {
            "name": "pop",
            "location": 91,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__repr__": {
            "name": "__repr__",
            "location": 94,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.__init__": {
            "name": "__init__",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.empty": {
            "name": "empty",
            "location": 103,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.push": {
            "name": "push",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "List",
                    "Dict[str,int]",
                    "Optional[Mapping]",
                    "Mapping",
                    "None"
                ]
            }
        },
        "PriorityQueue.pop": {
            "name": "pop",
            "location": 109,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.__repr__": {
            "name": "__repr__",
            "location": 112,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Node.__init__": {
            "name": "__init__",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "str",
                    "int",
                    "Optional[dict]",
                    "Dict",
                    "bool",
                    "None"
                ],
                "parent": [
                    "Optional[Mapping[str,Any]]",
                    "Mapping",
                    "Optional[Sequence[str]]",
                    "None",
                    "Sequence[str]"
                ],
                "cost": [
                    "float",
                    "Optional[int]"
                ],
                "heuristic": [
                    "float",
                    "Optional[int]"
                ]
            }
        },
        "Node.__lt__": {
            "name": "__lt__",
            "location": 129,
            "return": [
                "bool",
                "Optional[bool]",
                "float",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/maze.py": {
        "euclidean_distance": {
            "name": "euclidean_distance",
            "location": 92,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "goal": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "manhattan_distance": {
            "name": "manhattan_distance",
            "location": 101,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "goal": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Maze.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rows": [
                    "int",
                    "List[int]",
                    "Union[int,Sequence[int]]"
                ],
                "columns": [
                    "int",
                    "List[int]",
                    "Union[int,Sequence[int]]"
                ],
                "sparseness": [
                    "float",
                    "List",
                    "Dict[str,Any]",
                    "int",
                    "List[list]"
                ],
                "start": [
                    "MazeLocation"
                ],
                "goal": [
                    "MazeLocation",
                    "List",
                    "int"
                ]
            }
        },
        "Maze._randomly_fill": {
            "name": "_randomly_fill",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rows": [
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "columns": [
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "sparseness": [
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "Maze.__str__": {
            "name": "__str__",
            "location": 52,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Maze.goal_test": {
            "name": "goal_test",
            "location": 58,
            "return": [
                "bool",
                "int",
                "str",
                "Dict[str,int]"
            ],
            "arguments": {
                "self": [],
                "ml": [
                    "int",
                    "str",
                    "Dict[str,int]"
                ]
            }
        },
        "Maze.successors": {
            "name": "successors",
            "location": 61,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "ml": [
                    "float",
                    "Node"
                ]
            }
        },
        "Maze.mark": {
            "name": "mark",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "bool"
                ]
            }
        },
        "Maze.clear": {
            "name": "clear",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "bool"
                ]
            }
        },
        "euclidean_distance.distance": {
            "name": "distance",
            "location": 93,
            "return": [
                "Any"
            ],
            "arguments": {
                "ml": []
            }
        },
        "manhattan_distance.distance": {
            "name": "distance",
            "location": 102,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "ml": [
                    "int",
                    "bytes",
                    "list"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/missionaries.py": {
        "display_solution": {
            "name": "display_solution",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "MCState.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "missionaries": [
                    "int",
                    "str",
                    "List[str]"
                ],
                "cannibals": [
                    "int",
                    "str",
                    "List[str]"
                ],
                "boat": [
                    "bool",
                    "str",
                    "None",
                    "float",
                    "int",
                    "Optional[bool]"
                ]
            }
        },
        "MCState.__str__": {
            "name": "__str__",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MCState.goal_test": {
            "name": "goal_test",
            "location": 19,
            "return": [
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MCState.is_legal": {
            "name": "is_legal",
            "location": 23,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MCState.successors": {
            "name": "successors",
            "location": 30,
            "return": [
                "List[MCState]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/csp.py": {
        "Constraint.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variables": [
                    "Callable",
                    "Exception",
                    "str",
                    "bool",
                    "Dict[str,Union[str,None]]",
                    "Dict[str,Optional[str]]",
                    "eth.abc.SignedTransactionAPI"
                ]
            }
        },
        "Constraint.satisfied": {
            "name": "satisfied",
            "location": 16,
            "return": [
                "bool",
                "None"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "CSP.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variables": [
                    "bool"
                ],
                "domains": [
                    "str",
                    "List",
                    "List[str]",
                    "Callable[...,None]",
                    "object"
                ]
            }
        },
        "CSP.add_constraint": {
            "name": "add_constraint",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "constraint": [
                    "bool",
                    "Iterable[int]",
                    "Dict",
                    "List"
                ]
            }
        },
        "CSP.consistent": {
            "name": "consistent",
            "location": 42,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "variable": [],
                "assignment": []
            }
        },
        "CSP.backtracking_search": {
            "name": "backtracking_search",
            "location": 48,
            "return": [
                "Optional[bool]",
                "Dict",
                "Optional[str]",
                "None"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "List[str]",
                    "list",
                    "bytes",
                    "tuple",
                    "List[List[T]]",
                    "List[int]",
                    "List[List[Any]]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/map_coloring.py": {
        "MapColoringConstraint.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "place1": [
                    "str",
                    "bytes"
                ],
                "place2": [
                    "str",
                    "bytes"
                ]
            }
        },
        "MapColoringConstraint.satisfied": {
            "name": "satisfied",
            "location": 11,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/queens.py": {
        "QueensConstraint.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "columns": [
                    "List[int]",
                    "int"
                ]
            }
        },
        "QueensConstraint.satisfied": {
            "name": "satisfied",
            "location": 10,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[int,int]",
                    "int",
                    "Union[str,int]",
                    "str"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/send_more_money.py": {
        "SendMoreMoneyConstraint.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "letters": [
                    "Sequence[str]",
                    "List[str]",
                    "str",
                    "Dict[str,float]",
                    "Optional[str]",
                    "None",
                    "Union[Set[str],List[str]]",
                    "Set[str]"
                ]
            }
        },
        "SendMoreMoneyConstraint.satisfied": {
            "name": "satisfied",
            "location": 10,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "int",
                    "List[int]",
                    "Sequence[T]",
                    "Callable[[], float]",
                    "List[float]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/word_search.py": {
        "generate_grid": {
            "name": "generate_grid",
            "location": 14,
            "return": [
                "list"
            ],
            "arguments": {
                "rows": [
                    "int",
                    "Counter[int]",
                    "Counter"
                ],
                "columns": [
                    "int",
                    "Counter[int]",
                    "Counter"
                ]
            }
        },
        "display_grid": {
            "name": "display_grid",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "grid": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "generate_domain": {
            "name": "generate_domain",
            "location": 24,
            "return": [
                "List[list]"
            ],
            "arguments": {
                "word": [
                    "list",
                    "bool",
                    "List[int]",
                    "List[str]",
                    "List[Tuple]"
                ],
                "grid": [
                    "list",
                    "List[List[int]]",
                    "List[List[str]]",
                    "Iterator[int]",
                    "List[int]"
                ]
            }
        },
        "WordSearchConstraint.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "Sequence[str]",
                    "List[str]",
                    "str",
                    "Dict[str,float]",
                    "Optional[str]",
                    "None",
                    "Union[Set[str],List[str]]",
                    "Set[str]"
                ]
            }
        },
        "WordSearchConstraint.satisfied": {
            "name": "satisfied",
            "location": 53,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[int,int]",
                    "int",
                    "str"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/dijkstra.py": {
        "dijkstra": {
            "name": "dijkstra",
            "location": 24,
            "return": [
                "Tuple[(list, dict)]"
            ],
            "arguments": {
                "wg": [
                    "weighted_graph.WeightedGraph[V]",
                    "int",
                    "bytes",
                    "List[int]"
                ],
                "root": [
                    "int",
                    "bytes",
                    "weighted_graph.WeightedGraph[V]"
                ]
            }
        },
        "distance_array_to_vertex_dict": {
            "name": "distance_array_to_vertex_dict",
            "location": 54,
            "return": [
                "dict"
            ],
            "arguments": {
                "wg": [
                    "Dict",
                    "weighted_graph.WeightedGraph[V]",
                    "None",
                    "Optional[Iterable[T]]"
                ],
                "distances": [
                    "List[Optional[float]]",
                    "Dict[str, Any]",
                    "dict",
                    "str"
                ]
            }
        },
        "path_dict_to_path": {
            "name": "path_dict_to_path",
            "location": 65,
            "return": [
                "list"
            ],
            "arguments": {
                "start": [
                    "int",
                    "str",
                    "bool"
                ],
                "end": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "List[int]",
                    "bytes",
                    "float",
                    "Optional[type]"
                ],
                "path_dict": [
                    "bool",
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        },
        "DijkstraNode.__lt__": {
            "name": "__lt__",
            "location": 17,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[str,Date]",
                    "str",
                    "Type",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        },
        "DijkstraNode.__eq__": {
            "name": "__eq__",
            "location": 20,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[str,Date]",
                    "str",
                    "Type",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/edge.py": {
        "Edge.reversed": {
            "name": "reversed",
            "location": 10,
            "return": [
                "Edge"
            ],
            "arguments": {
                "self": [
                    "_TEdge@@Edge@@"
                ]
            }
        },
        "Edge.__str__": {
            "name": "__str__",
            "location": 13,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/graph.py": {
        "Graph.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "List",
                    "List[SqlFile]",
                    "int",
                    "List[LoadableRelation]"
                ]
            }
        },
        "Graph.vertex_count": {
            "name": "vertex_count",
            "location": 13,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Graph.edge_count": {
            "name": "edge_count",
            "location": 17,
            "return": [
                "bool",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Graph.add_vertex": {
            "name": "add_vertex",
            "location": 21,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "float",
                    "int"
                ]
            }
        },
        "Graph.add_edge": {
            "name": "add_edge",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "edge": [
                    "int",
                    "List[List[int]]"
                ]
            }
        },
        "Graph.add_edge_by_indices": {
            "name": "add_edge_by_indices",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "int"
                ],
                "v": [
                    "int"
                ]
            }
        },
        "Graph.add_edge_by_vertices": {
            "name": "add_edge_by_vertices",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "first": [
                    "bool",
                    "List[int]",
                    "int"
                ],
                "second": [
                    "bool",
                    "List[int]",
                    "int"
                ]
            }
        },
        "Graph.vertex_at": {
            "name": "vertex_at",
            "location": 43,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Graph.index_of": {
            "name": "index_of",
            "location": 47,
            "return": [
                "Iterable[T]",
                "str",
                "Callable[[T], bool]"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "int",
                    "str",
                    "Sequence[int]",
                    "Optional[Collection[int]]",
                    "Collection",
                    "None"
                ]
            }
        },
        "Graph.neighbors_for_index": {
            "name": "neighbors_for_index",
            "location": 51,
            "return": [
                "List[nothing]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "List",
                    "str"
                ]
            }
        },
        "Graph.neighbors_for_vertex": {
            "name": "neighbors_for_vertex",
            "location": 55,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "Optional[Collection[int]]",
                    "int",
                    "Collection",
                    "str",
                    "None"
                ]
            }
        },
        "Graph.edges_for_index": {
            "name": "edges_for_index",
            "location": 59,
            "return": [
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "float"
                ]
            }
        },
        "Graph.edges_for_vertex": {
            "name": "edges_for_vertex",
            "location": 63,
            "return": [
                "bool",
                "Optional[str]",
                "str",
                "Optional[Sequence[str]]",
                "Optional[Callable]",
                "Dict[str, Union[str, int]]"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "Optional[Collection[int]]",
                    "int",
                    "Collection",
                    "str",
                    "None"
                ]
            }
        },
        "Graph.__str__": {
            "name": "__str__",
            "location": 67,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/mst.py": {
        "total_weight": {
            "name": "total_weight",
            "location": 10,
            "return": [
                "bool",
                "List[str]",
                "str",
                "int"
            ],
            "arguments": {
                "wp": [
                    "str",
                    "List[dict[str,Any]]",
                    "Callable[,Any]",
                    "int",
                    "List[Dict[str,Any]]"
                ]
            }
        },
        "mst": {
            "name": "mst",
            "location": 14,
            "return": [
                "Optional[list]"
            ],
            "arguments": {
                "wg": [
                    "bool",
                    "collections.abc.AsyncIterator",
                    "AsyncIterator[T]",
                    "collections.abc.AsyncIterable",
                    "AsyncIterable[T]",
                    "weighted_graph.WeightedGraph[V]"
                ],
                "start": [
                    "int",
                    "Dict"
                ]
            }
        },
        "print_weighted_path": {
            "name": "print_weighted_path",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "wg": [
                    "str",
                    "T"
                ],
                "wp": [
                    "str",
                    "T"
                ]
            }
        },
        "mst.visit": {
            "name": "visit",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "index": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/priority_queue.py": {
        "PriorityQueue.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.empty": {
            "name": "empty",
            "location": 12,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.push": {
            "name": "push",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "List",
                    "Dict[str,int]",
                    "Optional[Mapping]",
                    "Mapping",
                    "None"
                ]
            }
        },
        "PriorityQueue.pop": {
            "name": "pop",
            "location": 18,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.__repr__": {
            "name": "__repr__",
            "location": 21,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/weighted_edge.py": {
        "WeightedEdge.reversed": {
            "name": "reversed",
            "location": 10,
            "return": [
                "WeightedEdge"
            ],
            "arguments": {
                "self": [
                    "_TWeightedEdge@@WeightedEdge@@"
                ]
            }
        },
        "WeightedEdge.__lt__": {
            "name": "__lt__",
            "location": 14,
            "return": [
                "bool",
                "Optional[str]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[str,Date]",
                    "str",
                    "Type",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        },
        "WeightedEdge.__str__": {
            "name": "__str__",
            "location": 17,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/weighted_graph.py": {
        "WeightedGraph.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "List",
                    "List[SqlFile]",
                    "int",
                    "List[LoadableRelation]"
                ]
            }
        },
        "WeightedGraph.add_edge_by_indices": {
            "name": "add_edge_by_indices",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "Callable"
                ],
                "v": [
                    "Callable"
                ],
                "weight": [
                    "Callable"
                ]
            }
        },
        "WeightedGraph.add_edge_by_vertices": {
            "name": "add_edge_by_vertices",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "first": [
                    "bool",
                    "List[int]",
                    "int"
                ],
                "second": [
                    "bool",
                    "List[int]",
                    "int"
                ],
                "weight": [
                    "int"
                ]
            }
        },
        "WeightedGraph.neighbors_for_index_with_weights": {
            "name": "neighbors_for_index_with_weights",
            "location": 22,
            "return": [
                "List[Tuple[(Any, Any)]]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "float"
                ]
            }
        },
        "WeightedGraph.__str__": {
            "name": "__str__",
            "location": 28,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/chromosome.py": {
        "Chromosome.fitness": {
            "name": "fitness",
            "location": 11,
            "return": [
                "float",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Chromosome.random_instance": {
            "name": "random_instance",
            "location": 16,
            "return": [
                "T",
                "None"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ]
            }
        },
        "Chromosome.crossover": {
            "name": "crossover",
            "location": 20,
            "return": [
                "Tuple[T,T]",
                "None"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "List[str]",
                    "SupportsFloat",
                    "int",
                    "Union[int,float]",
                    "float",
                    "AbstractSet[T]",
                    "AbstractSet"
                ]
            }
        },
        "Chromosome.mutate": {
            "name": "mutate",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/genetic_algorithm.py": {
        "GeneticAlgorithm.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initial_population": [
                    "List",
                    "float",
                    "int"
                ],
                "threshold": [
                    "float",
                    "str"
                ],
                "max_generations": [
                    "int",
                    "str",
                    "List[str]"
                ],
                "mutation_chance": [
                    "float",
                    "str"
                ],
                "crossover_chance": [
                    "float",
                    "str"
                ],
                "selection_type": [
                    "str",
                    "Sequence[str]",
                    "int",
                    "BaseException",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "GeneticAlgorithm._pick_roulette": {
            "name": "_pick_roulette",
            "location": 34,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "wheel": [
                    "List",
                    "List[T]",
                    "List[float]",
                    "str",
                    "float"
                ]
            }
        },
        "GeneticAlgorithm._pick_tournament": {
            "name": "_pick_tournament",
            "location": 38,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "num_participants": [
                    "int",
                    "List[str]",
                    "Optional[int]",
                    "List",
                    "None"
                ]
            }
        },
        "GeneticAlgorithm._reproduce_and_replace": {
            "name": "_reproduce_and_replace",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneticAlgorithm._mutate": {
            "name": "_mutate",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneticAlgorithm.run": {
            "name": "run",
            "location": 72,
            "return": [
                "str",
                "int",
                "bool",
                "list"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/list_compression.py": {
        "ListCompression.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lst": [
                    "List",
                    "float",
                    "int",
                    "Dict",
                    "Iterable[int]"
                ]
            }
        },
        "ListCompression.bytes_compressed": {
            "name": "bytes_compressed",
            "location": 34,
            "return": [
                "bool",
                "Dict[str, List[str]]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListCompression.fitness": {
            "name": "fitness",
            "location": 37,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListCompression.random_instance": {
            "name": "random_instance",
            "location": 41,
            "return": [
                "ListCompression"
            ],
            "arguments": {
                "cls": [
                    "Type[_TListCompression]"
                ]
            }
        },
        "ListCompression.crossover": {
            "name": "crossover",
            "location": 46,
            "return": [
                "Tuple[(ListCompression, _T0)]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "ListCompression.mutate": {
            "name": "mutate",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListCompression.__str__": {
            "name": "__str__",
            "location": 61,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/send_more_money2.py": {
        "SendMoreMoney2.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "letters": [
                    "str",
                    "List[str]",
                    "Optional[List[str]]",
                    "None"
                ]
            }
        },
        "SendMoreMoney2.fitness": {
            "name": "fitness",
            "location": 13,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SendMoreMoney2.random_instance": {
            "name": "random_instance",
            "location": 29,
            "return": [
                "SendMoreMoney2"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSendMoreMoney2]"
                ]
            }
        },
        "SendMoreMoney2.crossover": {
            "name": "crossover",
            "location": 34,
            "return": [
                "Tuple[(SendMoreMoney2, _T0)]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "SendMoreMoney2.mutate": {
            "name": "mutate",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SendMoreMoney2.__str__": {
            "name": "__str__",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/simple_equation.py": {
        "SimpleEquation.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "y": [
                    "int"
                ]
            }
        },
        "SimpleEquation.fitness": {
            "name": "fitness",
            "location": 14,
            "return": [
                "str",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleEquation.random_instance": {
            "name": "random_instance",
            "location": 18,
            "return": [
                "SimpleEquation"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSimpleEquation]"
                ]
            }
        },
        "SimpleEquation.crossover": {
            "name": "crossover",
            "location": 21,
            "return": [
                "Tuple[(SimpleEquation, _T0)]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "int",
                    "Hashable",
                    "str",
                    "Collection"
                ]
            }
        },
        "SimpleEquation.mutate": {
            "name": "mutate",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleEquation.__str__": {
            "name": "__str__",
            "location": 40,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/data_point.py": {
        "DataPoint.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initial": [
                    "Dict[Union[str,str,str,str,str,str,str,str,str,str,str,str,str,str,str],Any]",
                    "str",
                    "Dict[str,Any]",
                    "Iterable[float]",
                    "float"
                ]
            }
        },
        "DataPoint.num_dimensions": {
            "name": "num_dimensions",
            "location": 12,
            "return": [
                "int",
                "str",
                "deque"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataPoint.distance": {
            "name": "distance",
            "location": 15,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Dict[str,Any]",
                    "Sequence[float]",
                    "Union[int,float]",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "DataPoint.__eq__": {
            "name": "__eq__",
            "location": 20,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Tuple[int,int,int]",
                    "Any",
                    "Tuple[Union[int,int,int]]"
                ]
            }
        },
        "DataPoint.__repr__": {
            "name": "__repr__",
            "location": 25,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/governors.py": {
        "Governor.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "longitude": [
                    "int",
                    "Dict[str,int]",
                    "float"
                ],
                "age": [
                    "float",
                    "Dict[str,int]"
                ],
                "state": [
                    "Sequence",
                    "bool",
                    "str"
                ]
            }
        },
        "Governor.__repr__": {
            "name": "__repr__",
            "location": 14,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/kmeans.py": {
        "zscores": {
            "name": "zscores",
            "location": 11,
            "return": [
                "list"
            ],
            "arguments": {
                "original": [
                    "Sequence[float]",
                    "float"
                ]
            }
        },
        "KMeans.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "int",
                    "float",
                    "bool",
                    "str",
                    "Tuple[str]"
                ],
                "points": [
                    "str"
                ]
            }
        },
        "KMeans._centroids": {
            "name": "_centroids",
            "location": 41,
            "return": [
                "List",
                "int",
                "str",
                "Optional[dict]",
                "Sequence[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._dimension_slice": {
            "name": "_dimension_slice",
            "location": 44,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "dimension": [
                    "int",
                    "bool"
                ]
            }
        },
        "KMeans._zscore_normalize": {
            "name": "_zscore_normalize",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._random_point": {
            "name": "_random_point",
            "location": 56,
            "return": [
                "data_point.DataPoint"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._assign_clusters": {
            "name": "_assign_clusters",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._generate_centroids": {
            "name": "_generate_centroids",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans.run": {
            "name": "run",
            "location": 88,
            "return": [
                "List[KMeans.Cluster]"
            ],
            "arguments": {
                "self": [],
                "max_iterations": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/mj.py": {
        "Album.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Dict[str,Any]",
                    "List[str]",
                    "Dict"
                ],
                "year": [
                    "int",
                    "str",
                    "Sequence",
                    "None",
                    "bool",
                    "Optional[str]"
                ],
                "length": [
                    "int",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "tracks": [
                    "int",
                    "str"
                ]
            }
        },
        "Album.__repr__": {
            "name": "__repr__",
            "location": 15,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/iris_test.py": {
        "iris_interpret_output": {
            "name": "iris_interpret_output",
            "location": 30,
            "return": [
                "str"
            ],
            "arguments": {
                "output": [
                    "List[float]",
                    "str",
                    "Tuple[Union[int,str]]",
                    "bytes",
                    "allennlp.common.util.JsonDict",
                    "Tuple[int,str]",
                    "float",
                    "Awaitable[Any]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/layer.py": {
        "Layer.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "previous_layer": [
                    "Optional[Tuple[float,float]]",
                    "Tuple[Union[float,float]]",
                    "Optional[int]",
                    "None",
                    "Optional[Any]",
                    "int",
                    "Any"
                ],
                "num_neurons": [
                    "int",
                    "float",
                    "Optional[str]",
                    "str",
                    "Union[float,Tuple[float,float]]",
                    "None",
                    "Tuple[Union[float,float]]"
                ],
                "learning_rate": [
                    "bool",
                    "float",
                    "int"
                ],
                "activation_function": [
                    "bool",
                    "float",
                    "int"
                ],
                "derivative_activation_function": [
                    "bool",
                    "float",
                    "int"
                ]
            }
        },
        "Layer.outputs": {
            "name": "outputs",
            "location": 33,
            "return": [
                "Union[(list, _T0)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "Layer.calculate_deltas_for_output_layer": {
            "name": "calculate_deltas_for_output_layer",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "expected": [
                    "str",
                    "int",
                    "defx.util.Candidate",
                    "bool"
                ]
            }
        },
        "Layer.calculate_deltas_for_hidden_layer": {
            "name": "calculate_deltas_for_hidden_layer",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "next_layer": [
                    "List[List[float]]",
                    "str",
                    "List[list[float]]",
                    "float",
                    "List[float]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/network.py": {
        "Network.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_structure": [
                    "List[int]",
                    "float",
                    "static_frame.core.util.IndexConstructor",
                    "int",
                    "Optional[int]"
                ],
                "learning_rate": [
                    "bool",
                    "Callable[[str],str]",
                    "Callable[str,str]",
                    "Optional[bool]",
                    "None"
                ],
                "activation_function": [
                    "bool",
                    "Callable[[str], str]",
                    "Optional[bool]"
                ],
                "derivative_activation_function": [
                    "bool",
                    "Callable[[str], str]",
                    "Optional[bool]"
                ]
            }
        },
        "Network.outputs": {
            "name": "outputs",
            "location": 45,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "str",
                    "int",
                    "busboy.util.Maybe[psycopg2.extensions.connection]"
                ]
            }
        },
        "Network.backpropagate": {
            "name": "backpropagate",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "expected": [
                    "str",
                    "bytes",
                    "Iterable[str]",
                    "Callable[[bytes],bytes]",
                    "Callable[bytes,bytes]",
                    "Optional[Mapping]",
                    "Mapping",
                    "None"
                ]
            }
        },
        "Network.update_weights": {
            "name": "update_weights",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Network.train": {
            "name": "train",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "int",
                    "Callable"
                ],
                "expecteds": [
                    "List[List[float]]",
                    "List[float]",
                    "List[list[float]]",
                    "str",
                    "float"
                ]
            }
        },
        "Network.validate": {
            "name": "validate",
            "location": 83,
            "return": [
                "Tuple[(int, int, float)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[List[float]]",
                    "float",
                    "int"
                ],
                "expecteds": [
                    "Iterable[float]",
                    "str",
                    "int",
                    "List[T]"
                ],
                "interpret_output": [
                    "str",
                    "List[int]",
                    "Tuple[int,int]",
                    "int",
                    "Tuple[Union[int,int]]",
                    "bytes"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/neuron.py": {
        "Neuron.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weights": [
                    "int",
                    "Optional[str]",
                    "List[float]",
                    "Union[float,Tuple[float,float]]",
                    "str",
                    "None",
                    "float",
                    "Tuple[Union[float,float]]"
                ],
                "learning_rate": [
                    "float"
                ],
                "activation_function": [
                    "Callable[str,str,float]",
                    "int",
                    "Callable[[str,str],float]",
                    "float",
                    "bool"
                ],
                "derivative_activation_function": [
                    "Callable[[str,str],float]",
                    "int",
                    "Callable[str,str,float]",
                    "Tuple[int]"
                ]
            }
        },
        "Neuron.output": {
            "name": "output",
            "location": 22,
            "return": [
                "str",
                "int",
                "BaseException"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/util.py": {
        "dot_product": {
            "name": "dot_product",
            "location": 6,
            "return": [
                "bool",
                "str",
                "List",
                "int"
            ],
            "arguments": {
                "xs": [
                    "List[float]",
                    "int"
                ],
                "ys": [
                    "List[float]",
                    "int"
                ]
            }
        },
        "sigmoid": {
            "name": "sigmoid",
            "location": 11,
            "return": [
                "float"
            ],
            "arguments": {
                "x": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "derivative_sigmoid": {
            "name": "derivative_sigmoid",
            "location": 15,
            "return": [
                "float"
            ],
            "arguments": {
                "x": [
                    "float"
                ]
            }
        },
        "normalize_by_feature_scaling": {
            "name": "normalize_by_feature_scaling",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "List[List[float]]",
                    "List[float]",
                    "str"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/wine_test.py": {
        "wine_interpret_output": {
            "name": "wine_interpret_output",
            "location": 30,
            "return": [
                "int"
            ],
            "arguments": {
                "output": [
                    "List[float]",
                    "str",
                    "Tuple[Union[int,str]]",
                    "bytes",
                    "allennlp.common.util.JsonDict",
                    "Tuple[int,str]",
                    "float",
                    "Awaitable[Any]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/board.py": {
        "Piece.opposite": {
            "name": "opposite",
            "location": 10,
            "return": [
                "Piece",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.turn": {
            "name": "turn",
            "location": 17,
            "return": [
                "Piece",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.move": {
            "name": "move",
            "location": 21,
            "return": [
                "Board",
                "None"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "str",
                    "bool",
                    "Iterable[Tuple[int,int]]",
                    "Iterable[tuple[Union[int,int]]]"
                ]
            }
        },
        "Board.legal_moves": {
            "name": "legal_moves",
            "location": 26,
            "return": [
                "List[Move]",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.is_win": {
            "name": "is_win",
            "location": 31,
            "return": [
                "bool",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.is_draw": {
            "name": "is_draw",
            "location": 35,
            "return": [
                "bool",
                "bytes",
                "Dict[str,Any]",
                "List[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.evaluate": {
            "name": "evaluate",
            "location": 39,
            "return": [
                "float",
                "None"
            ],
            "arguments": {
                "self": [],
                "player": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/connectfour.py": {
        "generate_segments": {
            "name": "generate_segments",
            "location": 25,
            "return": [
                "List[List[Tuple[(int, int)]]]"
            ],
            "arguments": {
                "num_columns": [
                    "int"
                ],
                "num_rows": [
                    "int",
                    "List"
                ],
                "segment_length": [
                    "int"
                ]
            }
        },
        "C4Piece.opposite": {
            "name": "opposite",
            "location": 13,
            "return": [
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Piece.__str__": {
            "name": "__str__",
            "location": 21,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.__init__": {
            "name": "__init__",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "position": [
                    "Optional[int]",
                    "None",
                    "List[int]",
                    "Dict[str,str]",
                    "int",
                    "float",
                    "List[Dict[str,Any]]",
                    "List[dict[str,Any]]"
                ],
                "turn": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "C4Board.turn": {
            "name": "turn",
            "location": 109,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.move": {
            "name": "move",
            "location": 112,
            "return": [
                "C4Board"
            ],
            "arguments": {
                "self": [
                    "_TC4Board@@C4Board@@"
                ],
                "location": [
                    "float",
                    "str",
                    "List[str]",
                    "List[Exception]"
                ]
            }
        },
        "C4Board.legal_moves": {
            "name": "legal_moves",
            "location": 120,
            "return": [
                "List[Move]",
                "Tuple[int]",
                "List[Tuple[str,Any]]",
                "Optional[dict]",
                "Sequence[str]",
                "List[Dict[str,Any]]",
                "frozenset",
                "List",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board._count_segment": {
            "name": "_count_segment",
            "location": 126,
            "return": [
                "Tuple[(int, int)]"
            ],
            "arguments": {
                "self": [],
                "segment": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "C4Board.is_win": {
            "name": "is_win",
            "location": 137,
            "return": [
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board._evaluate_segment": {
            "name": "_evaluate_segment",
            "location": 144,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "segment": [
                    "int",
                    "bool"
                ],
                "player": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "C4Board.evaluate": {
            "name": "evaluate",
            "location": 163,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "player": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "C4Board.__repr__": {
            "name": "__repr__",
            "location": 169,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.full": {
            "name": "full",
            "location": 76,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.push": {
            "name": "push",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "int",
                    "T",
                    "List[deque]",
                    "str",
                    "Callable"
                ]
            }
        },
        "C4Board.Column.__getitem__": {
            "name": "__getitem__",
            "location": 84,
            "return": [
                "Dict[str, Any]",
                "Dict[str, int]",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "dict",
                    "Dict[str, Any]",
                    "str",
                    "Union[List[str], List[int]]"
                ]
            }
        },
        "C4Board.Column.__repr__": {
            "name": "__repr__",
            "location": 89,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.copy": {
            "name": "copy",
            "location": 92,
            "return": [
                "C4Board.Column"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/connectfour_ai.py": {
        "get_player_move": {
            "name": "get_player_move",
            "location": 8,
            "return": [
                "_board.Move"
            ],
            "arguments": {}
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/minimax.py": {
        "minimax": {
            "name": "minimax",
            "location": 6,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "board": [
                    "board.Board",
                    "int",
                    "float"
                ],
                "maximizing": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "original_player": [
                    "float",
                    "int",
                    "board.Piece"
                ],
                "max_depth": [
                    "int",
                    "float",
                    "board.Piece"
                ]
            }
        },
        "find_best_move": {
            "name": "find_best_move",
            "location": 34,
            "return": [
                "Move",
                "int",
                "Set",
                "str"
            ],
            "arguments": {
                "board": [
                    "float",
                    "int",
                    "board.Board"
                ],
                "max_depth": [
                    "int",
                    "float"
                ]
            }
        },
        "alphabeta": {
            "name": "alphabeta",
            "location": 45,
            "return": [
                "int",
                "float",
                "Callable",
                "str"
            ],
            "arguments": {
                "board": [
                    "board.Board",
                    "int",
                    "float"
                ],
                "maximizing": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "original_player": [
                    "float",
                    "int",
                    "board.Piece"
                ],
                "max_depth": [
                    "int",
                    "float",
                    "board.Piece"
                ],
                "alpha": [
                    "float"
                ],
                "beta": [
                    "float",
                    "List[int]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/tictactoe.py": {
        "TTTPiece.opposite": {
            "name": "opposite",
            "location": 13,
            "return": [
                "Dict[str, Any]",
                "Dict[str, int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTPiece.__str__": {
            "name": "__str__",
            "location": 21,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "position": [
                    "list[]"
                ],
                "turn": [
                    "int",
                    "bool",
                    "game.board.Board",
                    "float"
                ]
            }
        },
        "TTTBoard.turn": {
            "name": "turn",
            "location": 33,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.move": {
            "name": "move",
            "location": 36,
            "return": [
                "TTTBoard"
            ],
            "arguments": {
                "self": [
                    "_TTTTBoard@@TTTBoard@@"
                ],
                "location": [
                    "float",
                    "str",
                    "List[str]",
                    "List[Exception]"
                ]
            }
        },
        "TTTBoard.legal_moves": {
            "name": "legal_moves",
            "location": 42,
            "return": [
                "List[Move]",
                "int",
                "str",
                "List[str]",
                "Tuple[int]",
                "Optional[dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.is_win": {
            "name": "is_win",
            "location": 48,
            "return": [
                "int",
                "str",
                "Union[str, int, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.evaluate": {
            "name": "evaluate",
            "location": 77,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "player": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "TTTBoard.__repr__": {
            "name": "__repr__",
            "location": 85,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/tictactoe_ai.py": {
        "get_player_move": {
            "name": "get_player_move",
            "location": 8,
            "return": [
                "_board.Move"
            ],
            "arguments": {}
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/tictactoe_tests.py": {
        "TTTMinimAxTestCase.test_easy_poisition": {
            "name": "test_easy_poisition",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTMinimAxTestCase.test_block_position": {
            "name": "test_block_position",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTMinimAxTestCase.test_hard_position": {
            "name": "test_hard_position",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH9_miscellaneous_problems/knapsack.py": {
        "knapsack": {
            "name": "knapsack",
            "location": 10,
            "return": [
                "list"
            ],
            "arguments": {
                "items": [
                    "int"
                ],
                "max_capacity": [
                    "int",
                    "str",
                    "List[float]",
                    "Tuple[float,float]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH9_miscellaneous_problems/phone_number_mnemonics.py": {
        "possible_mnemonics": {
            "name": "possible_mnemonics",
            "location": 16,
            "return": [
                "itertools.product"
            ],
            "arguments": {
                "phone_number": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH9_miscellaneous_problems/tsp.py": {}
}
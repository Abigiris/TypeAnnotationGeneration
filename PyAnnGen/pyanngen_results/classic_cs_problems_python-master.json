{
    "classic_cs_problems_python-master/CH1_small_problems/calculating_pi.py": {
        "calculate_pi": {
            "name": "calculate_pi",
            "location": 1,
            "return": [
                "float"
            ],
            "arguments": {
                "n_terms": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib1.py": {
        "fib1": {
            "name": "fib1",
            "location": 3,
            "return": [
                "int"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib2.py": {
        "fib2": {
            "name": "fib2",
            "location": 3,
            "return": [
                "int"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib3.py": {
        "fib3": {
            "name": "fib3",
            "location": 14,
            "return": [
                "int"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib4.py": {
        "fib4": {
            "name": "fib4",
            "location": 7,
            "return": [
                "int",
                "str",
                "bool"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib5.py": {
        "fib5": {
            "name": "fib5",
            "location": 8,
            "return": [
                "int"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/fib6.py": {
        "fib6": {
            "name": "fib6",
            "location": 6,
            "return": [
                "Generator[(int, None, None)]"
            ],
            "arguments": {
                "n": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/hanoi.py": {
        "hanoi": {
            "name": "hanoi",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "begin": [
                    "Stack[int]"
                ],
                "end": [
                    "Stack[int]"
                ],
                "temp": [
                    "Stack[int]"
                ],
                "n": [
                    "int"
                ]
            }
        },
        "Stack.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.push": {
            "name": "push",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T"
                ]
            }
        },
        "Stack.pop": {
            "name": "pop",
            "location": 13,
            "return": [
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__repr__": {
            "name": "__repr__",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/trivial_compression.py": {
        "CompressedGene.__init__": {
            "name": "__init__",
            "location": 2,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "gene": [
                    "str"
                ]
            }
        },
        "CompressedGene._compress": {
            "name": "_compress",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "gene": [
                    "str"
                ]
            }
        },
        "CompressedGene.decompress": {
            "name": "decompress",
            "location": 20,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompressedGene.__str__": {
            "name": "__str__",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH1_small_problems/unbreakable_encryption.py": {
        "random_key": {
            "name": "random_key",
            "location": 5,
            "return": [
                "int"
            ],
            "arguments": {
                "length": [
                    "int"
                ]
            }
        },
        "encrypt": {
            "name": "encrypt",
            "location": 12,
            "return": [
                "Tuple[(int, int)]"
            ],
            "arguments": {
                "original": [
                    "str"
                ]
            }
        },
        "decrypt": {
            "name": "decrypt",
            "location": 20,
            "return": [
                "str"
            ],
            "arguments": {
                "key1": [
                    "int"
                ],
                "key2": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/dna_search.py": {
        "string_to_gene": {
            "name": "string_to_gene",
            "location": 12,
            "return": [
                "List[Tuple[(Any, Any, Any)]]"
            ],
            "arguments": {
                "s": [
                    "str"
                ]
            }
        },
        "linear_contains": {
            "name": "linear_contains",
            "location": 26,
            "return": [
                "bool"
            ],
            "arguments": {
                "gene": [
                    "List[Tuple[(Any, Any, Any)]]"
                ],
                "key_codon": [
                    "Tuple[(Any, Any, Any)]"
                ]
            }
        },
        "binary_contains": {
            "name": "binary_contains",
            "location": 43,
            "return": [
                "bool"
            ],
            "arguments": {
                "gene": [
                    "List[Tuple[(Any, Any, Any)]]"
                ],
                "key_codon": [
                    "Tuple[(Any, Any, Any)]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/generic_search.py": {
        "linear_contains": {
            "name": "linear_contains",
            "location": 21,
            "return": [
                "bool"
            ],
            "arguments": {
                "iterable": [
                    "Iterable[T]"
                ],
                "key": [
                    "T"
                ]
            }
        },
        "binary_contains": {
            "name": "binary_contains",
            "location": 48,
            "return": [
                "bool"
            ],
            "arguments": {
                "sequence": [
                    "Sequence[C]"
                ],
                "key": [
                    "C"
                ]
            }
        },
        "dfs": {
            "name": "dfs",
            "location": 133,
            "return": [
                "Optional[Node[T]]"
            ],
            "arguments": {
                "initial": [
                    "T"
                ],
                "goal_test": [
                    "Callable[([T], bool)]"
                ],
                "successors": [
                    "Callable[([T], List[T])]"
                ]
            }
        },
        "bfs": {
            "name": "bfs",
            "location": 158,
            "return": [
                "Optional[Node[T]]"
            ],
            "arguments": {
                "initial": [
                    "T"
                ],
                "goal_test": [
                    "Callable[([T], bool)]"
                ],
                "successors": [
                    "Callable[([T], List[T])]"
                ]
            }
        },
        "astar": {
            "name": "astar",
            "location": 183,
            "return": [
                "Optional[Node[T]]"
            ],
            "arguments": {
                "initial": [
                    "T"
                ],
                "goal_test": [
                    "Callable[([T], bool)]"
                ],
                "successors": [
                    "Callable[([T], List[T])]"
                ],
                "heuristic": [
                    "Callable[([T], float)]"
                ]
            }
        },
        "node_to_path": {
            "name": "node_to_path",
            "location": 212,
            "return": [
                "List[T]"
            ],
            "arguments": {
                "node": [
                    "Node[T]"
                ]
            }
        },
        "Comparable.__eq__": {
            "name": "__eq__",
            "location": 32,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "SupportsFloat",
                    "list[str]",
                    "List[str]",
                    "int",
                    "Union[int, float]",
                    "float",
                    "AbstractSet[T]",
                    "typing.AbstractSet"
                ]
            }
        },
        "Comparable.__lt__": {
            "name": "__lt__",
            "location": 35,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [
                    "C"
                ],
                "other": [
                    "C"
                ]
            }
        },
        "Comparable.__gt__": {
            "name": "__gt__",
            "location": 38,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [
                    "C"
                ],
                "other": [
                    "C"
                ]
            }
        },
        "Comparable.__le__": {
            "name": "__le__",
            "location": 41,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [
                    "C"
                ],
                "other": [
                    "C"
                ]
            }
        },
        "Comparable.__ge__": {
            "name": "__ge__",
            "location": 44,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [
                    "C"
                ],
                "other": [
                    "C"
                ]
            }
        },
        "Stack.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.empty": {
            "name": "empty",
            "location": 67,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.push": {
            "name": "push",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T"
                ]
            }
        },
        "Stack.pop": {
            "name": "pop",
            "location": 73,
            "return": [
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "Stack.__repr__": {
            "name": "__repr__",
            "location": 76,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__init__": {
            "name": "__init__",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.empty": {
            "name": "empty",
            "location": 85,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.push": {
            "name": "push",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T"
                ]
            }
        },
        "Queue.pop": {
            "name": "pop",
            "location": 91,
            "return": [
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "Queue.__repr__": {
            "name": "__repr__",
            "location": 94,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.__init__": {
            "name": "__init__",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.empty": {
            "name": "empty",
            "location": 103,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.push": {
            "name": "push",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T"
                ]
            }
        },
        "PriorityQueue.pop": {
            "name": "pop",
            "location": 109,
            "return": [
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.__repr__": {
            "name": "__repr__",
            "location": 112,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Node.__init__": {
            "name": "__init__",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "T"
                ],
                "parent": [
                    "Optional[Node]"
                ],
                "cost": [
                    "float"
                ],
                "heuristic": [
                    "float"
                ]
            }
        },
        "Node.__lt__": {
            "name": "__lt__",
            "location": 129,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Node"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/maze.py": {
        "euclidean_distance": {
            "name": "euclidean_distance",
            "location": 92,
            "return": [
                "Callable[([MazeLocation], float)]"
            ],
            "arguments": {
                "goal": [
                    "MazeLocation"
                ]
            }
        },
        "manhattan_distance": {
            "name": "manhattan_distance",
            "location": 101,
            "return": [
                "Callable[([MazeLocation], float)]"
            ],
            "arguments": {
                "goal": [
                    "MazeLocation"
                ]
            }
        },
        "Maze.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rows": [
                    "int"
                ],
                "columns": [
                    "int"
                ],
                "sparseness": [
                    "float"
                ],
                "start": [
                    "MazeLocation"
                ],
                "goal": [
                    "MazeLocation"
                ]
            }
        },
        "Maze._randomly_fill": {
            "name": "_randomly_fill",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "rows": [
                    "int"
                ],
                "columns": [
                    "int"
                ],
                "sparseness": [
                    "float"
                ]
            }
        },
        "Maze.__str__": {
            "name": "__str__",
            "location": 52,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Maze.goal_test": {
            "name": "goal_test",
            "location": 58,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "ml": [
                    "MazeLocation"
                ]
            }
        },
        "Maze.successors": {
            "name": "successors",
            "location": 61,
            "return": [
                "List[MazeLocation]"
            ],
            "arguments": {
                "self": [],
                "ml": [
                    "MazeLocation"
                ]
            }
        },
        "Maze.mark": {
            "name": "mark",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "List[MazeLocation]"
                ]
            }
        },
        "Maze.clear": {
            "name": "clear",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "List[MazeLocation]"
                ]
            }
        },
        "euclidean_distance.distance": {
            "name": "distance",
            "location": 93,
            "return": [],
            "arguments": {
                "ml": []
            }
        },
        "manhattan_distance.distance": {
            "name": "distance",
            "location": 102,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "ml": [
                    "int",
                    "bytes",
                    "list"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH2_search_problems/missionaries.py": {
        "display_solution": {
            "name": "display_solution",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "path": [
                    "List[MCState]"
                ]
            }
        },
        "MCState.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "missionaries": [
                    "int"
                ],
                "cannibals": [
                    "int"
                ],
                "boat": [
                    "bool"
                ]
            }
        },
        "MCState.__str__": {
            "name": "__str__",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MCState.goal_test": {
            "name": "goal_test",
            "location": 19,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MCState.is_legal": {
            "name": "is_legal",
            "location": 23,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MCState.successors": {
            "name": "successors",
            "location": 30,
            "return": [
                "List[MCState]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/csp.py": {
        "Constraint.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variables": [
                    "List[V]"
                ]
            }
        },
        "Constraint.satisfied": {
            "name": "satisfied",
            "location": 16,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[(V, D)]"
                ]
            }
        },
        "CSP.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "variables": [
                    "List[V]"
                ],
                "domains": [
                    "Dict[(V, List[D])]"
                ]
            }
        },
        "CSP.add_constraint": {
            "name": "add_constraint",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "constraint": [
                    "Constraint[(V, D)]"
                ]
            }
        },
        "CSP.consistent": {
            "name": "consistent",
            "location": 42,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "variable": [
                    "V"
                ],
                "assignment": [
                    "Dict[(V, D)]"
                ]
            }
        },
        "CSP.backtracking_search": {
            "name": "backtracking_search",
            "location": 48,
            "return": [
                "Optional[Dict[(V, D)]]"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[(V, D)]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/map_coloring.py": {
        "MapColoringConstraint.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "place1": [
                    "str"
                ],
                "place2": [
                    "str"
                ]
            }
        },
        "MapColoringConstraint.satisfied": {
            "name": "satisfied",
            "location": 11,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[(str, str)]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/queens.py": {
        "QueensConstraint.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "columns": [
                    "List[int]"
                ]
            }
        },
        "QueensConstraint.satisfied": {
            "name": "satisfied",
            "location": 10,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[(int, int)]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/send_more_money.py": {
        "SendMoreMoneyConstraint.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "letters": [
                    "List[str]"
                ]
            }
        },
        "SendMoreMoneyConstraint.satisfied": {
            "name": "satisfied",
            "location": 10,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[(str, int)]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH3_constraint_satisfacation_problems/word_search.py": {
        "generate_grid": {
            "name": "generate_grid",
            "location": 14,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "rows": [
                    "int"
                ],
                "columns": [
                    "int"
                ]
            }
        },
        "display_grid": {
            "name": "display_grid",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "grid": [
                    "List[List[str]]"
                ]
            }
        },
        "generate_domain": {
            "name": "generate_domain",
            "location": 24,
            "return": [
                "List[List[GridLocation]]"
            ],
            "arguments": {
                "word": [
                    "str"
                ],
                "grid": [
                    "List[List[str]]"
                ]
            }
        },
        "WordSearchConstraint.__init__": {
            "name": "__init__",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "words": [
                    "List[str]"
                ]
            }
        },
        "WordSearchConstraint.satisfied": {
            "name": "satisfied",
            "location": 53,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "assignment": [
                    "Dict[(str, List[GridLocation])]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/dijkstra.py": {
        "dijkstra": {
            "name": "dijkstra",
            "location": 24,
            "return": [
                "Tuple[(List[Optional[float]], Dict[(int, weighted_edge.WeightedEdge)])]"
            ],
            "arguments": {
                "wg": [
                    "weighted_graph.WeightedGraph[V]"
                ],
                "root": [
                    "V"
                ]
            }
        },
        "distance_array_to_vertex_dict": {
            "name": "distance_array_to_vertex_dict",
            "location": 54,
            "return": [
                "Dict[(V, Any)]"
            ],
            "arguments": {
                "wg": [
                    "weighted_graph.WeightedGraph[V]"
                ],
                "distances": [
                    "List[Optional[float]]"
                ]
            }
        },
        "path_dict_to_path": {
            "name": "path_dict_to_path",
            "location": 65,
            "return": [
                "List[weighted_edge.WeightedEdge]"
            ],
            "arguments": {
                "start": [
                    "int"
                ],
                "end": [
                    "int"
                ],
                "path_dict": [
                    "Dict[(int, weighted_edge.WeightedEdge)]"
                ]
            }
        },
        "DijkstraNode.__lt__": {
            "name": "__lt__",
            "location": 17,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "DijkstraNode"
                ]
            }
        },
        "DijkstraNode.__eq__": {
            "name": "__eq__",
            "location": 20,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "DijkstraNode"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/edge.py": {
        "Edge.reversed": {
            "name": "reversed",
            "location": 10,
            "return": [
                "Edge"
            ],
            "arguments": {
                "self": [
                    "_TEdge"
                ]
            }
        },
        "Edge.__str__": {
            "name": "__str__",
            "location": 13,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/graph.py": {
        "Graph.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "List[V]"
                ]
            }
        },
        "Graph.vertex_count": {
            "name": "vertex_count",
            "location": 13,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Graph.edge_count": {
            "name": "edge_count",
            "location": 17,
            "return": [
                "bool",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Graph.add_vertex": {
            "name": "add_vertex",
            "location": 21,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "V"
                ]
            }
        },
        "Graph.add_edge": {
            "name": "add_edge",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "edge": [
                    "edge.Edge"
                ]
            }
        },
        "Graph.add_edge_by_indices": {
            "name": "add_edge_by_indices",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "int"
                ],
                "v": [
                    "int"
                ]
            }
        },
        "Graph.add_edge_by_vertices": {
            "name": "add_edge_by_vertices",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "first": [
                    "V"
                ],
                "second": [
                    "V"
                ]
            }
        },
        "Graph.vertex_at": {
            "name": "vertex_at",
            "location": 43,
            "return": [
                "V"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "Graph.index_of": {
            "name": "index_of",
            "location": 47,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "V"
                ]
            }
        },
        "Graph.neighbors_for_index": {
            "name": "neighbors_for_index",
            "location": 51,
            "return": [
                "List[V]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "Graph.neighbors_for_vertex": {
            "name": "neighbors_for_vertex",
            "location": 55,
            "return": [
                "List[V]"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "V"
                ]
            }
        },
        "Graph.edges_for_index": {
            "name": "edges_for_index",
            "location": 59,
            "return": [
                "List[edge.Edge]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "Graph.edges_for_vertex": {
            "name": "edges_for_vertex",
            "location": 63,
            "return": [
                "List[edge.Edge]"
            ],
            "arguments": {
                "self": [],
                "vertex": [
                    "V"
                ]
            }
        },
        "Graph.__str__": {
            "name": "__str__",
            "location": 67,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/mst.py": {
        "total_weight": {
            "name": "total_weight",
            "location": 10,
            "return": [
                "float"
            ],
            "arguments": {
                "wp": [
                    "List[weighted_edge.WeightedEdge]"
                ]
            }
        },
        "mst": {
            "name": "mst",
            "location": 14,
            "return": [
                "Optional[List[weighted_edge.WeightedEdge]]"
            ],
            "arguments": {
                "wg": [
                    "weighted_graph.WeightedGraph[V]"
                ],
                "start": [
                    "int"
                ]
            }
        },
        "print_weighted_path": {
            "name": "print_weighted_path",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "wg": [
                    "weighted_graph.WeightedGraph"
                ],
                "wp": [
                    "List[weighted_edge.WeightedEdge]"
                ]
            }
        },
        "mst.visit": {
            "name": "visit",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "index": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/priority_queue.py": {
        "PriorityQueue.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.empty": {
            "name": "empty",
            "location": 12,
            "return": [
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.push": {
            "name": "push",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "T"
                ]
            }
        },
        "PriorityQueue.pop": {
            "name": "pop",
            "location": 18,
            "return": [
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "PriorityQueue.__repr__": {
            "name": "__repr__",
            "location": 21,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/weighted_edge.py": {
        "WeightedEdge.reversed": {
            "name": "reversed",
            "location": 10,
            "return": [
                "WeightedEdge"
            ],
            "arguments": {
                "self": [
                    "_TWeightedEdge"
                ]
            }
        },
        "WeightedEdge.__lt__": {
            "name": "__lt__",
            "location": 14,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "WeightedEdge"
                ]
            }
        },
        "WeightedEdge.__str__": {
            "name": "__str__",
            "location": 17,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH4_graph_problems/weighted_graph.py": {
        "WeightedGraph.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vertices": [
                    "List[V]"
                ]
            }
        },
        "WeightedGraph.add_edge_by_indices": {
            "name": "add_edge_by_indices",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "int"
                ],
                "v": [
                    "int"
                ],
                "weight": [
                    "float"
                ]
            }
        },
        "WeightedGraph.add_edge_by_vertices": {
            "name": "add_edge_by_vertices",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "first": [
                    "V"
                ],
                "second": [
                    "V"
                ],
                "weight": [
                    "float"
                ]
            }
        },
        "WeightedGraph.neighbors_for_index_with_weights": {
            "name": "neighbors_for_index_with_weights",
            "location": 22,
            "return": [
                "List[Tuple[(V, float)]]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "WeightedGraph.__str__": {
            "name": "__str__",
            "location": 28,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/chromosome.py": {
        "Chromosome.fitness": {
            "name": "fitness",
            "location": 11,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Chromosome.random_instance": {
            "name": "random_instance",
            "location": 16,
            "return": [
                "T"
            ],
            "arguments": {
                "cls": [
                    "Type[T]"
                ]
            }
        },
        "Chromosome.crossover": {
            "name": "crossover",
            "location": 20,
            "return": [
                "Tuple[(T, T)]"
            ],
            "arguments": {
                "self": [
                    "T"
                ],
                "other": [
                    "T"
                ]
            }
        },
        "Chromosome.mutate": {
            "name": "mutate",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/genetic_algorithm.py": {
        "GeneticAlgorithm.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initial_population": [
                    "List[C]"
                ],
                "threshold": [
                    "float"
                ],
                "max_generations": [
                    "int"
                ],
                "mutation_chance": [
                    "float"
                ],
                "crossover_chance": [
                    "float"
                ],
                "selection_type": [
                    "enum.Enum"
                ]
            }
        },
        "GeneticAlgorithm._pick_roulette": {
            "name": "_pick_roulette",
            "location": 34,
            "return": [
                "Tuple[(C, C)]"
            ],
            "arguments": {
                "self": [],
                "wheel": [
                    "List[float]"
                ]
            }
        },
        "GeneticAlgorithm._pick_tournament": {
            "name": "_pick_tournament",
            "location": 38,
            "return": [
                "Tuple[(C, C)]"
            ],
            "arguments": {
                "self": [],
                "num_participants": [
                    "int"
                ]
            }
        },
        "GeneticAlgorithm._reproduce_and_replace": {
            "name": "_reproduce_and_replace",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneticAlgorithm._mutate": {
            "name": "_mutate",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GeneticAlgorithm.run": {
            "name": "run",
            "location": 72,
            "return": [
                "C"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/list_compression.py": {
        "ListCompression.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lst": [
                    "list"
                ]
            }
        },
        "ListCompression.bytes_compressed": {
            "name": "bytes_compressed",
            "location": 34,
            "return": [
                "bool",
                "Dict[str, List[str]]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListCompression.fitness": {
            "name": "fitness",
            "location": 37,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListCompression.random_instance": {
            "name": "random_instance",
            "location": 41,
            "return": [
                "ListCompression"
            ],
            "arguments": {
                "cls": [
                    "Type[_TListCompression]"
                ]
            }
        },
        "ListCompression.crossover": {
            "name": "crossover",
            "location": 46,
            "return": [
                "Tuple[(ListCompression, ListCompression)]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "ListCompression"
                ]
            }
        },
        "ListCompression.mutate": {
            "name": "mutate",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ListCompression.__str__": {
            "name": "__str__",
            "location": 61,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/send_more_money2.py": {
        "SendMoreMoney2.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "letters": [
                    "List[str]"
                ]
            }
        },
        "SendMoreMoney2.fitness": {
            "name": "fitness",
            "location": 13,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "SendMoreMoney2.random_instance": {
            "name": "random_instance",
            "location": 29,
            "return": [
                "SendMoreMoney2"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSendMoreMoney2]"
                ]
            }
        },
        "SendMoreMoney2.crossover": {
            "name": "crossover",
            "location": 34,
            "return": [
                "Tuple[(SendMoreMoney2, SendMoreMoney2)]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "SendMoreMoney2"
                ]
            }
        },
        "SendMoreMoney2.mutate": {
            "name": "mutate",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SendMoreMoney2.__str__": {
            "name": "__str__",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH5_genetic_algorithms/simple_equation.py": {
        "SimpleEquation.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ],
                "y": [
                    "int"
                ]
            }
        },
        "SimpleEquation.fitness": {
            "name": "fitness",
            "location": 14,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleEquation.random_instance": {
            "name": "random_instance",
            "location": 18,
            "return": [
                "SimpleEquation"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSimpleEquation]"
                ]
            }
        },
        "SimpleEquation.crossover": {
            "name": "crossover",
            "location": 21,
            "return": [
                "Tuple[(SimpleEquation, SimpleEquation)]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "SimpleEquation"
                ]
            }
        },
        "SimpleEquation.mutate": {
            "name": "mutate",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleEquation.__str__": {
            "name": "__str__",
            "location": 40,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/data_point.py": {
        "DataPoint.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "initial": [
                    "Iterable[float]"
                ]
            }
        },
        "DataPoint.num_dimensions": {
            "name": "num_dimensions",
            "location": 12,
            "return": [
                "int",
                "str",
                "deque"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataPoint.distance": {
            "name": "distance",
            "location": 15,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "DataPoint"
                ]
            }
        },
        "DataPoint.__eq__": {
            "name": "__eq__",
            "location": 20,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "object"
                ]
            }
        },
        "DataPoint.__repr__": {
            "name": "__repr__",
            "location": 25,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/governors.py": {
        "Governor.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "longitude": [
                    "float"
                ],
                "age": [
                    "float"
                ],
                "state": [
                    "str"
                ]
            }
        },
        "Governor.__repr__": {
            "name": "__repr__",
            "location": 14,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/kmeans.py": {
        "zscores": {
            "name": "zscores",
            "location": 11,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "original": [
                    "Sequence[float]"
                ]
            }
        },
        "KMeans.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "k": [
                    "int"
                ],
                "points": [
                    "List[Point]"
                ]
            }
        },
        "KMeans._centroids": {
            "name": "_centroids",
            "location": 41,
            "return": [
                "list[]",
                "int",
                "str",
                "Optional[dict]",
                "Sequence[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._dimension_slice": {
            "name": "_dimension_slice",
            "location": 44,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "self": [],
                "dimension": [
                    "int"
                ]
            }
        },
        "KMeans._zscore_normalize": {
            "name": "_zscore_normalize",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._random_point": {
            "name": "_random_point",
            "location": 56,
            "return": [
                "data_point.DataPoint"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._assign_clusters": {
            "name": "_assign_clusters",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans._generate_centroids": {
            "name": "_generate_centroids",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "KMeans.run": {
            "name": "run",
            "location": 88,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "max_iterations": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH6_K-means_clustering/mj.py": {
        "Album.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "year": [
                    "int"
                ],
                "length": [
                    "float"
                ],
                "tracks": [
                    "float"
                ]
            }
        },
        "Album.__repr__": {
            "name": "__repr__",
            "location": 15,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/iris_test.py": {
        "iris_interpret_output": {
            "name": "iris_interpret_output",
            "location": 30,
            "return": [
                "str"
            ],
            "arguments": {
                "output": [
                    "List[float]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/layer.py": {
        "Layer.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "previous_layer": [
                    "Optional[Layer]"
                ],
                "num_neurons": [
                    "int"
                ],
                "learning_rate": [
                    "float"
                ],
                "activation_function": [
                    "Callable[([float], float)]"
                ],
                "derivative_activation_function": [
                    "Callable[([float], float)]"
                ]
            }
        },
        "Layer.outputs": {
            "name": "outputs",
            "location": 33,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[float]"
                ]
            }
        },
        "Layer.calculate_deltas_for_output_layer": {
            "name": "calculate_deltas_for_output_layer",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "expected": [
                    "List[float]"
                ]
            }
        },
        "Layer.calculate_deltas_for_hidden_layer": {
            "name": "calculate_deltas_for_hidden_layer",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "next_layer": [
                    "Layer"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/network.py": {
        "Network.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "layer_structure": [
                    "List[int]"
                ],
                "learning_rate": [
                    "float"
                ],
                "activation_function": [
                    "Callable[([float], float)]"
                ],
                "derivative_activation_function": [
                    "Callable[([float], float)]"
                ]
            }
        },
        "Network.outputs": {
            "name": "outputs",
            "location": 45,
            "return": [
                "List[float]"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "List[float]"
                ]
            }
        },
        "Network.backpropagate": {
            "name": "backpropagate",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "expected": [
                    "List[float]"
                ]
            }
        },
        "Network.update_weights": {
            "name": "update_weights",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Network.train": {
            "name": "train",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[List[float]]"
                ],
                "expecteds": [
                    "List[List[float]]"
                ]
            }
        },
        "Network.validate": {
            "name": "validate",
            "location": 83,
            "return": [
                "Tuple[(int, int, float)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[List[float]]"
                ],
                "expecteds": [
                    "List[T]"
                ],
                "interpret_output": [
                    "Callable[([List[float]], T)]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/neuron.py": {
        "Neuron.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weights": [
                    "List[float]"
                ],
                "learning_rate": [
                    "float"
                ],
                "activation_function": [
                    "Callable[([float], float)]"
                ],
                "derivative_activation_function": [
                    "Callable[([float], float)]"
                ]
            }
        },
        "Neuron.output": {
            "name": "output",
            "location": 22,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[float]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/util.py": {
        "dot_product": {
            "name": "dot_product",
            "location": 6,
            "return": [
                "float"
            ],
            "arguments": {
                "xs": [
                    "List[float]"
                ],
                "ys": [
                    "List[float]"
                ]
            }
        },
        "sigmoid": {
            "name": "sigmoid",
            "location": 11,
            "return": [
                "float"
            ],
            "arguments": {
                "x": [
                    "float"
                ]
            }
        },
        "derivative_sigmoid": {
            "name": "derivative_sigmoid",
            "location": 15,
            "return": [
                "float"
            ],
            "arguments": {
                "x": [
                    "float"
                ]
            }
        },
        "normalize_by_feature_scaling": {
            "name": "normalize_by_feature_scaling",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "List[List[float]]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH7_neural_network/wine_test.py": {
        "wine_interpret_output": {
            "name": "wine_interpret_output",
            "location": 30,
            "return": [
                "int"
            ],
            "arguments": {
                "output": [
                    "List[float]"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/board.py": {
        "Piece.opposite": {
            "name": "opposite",
            "location": 10,
            "return": [
                "Piece",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.turn": {
            "name": "turn",
            "location": 17,
            "return": [
                "Piece",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.move": {
            "name": "move",
            "location": 21,
            "return": [
                "Board"
            ],
            "arguments": {
                "self": [
                    "_TBoard"
                ],
                "location": [
                    "Move"
                ]
            }
        },
        "Board.legal_moves": {
            "name": "legal_moves",
            "location": 26,
            "return": [
                "typing.List[Move]",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.is_win": {
            "name": "is_win",
            "location": 31,
            "return": [
                "builtins.bool",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.is_draw": {
            "name": "is_draw",
            "location": 35,
            "return": [
                "bool",
                "bytes",
                "Dict[str, Any]",
                "List[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Board.evaluate": {
            "name": "evaluate",
            "location": 39,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "player": [
                    "Piece"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/connectfour.py": {
        "generate_segments": {
            "name": "generate_segments",
            "location": 25,
            "return": [
                "List[List[Tuple[(int, int)]]]"
            ],
            "arguments": {
                "num_columns": [
                    "int"
                ],
                "num_rows": [
                    "int"
                ],
                "segment_length": [
                    "int"
                ]
            }
        },
        "C4Piece.opposite": {
            "name": "opposite",
            "location": 13,
            "return": [
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Piece.__str__": {
            "name": "__str__",
            "location": 21,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.__init__": {
            "name": "__init__",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "position": [
                    "Optional[list]"
                ],
                "turn": [
                    "C4Piece"
                ]
            }
        },
        "C4Board.turn": {
            "name": "turn",
            "location": 109,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.move": {
            "name": "move",
            "location": 112,
            "return": [
                "board.Board"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "board.Move"
                ]
            }
        },
        "C4Board.legal_moves": {
            "name": "legal_moves",
            "location": 120,
            "return": [
                "list[Move]",
                "Tuple[int]",
                "List[Tuple[str, Any]]",
                "Optional[dict]",
                "Sequence[str]",
                "List[Dict[str, Any]]",
                "frozenset",
                "list",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board._count_segment": {
            "name": "_count_segment",
            "location": 126,
            "return": [
                "Tuple[(int, int)]"
            ],
            "arguments": {
                "self": [],
                "segment": [
                    "List[Tuple[(int, int)]]"
                ]
            }
        },
        "C4Board.is_win": {
            "name": "is_win",
            "location": 137,
            "return": [
                "bool",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board._evaluate_segment": {
            "name": "_evaluate_segment",
            "location": 144,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "segment": [
                    "List[Tuple[(int, int)]]"
                ],
                "player": [
                    "board.Piece"
                ]
            }
        },
        "C4Board.evaluate": {
            "name": "evaluate",
            "location": 163,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "player": [
                    "board.Piece"
                ]
            }
        },
        "C4Board.__repr__": {
            "name": "__repr__",
            "location": 169,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.__init__": {
            "name": "__init__",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.full": {
            "name": "full",
            "location": 76,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.push": {
            "name": "push",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "C4Piece"
                ]
            }
        },
        "C4Board.Column.__getitem__": {
            "name": "__getitem__",
            "location": 84,
            "return": [
                "C4Piece"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int"
                ]
            }
        },
        "C4Board.Column.__repr__": {
            "name": "__repr__",
            "location": 89,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "C4Board.Column.copy": {
            "name": "copy",
            "location": 92,
            "return": [
                "Column",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/connectfour_ai.py": {
        "get_player_move": {
            "name": "get_player_move",
            "location": 8,
            "return": [
                "_board.Move"
            ],
            "arguments": {}
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/minimax.py": {
        "minimax": {
            "name": "minimax",
            "location": 6,
            "return": [
                "float"
            ],
            "arguments": {
                "board": [
                    "board.Board"
                ],
                "maximizing": [
                    "bool"
                ],
                "original_player": [
                    "board.Piece"
                ],
                "max_depth": [
                    "int"
                ]
            }
        },
        "find_best_move": {
            "name": "find_best_move",
            "location": 34,
            "return": [
                "board.Move"
            ],
            "arguments": {
                "board": [
                    "board.Board"
                ],
                "max_depth": [
                    "int"
                ]
            }
        },
        "alphabeta": {
            "name": "alphabeta",
            "location": 45,
            "return": [
                "float"
            ],
            "arguments": {
                "board": [
                    "board.Board"
                ],
                "maximizing": [
                    "bool"
                ],
                "original_player": [
                    "board.Piece"
                ],
                "max_depth": [
                    "int"
                ],
                "alpha": [
                    "float"
                ],
                "beta": [
                    "float"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/tictactoe.py": {
        "TTTPiece.opposite": {
            "name": "opposite",
            "location": 13,
            "return": [
                "Dict[str, Any]",
                "Dict[str, int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTPiece.__str__": {
            "name": "__str__",
            "location": 21,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "position": [
                    "List[TTTPiece]"
                ],
                "turn": [
                    "TTTPiece"
                ]
            }
        },
        "TTTBoard.turn": {
            "name": "turn",
            "location": 33,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.move": {
            "name": "move",
            "location": 36,
            "return": [
                "board.Board"
            ],
            "arguments": {
                "self": [],
                "location": [
                    "board.Move"
                ]
            }
        },
        "TTTBoard.legal_moves": {
            "name": "legal_moves",
            "location": 42,
            "return": [
                "list[Move]",
                "int",
                "str",
                "List[str]",
                "Tuple[int]",
                "Optional[dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.is_win": {
            "name": "is_win",
            "location": 48,
            "return": [
                "int",
                "str",
                "Union[str, int, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTBoard.evaluate": {
            "name": "evaluate",
            "location": 77,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "player": [
                    "board.Piece"
                ]
            }
        },
        "TTTBoard.__repr__": {
            "name": "__repr__",
            "location": 85,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/tictactoe_ai.py": {
        "get_player_move": {
            "name": "get_player_move",
            "location": 8,
            "return": [
                "_board.Move"
            ],
            "arguments": {}
        }
    },
    "classic_cs_problems_python-master/CH8_adversarial_search/tictactoe_tests.py": {
        "TTTMinimAxTestCase.test_easy_poisition": {
            "name": "test_easy_poisition",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTMinimAxTestCase.test_block_position": {
            "name": "test_block_position",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TTTMinimAxTestCase.test_hard_position": {
            "name": "test_hard_position",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "classic_cs_problems_python-master/CH9_miscellaneous_problems/knapsack.py": {
        "knapsack": {
            "name": "knapsack",
            "location": 10,
            "return": [
                "List[Item]"
            ],
            "arguments": {
                "items": [
                    "List[Item]"
                ],
                "max_capacity": [
                    "int"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH9_miscellaneous_problems/phone_number_mnemonics.py": {
        "possible_mnemonics": {
            "name": "possible_mnemonics",
            "location": 16,
            "return": [
                "Iterable[Tuple[(str, ...)]]"
            ],
            "arguments": {
                "phone_number": [
                    "str"
                ]
            }
        }
    },
    "classic_cs_problems_python-master/CH9_miscellaneous_problems/tsp.py": {}
}
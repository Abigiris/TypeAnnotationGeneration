{
    "core-master/setup.py": {},
    "core-master/core/util.py": {
        "arr_map": {
            "name": "arr_map",
            "location": 8,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "func": [
                    "Dict[str,Any]",
                    "str"
                ]
            }
        },
        "differentiate": {
            "name": "differentiate",
            "location": 12,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "xs": [
                    "float",
                    "int",
                    "Optional[int]",
                    "None",
                    "numpy.ndarray"
                ],
                "ts": [
                    "float",
                    "Optional[int]",
                    "int",
                    "numpy.ndarray"
                ],
                "L": [
                    "int",
                    "Optional[Exception]",
                    "bool",
                    "str"
                ]
            }
        },
        "torch_guard": {
            "name": "torch_guard",
            "location": 30,
            "return": [
                "int",
                "List",
                "IO[str]",
                "numpy.ndarray",
                "Tuple",
                "Dict[bytes,str]",
                "Tuple[Union[Literal,Literal,Literal,Literal]]",
                "bytes"
            ],
            "arguments": {
                "params": [
                    "Dict[str,Any]",
                    "Callable",
                    "bytes",
                    "Dict",
                    "Dict[str,str]",
                    "Optional[Dict[str,str]]"
                ],
                "function": [
                    "bool",
                    "Callable",
                    "str",
                    "T"
                ]
            }
        },
        "default_fig": {
            "name": "default_fig",
            "location": 60,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "fig": [
                    "str",
                    "int",
                    "Optional[int]",
                    "float",
                    "None"
                ],
                "ax": [
                    "int",
                    "float",
                    "Iterable[Optional[Any]]"
                ]
            }
        },
        "differentiate.diff": {
            "name": "diff",
            "location": 17,
            "return": [
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "xs": [
                    "numpy.ndarray",
                    "int",
                    "str",
                    "T"
                ],
                "ts": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[float, float]",
                    "torch.Tensor"
                ]
            }
        }
    },
    "core-master/core/__init__.py": {},
    "core-master/core/controllers/constant_controller.py": {
        "ConstantController.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dynamics": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[Any,Any,bool]"
                ],
                "u_const": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ConstantController.eval": {
            "name": "eval",
            "location": 17,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        }
    },
    "core-master/core/controllers/controller.py": {
        "Controller.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dynamics": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "Controller.eval": {
            "name": "eval",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "Controller.process": {
            "name": "process",
            "location": 29,
            "return": [
                "int",
                "str",
                "Callable",
                "Iterable[C]"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Controller.reset": {
            "name": "reset",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "core-master/core/controllers/energy_controller.py": {
        "EnergyController.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "robotic_dynamics": [
                    "bool",
                    "str"
                ],
                "K_p": [
                    "bool",
                    "Optional[str]",
                    "Union[int, str]",
                    "str"
                ],
                "K_d": [
                    "bool",
                    "Tuple[int,int,int]",
                    "Tuple[Union[int,int,int]]",
                    "Tuple[str]",
                    "int",
                    "Dict",
                    "Optional[dict]",
                    "None"
                ],
                "q_d": [
                    "Optional[int]",
                    "int",
                    "None",
                    "str"
                ]
            }
        },
        "EnergyController.eval": {
            "name": "eval",
            "location": 27,
            "return": [
                "int",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "T"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        }
    },
    "core-master/core/controllers/fb_lin_controller.py": {
        "FBLinController.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fb_lin_dynamics": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[Any,Any,bool]"
                ],
                "linear_controller": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "FBLinController.eval": {
            "name": "eval",
            "location": 27,
            "return": [
                "numpy.ndarray",
                "str",
                "float",
                "bytearray",
                "Dict[str, int]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Union[pandas.DataFrame,numpy.ndarray]"
                ],
                "t": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Union[pandas.DataFrame,numpy.ndarray]"
                ]
            }
        }
    },
    "core-master/core/controllers/linear_controller.py": {
        "LinearController.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "str",
                    "List[float]"
                ],
                "K": [
                    "int",
                    "str"
                ]
            }
        },
        "LinearController.eval": {
            "name": "eval",
            "location": 21,
            "return": [
                "Optional[Any]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray"
                ],
                "t": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "core-master/core/controllers/lqr_controller.py": {
        "LQRController.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_linearizable_dynamics": [
                    "int",
                    "str",
                    "Tuple[Union[int,int]]",
                    "bool",
                    "Tuple[int,int]"
                ],
                "P": [
                    "str",
                    "Callable",
                    "int",
                    "numpy.array",
                    "bool"
                ],
                "R": [
                    "int",
                    "Tuple[Union[int,int]]",
                    "Tuple[int,int]",
                    "numpy.random.RandomState"
                ]
            }
        },
        "LQRController.eval": {
            "name": "eval",
            "location": 28,
            "return": [
                "int",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "LQRController.build": {
            "name": "build",
            "location": 32,
            "return": [
                "LQRController"
            ],
            "arguments": {
                "affine_linearizable_dynamics": [
                    "LQRController"
                ],
                "Q": [
                    "bytes",
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "R": [
                    "int",
                    "List[int]",
                    "str",
                    "Dict[str,Any]",
                    "None",
                    "Optional[str]",
                    "Optional[int]"
                ]
            }
        }
    },
    "core-master/core/controllers/mpc_controller.py": {
        "MPCController.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dynamics": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[Any,Any,bool]"
                ],
                "trajopt": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MPCController.eval": {
            "name": "eval",
            "location": 12,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Tuple",
                    "numpy.ndarray",
                    "Optional[int]",
                    "Optional[Tuple]",
                    "Optional[numpy.ndarray]"
                ],
                "t": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "core-master/core/controllers/pd_controller.py": {
        "PDController.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "pd_dynamics": [
                    "str",
                    "int"
                ],
                "K_p": [
                    "bool",
                    "float",
                    "str",
                    "Optional[str]",
                    "None",
                    "Type[AbstractIntegrationConversation]",
                    "Type",
                    "Optional[Mapping]",
                    "Mapping",
                    "int"
                ],
                "K_d": [
                    "int",
                    "bool",
                    "Dict",
                    "Optional[dict]",
                    "None",
                    "Union[float,Tuple[float,float]]",
                    "float",
                    "List[cirq.Circuit]",
                    "Tuple[Union[float,float]]",
                    "Tuple[int,int,int]",
                    "List[C]",
                    "Tuple[Union[int,int,int]]"
                ]
            }
        },
        "PDController.eval": {
            "name": "eval",
            "location": 24,
            "return": [
                "str",
                "Optional[str]",
                "Optional[Any]",
                "int",
                "Callable[..., None]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray",
                    "Union[pandas.DataFrame,numpy.ndarray]"
                ],
                "t": [
                    "int",
                    "numpy.ndarray",
                    "Union[pandas.DataFrame,numpy.ndarray]"
                ]
            }
        }
    },
    "core-master/core/controllers/piecewise_constant_controller.py": {
        "PiecewiseConstantController.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dynamics": [
                    "int",
                    "str",
                    "bool"
                ],
                "h": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "str",
                    "int"
                ],
                "ut": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "str",
                    "int"
                ],
                "round_mode": [
                    "bool",
                    "int",
                    "str",
                    "Optional[int]",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "PiecewiseConstantController.eval": {
            "name": "eval",
            "location": 13,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "int",
                    "numpy.ndarray",
                    "bytes",
                    "Union[bytes,bytearray,memoryview]",
                    "bytearray",
                    "memoryview"
                ]
            }
        }
    },
    "core-master/core/controllers/qp_controller.py": {
        "QPController.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "bool",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]",
                    "Callable[A,bool]"
                ],
                "m": [
                    "int",
                    "str",
                    "float",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "QPController.add_static_cost": {
            "name": "add_static_cost",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "P": [
                    "None",
                    "numpy.ndarray",
                    "Callable",
                    "Optional[Callable]",
                    "bool",
                    "Dict[str,str]",
                    "Optional[Dict[str,str]]",
                    "Tuple[Union[int,int]]",
                    "Optional[numpy.ndarray]",
                    "Optional[Tuple[int,int]]",
                    "Dict",
                    "Optional[dict]"
                ],
                "q": [
                    "bool",
                    "None",
                    "Optional[float]",
                    "numpy.ndarray",
                    "float",
                    "Union[str,dict]",
                    "str",
                    "Optional[numpy.ndarray]",
                    "Dict"
                ],
                "r": [
                    "int",
                    "Exception",
                    "Collection[int]",
                    "Dict[int,Tuple[int,int]]"
                ]
            }
        },
        "QPController.add_dynamic_cost": {
            "name": "add_dynamic_cost",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "P": [
                    "None",
                    "int",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]"
                ],
                "q": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "r": [
                    "Optional[numpy.ndarray]",
                    "float",
                    "None",
                    "Optional[Tuple]",
                    "Tuple",
                    "Optional[int]",
                    "int"
                ]
            }
        },
        "QPController.add_regularizer": {
            "name": "add_regularizer",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "controller": [
                    "Tuple[Union[int,int]]",
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[float,float]]",
                    "numpy.ndarray",
                    "Tuple[float,float]",
                    "bool"
                ],
                "coeff": [
                    "int",
                    "Tuple[int,int]",
                    "numpy.ndarray",
                    "Tuple[float,float]",
                    "bool"
                ]
            }
        },
        "QPController.add_stability_constraint": {
            "name": "add_stability_constraint",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "aff_lyap": [
                    "int",
                    "float"
                ],
                "comp": [
                    "Optional[Tuple[float,float]]",
                    "None",
                    "float",
                    "int",
                    "Set",
                    "Tuple[Union[float,float]]"
                ],
                "slacked": [
                    "bool",
                    "str",
                    "bytes",
                    "List[str]"
                ],
                "coeff": [
                    "int",
                    "Callable[,None]",
                    "str",
                    "List",
                    "Tuple"
                ]
            }
        },
        "QPController.add_safety_constraint": {
            "name": "add_safety_constraint",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "aff_safety": [
                    "int",
                    "float"
                ],
                "comp": [
                    "Optional[Tuple[float,float]]",
                    "None",
                    "float",
                    "int",
                    "Set",
                    "Tuple[Union[float,float]]"
                ],
                "slacked": [
                    "bool",
                    "str",
                    "bytes",
                    "List[str]"
                ],
                "coeff": [
                    "int",
                    "Callable[,None]",
                    "str",
                    "List",
                    "Tuple"
                ]
            }
        },
        "QPController.build_care": {
            "name": "build_care",
            "location": 117,
            "return": [
                "QPController"
            ],
            "arguments": {
                "aff_dynamics": [
                    "Dict",
                    "str",
                    "Dict[str,Any]",
                    "bool",
                    "List[tuple[Union[int,int]]]",
                    "List[Tuple[int,int]]",
                    "blurr.core.schema_loader.SchemaLoader"
                ],
                "Q": [
                    "Dict",
                    "str",
                    "Dict[str,Any]",
                    "bool",
                    "List[tuple[Union[int,int]]]",
                    "List[Tuple[int,int]]",
                    "blurr.core.schema_loader.SchemaLoader"
                ],
                "R": [
                    "Dict",
                    "str",
                    "Dict[str,Any]",
                    "bool",
                    "List[tuple[Union[int,int]]]",
                    "List[Tuple[int,int]]",
                    "blurr.core.schema_loader.SchemaLoader"
                ]
            }
        },
        "QPController.build_ctle": {
            "name": "build_ctle",
            "location": 132,
            "return": [
                "QPController"
            ],
            "arguments": {
                "aff_dynamics": [
                    "str"
                ],
                "K": [
                    "str"
                ],
                "Q": [
                    "str"
                ]
            }
        },
        "QPController._build": {
            "name": "_build",
            "location": 147,
            "return": [
                "QPController"
            ],
            "arguments": {
                "aff_dynamics": [
                    "bool",
                    "Dict[str,Any]",
                    "int",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "K": [
                    "List[str]",
                    "Optional[int]",
                    "Union[List[str], List[int]]",
                    "bool"
                ],
                "Q": [
                    "bool",
                    "Dict[str,Any]",
                    "int",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "R": [
                    "numpy.array",
                    "str",
                    "Dict[str, str]",
                    "List[str]",
                    "Optional[List[str]]"
                ],
                "method": [
                    "bool",
                    "List[str]",
                    "str"
                ]
            }
        },
        "QPController.eval": {
            "name": "eval",
            "location": 164,
            "return": [
                "Tuple[(Any, list)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "QPController.process": {
            "name": "process",
            "location": 173,
            "return": [
                "int",
                "str",
                "Callable",
                "List[str]",
                "bytes",
                "Tuple[Union[int,int]]"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "int",
                    "List",
                    "str"
                ]
            }
        }
    },
    "core-master/core/controllers/random_controller.py": {
        "RandomController.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "controller": [
                    "Callable[...,None]",
                    "float"
                ],
                "cov": [
                    "Callable[[None],None]",
                    "str",
                    "Callable[None,None]",
                    "List[str]",
                    "List[Outcome]",
                    "Optional[IO[Any]]",
                    "IO",
                    "None",
                    "List[Tuple[float,str]]",
                    "List[tuple[Union[float,str]]]"
                ],
                "reps": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "RandomController.sample": {
            "name": "sample",
            "location": 29,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RandomController.eval": {
            "name": "eval",
            "location": 38,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "RandomController.process": {
            "name": "process",
            "location": 45,
            "return": [
                "int",
                "str",
                "Callable",
                "List[Union[int,int,list[int]]]",
                "List[int]",
                "List[list[int]]"
            ],
            "arguments": {
                "self": [],
                "u": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "RandomController.reset": {
            "name": "reset",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "core-master/core/controllers/__init__.py": {},
    "core-master/core/dynamics/affine_dynamics.py": {
        "AffineDynamics.drift": {
            "name": "drift",
            "location": 13,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "t": [
                    "int",
                    "float"
                ]
            }
        },
        "AffineDynamics.drift_impl": {
            "name": "drift_impl",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "AffineDynamics.act": {
            "name": "act",
            "location": 29,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "t": [
                    "int",
                    "float"
                ]
            }
        },
        "AffineDynamics.act_impl": {
            "name": "act_impl",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "AffineDynamics.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 45,
            "return": [
                "bool",
                "float",
                "List[int]",
                "int",
                "str",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int"
                ],
                "u": [
                    "float",
                    "int"
                ],
                "t": [
                    "float",
                    "int"
                ]
            }
        }
    },
    "core-master/core/dynamics/affine_quad_clf.py": {
        "AffineQuadCLF.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "str",
                    "bool",
                    "Union[str,dict]",
                    "Dict"
                ],
                "P": [
                    "str",
                    "bool",
                    "Union[str,dict]",
                    "Dict"
                ]
            }
        },
        "AffineQuadCLF.drift": {
            "name": "drift",
            "location": 20,
            "return": [
                "Dict[str, int]",
                "int",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ],
                "t": [
                    "int"
                ]
            }
        },
        "AffineQuadCLF.act": {
            "name": "act",
            "location": 23,
            "return": [
                "Dict[str, int]",
                "int",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ],
                "t": [
                    "int"
                ]
            }
        },
        "AffineQuadCLF.build_care": {
            "name": "build_care",
            "location": 26,
            "return": [
                "AffineQuadCLF"
            ],
            "arguments": {
                "affine_linearizable_dynamics": [
                    "AffineQuadCLF"
                ],
                "Q": [
                    "float",
                    "int",
                    "bool"
                ],
                "R": [
                    "float",
                    "int",
                    "bool"
                ]
            }
        },
        "AffineQuadCLF.build_ctle": {
            "name": "build_ctle",
            "location": 41,
            "return": [
                "AffineQuadCLF"
            ],
            "arguments": {
                "affine_linearizable_dynamics": [
                    "AffineQuadCLF"
                ],
                "K": [
                    "float",
                    "int",
                    "Tuple[int]",
                    "Callable",
                    "bool"
                ],
                "Q": [
                    "float",
                    "bool",
                    "List[Dict[str,str]]",
                    "str",
                    "int"
                ]
            }
        }
    },
    "core-master/core/dynamics/configuration_dynamics.py": {
        "ConfigurationDynamics.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "robotic_dynamics": [
                    "int",
                    "str"
                ],
                "k": [
                    "int",
                    "numpy.ndarray",
                    "Tuple[int,int]"
                ]
            }
        },
        "ConfigurationDynamics.y": {
            "name": "y",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ConfigurationDynamics.dydq": {
            "name": "dydq",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ConfigurationDynamics.d2ydq2": {
            "name": "d2ydq2",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str"
                ]
            }
        },
        "ConfigurationDynamics.y_d": {
            "name": "y_d",
            "location": 23,
            "return": [
                "str",
                "bool",
                "Optional[int]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "str",
                    "bool",
                    "List",
                    "Type",
                    "Union[type,numpy.dtype]",
                    "int",
                    "T",
                    "numpy.array"
                ]
            }
        },
        "ConfigurationDynamics.y_d_dot": {
            "name": "y_d_dot",
            "location": 26,
            "return": [
                "str",
                "bool",
                "Optional[int]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "str",
                    "bool",
                    "List",
                    "Type",
                    "Union[type,numpy.dtype]",
                    "int",
                    "T",
                    "numpy.array"
                ]
            }
        },
        "ConfigurationDynamics.y_d_ddot": {
            "name": "y_d_ddot",
            "location": 29,
            "return": [
                "str",
                "bool",
                "Optional[int]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "str",
                    "bool",
                    "List",
                    "Type",
                    "Union[type,numpy.dtype]",
                    "int",
                    "T",
                    "numpy.array"
                ]
            }
        },
        "ConfigurationDynamics.eval": {
            "name": "eval",
            "location": 32,
            "return": [
                "Optional[int]",
                "Optional[List[int]]",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "t": [
                    "int",
                    "float"
                ]
            }
        },
        "ConfigurationDynamics.drift": {
            "name": "drift",
            "location": 35,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "Union[float,numpy.ndarray]",
                    "float"
                ]
            }
        },
        "ConfigurationDynamics.act": {
            "name": "act",
            "location": 41,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "ConfigurationDynamics.proportional": {
            "name": "proportional",
            "location": 46,
            "return": [
                "Dict[str, int]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "t": [
                    "int",
                    "List[int]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "ConfigurationDynamics.derivative": {
            "name": "derivative",
            "location": 50,
            "return": [
                "numpy.ndarray",
                "bytearray",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "T"
                ],
                "t": [
                    "Callable",
                    "int"
                ]
            }
        }
    },
    "core-master/core/dynamics/configuration_trajectory_dynamics.py": {
        "ConfigurationTrajectoryDynamics.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "robotic_dynamics": [
                    "bool",
                    "None",
                    "Optional[bool]",
                    "float",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "k": [
                    "bool",
                    "None",
                    "Optional[bool]",
                    "float",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "_y_d": [
                    "int",
                    "None",
                    "float",
                    "bool",
                    "Optional[int]"
                ],
                "_y_d_dot": [
                    "bool",
                    "None",
                    "int",
                    "numpy.array"
                ],
                "_y_d_ddot": [
                    "bool",
                    "None",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.y": {
            "name": "y",
            "location": 13,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.dydq": {
            "name": "dydq",
            "location": 16,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.d2ydq2": {
            "name": "d2ydq2",
            "location": 19,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.y_d": {
            "name": "y_d",
            "location": 22,
            "return": [
                "bool",
                "Dict[str, str]",
                "dict",
                "Mapping[str, Sequence[str]]"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "int",
                    "float",
                    "str",
                    "numpy.array"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.y_d_dot": {
            "name": "y_d_dot",
            "location": 25,
            "return": [
                "int",
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "int",
                    "str"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.y_d_ddot": {
            "name": "y_d_ddot",
            "location": 28,
            "return": [
                "int",
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "int",
                    "str"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.add_trajectory": {
            "name": "add_trajectory",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "qs": [
                    "str",
                    "Dict[str,Any]",
                    "bool",
                    "float"
                ],
                "q_dots": [
                    "str",
                    "bool",
                    "Dict[str,Any]",
                    "float"
                ],
                "ts": [
                    "str",
                    "bool",
                    "Dict[str,Any]",
                    "float"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.add_trajectory.cubic_spline": {
            "name": "cubic_spline",
            "location": 35,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "t": []
            }
        },
        "ConfigurationTrajectoryDynamics.add_trajectory._y_d": {
            "name": "_y_d",
            "location": 72,
            "return": [
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "t": [
                    "int",
                    "List[T]",
                    "bool",
                    "Union[int, List[int]]",
                    "Union[int, float]",
                    "Dict[str, int]"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.add_trajectory._y_d_dot": {
            "name": "_y_d_dot",
            "location": 76,
            "return": [
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "t": [
                    "bool",
                    "numpy.array",
                    "list",
                    "List[T]"
                ]
            }
        },
        "ConfigurationTrajectoryDynamics.add_trajectory._y_d_ddot": {
            "name": "_y_d_ddot",
            "location": 80,
            "return": [
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "t": [
                    "float",
                    "int",
                    "str",
                    "Optional[float]",
                    "numpy.array"
                ]
            }
        }
    },
    "core-master/core/dynamics/dynamics.py": {
        "Dynamics.eval": {
            "name": "eval",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "Dynamics.eval_dot": {
            "name": "eval_dot",
            "location": 24,
            "return": [
                "Optional[int]",
                "str",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "u": [
                    "int",
                    "float"
                ],
                "t": [
                    "int",
                    "float"
                ]
            }
        },
        "Dynamics.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "List[List[str]]",
                    "None",
                    "List[list[str]]"
                ],
                "u": [
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "List[List[str]]",
                    "None",
                    "List[list[str]]"
                ],
                "t": [
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "List[List[str]]",
                    "None",
                    "List[list[str]]"
                ]
            }
        },
        "Dynamics.jacobian": {
            "name": "jacobian",
            "location": 41,
            "return": [
                "Optional[int]",
                "str",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "u": [
                    "int",
                    "float"
                ],
                "t": [
                    "int",
                    "float"
                ]
            }
        },
        "Dynamics.jacobian_impl": {
            "name": "jacobian_impl",
            "location": 44,
            "return": [
                "Optional[int]",
                "int",
                "List[int]",
                "torch.FloatTensor",
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ],
                "u": [
                    "int"
                ],
                "t": [
                    "int"
                ]
            }
        },
        "Dynamics.jacobian_exp": {
            "name": "jacobian_exp",
            "location": 47,
            "return": [
                "Optional[int]",
                "int",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int"
                ],
                "u": [
                    "float",
                    "int"
                ],
                "t": [
                    "float",
                    "int"
                ],
                "delta_t": [
                    "float",
                    "int"
                ]
            }
        },
        "Dynamics.jacobian_exp_impl": {
            "name": "jacobian_exp_impl",
            "location": 50,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Union[int, float]",
                    "int"
                ],
                "u": [
                    "float",
                    "int"
                ],
                "t": [
                    "int"
                ],
                "delta_t": [
                    "int",
                    "float",
                    "torch.Tensor"
                ]
            }
        }
    },
    "core-master/core/dynamics/fb_lin_dynamics.py": {
        "FBLinDynamics.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "relative_degrees": [
                    "int",
                    "bool",
                    "float"
                ],
                "perm": [
                    "Optional[float]",
                    "None",
                    "Optional[str]",
                    "float",
                    "int",
                    "Optional[int]",
                    "str",
                    "Optional[Callable]",
                    "Optional[Hashable]",
                    "Callable",
                    "Hashable"
                ]
            }
        },
        "FBLinDynamics.select": {
            "name": "select",
            "location": 36,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "FBLinDynamics.permute": {
            "name": "permute",
            "location": 48,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "FBLinDynamics.inv_permute": {
            "name": "inv_permute",
            "location": 60,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "FBLinDynamics.linear_system": {
            "name": "linear_system",
            "location": 72,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "core-master/core/dynamics/fully_actuated_robotic_dynamics.py": {
        "FullyActuatedRoboticDynamics.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int",
                    "str",
                    "float"
                ],
                "m": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "core-master/core/dynamics/learned_affine_dynamics.py": {
        "LearnedAffineDynamics.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "int",
                    "float",
                    "str",
                    "List[cirq.Circuit]",
                    "bool"
                ],
                "res_aff_model": [
                    "int",
                    "float",
                    "str",
                    "List[cirq.Circuit]",
                    "bool"
                ]
            }
        },
        "LearnedAffineDynamics.process_drift": {
            "name": "process_drift",
            "location": 11,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "Tuple",
                    "float"
                ],
                "t": [
                    "int",
                    "Tuple",
                    "float"
                ]
            }
        },
        "LearnedAffineDynamics.process_act": {
            "name": "process_act",
            "location": 14,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "Tuple",
                    "float"
                ],
                "t": [
                    "int",
                    "Tuple",
                    "float"
                ]
            }
        },
        "LearnedAffineDynamics.eval": {
            "name": "eval",
            "location": 17,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ],
                "t": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ]
            }
        },
        "LearnedAffineDynamics.drift": {
            "name": "drift",
            "location": 20,
            "return": [
                "bool",
                "List[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Tuple[Union[float,float]]",
                    "numpy.ndarray",
                    "Tuple[float,float]"
                ],
                "t": [
                    "float",
                    "Tuple[Union[float,float]]",
                    "numpy.ndarray",
                    "Tuple[float,float]"
                ]
            }
        },
        "LearnedAffineDynamics.act": {
            "name": "act",
            "location": 23,
            "return": [
                "bool",
                "List[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Tuple[Union[float,float]]",
                    "numpy.ndarray",
                    "Tuple[float,float]"
                ],
                "t": [
                    "float",
                    "Tuple[Union[float,float]]",
                    "numpy.ndarray",
                    "Tuple[float,float]"
                ]
            }
        },
        "LearnedAffineDynamics.process_episode": {
            "name": "process_episode",
            "location": 26,
            "return": [
                "Tuple[(Any, Any, _T1, Any)]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "int",
                    "float"
                ],
                "us": [
                    "int",
                    "List[int]",
                    "Sized",
                    "numpy.ndarray",
                    "str"
                ],
                "ts": [
                    "Tuple[int,int]",
                    "str",
                    "Tuple[Union[int,int]]"
                ],
                "window": [
                    "int",
                    "bool",
                    "Tuple[float,float]",
                    "Union[numpy.ndarray,numpy.void]",
                    "str",
                    "Optional[Set[str]]"
                ]
            }
        },
        "LearnedAffineDynamics.init_data": {
            "name": "init_data",
            "location": 47,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "d_drift_in": [
                    "int",
                    "bool"
                ],
                "d_act_in": [
                    "int",
                    "bool"
                ],
                "m": [
                    "int",
                    "bool"
                ],
                "d_out": [
                    "int",
                    "bool"
                ]
            }
        },
        "LearnedAffineDynamics.fit": {
            "name": "fit",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "str",
                    "int",
                    "Dict[str,Any]",
                    "List[str]"
                ],
                "batch_size": [
                    "int",
                    "List",
                    "Optional[int]",
                    "bool",
                    "float"
                ],
                "num_epochs": [
                    "int",
                    "List",
                    "Optional[int]",
                    "bool",
                    "float"
                ],
                "validation_split": [
                    "int",
                    "List",
                    "Optional[int]",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "core-master/core/dynamics/learned_dynamics.py": {
        "LearnedDynamics.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dynamics": [
                    "int",
                    "Dict[str,Any]",
                    "str",
                    "Optional[str]",
                    "None",
                    "bool"
                ],
                "res_model": [
                    "int",
                    "Dict[str,Any]",
                    "str",
                    "Optional[str]",
                    "None",
                    "bool"
                ]
            }
        },
        "LearnedDynamics.process": {
            "name": "process",
            "location": 11,
            "return": [
                "str",
                "Optional[int]",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "List[int]"
                ],
                "u": [
                    "int",
                    "float",
                    "List[int]"
                ],
                "t": [
                    "int",
                    "float",
                    "List[int]"
                ]
            }
        },
        "LearnedDynamics.eval": {
            "name": "eval",
            "location": 14,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ],
                "t": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ]
            }
        },
        "LearnedDynamics.eval_dot": {
            "name": "eval_dot",
            "location": 17,
            "return": [
                "Optional[int]",
                "int",
                "List[int]",
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray"
                ],
                "u": [
                    "int",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "LearnedDynamics.process_episode": {
            "name": "process_episode",
            "location": 20,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "str",
                    "Mapping[str,float]",
                    "int",
                    "Dict"
                ],
                "us": [
                    "int",
                    "float",
                    "List[int]"
                ],
                "ts": [
                    "int",
                    "numpy.ndarray"
                ],
                "window": [
                    "int",
                    "bool",
                    "Tuple[float,float]",
                    "Union[numpy.ndarray,numpy.void]",
                    "str",
                    "Optional[Set[str]]"
                ]
            }
        },
        "LearnedDynamics.init_data": {
            "name": "init_data",
            "location": 39,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "d_in": [
                    "Iterable[bytes]",
                    "int",
                    "float",
                    "List[Dict]",
                    "Set"
                ],
                "d_out": [
                    "Iterable[bytes]",
                    "int",
                    "float",
                    "List[Dict]",
                    "Set"
                ]
            }
        },
        "LearnedDynamics.aggregate_data": {
            "name": "aggregate_data",
            "location": 42,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "old_data": [
                    "Dict",
                    "bytes",
                    "str",
                    "Dict[str,Any]"
                ],
                "new_data": [
                    "Dict",
                    "bytes",
                    "str",
                    "Dict[str,Any]"
                ]
            }
        },
        "LearnedDynamics.fit": {
            "name": "fit",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Dict",
                    "str",
                    "List[dict]",
                    "List[Dict]",
                    "bool",
                    "Callable[dict,None]",
                    "None",
                    "Optional[Callable[[dict],None]]",
                    "ks.Series",
                    "int",
                    "Optional[Dict]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int,int]"
                ],
                "num_epochs": [
                    "int",
                    "float",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int,int]"
                ],
                "validation_split": [
                    "int",
                    "float",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int,int]"
                ]
            }
        }
    },
    "core-master/core/dynamics/learned_fb_lin_dynamics.py": {
        "LearnedFBLinDynamics.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fb_lin_dynamics": [
                    "str",
                    "int",
                    "float",
                    "Optional[str]",
                    "None"
                ],
                "res_aff_model": [
                    "str",
                    "bool",
                    "Optional[bool]",
                    "List[str]",
                    "None"
                ]
            }
        },
        "LearnedFBLinDynamics.drift": {
            "name": "drift",
            "location": 12,
            "return": [
                "int",
                "List[Union[float,tuple[Union[Any,Any]]]]",
                "str",
                "List",
                "List[int]",
                "List[tuple[Union[Any,Any]]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray",
                    "None",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ],
                "t": [
                    "int",
                    "numpy.ndarray",
                    "None",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ]
            }
        },
        "LearnedFBLinDynamics.act": {
            "name": "act",
            "location": 19,
            "return": [
                "int",
                "List[Union[float,tuple[Union[Any,Any]]]]",
                "str",
                "List",
                "List[int]",
                "List[tuple[Union[Any,Any]]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray",
                    "None",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ],
                "t": [
                    "int",
                    "numpy.ndarray",
                    "None",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ]
            }
        },
        "LearnedFBLinDynamics.process_episode": {
            "name": "process_episode",
            "location": 26,
            "return": [
                "Tuple[(Any, Any, _T1, numpy.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "bool"
                ],
                "us": [
                    "float",
                    "Mapping[str,Tuple[float,float,float]]",
                    "str",
                    "Mapping",
                    "Union[int,float]",
                    "int"
                ],
                "ts": [
                    "bool"
                ],
                "window": [
                    "bool",
                    "int"
                ]
            }
        }
    },
    "core-master/core/dynamics/learned_scalar_affine_dynamics.py": {
        "LearnedScalarAffineDynamics.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "str",
                    "bool",
                    "Optional[bool]",
                    "None"
                ],
                "res_aff_model": [
                    "str",
                    "bool",
                    "Optional[bool]",
                    "None"
                ]
            }
        },
        "LearnedScalarAffineDynamics.init_data": {
            "name": "init_data",
            "location": 8,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "d_drift_in": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[bool]"
                ],
                "d_act_in": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[bool]"
                ],
                "m": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "Optional[bool]"
                ],
                "d_out": [
                    "bool",
                    "str",
                    "int",
                    "float",
                    "Optional[float]",
                    "None"
                ]
            }
        }
    },
    "core-master/core/dynamics/linearizable_dynamics.py": {
        "LinearizableDynamics.linear_system": {
            "name": "linear_system",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LinearizableDynamics.closed_loop_linear_system": {
            "name": "closed_loop_linear_system",
            "location": 20,
            "return": [
                "float",
                "int",
                "bool",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "K": [
                    "str",
                    "Callable[[str],Any]",
                    "Hashable",
                    "Callable[str,Any]",
                    "Optional[Dict[str,str]]",
                    "Dict[str,str]",
                    "None"
                ]
            }
        }
    },
    "core-master/core/dynamics/pd_dynamics.py": {
        "PDDynamics.proportional": {
            "name": "proportional",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "PDDynamics.derivative": {
            "name": "derivative",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        }
    },
    "core-master/core/dynamics/quadratic_clf.py": {
        "QuadraticCLF.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dynamics": [
                    "int",
                    "float",
                    "bool"
                ],
                "P": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "QuadraticCLF.eval": {
            "name": "eval",
            "location": 19,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "t": [
                    "float"
                ]
            }
        },
        "QuadraticCLF.eval_grad": {
            "name": "eval_grad",
            "location": 33,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "t": [
                    "float"
                ]
            }
        },
        "QuadraticCLF.eval_dot": {
            "name": "eval_dot",
            "location": 37,
            "return": [
                "Dict[str, int]",
                "int",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "u": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "core-master/core/dynamics/robotic_dynamics.py": {
        "RoboticDynamics.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int",
                    "bool"
                ],
                "m": [
                    "int",
                    "bool"
                ]
            }
        },
        "RoboticDynamics.D": {
            "name": "D",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str"
                ]
            }
        },
        "RoboticDynamics.C": {
            "name": "C",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str"
                ],
                "q_dot": [
                    "str"
                ]
            }
        },
        "RoboticDynamics.B": {
            "name": "B",
            "location": 56,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "Iterable[Any]"
                ]
            }
        },
        "RoboticDynamics.U": {
            "name": "U",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "RoboticDynamics.G": {
            "name": "G",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "RoboticDynamics.F_ext": {
            "name": "F_ext",
            "location": 92,
            "return": [
                "str",
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "int",
                    "List[str]"
                ],
                "qdot": [
                    "bool",
                    "str",
                    "List[str]",
                    "Set[str]"
                ]
            }
        },
        "RoboticDynamics.T": {
            "name": "T",
            "location": 105,
            "return": [
                "str",
                "int",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Sequence[str]"
                ],
                "q_dot": [
                    "int",
                    "str",
                    "Sequence[str]"
                ]
            }
        },
        "RoboticDynamics.H": {
            "name": "H",
            "location": 117,
            "return": [
                "float",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "bytes",
                    "int",
                    "str",
                    "float",
                    "Dict"
                ],
                "q_dot": [
                    "str",
                    "int",
                    "float",
                    "torch.Tensor",
                    "Dict",
                    "bool"
                ]
            }
        },
        "RoboticDynamics.drift_impl": {
            "name": "drift_impl",
            "location": 134,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "t": [
                    "float"
                ]
            }
        },
        "RoboticDynamics.act_impl": {
            "name": "act_impl",
            "location": 141,
            "return": [
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "torch.Tensor"
                ],
                "t": [
                    "float"
                ]
            }
        },
        "RoboticDynamics.proportional": {
            "name": "proportional",
            "location": 149,
            "return": [
                "str",
                "Callable[[KT],VT]",
                "Type",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "int",
                    "T"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "RoboticDynamics.derivative": {
            "name": "derivative",
            "location": 152,
            "return": [
                "str",
                "Callable[[KT],VT]",
                "Type",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "int",
                    "T"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "RoboticDynamics.plot_coordinates": {
            "name": "plot_coordinates",
            "location": 155,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "bool",
                    "int",
                    "str",
                    "Optional[Union[str,Any]]",
                    "Any",
                    "None"
                ],
                "qs": [
                    "bool",
                    "int",
                    "str",
                    "Optional[Union[str,Any]]",
                    "Any",
                    "None"
                ],
                "fig": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[str,Any]]",
                    "str",
                    "Any"
                ],
                "ax": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[str,Any]]",
                    "str",
                    "Any"
                ],
                "labels": [
                    "None",
                    "int",
                    "Optional[int]",
                    "List[int]",
                    "Optional[List[Any]]",
                    "Optional[bool]"
                ]
            }
        },
        "RoboticDynamics.plot": {
            "name": "plot",
            "location": 161,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "Tuple[Union[ndarray,ndarray,ndarray]]",
                    "int",
                    "Mapping[str,float]",
                    "float",
                    "Tuple[ndarray,ndarray,ndarray]"
                ],
                "us": [
                    "Dict[str,torch.Tensor]",
                    "bool",
                    "str",
                    "Optional[torch.Tensor]",
                    "None"
                ],
                "ts": [
                    "Dict[str,torch.Tensor]",
                    "int",
                    "str",
                    "List",
                    "None",
                    "Optional[torch.Tensor]",
                    "PerceptionSemanticAlignment"
                ],
                "fig": [
                    "bool",
                    "str",
                    "None"
                ],
                "coordinate_labels": [
                    "Dict[str,torch.Tensor]",
                    "None",
                    "bool",
                    "str",
                    "Optional[torch.Tensor]"
                ],
                "action_labels": [
                    "Dict[str,torch.Tensor]",
                    "None",
                    "bool",
                    "str",
                    "Optional[torch.Tensor]"
                ]
            }
        }
    },
    "core-master/core/dynamics/scalar_dynamics.py": {
        "ScalarDynamics.eval_grad": {
            "name": "eval_grad",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        }
    },
    "core-master/core/dynamics/system_dynamics.py": {
        "SystemDynamics.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int"
                ],
                "m": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "SystemDynamics.eval": {
            "name": "eval",
            "location": 25,
            "return": [
                "str",
                "Exception",
                "None",
                "List[str]",
                "List[float]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "SystemDynamics.step": {
            "name": "step",
            "location": 28,
            "return": [
                "List[int]",
                "numpy.ndarray",
                "Iterable[str]",
                "Iterable[T]",
                "int"
            ],
            "arguments": {
                "self": [],
                "x_0": [
                    "int",
                    "List[str]",
                    "Tuple[float,float]",
                    "float",
                    "Tuple[Union[float,float]]"
                ],
                "u_0": [
                    "List[int]",
                    "numpy.ndarray",
                    "T"
                ],
                "t_0": [
                    "str",
                    "Optional[str]",
                    "List[float]",
                    "None"
                ],
                "t_f": [
                    "str",
                    "Optional[str]",
                    "List[float]",
                    "None"
                ],
                "atol": [
                    "float",
                    "int",
                    "Tuple[float,float]",
                    "List[str]"
                ],
                "rtol": [
                    "float",
                    "int",
                    "Tuple[float,float]",
                    "List[str]"
                ]
            }
        },
        "SystemDynamics.simulate": {
            "name": "simulate",
            "location": 51,
            "return": [
                "Tuple[(Any, Union[(list, numpy.ndarray)])]"
            ],
            "arguments": {
                "self": [],
                "x_0": [
                    "float",
                    "Iterable[float]",
                    "T"
                ],
                "controller": [
                    "Dict[str, Any]"
                ],
                "ts": [
                    "int",
                    "numpy.ndarray"
                ],
                "processed": [
                    "bool",
                    "numpy.ndarray",
                    "Tuple[float,float]",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ],
                "atol": [
                    "float",
                    "numpy.ndarray",
                    "Tuple[float,float]",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ],
                "rtol": [
                    "float",
                    "numpy.ndarray",
                    "Tuple[float,float]",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ]
            }
        },
        "SystemDynamics.plot_timeseries": {
            "name": "plot_timeseries",
            "location": 93,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "float",
                    "str"
                ],
                "data": [
                    "float",
                    "str"
                ],
                "fig": [
                    "bool",
                    "None",
                    "int"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Optional[Union[int,Any]]",
                    "Any",
                    "float",
                    "List[int]",
                    "Union[int,str]",
                    "str",
                    "Optional[bool]",
                    "Optional[int]",
                    "bool"
                ],
                "title": [
                    "bool",
                    "None",
                    "Union[None,str]",
                    "str",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "labels": [
                    "None",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "str",
                    "Sequence[str]",
                    "Optional[int]",
                    "Optional[str]"
                ]
            }
        },
        "SystemDynamics.plot_states": {
            "name": "plot_states",
            "location": 107,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "float",
                    "numpy.ndarray",
                    "int",
                    "util.ArrayLike",
                    "Union[int,float]"
                ],
                "xs": [
                    "float",
                    "numpy.ndarray",
                    "int",
                    "util.ArrayLike",
                    "Union[int,float]"
                ],
                "fig": [
                    "None",
                    "float",
                    "numpy.ndarray",
                    "int",
                    "util.ArrayLike",
                    "Union[int,float]"
                ],
                "ax": [
                    "None",
                    "float",
                    "numpy.ndarray",
                    "int",
                    "util.ArrayLike",
                    "Union[int,float]"
                ],
                "labels": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Callable",
                    "Optional[numpy.ndarray]",
                    "Optional[int]",
                    "Optional[bool]",
                    "Optional[Callable]"
                ]
            }
        },
        "SystemDynamics.plot_actions": {
            "name": "plot_actions",
            "location": 113,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "str",
                    "bytes",
                    "int",
                    "Optional[Union[str,Any]]",
                    "bool",
                    "Type[Any]"
                ],
                "us": [
                    "int",
                    "Optional[Union[str,Any]]",
                    "str",
                    "bytes",
                    "bool",
                    "Any",
                    "Type[Any]",
                    "None",
                    "Type"
                ],
                "fig": [
                    "int",
                    "None",
                    "Optional[Union[str,Any]]",
                    "bytes",
                    "bool",
                    "str",
                    "Type[Any]",
                    "Any",
                    "Type"
                ],
                "ax": [
                    "int",
                    "None",
                    "Optional[Union[str,Any]]",
                    "bytes",
                    "bool",
                    "str",
                    "Type[Any]",
                    "Any",
                    "Type"
                ],
                "labels": [
                    "int",
                    "None",
                    "str",
                    "Dict[str,int]",
                    "Sequence[str]",
                    "numpy.ndarray"
                ]
            }
        },
        "SystemDynamics.plot": {
            "name": "plot",
            "location": 119,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "Optional[float]",
                    "int",
                    "float",
                    "None"
                ],
                "us": [
                    "float",
                    "Tuple[int]",
                    "util.ArrayLike",
                    "Union[GenericFixed,Table]"
                ],
                "ts": [
                    "int",
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "fig": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "List[Dict]",
                    "Dict",
                    "List[dict]",
                    "List[Dict[str,int]]",
                    "int",
                    "List[dict[str,int]]"
                ],
                "state_labels": [
                    "Optional[float]",
                    "int",
                    "None",
                    "float"
                ],
                "action_labels": [
                    "float",
                    "None",
                    "Tuple[int]",
                    "util.ArrayLike",
                    "Union[GenericFixed,Table]"
                ]
            }
        }
    },
    "core-master/core/dynamics/__init__.py": {},
    "core-master/core/geometry/ball.py": {
        "Ball.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "str",
                    "bool",
                    "Union[str,dict]",
                    "Dict"
                ]
            }
        },
        "Ball.sample": {
            "name": "sample",
            "location": 14,
            "return": [
                "int",
                "List[Tuple[int, float, float]]",
                "List[dict]",
                "bool",
                "str",
                "Sequence[int]"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "List[int]",
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "Ball.is_member": {
            "name": "is_member",
            "location": 22,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "float",
                    "int",
                    "T"
                ]
            }
        },
        "Ball.uniform": {
            "name": "uniform",
            "location": 25,
            "return": [
                "Tuple[(numpy.ndarray, Any)]"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "Sequence",
                    "List"
                ]
            }
        },
        "Ball.uniform_grid": {
            "name": "uniform_grid",
            "location": 30,
            "return": [
                "List",
                "int",
                "str",
                "List[T]",
                "List[float]",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "Ball.uniform_list": {
            "name": "uniform_list",
            "location": 36,
            "return": [
                "str",
                "Tuple[float,float]",
                "List[int]",
                "Union[int,float]"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "float"
                ]
            }
        },
        "Ball.safety": {
            "name": "safety",
            "location": 40,
            "return": [
                "Ball.SafetyDynamics"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Ball.SafetyDynamics.__init__": {
            "name": "__init__",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Ball.SafetyDynamics.eval": {
            "name": "eval",
            "location": 47,
            "return": [
                "int",
                "Dict[str,int]",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "t": [
                    "float"
                ]
            }
        },
        "Ball.SafetyDynamics.eval_grad": {
            "name": "eval_grad",
            "location": 50,
            "return": [
                "int",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ],
                "t": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "Ball.SafetyDynamics.drift": {
            "name": "drift",
            "location": 53,
            "return": [
                "Dict[str, int]",
                "int",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ],
                "t": [
                    "int"
                ]
            }
        },
        "Ball.SafetyDynamics.act": {
            "name": "act",
            "location": 56,
            "return": [
                "Dict[str, int]",
                "int",
                "numpy.ndarray",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int"
                ],
                "t": [
                    "int"
                ]
            }
        }
    },
    "core-master/core/geometry/box.py": {
        "Box.sample": {
            "name": "sample",
            "location": 10,
            "return": [
                "int",
                "str",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int"
                ]
            }
        },
        "Box.is_member": {
            "name": "is_member",
            "location": 13,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "float",
                    "int",
                    "T"
                ]
            }
        },
        "Box.meshgrid": {
            "name": "meshgrid",
            "location": 16,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int"
                ]
            }
        },
        "Box.uniform_grid": {
            "name": "uniform_grid",
            "location": 20,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int"
                ]
            }
        },
        "Box.uniform_list": {
            "name": "uniform_list",
            "location": 24,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "float"
                ]
            }
        }
    },
    "core-master/core/geometry/convex_body.py": {
        "ConvexBody.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ConvexBody.sample": {
            "name": "sample",
            "location": 13,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "bool"
                ]
            }
        },
        "ConvexBody.is_member": {
            "name": "is_member",
            "location": 16,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "Dict[str,Any]",
                    "int",
                    "Sequence",
                    "None",
                    "T",
                    "Optional[bool]"
                ]
            }
        },
        "ConvexBody.uniform_grid": {
            "name": "uniform_grid",
            "location": 19,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "bool"
                ]
            }
        },
        "ConvexBody.uniform_list": {
            "name": "uniform_list",
            "location": 22,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "bool"
                ]
            }
        },
        "ConvexBody.safety": {
            "name": "safety",
            "location": 25,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ConvexBody.voronoi_iteration": {
            "name": "voronoi_iteration",
            "location": 28,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "k": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "tol": [
                    "int",
                    "str"
                ],
                "verbose": [
                    "bool",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "ConvexBody.grid_map": {
            "name": "grid_map",
            "location": 57,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "func": [
                    "Callable",
                    "bool"
                ],
                "grids": [
                    "Iterable",
                    "Callable"
                ]
            }
        },
        "ConvexBody.voronoi_iteration.centers_to_clusters": {
            "name": "centers_to_clusters",
            "location": 31,
            "return": [
                "List",
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "centers": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "ConvexBody.voronoi_iteration.total_distance": {
            "name": "total_distance",
            "location": 39,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "clusters": [
                    "int",
                    "Callable",
                    "str"
                ],
                "centers": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        }
    },
    "core-master/core/geometry/derived.py": {
        "Derived.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "primitive": [
                    "bool",
                    "List[str]",
                    "Callable[[dict],None]",
                    "str",
                    "Callable[dict,None]",
                    "float",
                    "Dict[str,Any]"
                ],
                "T": [
                    "int",
                    "List[int]",
                    "None",
                    "Optional[List[int]]",
                    "bool"
                ],
                "c": [
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "Derived.from_primitive": {
            "name": "from_primitive",
            "location": 17,
            "return": [
                "bool",
                "List[Tuple[str, int]]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "Type",
                    "List[str]",
                    "numpy.ndarray",
                    "int",
                    "Type[T]",
                    "bool"
                ]
            }
        },
        "Derived.to_primitive": {
            "name": "to_primitive",
            "location": 20,
            "return": [
                "int",
                "List[int]",
                "bool",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "int",
                    "float"
                ]
            }
        },
        "Derived.sample": {
            "name": "sample",
            "location": 23,
            "return": [
                "bytes",
                "str",
                "Dict[str, Any]",
                "int",
                "allennlp.common.util.JsonDict"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int"
                ]
            }
        },
        "Derived.is_member": {
            "name": "is_member",
            "location": 26,
            "return": [
                "bool",
                "Optional[str]",
                "Callable[..., None]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "int",
                    "float",
                    "str",
                    "numpy.array"
                ]
            }
        },
        "Derived.uniform_grid": {
            "name": "uniform_grid",
            "location": 29,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ]
            }
        },
        "Derived.uniform_list": {
            "name": "uniform_list",
            "location": 42,
            "return": [
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "Derived.safety": {
            "name": "safety",
            "location": 45,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "affine_dynamics": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Derived.DerivedDynamics.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "derived": [
                    "int",
                    "bool",
                    "float"
                ],
                "affine_dynamics": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Derived.DerivedDynamics.eval": {
            "name": "eval",
            "location": 54,
            "return": [
                "float",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float"
                ],
                "t": [
                    "float"
                ]
            }
        },
        "Derived.DerivedDynamics.drift": {
            "name": "drift",
            "location": 57,
            "return": [
                "int",
                "Optional[int]",
                "List[int]",
                "Tuple[Tuple[int, Any]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float"
                ],
                "t": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "Derived.DerivedDynamics.act": {
            "name": "act",
            "location": 60,
            "return": [
                "int",
                "Optional[int]",
                "List[int]",
                "Tuple[Tuple[int, Any]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float"
                ],
                "t": [
                    "numpy.ndarray",
                    "float"
                ]
            }
        }
    },
    "core-master/core/geometry/two_ball.py": {
        "TwoBall.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TwoBall.boundary": {
            "name": "boundary",
            "location": 10,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int"
                ]
            }
        }
    },
    "core-master/core/geometry/visual.py": {
        "Visual.boundary": {
            "name": "boundary",
            "location": 2,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "core-master/core/geometry/visual_derived.py": {
        "VisualDerived.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "visual_primitive": [
                    "bool",
                    "List[str]",
                    "Type",
                    "float",
                    "Sequence[str]"
                ],
                "T": [
                    "bool",
                    "List[str]",
                    "Type",
                    "float",
                    "Sequence[str]"
                ],
                "c": [
                    "bool",
                    "List[str]",
                    "Type",
                    "float",
                    "Sequence[str]"
                ]
            }
        },
        "VisualDerived.boundary": {
            "name": "boundary",
            "location": 8,
            "return": [
                "bytes",
                "str",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "N": [
                    "int"
                ]
            }
        }
    },
    "core-master/core/geometry/__init__.py": {},
    "core-master/core/learning/gaussian_process.py": {
        "pi": {
            "name": "pi",
            "location": 13,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "diff_mat": {
            "name": "diff_mat",
            "location": 16,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "x1": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ],
                "x2": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "save_gp": {
            "name": "save_gp",
            "location": 550,
            "return": [
                "None"
            ],
            "arguments": {
                "gp": [
                    "str",
                    "Union[str, Dict[str, Any]]",
                    "list"
                ],
                "dir": [
                    "str",
                    "List",
                    "Union[str,Dict[str,Any]]",
                    "Dict[str,Any]"
                ]
            }
        },
        "load_gp": {
            "name": "load_gp",
            "location": 553,
            "return": [
                "GaussianProcess"
            ],
            "arguments": {
                "dir": [
                    "str",
                    "Dict"
                ],
                "kernel": [
                    "str",
                    "Optional[str]",
                    "None",
                    "Optional[Dict[str,dict]]",
                    "Dict[str,dict]"
                ]
            }
        },
        "PeriodicKernel.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "p_prior": [
                    "int",
                    "bool"
                ],
                "active_dims": [
                    "int",
                    "None",
                    "Dict[str,Any]",
                    "Union[str,int]",
                    "bool",
                    "str"
                ],
                "learn_period": [
                    "bool",
                    "int"
                ]
            }
        },
        "PeriodicKernel.forward": {
            "name": "forward",
            "location": 28,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "torch.Tensor",
                    "Union[float,numpy.ndarray]"
                ],
                "x2": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "PeriodicKernel.ddx1": {
            "name": "ddx1",
            "location": 36,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "torch.Tensor"
                ],
                "x2": [
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "PeriodicKernel.ddx2": {
            "name": "ddx2",
            "location": 44,
            "return": [
                "bool",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "bool",
                    "int"
                ],
                "x2": [
                    "bool",
                    "int"
                ]
            }
        },
        "PeriodicKernel.d2dx1x2": {
            "name": "d2dx1x2",
            "location": 47,
            "return": [
                "Tuple[float, float]",
                "bool",
                "Optional[str]",
                "Type[BaseException]",
                "Optional[static_frame.core.store_filter.StoreFilter]",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "str",
                    "numpy.array"
                ],
                "x2": [
                    "float",
                    "str",
                    "numpy.array"
                ]
            }
        },
        "PeriodicKernel.length_scale": {
            "name": "length_scale",
            "location": 56,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeriodicKernel.signal_variance": {
            "name": "signal_variance",
            "location": 60,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeriodicKernel.__str__": {
            "name": "__str__",
            "location": 63,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiplicativeKernel.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernels": [
                    "str",
                    "src.core.model.library.Library",
                    "Tuple[int]",
                    "List[int]",
                    "List",
                    "List[str]",
                    "List[tuple]",
                    "List[Tuple]"
                ],
                "active_dims": [
                    "str",
                    "int",
                    "List[str]",
                    "Tuple[int]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "MultiplicativeKernel.forward": {
            "name": "forward",
            "location": 75,
            "return": [
                "bool",
                "torch.Tensor",
                "List[Dict[str, Any]]",
                "List[int]",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "numpy.array",
                    "torch.Tensor",
                    "float",
                    "numpy.ndarray",
                    "int"
                ],
                "x2": [
                    "numpy.array",
                    "torch.Tensor",
                    "float",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "MultiplicativeKernel._augment_jacobian": {
            "name": "_augment_jacobian",
            "location": 83,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "numpy.ndarray",
                    "List[list[T]]",
                    "List[T]",
                    "torch.Tensor",
                    "List[List[T]]"
                ],
                "x2": [
                    "float",
                    "numpy.ndarray",
                    "List[list[T]]",
                    "List[T]",
                    "torch.Tensor",
                    "List[List[T]]"
                ],
                "j_small": [
                    "str",
                    "float",
                    "numpy.ndarray",
                    "Container",
                    "int",
                    "List[str]"
                ],
                "ad": [
                    "str",
                    "float",
                    "Container",
                    "int",
                    "List[str]",
                    "numpy.ndarray"
                ]
            }
        },
        "MultiplicativeKernel._ddx": {
            "name": "_ddx",
            "location": 90,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "x2": [
                    "torch.Tensor",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "var_x": [
                    "int",
                    "numpy.ndarray",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        },
        "MultiplicativeKernel.ddx1": {
            "name": "ddx1",
            "location": 115,
            "return": [
                "str",
                "int",
                "float",
                "Tuple[Tuple[int, Any]]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "torch.Tensor"
                ],
                "x2": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "torch.Tensor"
                ]
            }
        },
        "MultiplicativeKernel.ddx2": {
            "name": "ddx2",
            "location": 118,
            "return": [
                "str",
                "int",
                "float",
                "Tuple[Tuple[int, Any]]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "torch.Tensor"
                ],
                "x2": [
                    "float",
                    "Iterable[T]",
                    "int",
                    "torch.Tensor"
                ]
            }
        },
        "MultiplicativeKernel.d2dx1x2": {
            "name": "d2dx1x2",
            "location": 121,
            "return": [
                "int",
                "List[int]",
                "List[str]",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "float"
                ],
                "x2": [
                    "List[list[T]]",
                    "List[T]",
                    "List[List[T]]",
                    "torch.Tensor"
                ]
            }
        },
        "AdditiveKernel.__init__": {
            "name": "__init__",
            "location": 182,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernels": [
                    "str",
                    "src.core.model.library.Library",
                    "Tuple[int]",
                    "List[int]",
                    "List",
                    "List[str]",
                    "List[tuple]",
                    "List[Tuple]"
                ],
                "active_dims": [
                    "str",
                    "int",
                    "List[str]",
                    "Tuple[int]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "AdditiveKernel.forward": {
            "name": "forward",
            "location": 188,
            "return": [
                "int",
                "Callable",
                "List[float]",
                "str",
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "x2": [
                    "None",
                    "Optional[str]",
                    "str",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.DataFrame,numpy.ndarray]"
                ]
            }
        },
        "AdditiveKernel.ddx1": {
            "name": "ddx1",
            "location": 198,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "x2": [
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "float",
                    "None",
                    "Optional[Tuple]",
                    "Tuple"
                ]
            }
        },
        "AdditiveKernel.ddx2": {
            "name": "ddx2",
            "location": 214,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "x2": [
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "float",
                    "None",
                    "Optional[Tuple]",
                    "Tuple"
                ]
            }
        },
        "AdditiveKernel.d2dx1x2": {
            "name": "d2dx1x2",
            "location": 227,
            "return": [
                "int",
                "List[int]",
                "List[str]",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "x2": [
                    "Iterable[Any]",
                    "str",
                    "Sequence[str]",
                    "numpy.ndarray",
                    "None",
                    "Optional[str]",
                    "Optional[T]"
                ]
            }
        },
        "AffineDotProductKernel.__init__": {
            "name": "__init__",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "s_idx": [
                    "Dict[str,str]",
                    "bytes",
                    "int",
                    "str",
                    "bool"
                ],
                "m_idx": [
                    "Dict[str,str]",
                    "bytes",
                    "int",
                    "str",
                    "bool"
                ],
                "kernels": [
                    "List[str]",
                    "numpy.array",
                    "List[list[int]]",
                    "List[Entity]",
                    "Callable[Type,str,bool]",
                    "List[List[int]]",
                    "Callable[[Type,str],bool]",
                    "List[dict[str,Any]]",
                    "List[Dict[str,Any]]"
                ],
                "last_is_unit": [
                    "bool",
                    "List[cirq.Circuit]",
                    "Exception",
                    "Optional[dict]",
                    "str"
                ]
            }
        },
        "AffineDotProductKernel._separate_affine": {
            "name": "_separate_affine",
            "location": 264,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "AffineDotProductKernel._build_affine_vec": {
            "name": "_build_affine_vec",
            "location": 266,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "m1": [
                    "int",
                    "Dict[str,Any]",
                    "numpy.ndarray",
                    "List",
                    "torch.Tensor"
                ],
                "m2": [
                    "int",
                    "Dict[str,Any]",
                    "numpy.ndarray",
                    "List",
                    "torch.Tensor"
                ]
            }
        },
        "AffineDotProductKernel.forward": {
            "name": "forward",
            "location": 272,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "List[float]",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "x2": [
                    "List[float]",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "AffineDotProductKernel.ddx1": {
            "name": "ddx1",
            "location": 280,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "List[float]",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "x2": [
                    "List[float]",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "AffineDotProductKernel.ddx2": {
            "name": "ddx2",
            "location": 296,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "List[float]",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "x2": [
                    "List[float]",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "AffineDotProductKernel.d2dx1x2": {
            "name": "d2dx1x2",
            "location": 312,
            "return": [
                "int",
                "List[int]",
                "Dict[Tuple[str, str], Tuple[float, float]]"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "int",
                    "Tuple[Union[int,int]]",
                    "numpy.ndarray",
                    "str",
                    "torch.Tensor",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "Tuple[int,int]"
                ],
                "x2": [
                    "int",
                    "Tuple[Union[int,int]]",
                    "numpy.ndarray",
                    "str",
                    "torch.Tensor",
                    "torch.FloatTensor",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "Tuple[int,int]"
                ]
            }
        },
        "RBFKernel.__init__": {
            "name": "__init__",
            "location": 340,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "d": [
                    "str",
                    "List",
                    "bytes",
                    "Dict[str,Union[Any,Any,Any,Any,Any,Any,Any]]",
                    "Set[int]",
                    "int",
                    "Callable(chr)[[int],str]",
                    "torch.Tensor"
                ],
                "ard_num_dims": [
                    "bool",
                    "List",
                    "int",
                    "str",
                    "Dict[str,str]",
                    "Dict[str,Dict[str,Any]]",
                    "Optional[Dict[str,Any]]"
                ]
            }
        },
        "RBFKernel.forward": {
            "name": "forward",
            "location": 349,
            "return": [
                "Optional[int]",
                "str",
                "pathlib.Path",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "numpy.ndarray"
                ],
                "x2": [
                    "numpy.ndarray"
                ]
            }
        },
        "RBFKernel.ddx1": {
            "name": "ddx1",
            "location": 359,
            "return": [
                "str",
                "numpy.ndarray",
                "pathlib.Path",
                "Dict[str, int]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "float"
                ],
                "x2": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "RBFKernel.ddx2": {
            "name": "ddx2",
            "location": 365,
            "return": [
                "bool",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "bool",
                    "int"
                ],
                "x2": [
                    "bool",
                    "int"
                ]
            }
        },
        "RBFKernel.d2dx1x2": {
            "name": "d2dx1x2",
            "location": 368,
            "return": [
                "int",
                "Optional[bool]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "x2": [
                    "Callable[[int], int]",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "List[float]",
                    "float"
                ]
            }
        },
        "RBFKernel.length_scale": {
            "name": "length_scale",
            "location": 378,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RBFKernel.signal_variance": {
            "name": "signal_variance",
            "location": 381,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RBFKernel.__str__": {
            "name": "__str__",
            "location": 384,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianProcess.__init__": {
            "name": "__init__",
            "location": 389,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_x": [
                    "int",
                    "Optional[int]",
                    "None",
                    "str",
                    "Optional[numpy.ndarray]",
                    "Optional[str]",
                    "bool"
                ],
                "train_y": [
                    "int",
                    "Optional[int]",
                    "str",
                    "None",
                    "Optional[float]",
                    "float"
                ],
                "kernel": [
                    "int",
                    "List[int]",
                    "float",
                    "None",
                    "bool",
                    "numpy.ndarray",
                    "Optional[List[Any]]"
                ],
                "K": [
                    "Dict[int,str]",
                    "None",
                    "bytes",
                    "int",
                    "str"
                ],
                "L": [
                    "Dict[int,str]",
                    "None",
                    "bytes",
                    "int",
                    "str"
                ],
                "alpha": [
                    "Dict[int,str]",
                    "None",
                    "bytes",
                    "int",
                    "str"
                ]
            }
        },
        "GaussianProcess.noise_variance": {
            "name": "noise_variance",
            "location": 410,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianProcess.marginal_log_likelihood": {
            "name": "marginal_log_likelihood",
            "location": 413,
            "return": [
                "float",
                "str",
                "List[bytes]",
                "Iterable[float]",
                "Type",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianProcess._fit_data": {
            "name": "_fit_data",
            "location": 418,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "GaussianProcess.train_model": {
            "name": "train_model",
            "location": 426,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_iters": [
                    "int",
                    "float"
                ],
                "lr": [
                    "float",
                    "int",
                    "str",
                    "Dict[Any,str]",
                    "Dict[str,Any]"
                ]
            }
        },
        "GaussianProcess.add_samples": {
            "name": "add_samples",
            "location": 442,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "Y": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "GaussianProcess.forward": {
            "name": "forward",
            "location": 448,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "GaussianProcess.posterior": {
            "name": "posterior",
            "location": 473,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "Dict",
                    "float",
                    "Tuple[Union[float,float]]",
                    "T",
                    "Tuple[float,float]",
                    "pathpy.core.network.Network"
                ]
            }
        },
        "GaussianProcess.ddx": {
            "name": "ddx",
            "location": 478,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "GaussianProcess.ddx_posterior": {
            "name": "ddx_posterior",
            "location": 534,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "GaussianProcess.load_state_dict": {
            "name": "load_state_dict",
            "location": 538,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state_dict": [
                    "Dict[str, Any]",
                    "Dict[str, List[int]]"
                ],
                "strict": [
                    "bool",
                    "Dict[str,Any]"
                ]
            }
        },
        "GPScaler.__init__": {
            "name": "__init__",
            "location": 562,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "xmins": [
                    "int",
                    "float",
                    "bool"
                ],
                "xmaxs": [
                    "int",
                    "float",
                    "bool"
                ],
                "wraps": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ]
            }
        },
        "GPScaler._wrapped_dims": {
            "name": "_wrapped_dims",
            "location": 568,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float",
                    "T"
                ]
            }
        },
        "GPScaler._wrap": {
            "name": "_wrap",
            "location": 572,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "torch.Tensor",
                    "int"
                ]
            }
        },
        "GPScaler.transform": {
            "name": "transform",
            "location": 579,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "GPScaler.inverse": {
            "name": "inverse",
            "location": 583,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "Y": [
                    "bool",
                    "float",
                    "str",
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "ScaledGaussianProcess.__init__": {
            "name": "__init__",
            "location": 587,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_x": [
                    "int",
                    "Dict[str,str]",
                    "bool"
                ],
                "train_y": [
                    "int",
                    "Dict[str,str]",
                    "bool"
                ],
                "kernel": [
                    "int",
                    "str",
                    "List[str]"
                ],
                "x_scaler": [
                    "int",
                    "None",
                    "numpy.ndarray",
                    "Optional[Collection[int]]",
                    "Collection"
                ],
                "y_scaler": [
                    "int",
                    "None",
                    "numpy.ndarray",
                    "Optional[Collection[int]]",
                    "Collection"
                ]
            }
        },
        "ScaledGaussianProcess._scale_guard": {
            "name": "_scale_guard",
            "location": 593,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "None",
                    "int",
                    "Optional[Tuple]",
                    "Tuple"
                ],
                "Y": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "Optional[numpy.array]"
                ]
            }
        },
        "ScaledGaussianProcess._descale_guard": {
            "name": "_descale_guard",
            "location": 602,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "X_scaled": [
                    "int",
                    "None",
                    "Optional[numpy.array]",
                    "float",
                    "Optional[int]",
                    "Optional[float]"
                ],
                "Y_scaled": [
                    "int",
                    "None",
                    "Optional[float]",
                    "float",
                    "Optional[dict]",
                    "Dict",
                    "Optional[T]",
                    "Optional[int]"
                ]
            }
        },
        "ScaledGaussianProcess.add_samples": {
            "name": "add_samples",
            "location": 611,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "Y": [
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "ScaledGaussianProcess.forward": {
            "name": "forward",
            "location": 615,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "ScaledGaussianProcess.ddx": {
            "name": "ddx",
            "location": 624,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "torch.Tensor",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "core-master/core/learning/gaussian_process_estimator.py": {
        "GaussianProcessEstimator.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernel": [
                    "int",
                    "Optional[Dict]",
                    "Dict",
                    "None"
                ],
                "data": [
                    "bytes",
                    "str",
                    "Hashable",
                    "Dict[str,Any]",
                    "Optional[Dict]",
                    "int",
                    "Dict",
                    "None"
                ]
            }
        },
        "GaussianProcessEstimator.embedding": {
            "name": "embedding",
            "location": 13,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "GaussianProcessEstimator.fit": {
            "name": "fit",
            "location": 16,
            "return": [
                "GaussianProcessEstimator"
            ],
            "arguments": {
                "self": [
                    "_TGaussianProcessEstimator@@GaussianProcessEstimator@@"
                ],
                "targets": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "GaussianProcessEstimator.eval": {
            "name": "eval",
            "location": 20,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        }
    },
    "core-master/core/learning/residual_affine_model.py": {
        "ResidualAffineModel.eval_drift": {
            "name": "eval_drift",
            "location": 2,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "drift_input": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ResidualAffineModel.eval_act": {
            "name": "eval_act",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "act_input": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ResidualAffineModel.fit": {
            "name": "fit",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "drift_inputs": [
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ],
                "act_inputs": [
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ],
                "us": [
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ],
                "residuals": [
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ],
                "num_epochs": [
                    "int",
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ],
                "validation_split": [
                    "int",
                    "bool",
                    "float",
                    "List[str]",
                    "Callable[...,None]"
                ]
            }
        }
    },
    "core-master/core/learning/residual_model.py": {
        "ResidualModel.eval_dot": {
            "name": "eval_dot",
            "location": 2,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "ResidualModel.fit": {
            "name": "fit",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bool",
                    "str",
                    "Union[None,float,str]",
                    "None",
                    "Type[BaseException]",
                    "float",
                    "Type"
                ],
                "residuals": [
                    "bool",
                    "str",
                    "Union[None,float,str]",
                    "None",
                    "Type[BaseException]",
                    "float",
                    "Type"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "str",
                    "Union[None,float,str]",
                    "Type[BaseException]"
                ],
                "num_epochs": [
                    "int",
                    "bool",
                    "str",
                    "Union[None,float,str]",
                    "Type[BaseException]"
                ],
                "validation_split": [
                    "int",
                    "bool",
                    "str",
                    "Union[None,float,str]",
                    "Type[BaseException]"
                ]
            }
        }
    },
    "core-master/core/learning/value_estimator.py": {
        "ValueEstimator.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernel": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "gamma": [
                    "int"
                ],
                "states": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "next_states": [
                    "str",
                    "int",
                    "numpy.ndarray"
                ],
                "rewards": [
                    "int"
                ]
            }
        },
        "ValueEstimator.transition_map": {
            "name": "transition_map",
            "location": 12,
            "return": [
                "Callable[([Any, Any], Any)]"
            ],
            "arguments": {
                "system": [
                    "ValueEstimator"
                ],
                "dt": [
                    "bool",
                    "List[str]",
                    "Callable[...,collections.abc.Awaitable]",
                    "List",
                    "Callable[...,Awaitable]",
                    "int"
                ],
                "atol": [
                    "float",
                    "bool",
                    "Callable[...,Awaitable]",
                    "List[str]",
                    "int",
                    "List"
                ],
                "rtol": [
                    "float",
                    "bool",
                    "Callable[...,Awaitable]",
                    "List[str]",
                    "int",
                    "List"
                ]
            }
        },
        "ValueEstimator.policy": {
            "name": "policy",
            "location": 19,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "controller": [
                    "ValueEstimator"
                ]
            }
        },
        "ValueEstimator.build": {
            "name": "build",
            "location": 26,
            "return": [
                "ValueEstimator"
            ],
            "arguments": {
                "kernel": [
                    "ValueEstimator"
                ],
                "system": [
                    "int",
                    "List",
                    "List[List[int]]",
                    "Callable",
                    "List[list[int]]",
                    "bytes",
                    "str"
                ],
                "controller": [
                    "bool",
                    "numpy.ndarray",
                    "Type",
                    "Dict",
                    "Callable"
                ],
                "R": [
                    "Type",
                    "bool",
                    "str"
                ],
                "gamma": [
                    "Type",
                    "bool",
                    "str"
                ],
                "states": [
                    "Type",
                    "bool",
                    "str"
                ],
                "dt": [
                    "int",
                    "List",
                    "List[List[int]]",
                    "Callable",
                    "List[list[int]]",
                    "bytes",
                    "str"
                ],
                "atol": [
                    "float",
                    "int",
                    "List[List[int]]",
                    "List",
                    "Callable",
                    "bytes",
                    "str"
                ],
                "rtol": [
                    "float",
                    "int",
                    "List[List[int]]",
                    "List",
                    "Callable",
                    "bytes",
                    "str"
                ]
            }
        },
        "ValueEstimator._build": {
            "name": "_build",
            "location": 31,
            "return": [
                "ValueEstimator"
            ],
            "arguments": {
                "kernel": [
                    "ValueEstimator"
                ],
                "f": [],
                "pi": [],
                "R": [],
                "gamma": [
                    "Tuple",
                    "int"
                ],
                "states": [
                    "str"
                ]
            }
        },
        "ValueEstimator.gen_data": {
            "name": "gen_data",
            "location": 35,
            "return": [
                "Tuple[(numpy.ndarray, numpy.ndarray, numpy.ndarray)]"
            ],
            "arguments": {
                "f": [
                    "ValueEstimator"
                ],
                "pi": [
                    "str",
                    "int"
                ],
                "R": [
                    "Dict[str,List[str]]",
                    "bytes",
                    "Dict[str,list[str]]",
                    "bool"
                ],
                "states": [
                    "str"
                ]
            }
        },
        "ValueEstimator.transition_map.f": {
            "name": "f",
            "location": 14,
            "return": [
                "str"
            ],
            "arguments": {
                "s": [
                    "int",
                    "str",
                    "Sequence[T]",
                    "Optional[str]",
                    "list"
                ],
                "a": [
                    "int",
                    "str",
                    "Sequence[T]",
                    "Optional[str]",
                    "list"
                ]
            }
        },
        "ValueEstimator.policy.pi": {
            "name": "pi",
            "location": 21,
            "return": [
                "Callable",
                "Tuple[int, int]",
                "str",
                "list",
                "bool"
            ],
            "arguments": {
                "s": [
                    "type",
                    "Dict[str, Any]",
                    "str",
                    "Sequence[str]",
                    "dict",
                    "MutableMapping[str, Any]"
                ]
            }
        }
    },
    "core-master/core/learning/__init__.py": {},
    "core-master/core/learning/keras/keras_residual_affine_model.py": {
        "KerasResidualAffineModel.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "d_drift_in": [
                    "bool",
                    "numpy.ndarray",
                    "Tuple[int]",
                    "List[float]",
                    "None",
                    "Optional[List[float]]",
                    "List[dict]",
                    "Optional[List[dict]]",
                    "List[str]",
                    "Optional[List[str]]",
                    "List[D]",
                    "List[DeliveryItem]",
                    "int"
                ],
                "d_act_in": [
                    "bool",
                    "numpy.ndarray",
                    "Tuple[int]",
                    "List[float]",
                    "None",
                    "Optional[List[float]]",
                    "List[dict]",
                    "Optional[List[dict]]",
                    "List[str]",
                    "Optional[List[str]]",
                    "List[D]",
                    "List[DeliveryItem]",
                    "int"
                ],
                "d_hidden": [
                    "None",
                    "numpy.ndarray",
                    "str",
                    "Tuple[int]",
                    "float",
                    "Optional[numpy.ndarray]"
                ],
                "m": [
                    "float",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray",
                    "Dict[str,int]"
                ],
                "d_out": [
                    "bool",
                    "Set",
                    "Optional[str]"
                ],
                "optimizer": [
                    "Text",
                    "str",
                    "bool",
                    "Optional[str]",
                    "int",
                    "Callable"
                ],
                "loss": [
                    "Text",
                    "str",
                    "bool",
                    "Optional[str]",
                    "int",
                    "Callable"
                ]
            }
        },
        "KerasResidualAffineModel.eval_drift": {
            "name": "eval_drift",
            "location": 34,
            "return": [
                "numpy.ndarray",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "drift_input": [
                    "str",
                    "Union[numpy.ndarray,numpy.void]",
                    "numpy.ndarray"
                ]
            }
        },
        "KerasResidualAffineModel.eval_act": {
            "name": "eval_act",
            "location": 37,
            "return": [
                "numpy.ndarray",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "act_input": [
                    "str",
                    "Union[numpy.ndarray,numpy.void]",
                    "numpy.ndarray"
                ]
            }
        },
        "KerasResidualAffineModel.shuffle": {
            "name": "shuffle",
            "location": 40,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "drift_inputs": [
                    "str",
                    "int",
                    "Callable"
                ],
                "act_inputs": [
                    "str",
                    "int",
                    "Callable"
                ],
                "us": [
                    "str",
                    "int",
                    "Callable"
                ],
                "residuals": [
                    "List[int]",
                    "list",
                    "bool",
                    "List[float]",
                    "str",
                    "int"
                ]
            }
        },
        "KerasResidualAffineModel.fit": {
            "name": "fit",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "drift_inputs": [
                    "bool",
                    "float",
                    "Collection",
                    "List[int]",
                    "Union[SAONegotiator,Collection[SAONegotiator]]",
                    "int"
                ],
                "act_inputs": [
                    "bool",
                    "float",
                    "Collection",
                    "List[int]",
                    "Union[SAONegotiator,Collection[SAONegotiator]]",
                    "int"
                ],
                "us": [
                    "bool",
                    "float",
                    "Collection",
                    "List[int]",
                    "Union[SAONegotiator,Collection[SAONegotiator]]",
                    "int"
                ],
                "residuals": [
                    "bool",
                    "float",
                    "Collection",
                    "List[int]",
                    "Union[SAONegotiator,Collection[SAONegotiator]]",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "Tuple[int,int]"
                ],
                "num_epochs": [
                    "int",
                    "Tuple[int,int]"
                ],
                "validation_split": [
                    "int",
                    "Tuple[int,int]"
                ]
            }
        }
    },
    "core-master/core/learning/keras/keras_residual_model.py": {
        "KerasResidualModel.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "d_in": [
                    "bool",
                    "Dict[str,int]",
                    "Set",
                    "int"
                ],
                "d_hidden": [
                    "bool",
                    "Dict[str,int]",
                    "Set",
                    "int"
                ],
                "d_out": [
                    "T",
                    "float",
                    "int",
                    "Optional[float]",
                    "Dict[str,int]",
                    "None"
                ],
                "optimizer": [
                    "Text",
                    "float",
                    "bool",
                    "Callable",
                    "Mapping",
                    "Optional[str]",
                    "Optional[float]"
                ],
                "loss": [
                    "Text",
                    "float",
                    "bool",
                    "Callable",
                    "Mapping",
                    "Optional[str]",
                    "Optional[float]"
                ]
            }
        },
        "KerasResidualModel.eval_dot": {
            "name": "eval_dot",
            "location": 16,
            "return": [
                "numpy.ndarray",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "float",
                    "List[float]",
                    "Union[numpy.ndarray,numpy.void]",
                    "numpy.ndarray"
                ]
            }
        },
        "KerasResidualModel.shuffle": {
            "name": "shuffle",
            "location": 19,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "List[int]",
                    "list",
                    "bool",
                    "List[float]",
                    "str",
                    "int"
                ],
                "residuals": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "KerasResidualModel.fit": {
            "name": "fit",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bool",
                    "List[float]",
                    "str",
                    "Optional[List[float]]",
                    "None",
                    "Hashable",
                    "Optional[str]",
                    "Optional[int]",
                    "int"
                ],
                "residuals": [
                    "bool",
                    "List[float]",
                    "str",
                    "Optional[List[float]]",
                    "None",
                    "Hashable",
                    "Optional[str]",
                    "Optional[int]",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "bool",
                    "Sequence[int]"
                ],
                "num_epochs": [
                    "int",
                    "float",
                    "bool",
                    "Sequence[int]"
                ],
                "validation_split": [
                    "int",
                    "float",
                    "bool",
                    "Sequence[int]"
                ]
            }
        }
    },
    "core-master/core/learning/keras/keras_residual_scalar_affine_model.py": {
        "KerasResidualScalarAffineModel.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "d_drift_in": [
                    "bool",
                    "int"
                ],
                "d_act_in": [
                    "bool",
                    "int"
                ],
                "d_hidden": [
                    "bool",
                    "int"
                ],
                "m": [
                    "bool",
                    "int"
                ],
                "d_out": [
                    "bool",
                    "int"
                ],
                "optimizer": [
                    "Text",
                    "bool",
                    "int"
                ],
                "loss": [
                    "Text",
                    "bool",
                    "int"
                ]
            }
        },
        "KerasResidualScalarAffineModel.eval_drift": {
            "name": "eval_drift",
            "location": 8,
            "return": [
                "numpy.ndarray",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "drift_input": [
                    "str",
                    "Union[numpy.ndarray,numpy.void]",
                    "numpy.ndarray"
                ]
            }
        },
        "KerasResidualScalarAffineModel.eval_act": {
            "name": "eval_act",
            "location": 11,
            "return": [
                "numpy.ndarray",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "act_input": [
                    "str",
                    "Union[numpy.ndarray,numpy.void]",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "core-master/core/learning/keras/__init__.py": {},
    "core-master/core/learning/kernels/kernel.py": {
        "Kernel.eval": {
            "name": "eval",
            "location": 2,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ],
                "y": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        }
    },
    "core-master/core/learning/kernels/laplacian_kernel.py": {
        "LaplacianKernel.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "alpha": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LaplacianKernel.eval": {
            "name": "eval",
            "location": 10,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ],
                "y": [
                    "float",
                    "Union[pandas.DataFrame,numpy.ndarray]",
                    "Union[pandas.Series,numpy.ndarray]"
                ]
            }
        }
    },
    "core-master/core/learning/kernels/__init__.py": {},
    "core-master/core/systems/affine_gp_system.py": {
        "AffineGPSystem.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "gaussianProcess": [
                    "bool",
                    "torch.nn.modules.rnn.GRUCell"
                ],
                "n": [
                    "None",
                    "List",
                    "numpy.ndarray",
                    "int",
                    "Optional[numpy.ndarray]",
                    "Optional[starfish.core.imagestack.imagestack.ImageStack]"
                ],
                "m": [
                    "bool",
                    "str",
                    "Sequence[str]",
                    "int"
                ],
                "delta_t": [
                    "bool",
                    "torch.nn.modules.rnn.GRUCell"
                ],
                "dyn_dims": [
                    "int",
                    "None",
                    "numpy.ndarray",
                    "List[int]",
                    "Optional[int]",
                    "Optional[List[int]]"
                ],
                "ddim_to_dim": [
                    "None",
                    "List",
                    "static_frame.core.util.UFunc",
                    "int",
                    "numpy.ndarray",
                    "Sequence[A]",
                    "Sequence[starfish.core.types.Axes]",
                    "bool"
                ],
                "ddim_to_gp_idx": [
                    "bool",
                    "None",
                    "str",
                    "Optional[int]",
                    "int",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "force_delta_mode": [
                    "bool",
                    "int",
                    "Optional[int]",
                    "str",
                    "Callable"
                ]
            }
        },
        "AffineGPSystem.eval_dot": {
            "name": "eval_dot",
            "location": 39,
            "return": [
                "Optional[int]",
                "str",
                "numpy.ndarray",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "u": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "AffineGPSystem.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 42,
            "return": [
                "float",
                "torch.FloatTensor",
                "List[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Tuple[float]",
                    "torch.Tensor",
                    "Union[int,float]"
                ],
                "u": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "Tuple[float]",
                    "torch.Tensor",
                    "Union[int,float]"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        },
        "AffineGPSystem.jacobian_exp": {
            "name": "jacobian_exp",
            "location": 46,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "xts": [
                    "int",
                    "Callable",
                    "str"
                ],
                "uts": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AffineGPSystem.jacobian_exp_impl": {
            "name": "jacobian_exp_impl",
            "location": 49,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "xts": [
                    "numpy.ndarray"
                ],
                "uts": [
                    "numpy.ndarray"
                ]
            }
        },
        "AffineGPSystem.addFrameDims": {
            "name": "addFrameDims",
            "location": 54,
            "return": [
                "float",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "Js": [
                    "str",
                    "numpy.ndarray",
                    "Sequence[cirq.Qid]",
                    "int",
                    "Union[str,bool,None]"
                ]
            }
        },
        "AffineGPSystem.step": {
            "name": "step",
            "location": 65,
            "return": [
                "Dict[str,Any]",
                "numpy.ndarray",
                "str",
                "Optional[int]",
                "int",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x_0": [
                    "Tuple[Union[int,int]]",
                    "Tuple",
                    "Optional[numpy.ndarray]",
                    "Tuple[int,int]",
                    "Optional[int]",
                    "Optional[Tuple]",
                    "Sequence[str]",
                    "numpy.ndarray"
                ],
                "u_0": [
                    "Tuple[Union[int,int]]",
                    "Tuple",
                    "Optional[numpy.ndarray]",
                    "Tuple[int,int]",
                    "Optional[int]",
                    "Optional[Tuple]",
                    "Sequence[str]",
                    "numpy.ndarray"
                ],
                "t_0": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "t_f": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "atol": [
                    "float",
                    "numpy.ndarray",
                    "int",
                    "torch.nn.Module"
                ],
                "rtol": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "Collection[int]",
                    "str"
                ]
            }
        },
        "AffineGPSystem.vec_step": {
            "name": "vec_step",
            "location": 73,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "xts": [
                    "int",
                    "Callable",
                    "str"
                ],
                "uts": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "AffineGPSystem.vec_step_impl": {
            "name": "vec_step_impl",
            "location": 76,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "xts": [
                    "BaseException"
                ],
                "uts": [
                    "BaseException"
                ]
            }
        },
        "AffineGPSystem.jacobian": {
            "name": "jacobian",
            "location": 94,
            "return": [
                "Optional[int]",
                "str",
                "numpy.ndarray",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "u": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "AffineGPSystem.jacobian_impl": {
            "name": "jacobian_impl",
            "location": 97,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "torch.Tensor"
                ],
                "u": [
                    "float",
                    "torch.Tensor"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        },
        "AffineGPSystem._make_AB": {
            "name": "_make_AB",
            "location": 101,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float",
                    "Sequence[int]",
                    "Sequence[float]",
                    "torch.Tensor"
                ],
                "u": [
                    "int",
                    "torch.Tensor"
                ]
            }
        },
        "AffineGPSystem._embed_kin_dim": {
            "name": "_embed_kin_dim",
            "location": 122,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "J_dyn": [
                    "bool",
                    "starfish.core.types.SpotAttributes"
                ],
                "delta_xtp1": [
                    "int",
                    "numpy.ndarray",
                    "Dict[str, int]",
                    "bool"
                ],
                "eAdt": [
                    "float",
                    "bool"
                ],
                "x": [
                    "bool",
                    "List[int]",
                    "float",
                    "int"
                ]
            }
        },
        "AffineGPSystem._next_step_info": {
            "name": "_next_step_info",
            "location": 142,
            "return": [
                "Tuple[(Any, Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "xts": [
                    "float",
                    "List['cirq.Qid']",
                    "bool",
                    "numpy.ndarray"
                ],
                "uts": [
                    "float",
                    "List['cirq.Qid']",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        }
    },
    "core-master/core/systems/cart_pole.py": {
        "CartPole.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "m_c": [
                    "int",
                    "bool"
                ],
                "m_p": [
                    "int",
                    "bool"
                ],
                "l": [
                    "int",
                    "bool"
                ],
                "g": [
                    "float",
                    "int",
                    "bool"
                ]
            }
        },
        "CartPole.D": {
            "name": "D",
            "location": 13,
            "return": [
                "float",
                "List[int]",
                "int",
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int"
                ]
            }
        },
        "CartPole.C": {
            "name": "C",
            "location": 20,
            "return": [
                "Optional[int]",
                "str",
                "int",
                "Optional[bool]"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "float"
                ],
                "q_dot": [
                    "int",
                    "float"
                ]
            }
        },
        "CartPole.U": {
            "name": "U",
            "location": 28,
            "return": [
                "str",
                "Dict[str, int]",
                "OrderedDict"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "CartPole.G": {
            "name": "G",
            "location": 33,
            "return": [
                "Optional[int]",
                "str",
                "Optional[bool]",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "CartPole.B": {
            "name": "B",
            "location": 39,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "Iterable[Any]"
                ]
            }
        }
    },
    "core-master/core/systems/car_system.py": {
        "Car.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Car.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 29,
            "return": [
                "str",
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "int"
                ],
                "u": [
                    "str",
                    "int",
                    "float"
                ],
                "t": [
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]",
                    "Optional[List[Any]]",
                    "List[Any]",
                    "List[List[str]]",
                    "None",
                    "List[list[str]]"
                ]
            }
        }
    },
    "core-master/core/systems/double_inverted_pendulum.py": {
        "DoubleInvertedPendulum.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "m_1": [
                    "float",
                    "numpy.array",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "m_2": [
                    "float",
                    "numpy.array",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "l_1": [
                    "float",
                    "numpy.array",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "l_2": [
                    "float",
                    "numpy.array",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ],
                "g": [
                    "float",
                    "numpy.array",
                    "starfish.core.imagestack.imagestack.ImageStack"
                ]
            }
        },
        "DoubleInvertedPendulum.D": {
            "name": "D",
            "location": 15,
            "return": [
                "Dict[str, int]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int"
                ]
            }
        },
        "DoubleInvertedPendulum.C": {
            "name": "C",
            "location": 25,
            "return": [
                "str",
                "Optional[int]",
                "Optional[List[int]]",
                "float",
                "torch.FloatTensor"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "float"
                ],
                "q_dot": [
                    "float",
                    "str",
                    "T",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "DoubleInvertedPendulum.B": {
            "name": "B",
            "location": 36,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "Iterable[Any]"
                ]
            }
        },
        "DoubleInvertedPendulum.U": {
            "name": "U",
            "location": 39,
            "return": [
                "str",
                "Dict[str, int]",
                "OrderedDict"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "DoubleInvertedPendulum.G": {
            "name": "G",
            "location": 44,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "DoubleInvertedPendulum.plot_coordinates": {
            "name": "plot_coordinates",
            "location": 51,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "bool",
                    "Dict",
                    "Exception",
                    "Callable[...,bool]",
                    "List[str]"
                ],
                "qs": [
                    "str"
                ],
                "fig": [
                    "int",
                    "None",
                    "bool",
                    "Dict[str,Any]",
                    "Union[int,float]",
                    "float",
                    "List[List]",
                    "List[list]"
                ],
                "ax": [
                    "bool",
                    "None",
                    "int",
                    "str",
                    "Callable[[numpy.ndarray],numpy.ndarray]",
                    "Callable[numpy.ndarray,numpy.ndarray]",
                    "Union[int,float]",
                    "float",
                    "List[pymatgen.core.sites.PeriodicSite]",
                    "List[P]"
                ],
                "labels": [
                    "bool",
                    "None",
                    "Dict",
                    "Exception",
                    "Callable[...,bool]",
                    "List[str]"
                ]
            }
        },
        "DoubleInvertedPendulum.plot_states": {
            "name": "plot_states",
            "location": 61,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "int",
                    "Iterable[str]",
                    "bool"
                ],
                "xs": [
                    "util.ArrayLike",
                    "Union[int, float]",
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "int"
                ],
                "fig": [
                    "int",
                    "None",
                    "float",
                    "numpy.ndarray"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Optional[Union[int,slice]]",
                    "bool",
                    "Optional[int]"
                ],
                "labels": [
                    "int",
                    "None",
                    "Iterable[str]",
                    "bool"
                ]
            }
        },
        "DoubleInvertedPendulum.plot_actions": {
            "name": "plot_actions",
            "location": 73,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Dict",
                    "int",
                    "str",
                    "bool"
                ],
                "us": [
                    "int",
                    "bytes",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "fig": [
                    "str",
                    "None",
                    "int",
                    "Union[int,float]",
                    "numpy.ndarray",
                    "float"
                ],
                "ax": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "Union[int,float]",
                    "Callable[numpy.ndarray,numpy.ndarray]",
                    "Callable[[numpy.ndarray],numpy.ndarray]",
                    "bool"
                ],
                "labels": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "List",
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Optional[float]",
                    "Optional[int]"
                ]
            }
        },
        "DoubleInvertedPendulum.plot_tangents": {
            "name": "plot_tangents",
            "location": 86,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Exception",
                    "Optional[Exception]",
                    "List[float]",
                    "None",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "xs": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "float",
                    "int"
                ],
                "fig": [
                    "None",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "T"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "List",
                    "int",
                    "str",
                    "Optional[Union[int,slice]]",
                    "float",
                    "Union[int,float]",
                    "pymatgen.core.structure.Structure"
                ],
                "skip": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "DoubleInvertedPendulum.plot_physical": {
            "name": "plot_physical",
            "location": 97,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Exception",
                    "Optional[Exception]",
                    "List[float]",
                    "None",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "xs": [
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "float",
                    "Union[pandas.Series, numpy.ndarray]"
                ],
                "fig": [
                    "None",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "T"
                ],
                "ax": [
                    "str",
                    "None",
                    "Union[int,float]",
                    "int",
                    "Optional[Union[int,slice]]",
                    "float",
                    "pymatgen.core.structure.Structure",
                    "numpy.ndarray"
                ],
                "skip": [
                    "int"
                ]
            }
        },
        "DoubleInvertedPendulum.plot": {
            "name": "plot",
            "location": 119,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "float",
                    "int",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ],
                "us": [
                    "Set",
                    "numpy.ndarray",
                    "List",
                    "bool",
                    "starfish.core.imagestack.imagestack.ImageStack",
                    "Union[List,numpy.ndarray,pymatgen.core.lattice.Lattice]"
                ],
                "ts": [
                    "float",
                    "int",
                    "Union[float,numpy.ndarray]"
                ],
                "fig": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Dict",
                    "Optional[int]",
                    "List[Dict]",
                    "List[dict]"
                ],
                "action_labels": [
                    "None",
                    "numpy.ndarray",
                    "Set",
                    "bool",
                    "starfish.core.imagestack.imagestack.ImageStack",
                    "List",
                    "Union[List,numpy.ndarray,pymatgen.core.lattice.Lattice]"
                ],
                "skip": [
                    "int",
                    "float",
                    "Tuple[float,float]"
                ]
            }
        }
    },
    "core-master/core/systems/inverted_pendulum.py": {
        "InvertedPendulum.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mass": [
                    "float",
                    "int",
                    "Iterable[T]"
                ],
                "l": [
                    "float",
                    "int",
                    "Iterable[T]"
                ],
                "g": [
                    "float",
                    "int",
                    "Iterable[T]"
                ]
            }
        },
        "InvertedPendulum.D": {
            "name": "D",
            "location": 16,
            "return": [
                "Optional[str]",
                "Optional[BaseException]"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "Optional[bytes]",
                    "bytes",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "None",
                    "Dict[str,Any]",
                    "Optional[int]",
                    "bool",
                    "int"
                ]
            }
        },
        "InvertedPendulum.C": {
            "name": "C",
            "location": 19,
            "return": [
                "T",
                "float",
                "numpy.ndarray",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "float",
                    "Union[float,int]",
                    "int",
                    "Union[float,Tuple[float,float]]",
                    "Tuple[Union[float,float]]"
                ],
                "q_dot": [
                    "str"
                ]
            }
        },
        "InvertedPendulum.U": {
            "name": "U",
            "location": 22,
            "return": [
                "DefaultDict[int, List[Any]]",
                "OrderedDict",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "List",
                    "List[str]",
                    "List[Callable]",
                    "Optional[List[str]]",
                    "bool",
                    "Optional[int]",
                    "Optional[List[Callable]]"
                ]
            }
        },
        "InvertedPendulum.G": {
            "name": "G",
            "location": 26,
            "return": [
                "DefaultDict[int, List[Any]]",
                "OrderedDict",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "List",
                    "List[str]",
                    "List[Callable]",
                    "Optional[List[str]]",
                    "bool",
                    "Optional[int]",
                    "Optional[List[Callable]]"
                ]
            }
        },
        "InvertedPendulum.B": {
            "name": "B",
            "location": 30,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "int",
                    "Union[float,int]",
                    "float",
                    "Tuple[int]",
                    "Union[float,Tuple[float,float]]",
                    "Tuple[Union[float,float]]"
                ]
            }
        },
        "InvertedPendulum.l": {
            "name": "l",
            "location": 34,
            "return": [
                "int",
                "bytearray",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "InvertedPendulum.mass": {
            "name": "mass",
            "location": 38,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "InvertedPendulum.g": {
            "name": "g",
            "location": 42,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "InvertedPendulum.plot_states": {
            "name": "plot_states",
            "location": 45,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "int",
                    "Iterable[str]",
                    "bool"
                ],
                "xs": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "fig": [
                    "int",
                    "None",
                    "float",
                    "numpy.ndarray"
                ],
                "ax": [
                    "int",
                    "None",
                    "float",
                    "List[int]",
                    "str",
                    "matplotlib.pyploAxes",
                    "Any",
                    "Union[int,str]",
                    "Optional[bool]",
                    "Optional[Union[int,Any]]",
                    "numpy.ndarray",
                    "Optional[int]"
                ],
                "labels": [
                    "int",
                    "None",
                    "Iterable[str]",
                    "bool"
                ],
                "color": [
                    "Text",
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "InvertedPendulum.plot_physical": {
            "name": "plot_physical",
            "location": 60,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Exception",
                    "Optional[Exception]",
                    "List[float]",
                    "None",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "xs": [
                    "str",
                    "numpy.ndarray",
                    "T",
                    "int"
                ],
                "fig": [
                    "None",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "T"
                ],
                "ax": [
                    "str",
                    "None",
                    "Union[int,float]",
                    "int",
                    "Optional[Union[int,slice]]",
                    "float",
                    "pymatgen.core.structure.Structure",
                    "numpy.ndarray"
                ],
                "skip": [
                    "int",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "InvertedPendulum.plot": {
            "name": "plot",
            "location": 81,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "us": [
                    "Set",
                    "numpy.ndarray",
                    "List",
                    "bool",
                    "starfish.core.imagestack.imagestack.ImageStack",
                    "Union[List,numpy.ndarray,pymatgen.core.lattice.Lattice]"
                ],
                "ts": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "fig": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Dict",
                    "Optional[int]",
                    "List[Dict]",
                    "List[dict]"
                ],
                "action_labels": [
                    "None",
                    "numpy.ndarray",
                    "Set",
                    "bool",
                    "starfish.core.imagestack.imagestack.ImageStack",
                    "List",
                    "Union[List,numpy.ndarray,pymatgen.core.lattice.Lattice]"
                ],
                "skip": [
                    "int",
                    "float",
                    "Tuple[float,float]"
                ]
            }
        }
    },
    "core-master/core/systems/linear_system.py": {
        "LinearSystemDynamics.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "A": [
                    "int",
                    "str",
                    "float",
                    "List",
                    "numpy.ndarray"
                ],
                "B": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ]
            }
        },
        "LinearSystemDynamics.drift_impl": {
            "name": "drift_impl",
            "location": 29,
            "return": [
                "Union[torch.Tensor, Tuple[torch.Tensor, torch.Tensor]]",
                "int",
                "List[str]",
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "List[numpy.ndarray]",
                    "torch.Tensor",
                    "Union[numpy.ndarray,List[numpy.ndarray]]",
                    "Iterable[Iterable[float]]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "LinearSystemDynamics.act_impl": {
            "name": "act_impl",
            "location": 33,
            "return": [
                "bool",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "LinearSystemDynamics.jacobian_impl": {
            "name": "jacobian_impl",
            "location": 36,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ],
                "u": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        },
        "LinearSystemDynamics.linear_system": {
            "name": "linear_system",
            "location": 39,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "core-master/core/systems/planar_quadrotor.py": {
        "PlanarQuadrotor.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "m": [
                    "float",
                    "Protocol",
                    "int",
                    "str"
                ],
                "J": [
                    "float",
                    "Protocol",
                    "int",
                    "str"
                ],
                "g": [
                    "float",
                    "Protocol",
                    "int",
                    "str"
                ]
            }
        },
        "PlanarQuadrotor.D": {
            "name": "D",
            "location": 18,
            "return": [
                "float",
                "T",
                "int",
                "IO"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str"
                ]
            }
        },
        "PlanarQuadrotor.C": {
            "name": "C",
            "location": 22,
            "return": [
                "T",
                "float",
                "numpy.ndarray",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str"
                ],
                "q_dot": [
                    "str"
                ]
            }
        },
        "PlanarQuadrotor.U": {
            "name": "U",
            "location": 25,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "bool",
                    "Container",
                    "Container[T]",
                    "Union[int,numpy.ndarray]"
                ]
            }
        },
        "PlanarQuadrotor.G": {
            "name": "G",
            "location": 30,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "PlanarQuadrotor.B": {
            "name": "B",
            "location": 35,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "float"
                ]
            }
        },
        "PlanarQuadrotor.plot_coordinates": {
            "name": "plot_coordinates",
            "location": 132,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "bool",
                    "Dict",
                    "Exception",
                    "Callable[...,bool]",
                    "List[str]"
                ],
                "qs": [
                    "int",
                    "Callable[int,None]",
                    "Sequence[T]",
                    "numpy.ndarray",
                    "Callable[[int],None]",
                    "torch.Tensor"
                ],
                "fig": [
                    "str",
                    "None",
                    "Optional[numpy.ndarray]"
                ],
                "ax": [
                    "Optional[numpy.ndarray]",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "labels": [
                    "bool",
                    "None",
                    "Dict",
                    "Exception",
                    "Callable[...,bool]",
                    "List[str]"
                ]
            }
        },
        "PlanarQuadrotor.plot_states": {
            "name": "plot_states",
            "location": 149,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "int",
                    "Iterable[str]",
                    "bool"
                ],
                "xs": [
                    "bool",
                    "Union[int, float]",
                    "int",
                    "numpy.array",
                    "float",
                    "util.ArrayLike"
                ],
                "fig": [
                    "int",
                    "None",
                    "float",
                    "numpy.ndarray"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Optional[Union[int,slice]]",
                    "bool",
                    "Optional[int]"
                ],
                "labels": [
                    "int",
                    "None",
                    "Iterable[str]",
                    "bool"
                ]
            }
        },
        "PlanarQuadrotor.plot_actions": {
            "name": "plot_actions",
            "location": 162,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Dict",
                    "int",
                    "str",
                    "bool"
                ],
                "us": [
                    "int",
                    "bytes",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "fig": [
                    "str",
                    "None",
                    "int",
                    "Union[int,float]",
                    "numpy.ndarray",
                    "float"
                ],
                "ax": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "Union[int,float]",
                    "Callable[numpy.ndarray,numpy.ndarray]",
                    "Callable[[numpy.ndarray],numpy.ndarray]",
                    "bool"
                ],
                "labels": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "List",
                    "numpy.ndarray",
                    "float",
                    "int",
                    "Optional[float]",
                    "Optional[int]"
                ]
            }
        },
        "PlanarQuadrotor.plot_tangents": {
            "name": "plot_tangents",
            "location": 175,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Exception",
                    "Optional[Exception]",
                    "List[float]",
                    "None",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "xs": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "float",
                    "int"
                ],
                "fig": [
                    "None",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "T"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "List",
                    "int",
                    "str",
                    "Optional[Union[int,slice]]",
                    "float",
                    "Union[int,float]",
                    "pymatgen.core.structure.Structure"
                ],
                "skip": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "PlanarQuadrotor.plot_physical": {
            "name": "plot_physical",
            "location": 186,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "ts": [
                    "Exception",
                    "Optional[Exception]",
                    "List[float]",
                    "None",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "xs": [
                    "numpy.ndarray",
                    "int",
                    "torch.Tensor",
                    "Union[numpy.ndarray, numpy.void]",
                    "bool"
                ],
                "fig": [
                    "None",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "T"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "List",
                    "int",
                    "str",
                    "Optional[Union[int,slice]]",
                    "float",
                    "Union[int,float]",
                    "pymatgen.core.structure.Structure"
                ],
                "skip": [
                    "int",
                    "torch.Tensor",
                    "nevergrad.common.Callable[[numpy.ndarray],numpy.ndarray]",
                    "Iterable[Any]",
                    "numpy.ndarray",
                    "Sequence[int]",
                    "Sequence[float]"
                ]
            }
        },
        "PlanarQuadrotor.plot": {
            "name": "plot",
            "location": 201,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "xs": [
                    "float",
                    "int",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ],
                "us": [
                    "Set",
                    "numpy.ndarray",
                    "List",
                    "bool",
                    "starfish.core.imagestack.imagestack.ImageStack",
                    "Union[List,numpy.ndarray,pymatgen.core.lattice.Lattice]"
                ],
                "ts": [
                    "float",
                    "int",
                    "Union[float,numpy.ndarray]"
                ],
                "fig": [
                    "Optional[Dict]",
                    "None",
                    "bool",
                    "Dict",
                    "Optional[int]",
                    "List[Dict]",
                    "List[dict]"
                ],
                "action_labels": [
                    "None",
                    "numpy.ndarray",
                    "Set",
                    "bool",
                    "starfish.core.imagestack.imagestack.ImageStack",
                    "List",
                    "Union[List,numpy.ndarray,pymatgen.core.lattice.Lattice]"
                ],
                "skip": [
                    "int",
                    "float",
                    "Tuple[float,float]"
                ]
            }
        },
        "PlanarQuadrotor.Extension.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "planar_quadrotor": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "PlanarQuadrotor.Extension.step": {
            "name": "step",
            "location": 50,
            "return": [
                "int",
                "List[int]",
                "tuple",
                "float"
            ],
            "arguments": {
                "self": [],
                "x_0": [
                    "int",
                    "numpy.ndarray",
                    "List[int]",
                    "Collection[int]",
                    "bool"
                ],
                "u_0": [
                    "float",
                    "Sequence[float]",
                    "list"
                ],
                "t_0": [
                    "numpy.ndarray",
                    "T",
                    "int"
                ],
                "t_f": [
                    "numpy.ndarray",
                    "T",
                    "int"
                ],
                "atol": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "List"
                ],
                "rtol": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "List"
                ]
            }
        },
        "PlanarQuadrotor.Output.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "extension": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "PlanarQuadrotor.Output.r_ddot": {
            "name": "r_ddot",
            "location": 70,
            "return": [
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "Callable[[], Any]",
                    "int"
                ],
                "theta": [
                    "Callable[[], Any]",
                    "int"
                ]
            }
        },
        "PlanarQuadrotor.Output.r_dddot": {
            "name": "r_dddot",
            "location": 76,
            "return": [
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "T",
                    "int"
                ],
                "f_dot": [
                    "T",
                    "int"
                ],
                "theta": [
                    "T",
                    "int"
                ],
                "theta_dot": [
                    "T",
                    "int"
                ]
            }
        },
        "PlanarQuadrotor.Output.r_ddddot_drift": {
            "name": "r_ddddot_drift",
            "location": 82,
            "return": [
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "int",
                    "bool"
                ],
                "f_dot": [
                    "int",
                    "bool"
                ],
                "theta": [
                    "int",
                    "bool"
                ],
                "theta_dot": [
                    "int",
                    "bool"
                ]
            }
        },
        "PlanarQuadrotor.Output.r_ddddot_act": {
            "name": "r_ddddot_act",
            "location": 90,
            "return": [
                "str",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "f": [
                    "Dict[str, Any]",
                    "Callable"
                ],
                "theta": [
                    "Dict[str, Any]",
                    "Callable"
                ]
            }
        },
        "PlanarQuadrotor.Output.eval": {
            "name": "eval",
            "location": 96,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "Tuple[int, int, int, int]",
                    "Tuple[int, int]",
                    "List[Tuple[str, str]]"
                ],
                "t": [
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "Iterable[int]",
                    "Iterable[float]",
                    "bool"
                ]
            }
        },
        "PlanarQuadrotor.Output.drift": {
            "name": "drift",
            "location": 105,
            "return": [
                "Optional[int]",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "torch.Tensor"
                ],
                "t": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "PlanarQuadrotor.Output.act": {
            "name": "act",
            "location": 111,
            "return": [
                "Optional[int]",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "T",
                    "numpy.array",
                    "numpy.ndarray",
                    "int"
                ],
                "t": [
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "Iterable[int]",
                    "Iterable[float]",
                    "bool"
                ]
            }
        },
        "PlanarQuadrotor.Output.to_state": {
            "name": "to_state",
            "location": 116,
            "return": [
                "numpy.ndarray",
                "str",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "eta": [
                    "list"
                ]
            }
        }
    },
    "core-master/core/systems/polynomial_system.py": {
        "PolynomialSystem.__init__": {
            "name": "__init__",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "int",
                    "Optional[str]",
                    "IO"
                ],
                "drift_gain": [
                    "int",
                    "Optional[str]",
                    "IO"
                ],
                "act_gain": [
                    "int",
                    "Optional[str]",
                    "IO"
                ]
            }
        },
        "PolynomialSystem.drift": {
            "name": "drift",
            "location": 13,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "List",
                    "numpy.ndarray",
                    "Generator[Union[str,None,None]]",
                    "Generator[str,None,None]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        },
        "PolynomialSystem.act": {
            "name": "act",
            "location": 16,
            "return": [
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ],
                "t": [
                    "Exception",
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "None",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]"
                ]
            }
        }
    },
    "core-master/core/systems/segway_3d_system.py": {
        "Segway3D.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Segway3D.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 72,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "bool",
                    "float",
                    "Union[pandas.Series, numpy.ndarray]"
                ],
                "U": [
                    "Sequence[float]",
                    "int",
                    "List",
                    "Dict[int,Tuple[int,int]]",
                    "Dict[int,tuple[Union[int,int]]]"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        }
    },
    "core-master/core/systems/segway_system.py": {
        "Segway.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Segway.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 18,
            "return": [
                "bool",
                "Optional[bool]",
                "Optional[Sequence[str]]",
                "Optional[Callable]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int"
                ],
                "u": [
                    "dict"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        }
    },
    "core-master/core/systems/single_track_bicycle_system.py": {
        "SingleTrackBicycle.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SingleTrackBicycle.eval_dot_impl": {
            "name": "eval_dot_impl",
            "location": 21,
            "return": [
                "str",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "torch.Tensor"
                ],
                "u": [
                    "List[int]",
                    "int",
                    "float",
                    "Optional[List[int]]"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        }
    },
    "core-master/core/systems/unicycle.py": {
        "Unicycle.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "m": [
                    "float",
                    "Protocol",
                    "int",
                    "str"
                ],
                "J": [
                    "float",
                    "Protocol",
                    "int",
                    "str"
                ]
            }
        },
        "Unicycle.D": {
            "name": "D",
            "location": 13,
            "return": [
                "float",
                "T",
                "int",
                "IO"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str"
                ]
            }
        },
        "Unicycle.C": {
            "name": "C",
            "location": 17,
            "return": [
                "str",
                "Optional[int]",
                "float"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "str",
                    "int",
                    "torch.device",
                    "torch.Tensor"
                ],
                "q_dot": [
                    "str"
                ]
            }
        },
        "Unicycle.B": {
            "name": "B",
            "location": 27,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "float"
                ]
            }
        },
        "Unicycle.G": {
            "name": "G",
            "location": 37,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "q": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Unicycle.get_state_names": {
            "name": "get_state_names",
            "location": 40,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "core-master/core/systems/__init__.py": {},
    "core-master/core/trajopt/gp_trajectory_optimizer.py": {
        "GPTrajectoryOptimizer.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "T": [
                    "int",
                    "float",
                    "str",
                    "None",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "h_k": [
                    "int",
                    "float",
                    "str",
                    "None",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "dynamics": [
                    "int",
                    "float",
                    "str",
                    "None",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "max_delta_x": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "max_delta_u": [
                    "int",
                    "None",
                    "float",
                    "str",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "solver": [
                    "Text",
                    "int",
                    "float",
                    "str",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "cov_penalty": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ]
            }
        },
        "GPTrajectoryOptimizer.make_continuous_linear_system_approx_constraints": {
            "name": "make_continuous_linear_system_approx_constraints",
            "location": 21,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "xt": [
                    "float",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ],
                "ut": [
                    "float",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        }
    },
    "core-master/core/trajopt/trajectory_optimizer.py": {
        "TrajectoryOptimizer.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "T": [
                    "List[int]",
                    "List[str]",
                    "float",
                    "List",
                    "numpy.ndarray"
                ],
                "h_k": [
                    "int",
                    "float",
                    "bool",
                    "numpy.array"
                ],
                "dynamics": [
                    "bool",
                    "float",
                    "List[float]",
                    "int"
                ],
                "collocation_mode": [
                    "int",
                    "float",
                    "bool",
                    "str",
                    "Tuple[str, int]",
                    "tuple",
                    "Optional[int]"
                ],
                "max_delta_x": [
                    "int",
                    "float",
                    "None",
                    "str"
                ],
                "max_delta_u": [
                    "int",
                    "float",
                    "None",
                    "str"
                ],
                "solver": [
                    "Text",
                    "int",
                    "float",
                    "bool",
                    "numpy.array"
                ]
            }
        },
        "TrajectoryOptimizer.make_hermite_simpson_dynamics_constraints": {
            "name": "make_hermite_simpson_dynamics_constraints",
            "location": 44,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "xt": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "ut": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "TrajectoryOptimizer.make_trapezoidal_dynamics_constraints": {
            "name": "make_trapezoidal_dynamics_constraints",
            "location": 47,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "xt": [
                    "int",
                    "numpy.ndarray"
                ],
                "ut": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "TrajectoryOptimizer.make_continuous_linear_system_approx_constraints": {
            "name": "make_continuous_linear_system_approx_constraints",
            "location": 63,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "xt": [
                    "bytes",
                    "numpy.ndarray",
                    "cirq.linalg.tolerance.Tolerance"
                ],
                "ut": [
                    "bytes",
                    "numpy.ndarray",
                    "cirq.linalg.tolerance.Tolerance"
                ]
            }
        },
        "TrajectoryOptimizer.add_input_constraints": {
            "name": "add_input_constraints",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "u_min": [
                    "str",
                    "float",
                    "Optional[int]",
                    "int",
                    "Optional[Mapping[int,complex]]",
                    "None",
                    "Optional[float]",
                    "Mapping"
                ],
                "u_max": [
                    "str",
                    "float",
                    "Optional[int]",
                    "int",
                    "Optional[Mapping[int,complex]]",
                    "None",
                    "Optional[float]",
                    "Mapping"
                ]
            }
        },
        "TrajectoryOptimizer.add_static_quad_cost": {
            "name": "add_static_quad_cost",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "Q": [
                    "None",
                    "numpy.ndarray",
                    "Dict",
                    "Optional[Dict]",
                    "Callable",
                    "Optional[Callable]",
                    "float",
                    "Optional[numpy.ndarray]",
                    "Optional[float]"
                ],
                "R": [
                    "None",
                    "Tuple[numpy.dtype]",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "offset": [
                    "None",
                    "numpy.ndarray",
                    "int",
                    "Optional[int]",
                    "Union[int,None]"
                ]
            }
        },
        "TrajectoryOptimizer.add_terminal_cost": {
            "name": "add_terminal_cost",
            "location": 98,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "Q_f": [
                    "int",
                    "str",
                    "Dict[str,Any]",
                    "AbstractSet[Any]",
                    "AbstractSet"
                ],
                "offset": [
                    "None",
                    "numpy.ndarray",
                    "Callable",
                    "Optional[Callable]",
                    "int",
                    "Optional[int]",
                    "Tuple[Union[int,int]]",
                    "Optional[numpy.ndarray]",
                    "Optional[Tuple[int,int]]"
                ],
                "R_f": [
                    "str",
                    "None",
                    "Sequence[str]",
                    "int",
                    "List[Dict]",
                    "List[dict]"
                ]
            }
        },
        "TrajectoryOptimizer.add_hard_terminal_constraint": {
            "name": "add_hard_terminal_constraint",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_f": [
                    "Callable",
                    "numpy.ndarray",
                    "int",
                    "collections.abc.Awaitable[T]",
                    "float",
                    "Awaitable[T]",
                    "bool"
                ]
            }
        },
        "TrajectoryOptimizer.add_trust_region_constraint": {
            "name": "add_trust_region_constraint",
            "location": 106,
            "return": [
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrajectoryOptimizer.add_state_box_constraints": {
            "name": "add_state_box_constraints",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_min": [
                    "int",
                    "str",
                    "float",
                    "numpy.ndarray"
                ],
                "x_max": [
                    "int",
                    "str",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "TrajectoryOptimizer._warmstart": {
            "name": "_warmstart",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_0": [
                    "int",
                    "Variable",
                    "numpy.ndarray"
                ],
                "ws_xt": [
                    "int",
                    "None",
                    "List[int]",
                    "Optional[int]",
                    "Callable",
                    "Optional[Callable]",
                    "str",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Optional[str]"
                ],
                "ws_ut": [
                    "int",
                    "None",
                    "List[int]",
                    "Optional[int]",
                    "Callable",
                    "Optional[Callable]",
                    "str",
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Optional[str]"
                ]
            }
        },
        "TrajectoryOptimizer.eval": {
            "name": "eval",
            "location": 137,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x_0": [
                    "float",
                    "numpy.ndarray"
                ],
                "ws_xt": [
                    "bool",
                    "None",
                    "int"
                ],
                "ws_ut": [
                    "bool",
                    "None",
                    "int"
                ],
                "max_cvx_iters": [
                    "int"
                ],
                "converge_tol": [
                    "float",
                    "int",
                    "Tuple[int,int]",
                    "str"
                ],
                "solver_opts": [
                    "None",
                    "Optional[Dict[str,numpy.ma.MaskedArray]]",
                    "Dict[str,numpy.ma.MaskedArray]",
                    "Optional[Union[astropy.units.quantity.Quantity,numpy.ndarray]]",
                    "float",
                    "Optional[float]",
                    "Dict",
                    "Optional[dict]",
                    "Optional[numpy.ndarray]"
                ]
            }
        }
    },
    "core-master/core/trajopt/__init__.py": {},
    "core-master/tests/generate_system_test_data.py": {
        "constant_controller": {
            "name": "constant_controller",
            "location": 16,
            "return": [
                "ctrl.constant_controller.ConstantController"
            ],
            "arguments": {
                "system": [
                    "int",
                    "str",
                    "bytes",
                    "bytearray"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "core-master/tests/test_controller.py": {
        "pendulum_with_controller": {
            "name": "pendulum_with_controller",
            "location": 11,
            "return": [
                "Tuple[Union[InvertedPendulum,LinearController,str,list[int],Type,int,list]]",
                "str",
                "Tuple"
            ],
            "arguments": {}
        },
        "test_pendulum_linear_controller": {
            "name": "test_pendulum_linear_controller",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "pendulum_with_controller": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "test_pendulum_qp_controller": {
            "name": "test_pendulum_qp_controller",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "pendulum_with_controller": [
                    "float",
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "test_double_pend_with_fb_linearize": {
            "name": "test_double_pend_with_fb_linearize",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "core-master/tests/test_gp_mpc.py": {
        "add_trajectory_arrows": {
            "name": "add_trajectory_arrows",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "ax": [
                    "Optional[numpy.ndarray]",
                    "str",
                    "Union[numpy.ndarray, astropy.units.quantity.Quantity]",
                    "float"
                ],
                "scale": [
                    "float",
                    "torch.Tensor",
                    "Optional[torch.Tensor]"
                ],
                "traj": [
                    "str",
                    "bytes",
                    "List[str]"
                ]
            }
        },
        "plot_2D_q_sys": {
            "name": "plot_2D_q_sys",
            "location": 29,
            "return": [
                "pathlib.Path",
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "xs": [
                    "Optional[int]",
                    "Mapping[str, float]",
                    "Callable[[numpy.ndarray, numpy.ndarray, bool], numpy.ndarray]",
                    "Union['IndexBase', 'Series']",
                    "Optional[float]"
                ],
                "ax": [
                    "bool",
                    "float",
                    "None",
                    "str"
                ],
                "traj": [
                    "None",
                    "Optional[str]",
                    "str",
                    "Optional[float]",
                    "float",
                    "Optional[List[str]]",
                    "Sequence[str]",
                    "List[str]",
                    "Optional[Callable]",
                    "Callable",
                    "Optional[dict]",
                    "Dict",
                    "Optional[numpy.ndarray]"
                ],
                "start": [
                    "Tuple[int]",
                    "int",
                    "str",
                    "float",
                    "Optional[str]"
                ],
                "end": [
                    "Tuple[int]",
                    "Optional[int]",
                    "Optional[Pattern[str]]",
                    "Callable[[Any],None]",
                    "bytes"
                ],
                "xlim": [
                    "Tuple[int]",
                    "str",
                    "Dict[str,Any]",
                    "numpy.ndarray"
                ],
                "ylim": [
                    "Tuple[int]",
                    "str",
                    "Dict[str,Any]",
                    "numpy.ndarray"
                ],
                "scale": [
                    "float",
                    "pathpy.core.edge.Edge",
                    "bool",
                    "torch.Tensor",
                    "pymatgen.core.structure.Structure"
                ]
            }
        },
        "load_data": {
            "name": "load_data",
            "location": 55,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "dir_name": [
                    "str",
                    "bytes"
                ],
                "suffix": [
                    "Text",
                    "str",
                    "bytes"
                ]
            }
        },
        "test_mpc_linear_system": {
            "name": "test_mpc_linear_system",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_pendulum": {
            "name": "test_mpc_pendulum",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_double_pendulum": {
            "name": "test_mpc_double_pendulum",
            "location": 180,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_segway": {
            "name": "test_mpc_segway",
            "location": 270,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_linear_system.mpc_step": {
            "name": "mpc_step",
            "location": 105,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "test_mpc_pendulum.mpc_step": {
            "name": "mpc_step",
            "location": 163,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "test_mpc_double_pendulum.mpc_step": {
            "name": "mpc_step",
            "location": 235,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "test_mpc_segway.mpc_step": {
            "name": "mpc_step",
            "location": 298,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "t": [
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "Iterable[int]",
                    "Iterable[float]",
                    "bool"
                ],
                "xt_prev": [
                    "numpy.ndarray",
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "ut_prev": [
                    "int",
                    "numpy.array",
                    "float"
                ]
            }
        }
    },
    "core-master/tests/test_gp_traj_opt.py": {
        "plot_2D_q_sys": {
            "name": "plot_2D_q_sys",
            "location": 17,
            "return": [
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "xs": [
                    "str",
                    "List[float]",
                    "bool",
                    "int",
                    "Optional[float]"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "bool",
                    "Dict",
                    "Optional[numpy.ndarray]",
                    "Optional[Dict]"
                ],
                "color": [
                    "Text",
                    "float",
                    "slice",
                    "List",
                    "List[int]"
                ],
                "box_side": [
                    "int",
                    "FrozenSet",
                    "float",
                    "str",
                    "Dict",
                    "Optional[Union[int,float]]"
                ],
                "start": [
                    "tuple[int]"
                ],
                "end": [
                    "Tuple[int]",
                    "Optional[int]",
                    "str",
                    "int",
                    "Callable[[Any],None]",
                    "Optional[Pattern[str]]"
                ]
            }
        },
        "plot_2D_dyn_sys": {
            "name": "plot_2D_dyn_sys",
            "location": 37,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "dyn": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "array.array"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "Dict",
                    "List[str]",
                    "Optional[Dict]",
                    "Dict[str,str]",
                    "Optional[Dict[str,str]]",
                    "torch.device"
                ],
                "low_x": [
                    "int",
                    "float",
                    "str"
                ],
                "high_x": [
                    "int",
                    "float",
                    "str"
                ],
                "low_y": [
                    "int",
                    "float",
                    "str"
                ],
                "high_y": [
                    "int",
                    "float",
                    "str"
                ],
                "n_sample": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "test_2D_lin_learned_phase": {
            "name": "test_2D_lin_learned_phase",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_double_pendulum_trajopt": {
            "name": "test_double_pendulum_trajopt",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_pend_trajopt": {
            "name": "test_pend_trajopt",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_4D_lin_trajopt": {
            "name": "test_4D_lin_trajopt",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2D_lin_trajopt": {
            "name": "test_2D_lin_trajopt",
            "location": 336,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "core-master/tests/test_jacobian.py": {
        "analytic_cartpole_jacobian": {
            "name": "analytic_cartpole_jacobian",
            "location": 22,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "Sequence[float]",
                    "int",
                    "List",
                    "Dict[int,Tuple[int,int]]",
                    "Dict[int,tuple[Union[int,int]]]"
                ],
                "u": [
                    "float",
                    "numpy.ndarray"
                ],
                "t": [
                    "numpy.ndarray",
                    "Tuple[Union[float,float]]",
                    "Tuple[float,float]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        },
        "analytic_pendulum_jacobian": {
            "name": "analytic_pendulum_jacobian",
            "location": 48,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "x": [
                    "List",
                    "Sequence[float]",
                    "int",
                    "numpy.ndarray"
                ],
                "u": [
                    "List[str]",
                    "numpy.ndarray",
                    "List",
                    "None",
                    "List[list[str]]",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ],
                "t": [
                    "List[str]",
                    "numpy.ndarray",
                    "List",
                    "None",
                    "List[list[str]]",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ]
            }
        },
        "test_system_jacboian": {
            "name": "test_system_jacboian",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "system": [
                    "int",
                    "List[numpy.ndarray]",
                    "float",
                    "bool"
                ],
                "analytic_jacobian": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "core-master/tests/test_learn_linear_system.py": {
        "plot_2D_q_sys": {
            "name": "plot_2D_q_sys",
            "location": 43,
            "return": [
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "xs": [
                    "str",
                    "List[str]",
                    "int",
                    "numpy.ndarray",
                    "bool"
                ],
                "ax": [
                    "None",
                    "Optional[Tuple]",
                    "Tuple",
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]",
                    "Optional[numpy.ndarray]",
                    "str",
                    "Optional[str]",
                    "numpy.ndarray"
                ],
                "color": [
                    "Text",
                    "numpy.ndarray",
                    "Union[pandas.Series,numpy.ndarray]",
                    "int"
                ],
                "box_side": [
                    "int",
                    "FrozenSet",
                    "Union[str,int,float]",
                    "Dict",
                    "float"
                ]
            }
        },
        "generate_optimal_trajectory": {
            "name": "generate_optimal_trajectory",
            "location": 63,
            "return": [
                "Tuple[(Any, Union[(list, numpy.ndarray)], Any)]"
            ],
            "arguments": {
                "dynamics": [
                    "int",
                    "List[dict]",
                    "bool"
                ]
            }
        },
        "plot_2D_dyn_sys": {
            "name": "plot_2D_dyn_sys",
            "location": 88,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "dyn": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "array.array"
                ],
                "ax": [
                    "None",
                    "numpy.ndarray",
                    "Dict",
                    "List[str]",
                    "Optional[Dict]",
                    "Dict[str,str]",
                    "Optional[Dict[str,str]]",
                    "torch.device"
                ],
                "low_x": [
                    "int",
                    "float",
                    "str"
                ],
                "high_x": [
                    "int",
                    "float",
                    "str"
                ],
                "low_y": [
                    "int",
                    "float",
                    "str"
                ],
                "high_y": [
                    "int",
                    "float",
                    "str"
                ],
                "n_sample": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "XY_from_traj": {
            "name": "XY_from_traj",
            "location": 104,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "xt": [
                    "Tuple[Union[float,float,float]]",
                    "str",
                    "Tuple[float,float,float]",
                    "cirq.linalg.tolerance.Tolerance",
                    "numpy.ndarray"
                ],
                "ut": [
                    "Tuple[Union[float,float,float]]",
                    "bool",
                    "numpy.ndarray",
                    "List",
                    "Tuple[float,float,float]",
                    "torch.Tensor"
                ]
            }
        },
        "test_rl_linear_system": {
            "name": "test_rl_linear_system",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_gp_lin_dyn_trajopt": {
            "name": "test_gp_lin_dyn_trajopt",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_pendulum_periodic_kernel_phase": {
            "name": "test_pendulum_periodic_kernel_phase",
            "location": 168,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_pendulum_learned_phase": {
            "name": "test_pendulum_learned_phase",
            "location": 245,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_pendulum_learned_phase_delta": {
            "name": "test_pendulum_learned_phase_delta",
            "location": 281,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_pendulum_learned_phase_delta_kin_approx": {
            "name": "test_pendulum_learned_phase_delta_kin_approx",
            "location": 327,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2D_lin_learned_phase": {
            "name": "test_2D_lin_learned_phase",
            "location": 375,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2D_lin_point_jacobian": {
            "name": "test_2D_lin_point_jacobian",
            "location": 415,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "core-master/tests/test_mpc_controller.py": {
        "add_trajectory_arrows": {
            "name": "add_trajectory_arrows",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "ax": [
                    "Optional[numpy.ndarray]",
                    "str",
                    "Union[numpy.ndarray, astropy.units.quantity.Quantity]",
                    "float"
                ],
                "scale": [
                    "float"
                ],
                "traj": [
                    "str",
                    "bytes",
                    "List[str]"
                ]
            }
        },
        "plot_2D_q_sys": {
            "name": "plot_2D_q_sys",
            "location": 27,
            "return": [
                "pathlib.Path",
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "xs": [
                    "Optional[int]",
                    "Mapping[str, float]",
                    "Callable[[numpy.ndarray, numpy.ndarray, bool], numpy.ndarray]",
                    "Union['IndexBase', 'Series']",
                    "Optional[float]"
                ],
                "ax": [
                    "bool",
                    "float",
                    "None",
                    "str"
                ],
                "traj": [
                    "None",
                    "Optional[str]",
                    "str",
                    "Optional[float]",
                    "float",
                    "Optional[List[str]]",
                    "Sequence[str]",
                    "List[str]",
                    "Optional[Callable]",
                    "Callable",
                    "Optional[dict]",
                    "Dict",
                    "Optional[numpy.ndarray]"
                ],
                "start": [
                    "Tuple[int]",
                    "int",
                    "str",
                    "float",
                    "Optional[str]"
                ],
                "end": [
                    "Tuple[int]",
                    "Optional[int]",
                    "Optional[Pattern[str]]",
                    "Callable[[Any],None]",
                    "bytes"
                ],
                "xlim": [
                    "Tuple[int]",
                    "str",
                    "Dict[str,Any]",
                    "numpy.ndarray"
                ],
                "ylim": [
                    "Tuple[int]",
                    "str",
                    "Dict[str,Any]",
                    "numpy.ndarray"
                ],
                "scale": [
                    "float",
                    "pathpy.core.edge.Edge",
                    "bool",
                    "pymatgen.core.structure.Structure"
                ]
            }
        },
        "plot_6D_config": {
            "name": "plot_6D_config",
            "location": 53,
            "return": [
                "str",
                "numpy.ndarray",
                "pathpy.core.network.Network",
                "Dict[str, Any]"
            ],
            "arguments": {
                "xs": [
                    "int",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "ax": [
                    "int",
                    "None",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "traj": [
                    "int",
                    "None",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "start": [
                    "int",
                    "None",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "end": [
                    "int",
                    "None",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "xlim": [
                    "int",
                    "None",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "ylim": [
                    "int",
                    "None",
                    "List[int]",
                    "Collection[int]",
                    "Collection"
                ],
                "scale": [
                    "int",
                    "Collection[int]",
                    "List[int]"
                ]
            }
        },
        "save_trajectory": {
            "name": "save_trajectory",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "us": [
                    "str",
                    "bool",
                    "pathlib.Path"
                ],
                "xs": [
                    "str",
                    "bool",
                    "pathlib.Path"
                ],
                "dir_name": [
                    "str",
                    "pathlib.Path"
                ],
                "suffix": [
                    "Text",
                    "pathlib.Path",
                    "str",
                    "Union[str,pathlib.Path]"
                ]
            }
        },
        "test_mpc_linear_system": {
            "name": "test_mpc_linear_system",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_pendulum": {
            "name": "test_mpc_pendulum",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "double_pendulum_episode": {
            "name": "double_pendulum_episode",
            "location": 148,
            "return": [
                "Tuple[(Union[(list, np.ndarray)], Any)]"
            ],
            "arguments": {
                "x_0": [
                    "int",
                    "numpy.ndarray",
                    "Union[numbers.Real, numpy.ndarray]"
                ],
                "x_f": [
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "test_mpc_double_pendulum": {
            "name": "test_mpc_double_pendulum",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_segway": {
            "name": "test_mpc_segway",
            "location": 206,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_single_track_bicycle": {
            "name": "test_single_track_bicycle",
            "location": 241,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_mpc_linear_system.mpc_step": {
            "name": "mpc_step",
            "location": 92,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "test_mpc_pendulum.mpc_step": {
            "name": "mpc_step",
            "location": 128,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "double_pendulum_episode.mpc_step": {
            "name": "mpc_step",
            "location": 160,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "test_mpc_segway.mpc_step": {
            "name": "mpc_step",
            "location": 221,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "x": [],
                "t": [],
                "xt_prev": [],
                "ut_prev": []
            }
        },
        "test_single_track_bicycle.mpc_step": {
            "name": "mpc_step",
            "location": 257,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "x": [
                    "int",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "numpy.ndarray"
                ],
                "t": [
                    "Optional[Exception]",
                    "List[str]",
                    "List[float]",
                    "Iterable[int]",
                    "Iterable[float]",
                    "bool"
                ],
                "xt_prev": [
                    "numpy.ndarray",
                    "int",
                    "Optional[int]",
                    "float"
                ],
                "ut_prev": [
                    "int",
                    "numpy.array",
                    "float"
                ]
            }
        }
    },
    "core-master/tests/test_multitask_gp.py": {
        "confidence_region": {
            "name": "confidence_region",
            "location": 12,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "mean": [
                    "int",
                    "Callable",
                    "str"
                ],
                "cov_matrix": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_1dx1dgp": {
            "name": "test_1dx1dgp",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2dx1dgp": {
            "name": "test_2dx1dgp",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_gp_save_load": {
            "name": "test_gp_save_load",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2d2dgp_multiplicative_periodic": {
            "name": "test_2d2dgp_multiplicative_periodic",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2d2dgp_scaling_wrapping": {
            "name": "test_2d2dgp_scaling_wrapping",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2d2dgp_scaling": {
            "name": "test_2d2dgp_scaling",
            "location": 398,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2d2dgp": {
            "name": "test_2d2dgp",
            "location": 519,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_exp_kernel": {
            "name": "test_exp_kernel",
            "location": 637,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_periodic_kernel": {
            "name": "test_periodic_kernel",
            "location": 670,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_additive_kernel": {
            "name": "test_additive_kernel",
            "location": 691,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_multiplicative_kernel": {
            "name": "test_multiplicative_kernel",
            "location": 740,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_affine_dot_product_kernel": {
            "name": "test_affine_dot_product_kernel",
            "location": 770,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_multiplicative_periodic_consistency": {
            "name": "test_multiplicative_periodic_consistency",
            "location": 791,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_2d2dgp_multiplicative_periodic.genYYprime": {
            "name": "genYYprime",
            "location": 118,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "X": [
                    "numpy.ndarray",
                    "int",
                    "Sequence[int]",
                    "Sequence[float]",
                    "float",
                    "numpy.array",
                    "torch.Tensor"
                ]
            }
        }
    },
    "core-master/tests/test_systems.py": {
        "constant_controller": {
            "name": "constant_controller",
            "location": 17,
            "return": [
                "ctrl.constant_controller.ConstantController"
            ],
            "arguments": {
                "system": [
                    "int",
                    "str",
                    "bytes",
                    "bytearray"
                ]
            }
        },
        "test_with_constrant_controller": {
            "name": "test_with_constrant_controller",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "system": [
                    "pathlib.Path",
                    "blurr.core.schema_loader.SchemaLoader",
                    "pypi2nix.path.Path"
                ]
            }
        }
    },
    "core-master/tests/test_traj_opt.py": {
        "plot_2D_q_sys": {
            "name": "plot_2D_q_sys",
            "location": 25,
            "return": [
                "float",
                "bool",
                "int"
            ],
            "arguments": {
                "xs": [
                    "str",
                    "List[str]",
                    "int",
                    "numpy.ndarray",
                    "bool"
                ],
                "ax": [
                    "Optional[Tuple]",
                    "None",
                    "int",
                    "Tuple",
                    "Tuple[int,int]",
                    "Optional[str]",
                    "Tuple[Union[int,int]]",
                    "Optional[numpy.ndarray]",
                    "str"
                ]
            }
        },
        "test_reach_goal": {
            "name": "test_reach_goal",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_continuous_approx": {
            "name": "test_continuous_approx",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_input_constraints": {
            "name": "test_input_constraints",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_nl_pendulum_with_constraints": {
            "name": "test_nl_pendulum_with_constraints",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_double_inv_pendulum_trapezoiodal_vs_linearization": {
            "name": "test_double_inv_pendulum_trapezoiodal_vs_linearization",
            "location": 135,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_nl_constrained_pendulum_trapezoidal_vs_linearization": {
            "name": "test_nl_constrained_pendulum_trapezoidal_vs_linearization",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_linear_integration": {
            "name": "test_linear_integration",
            "location": 215,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_nl_pendulum_with_constraints.sqp_step": {
            "name": "sqp_step",
            "location": 112,
            "return": [],
            "arguments": {
                "ws_ut": []
            }
        },
        "test_double_inv_pendulum_trapezoiodal_vs_linearization.sqp_step": {
            "name": "sqp_step",
            "location": 144,
            "return": [],
            "arguments": {
                "mode": []
            }
        },
        "test_nl_constrained_pendulum_trapezoidal_vs_linearization.sqp_step": {
            "name": "sqp_step",
            "location": 182,
            "return": [],
            "arguments": {
                "mode": []
            }
        },
        "test_linear_integration.sqp_step": {
            "name": "sqp_step",
            "location": 222,
            "return": [
                "bool",
                "List[str]",
                "int"
            ],
            "arguments": {
                "mode": [
                    "bytes",
                    "float",
                    "core.models.GroupingKey",
                    "int",
                    "Optional[int]",
                    "Hashable"
                ]
            }
        }
    }
}
{
    "datawig-master/setup.py": {},
    "datawig-master/datawig/calibration.py": {
        "compute_ece": {
            "name": "compute_ece",
            "location": 27,
            "return": [
                "float"
            ],
            "arguments": {
                "scores": [
                    "np.ndarray"
                ],
                "labels": [
                    "np.ndarray"
                ],
                "lbda": [
                    "float"
                ],
                "step": [
                    "float"
                ]
            }
        },
        "ece_loss": {
            "name": "ece_loss",
            "location": 68,
            "return": [
                "float"
            ],
            "arguments": {
                "lbda": [
                    "float"
                ]
            }
        },
        "logits_from_probas": {
            "name": "logits_from_probas",
            "location": 81,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "probas": [
                    "np.ndarray"
                ],
                "force": [
                    "bool"
                ]
            }
        },
        "probas_from_logits": {
            "name": "probas_from_logits",
            "location": 97,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "scores": [
                    "np.ndarray"
                ],
                "lbda": [
                    "float"
                ],
                "force": [
                    "bool"
                ]
            }
        },
        "calibrate": {
            "name": "calibrate",
            "location": 114,
            "return": [
                "np.ndarray"
            ],
            "arguments": {
                "scores": [
                    "np.ndarray"
                ],
                "lbda": [
                    "float"
                ]
            }
        },
        "reliability": {
            "name": "reliability",
            "location": 128,
            "return": [
                "tuple"
            ],
            "arguments": {
                "scores": [
                    "np.ndarray"
                ],
                "labels": [
                    "np.ndarray"
                ],
                "step": [
                    "float"
                ]
            }
        },
        "fit_temperature": {
            "name": "fit_temperature",
            "location": 159,
            "return": [
                "float"
            ],
            "arguments": {
                "scores": [
                    "np.ndarray"
                ],
                "labels": [
                    "np.ndarray"
                ]
            }
        }
    },
    "datawig-master/datawig/column_encoders.py": {
        "ColumnEncoder.__init__": {
            "name": "__init__",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "List[str]"
                ],
                "output_column": [
                    "Optional[List[Any]]",
                    "None",
                    "str",
                    "bool",
                    "list[typing.Any]",
                    "List[str]",
                    "Optional[bytes]",
                    "list[str]",
                    "bytes"
                ],
                "output_dim": [
                    "str",
                    "int",
                    "Dict[str, int]",
                    "Tuple[int]",
                    "List[str]",
                    "Tuple[Literal, Literal, Literal]"
                ]
            }
        },
        "ColumnEncoder.transform": {
            "name": "transform",
            "location": 92,
            "return": [
                "numpy.array",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "bytes",
                    "dict[, ]",
                    "bool",
                    "dict"
                ]
            }
        },
        "ColumnEncoder.fit": {
            "name": "fit",
            "location": 105,
            "return": [
                "ColumnEncoder",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "bytes",
                    "dict[, ]",
                    "bool",
                    "dict"
                ]
            }
        },
        "ColumnEncoder.is_fitted": {
            "name": "is_fitted",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ColumnEncoder.decode": {
            "name": "decode",
            "location": 128,
            "return": [
                "pandas.Series",
                "None"
            ],
            "arguments": {
                "self": [],
                "col": [
                    "str",
                    "bool",
                    "list[tuple[typing.Union[str,str]]]",
                    "List[Tuple[str, str]]",
                    "int"
                ]
            }
        },
        "CategoricalEncoder.__init__": {
            "name": "__init__",
            "location": 153,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "str",
                    "None",
                    "Optional[str]",
                    "numpy.ndarray",
                    "Union[numpy.ndarray, numpy.void]"
                ],
                "output_column": [
                    "str"
                ],
                "token_to_idx": [
                    "Dict[(str, int)]"
                ],
                "max_tokens": [
                    "int"
                ]
            }
        },
        "CategoricalEncoder.transform_func_categorical": {
            "name": "transform_func_categorical",
            "location": 170,
            "return": [
                "list[typing.Union[dict[str, str],str]]",
                "bool",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "col": [
                    "str",
                    "dict[, ]",
                    "dict[str, dict[str, str]]",
                    "bool",
                    "dict[str, str]",
                    "Optional[Dict]",
                    "dict",
                    "Dict[str, Dict[str, str]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Dict[str, str]"
                ],
                "token_to_idx": [
                    "Dict[(str, int)]"
                ],
                "missing_token_idx": [
                    "int"
                ]
            }
        },
        "CategoricalEncoder.is_fitted": {
            "name": "is_fitted",
            "location": 185,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalEncoder.transform": {
            "name": "transform",
            "location": 195,
            "return": [
                "str",
                "int",
                "dict",
                "bool",
                "List[numpy.ndarray]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "list"
                ]
            }
        },
        "CategoricalEncoder.fit": {
            "name": "fit",
            "location": 223,
            "return": [
                "CategoricalEncoder"
            ],
            "arguments": {
                "self": [
                    "_TCategoricalEncoder"
                ],
                "data_frame": [
                    "str",
                    "int",
                    "bytes"
                ]
            }
        },
        "CategoricalEncoder.decode_token": {
            "name": "decode_token",
            "location": 254,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "token_idx": [
                    "int"
                ]
            }
        },
        "CategoricalEncoder.decode": {
            "name": "decode",
            "location": 265,
            "return": [
                "bool",
                "dict",
                "str",
                "raiden.utils.TokenAmount",
                "cmk.utils.type_defs.UserId",
                "Optional[Any]"
            ],
            "arguments": {
                "self": [],
                "col": [
                    "str",
                    "bool",
                    "None",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "SequentialEncoder.__init__": {
            "name": "__init__",
            "location": 292,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bytes",
                    "None"
                ],
                "output_column": [
                    "str"
                ],
                "token_to_idx": [
                    "Dict[(str, int)]"
                ],
                "max_tokens": [
                    "int"
                ],
                "seq_len": [
                    "int"
                ]
            }
        },
        "SequentialEncoder.transform_func_seq_single": {
            "name": "transform_func_seq_single",
            "location": 310,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "string": [
                    "str"
                ],
                "token_to_idx": [
                    "Dict[(str, int)]"
                ],
                "seq_len": [
                    "int"
                ],
                "missing_token_idx": [
                    "int"
                ]
            }
        },
        "SequentialEncoder.is_fitted": {
            "name": "is_fitted",
            "location": 332,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequentialEncoder.fit": {
            "name": "fit",
            "location": 342,
            "return": [
                "SequentialEncoder"
            ],
            "arguments": {
                "self": [
                    "_TSequentialEncoder"
                ],
                "data_frame": [
                    "str",
                    "bytes",
                    "List[List[str]]",
                    "Tuple[int, int]",
                    "\"Project\""
                ]
            }
        },
        "SequentialEncoder.transform": {
            "name": "transform",
            "location": 375,
            "return": [
                "int",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "pandas.DataFrame",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "SequentialEncoder.decode_seq": {
            "name": "decode_seq",
            "location": 403,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "token_index_sequence": [
                    "Iterable[int]"
                ]
            }
        },
        "SequentialEncoder.decode": {
            "name": "decode",
            "location": 414,
            "return": [
                "bool",
                "int",
                "Tuple[int]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "col": [
                    "str",
                    "bool",
                    "None",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "TfIdfEncoder.__init__": {
            "name": "__init__",
            "location": 439,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "str",
                    "bool",
                    "list[typing.Optional[float]]",
                    "float",
                    "random.Random",
                    "List[Optional[float]]",
                    "int"
                ],
                "output_column": [
                    "str"
                ],
                "max_tokens": [
                    "int"
                ],
                "tokens": [
                    "str"
                ],
                "ngram_range": [
                    "tuple"
                ],
                "prefixed_concatenation": [
                    "bool"
                ]
            }
        },
        "TfIdfEncoder.__preprocess_input": {
            "name": "__preprocess_input",
            "location": 469,
            "return": [
                "int",
                "list[]",
                "bool",
                "Tuple[int]",
                "Hashable"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "tuple[typing.Union[int,int]]",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ]
            }
        },
        "TfIdfEncoder.fit": {
            "name": "fit",
            "location": 489,
            "return": [
                "fIdfEncoder"
            ],
            "arguments": {
                "self": [
                    "_TTfIdfEncoder"
                ],
                "data_frame": [
                    "int",
                    "str",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "TfIdfEncoder.is_fitted": {
            "name": "is_fitted",
            "location": 500,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "TfIdfEncoder.transform": {
            "name": "transform",
            "location": 508,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "str",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "TfIdfEncoder.decode": {
            "name": "decode",
            "location": 518,
            "return": [
                "bool",
                "cmk.utils.type_defs.UserId",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "col": [
                    "int"
                ]
            }
        },
        "BowEncoder.__init__": {
            "name": "__init__",
            "location": 544,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "str",
                    "bool",
                    "list[typing.Optional[float]]",
                    "float",
                    "random.Random",
                    "List[Optional[float]]",
                    "int"
                ],
                "output_column": [
                    "str"
                ],
                "max_tokens": [
                    "int"
                ],
                "tokens": [
                    "str"
                ],
                "ngram_range": [
                    "tuple"
                ],
                "prefixed_concatenation": [
                    "bool"
                ]
            }
        },
        "BowEncoder.fit": {
            "name": "fit",
            "location": 570,
            "return": [
                "BowEncoder"
            ],
            "arguments": {
                "self": [
                    "_TBowEncoder"
                ],
                "data_frame": [
                    "int",
                    "bytes",
                    "dict[, ]",
                    "bool",
                    "dict"
                ]
            }
        },
        "BowEncoder.is_fitted": {
            "name": "is_fitted",
            "location": 582,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "BowEncoder.transform": {
            "name": "transform",
            "location": 593,
            "return": [
                "List[int]",
                "str",
                "List[dict]",
                "int",
                "pandas._ArrayLike"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "tuple[typing.Union[int,int]]",
                    "numpy.ndarray",
                    "Tuple[int, int]"
                ]
            }
        },
        "BowEncoder.decode": {
            "name": "decode",
            "location": 622,
            "return": [
                "pandas.Series",
                "None"
            ],
            "arguments": {
                "self": [],
                "col": [
                    "str",
                    "bool",
                    "list[tuple[typing.Union[str,str]]]",
                    "List[Tuple[str, str]]",
                    "int"
                ]
            }
        },
        "NumericalEncoder.__init__": {
            "name": "__init__",
            "location": 647,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "str",
                    "list[int]",
                    "List[int]",
                    "int",
                    "list[str]",
                    "functools.partial[None]",
                    "list[]",
                    "List[str]",
                    "list"
                ],
                "output_column": [
                    "str"
                ],
                "normalize": [
                    "bool",
                    "int",
                    "List[str]",
                    "List[List[int]]",
                    "float",
                    "list",
                    "str"
                ]
            }
        },
        "NumericalEncoder.is_fitted": {
            "name": "is_fitted",
            "location": 658,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NumericalEncoder.fit": {
            "name": "fit",
            "location": 674,
            "return": [
                "NumericalEncoder"
            ],
            "arguments": {
                "self": [
                    "_TNumericalEncoder"
                ],
                "data_frame": [
                    "int",
                    "str",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "NumericalEncoder.transform": {
            "name": "transform",
            "location": 692,
            "return": [
                "int",
                "str",
                "Callable",
                "list[str]",
                "typing.Pattern"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "tuple[typing.Union[int,int]]",
                    "int",
                    "pandas.DataFrame",
                    "Tuple[int, int]"
                ]
            }
        },
        "NumericalEncoder.decode": {
            "name": "decode",
            "location": 723,
            "return": [
                "str",
                "int",
                "dict[, ]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "col": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "datawig-master/datawig/evaluation.py": {
        "evaluate_and_persist_metrics": {
            "name": "evaluate_and_persist_metrics",
            "location": 27,
            "return": [
                "dict"
            ],
            "arguments": {
                "true_labels_string": [
                    "str",
                    "List[str]",
                    "bool",
                    "Mapping[str, Any]",
                    "Tuple[str]"
                ],
                "true_labels_int": [
                    "str",
                    "int",
                    "float"
                ],
                "predictions": [
                    "list",
                    "str",
                    "list[]",
                    "dict",
                    "dict[, ]"
                ],
                "predictions_proba": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "int",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "list",
                    "list[]"
                ],
                "metrics_file": [
                    "str"
                ],
                "missing_symbol": [
                    "str",
                    "None"
                ],
                "numerical_labels": [
                    "str",
                    "tuple",
                    "int"
                ],
                "numerical_predictions": [
                    "str"
                ]
            }
        },
        "evaluate_model_outputs": {
            "name": "evaluate_model_outputs",
            "location": 122,
            "return": [
                "Dict[(Any, Dict[(str, Any)])]"
            ],
            "arguments": {
                "df": [
                    "str"
                ],
                "attribute_column_name": [
                    "str",
                    "typing.Text"
                ],
                "true_label_column_name": [
                    "typing.Text",
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ],
                "predicted_label_column_name": [
                    "typing.Text",
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "evaluate_model_outputs_single_attribute": {
            "name": "evaluate_model_outputs_single_attribute",
            "location": 146,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "true": [
                    "str",
                    "Union[str, bytes]",
                    "Iterable[str]"
                ],
                "predicted": [
                    "str",
                    "trezor.utils.BufferReader"
                ],
                "topMisclassifications": [
                    "int",
                    "dict",
                    "bytes",
                    "Callable[[str], bool]"
                ]
            }
        }
    },
    "datawig-master/datawig/imputer.py": {
        "Imputer.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_encoders": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Sequence[numpy.ndarray]",
                    "List[numpy.ndarray]",
                    "List[str]"
                ],
                "data_featurizers": [
                    "List[bytes]",
                    "list",
                    "int",
                    "numpy.array",
                    "bool"
                ],
                "label_encoders": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "Sequence[numpy.ndarray]",
                    "List[numpy.ndarray]",
                    "List[str]"
                ],
                "output_path": [
                    "typing.Text",
                    "str",
                    "numpy.ndarray",
                    "Optional[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Imputer.__attach_log_filehandler": {
            "name": "__attach_log_filehandler",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "filename": [
                    "str",
                    "bytes"
                ],
                "level": [
                    "typing.Text",
                    "str",
                    "logging.Formatter",
                    "logging.Logger",
                    "int",
                    "bool",
                    "logging.Handler"
                ]
            }
        },
        "Imputer.__close_filehandlers": {
            "name": "__close_filehandlers",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Imputer.__check_data": {
            "name": "__check_data",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "set[str]",
                    "Set[str]",
                    "typing.Generator[]",
                    "Generator",
                    "Iterable[Sequence[T]]"
                ]
            }
        },
        "Imputer.fit": {
            "name": "fit",
            "location": 212,
            "return": [
                "Imputer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "None",
                    "pandas.DataFrame",
                    "list[int]",
                    "Optional[numpy.ndarray]",
                    "int",
                    "float",
                    "Optional[List[int]]",
                    "Optional[int]",
                    "bool",
                    "Optional[float]"
                ],
                "test_df": [
                    "pandas.DataFrame",
                    "None",
                    "bytes",
                    "Optional[List[int]]",
                    "list[int]"
                ],
                "ctx": [
                    "str",
                    "AsyncContextManager[None]"
                ],
                "learning_rate": [
                    "int",
                    "float"
                ],
                "num_epochs": [
                    "int"
                ],
                "patience": [
                    "int"
                ],
                "test_split": [
                    "float",
                    "pandas.DataFrame",
                    "int",
                    "bool",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]"
                ],
                "weight_decay": [
                    "int",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "bool",
                    "str",
                    "Union[Tuple[int, int], int]"
                ],
                "final_fc_hidden_units": [
                    "None",
                    "Optional[str]",
                    "bool",
                    "str",
                    "List[int]",
                    "list[int]",
                    "Optional[int]",
                    "int"
                ],
                "calibrate": [
                    "bool",
                    "List[int]",
                    "raiden.utils.TokenAmount",
                    "int",
                    "Optional[str]",
                    "list",
                    "List[List[str]]",
                    "List[str]"
                ]
            }
        },
        "Imputer.__persist_class_prototypes": {
            "name": "__persist_class_prototypes",
            "location": 295,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "iter_train": [
                    "Type[T]",
                    "str"
                ],
                "train_df": [
                    "Optional[List[Any]]",
                    "str",
                    "list[typing.Any]",
                    "int",
                    "None"
                ]
            }
        },
        "Imputer.__get_label_encoder": {
            "name": "__get_label_encoder",
            "location": 349,
            "return": [
                "str",
                "Dict[str, Union[str, int]]",
                "list[int]",
                "None",
                "list[str]",
                "typing.Type",
                "list[]"
            ],
            "arguments": {
                "self": [],
                "label_column": [
                    "Optional[str]",
                    "None",
                    "str",
                    "int",
                    "Optional[float]",
                    "float",
                    "Optional[Callable]",
                    "typing.Callable[, ]"
                ]
            }
        },
        "Imputer.explain": {
            "name": "explain",
            "location": 368,
            "return": [
                "dict[, ]",
                "Dict[str, Any]",
                "str",
                "dict",
                "dict[str, str]",
                "raiden.utils.Dict[str, raiden.utils.Any]",
                "Dict[str, Dict[str, str]]"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "int"
                ],
                "k": [
                    "int",
                    "Tuple[Type[str], Type[bytes]]",
                    "bool",
                    "Callable"
                ],
                "label_column": [
                    "int",
                    "None",
                    "str",
                    "Optional[Dict]",
                    "bool",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "Imputer.explain_instance": {
            "name": "explain_instance",
            "location": 405,
            "return": [
                "dict[, ]",
                "Dict[str, Any]",
                "dict[typing.Any, str]",
                "dict",
                "dict[str, str]",
                "raiden.utils.Dict[str, raiden.utils.Any]",
                "Dict[str, Dict[str, str]]"
            ],
            "arguments": {
                "self": [],
                "instance": [
                    "int",
                    "bytes",
                    "str",
                    "raiden.utils.BalanceHash"
                ],
                "k": [
                    "int",
                    "bool",
                    "Optional[float]"
                ],
                "label_column": [
                    "float",
                    "None",
                    "int",
                    "bool"
                ],
                "label": [
                    "float",
                    "None",
                    "Optional[Sequence[Any]]",
                    "typing.Sequence[typing.Any]"
                ]
            }
        },
        "Imputer.__fit_module": {
            "name": "__fit_module",
            "location": 468,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "iter_train": [
                    "int",
                    "pandas.DataFrame",
                    "raiden.utils.FeeAmount"
                ],
                "iter_test": [
                    "int",
                    "pandas.DataFrame",
                    "raiden.utils.FeeAmount"
                ],
                "learning_rate": [
                    "int",
                    "pandas.DataFrame",
                    "raiden.utils.FeeAmount"
                ],
                "num_epochs": [
                    "int",
                    "pandas.DataFrame",
                    "raiden.utils.FeeAmount"
                ],
                "patience": [
                    "int",
                    "typing.Callable[, ]",
                    "bool",
                    "None",
                    "Callable",
                    "typing.Iterable[typing.Any]",
                    "Optional[Callable]",
                    "Iterable[Any]"
                ],
                "weight_decay": [
                    "int",
                    "pandas.DataFrame",
                    "raiden.utils.FeeAmount"
                ]
            }
        },
        "Imputer.__build_module": {
            "name": "__build_module",
            "location": 530,
            "return": [
                "T",
                "set"
            ],
            "arguments": {
                "self": [],
                "iter_train": [
                    "typing.Type",
                    "iterators.ImputerIterDf",
                    "dict[, ]",
                    "Type[object]",
                    "dict",
                    "Type[\"SerializationDialect\"]"
                ]
            }
        },
        "Imputer.__build_iterators": {
            "name": "__build_iterators",
            "location": 534,
            "return": [
                "bool",
                "tuple[ImputerIterDf]"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "int",
                    "Union[np.ndarray, Dict[str, np.ndarray], loompy.LayerManager]",
                    "Iterable[T]",
                    "Callable[[T], Any]",
                    "Optional[T]",
                    "Dict[str, Any]",
                    "Optional[float]"
                ],
                "test_df": [
                    "pandas.DataFrame",
                    "float",
                    "Optional[float]",
                    "None",
                    "Optional[dict]",
                    "dict[, ]",
                    "Optional[str]",
                    "str",
                    "Optional[List[int]]",
                    "list[int]"
                ],
                "test_split": [
                    "float",
                    "int",
                    "pandas.DataFrame",
                    "str"
                ]
            }
        },
        "Imputer.__transform_mxnet_iter": {
            "name": "__transform_mxnet_iter",
            "location": 609,
            "return": [
                "dict[, ]",
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": [],
                "mxnet_iter": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "Imputer.__filter_predictions": {
            "name": "__filter_predictions",
            "location": 627,
            "return": [
                "list[tuple[]]",
                "list[typing.Text]",
                "float",
                "logging.LogRecord",
                "Callable[[None], bool]",
                "pandas.DataFrame",
                "List[str]",
                "int"
            ],
            "arguments": {
                "predictions": [
                    "str",
                    "logging.LogRecord",
                    "list[]",
                    "bool",
                    "list"
                ],
                "precision_threshold": [
                    "float",
                    "logging.LogRecord",
                    "Callable[[None], bool]",
                    "pandas.DataFrame",
                    "List[str]",
                    "int"
                ]
            }
        },
        "Imputer.__predict_above_precision_mxnet_iter": {
            "name": "__predict_above_precision_mxnet_iter",
            "location": 646,
            "return": [
                "int",
                "str",
                "Tuple[int, int]",
                "numpy.ndarray",
                "Callable[[T], bool]"
            ],
            "arguments": {
                "self": [],
                "mxnet_iter": [
                    "int",
                    "str",
                    "bool"
                ],
                "precision_threshold": [
                    "float",
                    "Iterable",
                    "Union[int, float]",
                    "str",
                    "List[str]"
                ]
            }
        },
        "Imputer.__predict_mxnet_iter": {
            "name": "__predict_mxnet_iter",
            "location": 670,
            "return": [
                "dict[, ]",
                "str",
                "int",
                "pandas.DataFrame"
            ],
            "arguments": {
                "self": [],
                "mxnet_iter": [
                    "bytes",
                    "raiden.utils.Address"
                ]
            }
        },
        "Imputer.__predict_top_k_mxnet_iter": {
            "name": "__predict_top_k_mxnet_iter",
            "location": 694,
            "return": [
                "dict[, list[]]",
                "numpy.ndarray",
                "Type"
            ],
            "arguments": {
                "self": [],
                "mxnet_iter": [
                    "bool",
                    "float",
                    "numpy.array"
                ],
                "top_k": [
                    "int",
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "str"
                ]
            }
        },
        "Imputer.__transform_and_compute_metrics_mxnet_iter": {
            "name": "__transform_and_compute_metrics_mxnet_iter",
            "location": 723,
            "return": [
                "cmk.utils.type_defs.EventRule",
                "Callable[[T], bool]",
                "Iterable[T]"
            ],
            "arguments": {
                "self": [],
                "mxnet_iter": [
                    "time",
                    "Sequence[str]",
                    "bool",
                    "str"
                ],
                "metrics_path": [
                    "str",
                    "None",
                    "Iterable[Tuple[str, dict]]",
                    "bool",
                    "List[str]",
                    "typing.Iterable[tuple[typing.Union[str,dict[, ]]]]",
                    "Callable[[], Any]",
                    "typing.Callable[_, typing.Any]"
                ]
            }
        },
        "Imputer.transform": {
            "name": "transform",
            "location": 783,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "dict[, ]",
                    "str",
                    "pandas.DataFrame",
                    "bytes",
                    "dict",
                    "list[str]",
                    "dict[str, typing.Any]",
                    "List[str]",
                    "Dict[str, Any]",
                    "Iterable[int]"
                ]
            }
        },
        "Imputer.predict": {
            "name": "predict",
            "location": 792,
            "return": [
                "list[str]",
                "str",
                "raiden.utils.signer.Signer",
                "Optional[float]",
                "int",
                "List[Dict[str, Any]]",
                "Dict[str, str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "list[str]",
                    "pandas.DataFrame",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "List[str]",
                    "str"
                ],
                "precision_threshold": [
                    "float",
                    "dict",
                    "Tuple[int, int]",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "imputation_suffix": [
                    "typing.Text",
                    "pandas.DataFrame",
                    "str",
                    "bytes"
                ],
                "score_suffix": [
                    "typing.Text",
                    "bytes",
                    "Dict[str, pandas.DataFrame]",
                    "dict",
                    "pandas.DataFrame",
                    "int",
                    "str",
                    "List[List[str]]"
                ],
                "inplace": [
                    "bool",
                    "int",
                    "bytes",
                    "dict"
                ]
            }
        },
        "Imputer.predict_proba": {
            "name": "predict_proba",
            "location": 861,
            "return": [
                "Callable"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "dict[, ]",
                    "str",
                    "pandas.DataFrame",
                    "bytes",
                    "dict",
                    "list[str]",
                    "dict[str, typing.Any]",
                    "List[str]",
                    "Dict[str, Any]",
                    "Iterable[int]"
                ]
            }
        },
        "Imputer.predict_above_precision": {
            "name": "predict_above_precision",
            "location": 870,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "dict[, ]",
                    "str",
                    "pandas.DataFrame",
                    "bytes",
                    "dict",
                    "list[str]",
                    "dict[str, typing.Any]",
                    "List[str]",
                    "Dict[str, Any]",
                    "Iterable[int]"
                ],
                "precision_threshold": [
                    "float",
                    "int",
                    "bool",
                    "numpy.ndarray",
                    "str"
                ]
            }
        },
        "Imputer.predict_proba_top_k": {
            "name": "predict_proba_top_k",
            "location": 884,
            "return": [
                "utils.diskstaSection",
                "str",
                "pandas.DataFrame",
                "float"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "Dict[str, Any]",
                    "str",
                    "dict[str, typing.Any]",
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "top_k": [
                    "int",
                    "bool",
                    "str",
                    "Tuple[int]"
                ]
            }
        },
        "Imputer.transform_and_compute_metrics": {
            "name": "transform_and_compute_metrics",
            "location": 897,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "str",
                    "pandas.DataFrame",
                    "dict[str, T]",
                    "list[str]",
                    "Dict[str, T]",
                    "List[str]"
                ],
                "metrics_path": [
                    "str",
                    "None",
                    "list",
                    "Union[str, TextIO]",
                    "list[]",
                    "typing.TextIO"
                ]
            }
        },
        "Imputer.__drop_missing_labels": {
            "name": "__drop_missing_labels",
            "location": 916,
            "return": [
                "dict",
                "str",
                "Optional[float]",
                "pandas.DataFrame",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "pandas.DataFrame",
                    "dict",
                    "str",
                    "Sequence[T]"
                ],
                "how": [
                    "typing.Text",
                    "bool",
                    "Iterable[bytes]",
                    "dict",
                    "tuple",
                    "List[Dict]",
                    "Optional[bool]",
                    "List[List[Any]]",
                    "bytes",
                    "str"
                ]
            }
        },
        "Imputer.__prune_models": {
            "name": "__prune_models",
            "location": 954,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Imputer.__get_best_epoch": {
            "name": "__get_best_epoch",
            "location": 968,
            "return": [
                "str",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Imputer.save": {
            "name": "save",
            "location": 977,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Imputer.load": {
            "name": "load",
            "location": 988,
            "return": [
                "Imputer",
                "str",
                "bool",
                "pandas._FilePathOrBuffer"
            ],
            "arguments": {
                "output_path": [
                    "str"
                ]
            }
        },
        "Imputer.__mxnet_iter_from_df": {
            "name": "__mxnet_iter_from_df",
            "location": 1036,
            "return": [
                "str",
                "ImputerIterDf"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "bool",
                    "typing.Iterator",
                    "bytes",
                    "Iterator[Dict[str, str]]",
                    "typing.Generator[]",
                    "Generator",
                    "str",
                    "Union[int, str]",
                    "dict[str, typing.Any]",
                    "Iterator",
                    "Dict[str, Any]"
                ]
            }
        },
        "Imputer.calibrate": {
            "name": "calibrate",
            "location": 1051,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "test_iter": [
                    "numpy.array",
                    "int",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "Optional[float]"
                ]
            }
        },
        "_MXNetModule.__init__": {
            "name": "__init__",
            "location": 1097,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "ctx": [
                    "bool",
                    "list[str]",
                    "int",
                    "List[str]"
                ],
                "label_encoders": [
                    "bool",
                    "str",
                    "int"
                ],
                "data_featurizers": [
                    "bool",
                    "str",
                    "int"
                ],
                "final_fc_hidden_units": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "_MXNetModule.__call__": {
            "name": "__call__",
            "location": 1117,
            "return": [
                "Callable",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "iter_train": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "_MXNetModule.__make_categorical_loss": {
            "name": "__make_categorical_loss",
            "location": 1149,
            "return": [
                "tuple[typing.Union[int,dict[, ],list[int],list[list[int]],str,dict[str, _]]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "latents": [
                    "str",
                    "Tuple[str, str]",
                    "tuple[typing.Union[str,str]]",
                    "List[str]",
                    "list[str]"
                ],
                "label_field_name": [
                    "str",
                    "int"
                ],
                "num_labels": [
                    "int",
                    "str"
                ],
                "final_fc_hidden_units": [
                    "int",
                    "str",
                    "float",
                    "List[int]",
                    "list",
                    "dict"
                ]
            }
        },
        "_MXNetModule.__make_numerical_loss": {
            "name": "__make_numerical_loss",
            "location": 1224,
            "return": [
                "tuple[typing.Union[float,int]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "latents": [
                    "Sequence[str]",
                    "str",
                    "typing.Sequence[str]",
                    "int",
                    "List[str]",
                    "list[str]"
                ],
                "label_field_name": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "_MXNetModule.__make_loss": {
            "name": "__make_loss",
            "location": 1247,
            "return": [
                "tuple[typing.Union[dict[, ],int,float,tuple[typing.Union[str,str]],typing.Pattern,list[list[int]],list[]]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "eps": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Imputer.__fit_module.checkpoint": {
            "name": "checkpoint",
            "location": 490,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "epoch": [
                    "str",
                    "int"
                ],
                "sym": [
                    "str",
                    "int"
                ],
                "arg": [
                    "str",
                    "int"
                ],
                "aux": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "datawig-master/datawig/iterators.py": {
        "ImputerIter.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_columns": [
                    "List[datawig.column_encoders.ColumnEncoder]"
                ],
                "label_columns": [
                    "List[datawig.column_encoders.ColumnEncoder]"
                ],
                "batch_size": [
                    "int"
                ]
            }
        },
        "ImputerIter.__iter__": {
            "name": "__iter__",
            "location": 59,
            "return": [
                "ImputerIter"
            ],
            "arguments": {
                "self": [
                    "_TImputerIter"
                ]
            }
        },
        "ImputerIter.__next__": {
            "name": "__next__",
            "location": 62,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputerIter.provide_data": {
            "name": "provide_data",
            "location": 66,
            "return": [
                "dict",
                "Dict[str, List[int]]",
                "raiden.utils.signer.Signer",
                "IO[bytes]",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputerIter.provide_label": {
            "name": "provide_label",
            "location": 76,
            "return": [
                "str",
                "bool",
                "Callable",
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputerIter.decode": {
            "name": "decode",
            "location": 85,
            "return": [
                "list[]",
                "bool",
                "int",
                "Tuple[int]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "mxnet_label_predictions": [
                    "int",
                    "Optional[Any]",
                    "typing.Any",
                    "str",
                    "bytes",
                    "List[List[Any]]",
                    "None",
                    "list[list[typing.Any]]",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "ImputerIter.mxnet_iterator_from_df": {
            "name": "mxnet_iterator_from_df",
            "location": 97,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "pandas.DataFrame",
                    "dict",
                    "List[str]",
                    "List['cirq.Circuit']",
                    "int"
                ]
            }
        },
        "ImputerIter._n_rows_padding": {
            "name": "_n_rows_padding",
            "location": 152,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "dict[, ]",
                    "str",
                    "dict",
                    "tuple[typing.Union[str,str,str]]",
                    "Tuple[str, str, str]",
                    "bool"
                ]
            }
        },
        "ImputerIter.reset": {
            "name": "reset",
            "location": 170,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputerIter.next": {
            "name": "next",
            "location": 179,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImputerIterDf.__init__": {
            "name": "__init__",
            "location": 210,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "float",
                    "int",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "numpy.ndarray",
                    "List[Tuple[int, int]]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]"
                ],
                "data_columns": [
                    "List[datawig.column_encoders.ColumnEncoder]"
                ],
                "label_columns": [
                    "List[datawig.column_encoders.ColumnEncoder]"
                ],
                "batch_size": [
                    "int"
                ]
            }
        }
    },
    "datawig-master/datawig/mxnet_input_symbols.py": {
        "Featurizer.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str"
                ],
                "latent_dim": [
                    "int"
                ]
            }
        },
        "Featurizer.latent_symbol": {
            "name": "latent_symbol",
            "location": 46,
            "return": [
                "bool",
                "str",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "NumericalFeaturizer.__init__": {
            "name": "__init__",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str"
                ],
                "numeric_latent_dim": [
                    "int"
                ],
                "numeric_hidden_layers": [
                    "int"
                ]
            }
        },
        "LSTMFeaturizer.__init__": {
            "name": "__init__",
            "location": 103,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str"
                ],
                "seq_len": [
                    "int"
                ],
                "max_tokens": [
                    "int"
                ],
                "embed_dim": [
                    "int"
                ],
                "num_hidden": [
                    "int"
                ],
                "num_layers": [
                    "int"
                ],
                "latent_dim": [
                    "int"
                ],
                "use_gpu": [
                    "bool"
                ]
            }
        },
        "EmbeddingFeaturizer.__init__": {
            "name": "__init__",
            "location": 153,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str"
                ],
                "max_tokens": [
                    "int"
                ],
                "embed_dim": [
                    "int"
                ]
            }
        },
        "BowFeaturizer.__init__": {
            "name": "__init__",
            "location": 181,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str"
                ],
                "max_tokens": [
                    "int"
                ]
            }
        },
        "LSTMFeaturizer.__init__.make_cell": {
            "name": "make_cell",
            "location": 127,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "layer_index": [
                    "Tuple['cirq.Qid']",
                    "str",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "datawig-master/datawig/simple_imputer.py": {
        "SimpleImputer.__init__": {
            "name": "__init__",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "List[str]"
                ],
                "output_column": [
                    "str"
                ],
                "output_path": [
                    "str"
                ],
                "num_hash_buckets": [
                    "int"
                ],
                "num_labels": [
                    "int"
                ],
                "tokens": [
                    "str"
                ],
                "numeric_latent_dim": [
                    "int"
                ],
                "numeric_hidden_layers": [
                    "int"
                ],
                "is_explainable": [
                    "bool"
                ]
            }
        },
        "SimpleImputer.check_data_types": {
            "name": "check_data_types",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "dict",
                    "dict[, ]",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "bytes",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "SimpleImputer._is_categorical": {
            "name": "_is_categorical",
            "location": 147,
            "return": [
                "bool"
            ],
            "arguments": {
                "col": [
                    "str",
                    "None",
                    "Optional[str]",
                    "tuple[typing.Union[int,int]]",
                    "bool",
                    "list[T]",
                    "bytes",
                    "raiden.utils.BlockNumber",
                    "numpy.ndarray",
                    "Tuple[int, int]",
                    "List[T]",
                    "int"
                ],
                "n_samples": [
                    "int"
                ],
                "max_unique_fraction": [
                    "float",
                    "int",
                    "Tuple[int, int]"
                ]
            }
        },
        "SimpleImputer.fit_hpo": {
            "name": "fit_hpo",
            "location": 168,
            "return": [
                "SimpleImputer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "float",
                    "bool",
                    "pandas.DataFrame"
                ],
                "test_df": [
                    "pandas.DataFrame",
                    "None",
                    "Optional[List[int]]",
                    "list[int]",
                    "Optional[int]",
                    "int"
                ],
                "hps": [
                    "dict"
                ],
                "num_evals": [
                    "int"
                ],
                "max_running_hours": [
                    "float"
                ],
                "hpo_run_name": [
                    "str"
                ],
                "user_defined_scores": [
                    "list"
                ],
                "num_epochs": [
                    "int"
                ],
                "patience": [
                    "int"
                ],
                "test_split": [
                    "float"
                ],
                "weight_decay": [
                    "List[float]"
                ],
                "batch_size": [
                    "int"
                ],
                "num_hash_bucket_candidates": [
                    "List[float]"
                ],
                "tokens_candidates": [
                    "List[str]"
                ],
                "numeric_latent_dim_candidates": [
                    "List[int]"
                ],
                "numeric_hidden_layers_candidates": [
                    "List[int]"
                ],
                "final_fc_hidden_units": [
                    "List[List[int]]"
                ],
                "learning_rate_candidates": [
                    "List[float]"
                ],
                "normalize_numeric": [
                    "bool"
                ],
                "hpo_max_train_samples": [
                    "int"
                ],
                "ctx": [
                    "int",
                    "str",
                    "bool",
                    "typing.Callable[[], None]",
                    "Callable[[], None]"
                ]
            }
        },
        "SimpleImputer.fit": {
            "name": "fit",
            "location": 299,
            "return": [
                "SimpleImputer",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "bool",
                    "float",
                    "raiden.utils.BlockTimeout",
                    "raiden.utils.ChainID",
                    "raiden.utils.Iterator[raiden.utils.Port]"
                ],
                "test_df": [
                    "int",
                    "None",
                    "float",
                    "bool",
                    "list[int]",
                    "pandas.DataFrame",
                    "List[int]"
                ],
                "ctx": [
                    "int",
                    "float",
                    "list[int]",
                    "bool",
                    "pandas.DataFrame",
                    "List[int]"
                ],
                "learning_rate": [
                    "float"
                ],
                "num_epochs": [
                    "int"
                ],
                "patience": [
                    "int"
                ],
                "test_split": [
                    "float"
                ],
                "weight_decay": [
                    "float"
                ],
                "batch_size": [
                    "int"
                ],
                "final_fc_hidden_units": [
                    "List[int]"
                ],
                "calibrate": [
                    "bool"
                ],
                "class_weights": [
                    "dict"
                ],
                "instance_weights": [
                    "list"
                ]
            }
        },
        "SimpleImputer.predict": {
            "name": "predict",
            "location": 395,
            "return": [
                "int",
                "Callable",
                "tuple[typing.Union[typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal,typing.Literal]]",
                "str",
                "typing.Type"
            ],
            "arguments": {
                "self": [],
                "data_frame": [
                    "int",
                    "str",
                    "bool",
                    "snorkel.types.DataPoins",
                    "numpy.ndarray"
                ],
                "precision_threshold": [
                    "float"
                ],
                "imputation_suffix": [
                    "str"
                ],
                "score_suffix": [
                    "str"
                ],
                "inplace": [
                    "bool"
                ]
            }
        },
        "SimpleImputer.explain": {
            "name": "explain",
            "location": 424,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str"
                ],
                "k": [
                    "int"
                ],
                "label_column": [
                    "str"
                ]
            }
        },
        "SimpleImputer.explain_instance": {
            "name": "explain_instance",
            "location": 438,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "instance": [
                    "Mapping[str, Any]",
                    "typing.Mapping",
                    "Union[int, numpy.ndarray]",
                    "int"
                ],
                "k": [
                    "int"
                ],
                "label_column": [
                    "str"
                ],
                "label": [
                    "str"
                ]
            }
        },
        "SimpleImputer.complete": {
            "name": "complete",
            "location": 459,
            "return": [
                "str",
                "raiden.utils.signer.Signer",
                "Optional[float]",
                "int",
                "List[Dict[str, Any]]",
                "Dict[str, str]",
                "bool"
            ],
            "arguments": {
                "data_frame": [
                    "numpy.ndarray",
                    "bool",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "float",
                    "int"
                ],
                "precision_threshold": [
                    "float"
                ],
                "inplace": [
                    "bool"
                ],
                "hpo": [
                    "bool"
                ],
                "verbose": [
                    "int"
                ],
                "num_epochs": [
                    "int"
                ],
                "iterations": [
                    "int"
                ],
                "output_path": [
                    "str"
                ]
            }
        },
        "SimpleImputer.save": {
            "name": "save",
            "location": 538,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleImputer.load_metrics": {
            "name": "load_metrics",
            "location": 549,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleImputer.load": {
            "name": "load",
            "location": 560,
            "return": [
                "SimpleImputer",
                "str",
                "bool",
                "pandas._FilePathOrBuffer"
            ],
            "arguments": {
                "output_path": [
                    "str"
                ]
            }
        },
        "SimpleImputer.load_hpo_model": {
            "name": "load_hpo_model",
            "location": 594,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hpo_name": [
                    "int"
                ]
            }
        },
        "SimpleImputer.__deserialize_confusion_matrix": {
            "name": "__deserialize_confusion_matrix",
            "location": 626,
            "return": [
                "bool",
                "str",
                "Optional[int]",
                "Optional[bool]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleImputer.check_for_label_shift": {
            "name": "check_for_label_shift",
            "location": 651,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "target_data": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "SimpleImputer.__add_weights_to_df": {
            "name": "__add_weights_to_df",
            "location": 689,
            "return": [
                "dict[str, dict[, ]]",
                "str",
                "Tuple[str, str]",
                "Set[str]",
                "int",
                "dict"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "dict[str, dict[, ]]",
                    "pandas.DataFrame",
                    "bool",
                    "Dict[str, Dict]",
                    "str",
                    "augury.types.YearRange",
                    "Union[numpy.ndarray, numpy.void]"
                ],
                "class_weights": [
                    "dict[, ]",
                    "None",
                    "dict",
                    "list",
                    "Optional[float]",
                    "bool",
                    "Optional[numpy.ndarray]"
                ],
                "instance_weights": [
                    "list",
                    "None",
                    "dict",
                    "list[]",
                    "bool",
                    "Optional[Tuple[int, int]]",
                    "dict[, ]",
                    "Optional[float]",
                    "tuple[typing.Union[int,int]]",
                    "float",
                    "Optional[numpy.array]"
                ],
                "in_place": [
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "datawig-master/datawig/utils.py": {
        "set_stream_log_level": {
            "name": "set_stream_log_level",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "level": [
                    "str"
                ]
            }
        },
        "flatten_dict": {
            "name": "flatten_dict",
            "location": 55,
            "return": [
                "dict"
            ],
            "arguments": {
                "d": [
                    "dict"
                ],
                "parent_key": [
                    "str"
                ],
                "sep": [
                    "str"
                ]
            }
        },
        "stringify_list": {
            "name": "stringify_list",
            "location": 81,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "cols": [
                    "str",
                    "bool",
                    "Callable[[str], None]",
                    "Tuple[str, str]",
                    "Optional[str]"
                ]
            }
        },
        "merge_dicts": {
            "name": "merge_dicts",
            "location": 88,
            "return": [
                "dict"
            ],
            "arguments": {
                "d1": [
                    "dict"
                ],
                "d2": [
                    "dict"
                ]
            }
        },
        "get_context": {
            "name": "get_context",
            "location": 100,
            "return": [
                "bytes",
                "List[str]",
                "List[Dict]",
                "str",
                "Union[str, List[Any]]",
                "List[List[Any]]"
            ],
            "arguments": {}
        },
        "random_split": {
            "name": "random_split",
            "location": 124,
            "return": [
                "list"
            ],
            "arguments": {
                "data_frame": [
                    "int",
                    "str",
                    "List[Dict]",
                    "List[int]"
                ],
                "split_ratios": [
                    "List[float]"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "rand_string": {
            "name": "rand_string",
            "location": 142,
            "return": [
                "str"
            ],
            "arguments": {
                "length": [
                    "int"
                ]
            }
        },
        "timing": {
            "name": "timing",
            "location": 155,
            "return": [
                ""
            ],
            "arguments": {
                "marker": [
                    "int",
                    "str"
                ]
            }
        },
        "normalize_dataframe": {
            "name": "normalize_dataframe",
            "location": 258,
            "return": [
                "Optional[float]",
                "str",
                "dict"
            ],
            "arguments": {
                "data_frame": [
                    "pandas.DataFrame",
                    "int",
                    "Union[str, bytes]",
                    "Type['nanaimo.fixtures.Fixture']",
                    "str",
                    "bytes",
                    "list"
                ]
            }
        },
        "softmax": {
            "name": "softmax",
            "location": 277,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "Optional[bool]",
                "str"
            ],
            "arguments": {
                "x": [
                    "float",
                    "Union[pandas.DataFrame, numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "generate_df_string": {
            "name": "generate_df_string",
            "location": 285,
            "return": [
                "str",
                "numpy.ndarray",
                "dict"
            ],
            "arguments": {
                "word_length": [
                    "int"
                ],
                "vocab_size": [
                    "int"
                ],
                "num_labels": [
                    "int"
                ],
                "num_words": [
                    "int"
                ],
                "num_samples": [
                    "int"
                ],
                "label_column_name": [
                    "str"
                ],
                "data_column_name": [
                    "str"
                ]
            }
        },
        "generate_df_numeric": {
            "name": "generate_df_numeric",
            "location": 320,
            "return": [
                "str",
                "numpy.ndarray",
                "dict"
            ],
            "arguments": {
                "num_samples": [
                    "int"
                ],
                "label_column_name": [
                    "str"
                ],
                "data_column_name": [
                    "str"
                ]
            }
        },
        "random_cartesian_product": {
            "name": "random_cartesian_product",
            "location": 338,
            "return": [
                "list"
            ],
            "arguments": {
                "sets": [
                    "list"
                ],
                "num": [
                    "int"
                ]
            }
        },
        "sample_cartesian": {
            "name": "sample_cartesian",
            "location": 374,
            "return": [
                "list"
            ],
            "arguments": {
                "sets": [
                    "list"
                ],
                "idx": [
                    "int"
                ],
                "n": [
                    "int"
                ]
            }
        },
        "MeanSymbol.__init__": {
            "name": "__init__",
            "location": 171,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "symbol_index": [
                    "dict",
                    "List[str]",
                    "Optional[bool]",
                    "int",
                    "str"
                ],
                "output_names": [
                    "str",
                    "float"
                ],
                "label_names": [
                    "str",
                    "float"
                ]
            }
        },
        "MeanSymbol.update": {
            "name": "update",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "_": [
                    "int",
                    "str",
                    "Optional[bool]",
                    "bool"
                ],
                "preds": [
                    "bool",
                    "Dict[str, Any]",
                    "callable"
                ]
            }
        },
        "AccuracyMetric.__init__": {
            "name": "__init__",
            "location": 188,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "label_index": [
                    "bool",
                    "Sequence",
                    "int"
                ]
            }
        },
        "AccuracyMetric.update": {
            "name": "update",
            "location": 192,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labels": [
                    "numpy.array",
                    "numpy.ndarray",
                    "List[str]",
                    "Hashable",
                    "str",
                    "List[List[Any]]",
                    "List[List[str]]"
                ],
                "preds": [
                    "bool",
                    "int",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "LogMetricCallBack.__init__": {
            "name": "__init__",
            "location": 205,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tracked_metrics": [
                    "int",
                    "bool",
                    "float"
                ],
                "patience": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LogMetricCallBack.__call__": {
            "name": "__call__",
            "location": 215,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "param": [
                    "Optional[Dict[str, Any]]",
                    "Optional[AbstractSet[str]]"
                ]
            }
        },
        "LogMetricCallBack.check_regression": {
            "name": "check_regression",
            "location": 225,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "generate_df_string.sentence_with_label": {
            "name": "sentence_with_label",
            "location": 311,
            "return": [
                "str",
                "bool",
                "Dict[str, str]",
                "bytes",
                "float"
            ],
            "arguments": {
                "labels": [
                    "str",
                    "List[List[int]]",
                    "pandas.DataFrame",
                    "List[Tuple[str, Any, Any]]",
                    "List[str]"
                ],
                "words": [
                    "str",
                    "List[str]",
                    "Dict[str, int]",
                    "list",
                    "int"
                ]
            }
        },
        "LogMetricCallBack.check_regression.convert_nans": {
            "name": "convert_nans",
            "location": 233,
            "return": [
                "str",
                "Optional[str]",
                "dict"
            ],
            "arguments": {
                "e": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "datawig-master/datawig/_hpo.py": {
        "_HPO.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_HPO.__preprocess_hps": {
            "name": "__preprocess_hps",
            "location": 57,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "int",
                    "pandas.DataFrame",
                    "tuple[typing.Union[int,int]]",
                    "typing.Sequence[typing.Any]",
                    "Tuple[int, int]",
                    "Sequence[Any]"
                ],
                "simple_imputer": [
                    "Optional[List[Any]]",
                    "list[typing.Any]",
                    "bool",
                    "bytes",
                    "None",
                    "float",
                    "pandas.DataFrame",
                    "str"
                ],
                "num_evals": [
                    "bool",
                    "float",
                    "int",
                    "None",
                    "pandas.DataFrame",
                    "Optional[float]"
                ]
            }
        },
        "_HPO.__fit_hp": {
            "name": "__fit_hp",
            "location": 145,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "int",
                    "pandas.DataFrame",
                    "bool"
                ],
                "test_df": [
                    "bool",
                    "pandas.DataFrame",
                    "float",
                    "None",
                    "Optional[float]"
                ],
                "hp": [
                    "str",
                    "dict",
                    "Optional[Union[str, bytes]]",
                    "Mapping[starfish.types.Coordinates, Tuple[starfish.types.Number, starfish.types.Number]]",
                    "Mapping[starfish.core.types.Coordinates, starfish.core.types.ArrayLike[starfish.core.types.Number]]",
                    "int",
                    "Dict[str, List[Any]]"
                ],
                "simple_imputer": [
                    "int",
                    "tuple",
                    "tuple[]"
                ],
                "name": [
                    "int"
                ],
                "user_defined_scores": [
                    "list[]",
                    "list",
                    "bool",
                    "int"
                ]
            }
        },
        "_HPO.tune": {
            "name": "tune",
            "location": 298,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "train_df": [
                    "int",
                    "pandas.DataFrame"
                ],
                "test_df": [
                    "None",
                    "pandas.DataFrame",
                    "float",
                    "Optional[float]",
                    "list[int]",
                    "Optional[List[int]]",
                    "int",
                    "Optional[int]",
                    "Union[None, float, int]"
                ],
                "hps": [
                    "dict"
                ],
                "num_evals": [
                    "int"
                ],
                "max_running_hours": [
                    "float"
                ],
                "user_defined_scores": [
                    "list"
                ],
                "hpo_run_name": [
                    "str"
                ],
                "simple_imputer": [
                    "bytes",
                    "str",
                    "cmk.utils.type_defs.ConfigSerial",
                    "cmk.utils.type_defs.HostName",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "datawig-master/datawig/__init__.py": {},
    "datawig-master/datawig-js/server.py": {},
    "datawig-master/datawig-js/blueprints/datawig.py": {
        "index": {
            "name": "index",
            "location": 7,
            "return": [
                "str",
                "Optional[Any]"
            ],
            "arguments": {}
        }
    },
    "datawig-master/docs/conf.py": {},
    "datawig-master/examples/imputer_intro.py": {},
    "datawig-master/examples/mae.py": {
        "prepare_dataset": {
            "name": "prepare_dataset",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "prefix": [
                    "tuple['cirq.Qid']",
                    "Tuple['cirq.Qid']",
                    "str",
                    "dict[str, str]",
                    "Dict[str, str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "prepare_dataset.parse_and_store_dataset": {
            "name": "parse_and_store_dataset",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "datawig-master/examples/params_tutorial.py": {},
    "datawig-master/examples/simpleimputer_intro.py": {},
    "datawig-master/experiments/benchmarks.py": {},
    "datawig-master/test/conftest.py": {
        "reset_random_seed": {
            "name": "reset_random_seed",
            "location": 28,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "test_dir": {
            "name": "test_dir",
            "location": 38,
            "return": [
                ""
            ],
            "arguments": {}
        },
        "data_frame": {
            "name": "data_frame",
            "location": 45,
            "return": [
                "str",
                "int",
                "bytes",
                "pandas.DataFrame",
                "set"
            ],
            "arguments": {}
        },
        "synthetic_label_shift_simple": {
            "name": "synthetic_label_shift_simple",
            "location": 91,
            "return": [
                "numpy.ndarray",
                "bool",
                "int"
            ],
            "arguments": {
                "N": [
                    "Callable",
                    "bool",
                    "Optional[Callable[[Any], None]]",
                    "int"
                ],
                "label_proportions": [
                    "List[int]",
                    "int",
                    "bool",
                    "List[str]",
                    "str",
                    "float",
                    "utils.Rect",
                    "Callable"
                ],
                "error_proba": [
                    "int",
                    "bool",
                    "float"
                ],
                "covariates": [
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "numpy.ndarray"
                ]
            }
        },
        "data_frame._inner_impl": {
            "name": "_inner_impl",
            "location": 47,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "feature_col": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "Iterator[numpy.ndarray]",
                    "str",
                    "numpy.array",
                    "numpy.ndarray"
                ],
                "label_col": [
                    "bool",
                    "int",
                    "pandas.DataFrame",
                    "Iterator[numpy.ndarray]",
                    "str",
                    "numpy.array",
                    "numpy.ndarray"
                ],
                "n_samples": [
                    "int",
                    "Union[int, str]",
                    "Tuple[float, float]"
                ],
                "word_length": [
                    "bool",
                    "str",
                    "float"
                ],
                "num_words": [
                    "bool",
                    "str",
                    "float"
                ],
                "vocab_size": [
                    "bool",
                    "str",
                    "float"
                ],
                "num_labels": [
                    "bool",
                    "str",
                    "float"
                ]
            }
        },
        "data_frame._inner_impl._sentence_with_label": {
            "name": "_sentence_with_label",
            "location": 68,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "labels": [
                    "str",
                    "bool"
                ],
                "words": [
                    "int",
                    "str",
                    "List[int]",
                    "Mapping[str, Sequence[Any]]",
                    "Tuple[str]"
                ]
            }
        }
    },
    "datawig-master/test/test_calibration.py": {
        "generate_synthetic_data": {
            "name": "generate_synthetic_data",
            "location": 30,
            "return": [
                "Tuple[(Any, np.ndarray)]"
            ],
            "arguments": {
                "K": [
                    "int"
                ],
                "N": [
                    "int"
                ],
                "p_correct": [
                    "float"
                ]
            }
        },
        "test_calibration_synthetic": {
            "name": "test_calibration_synthetic",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_automatic_calibration": {
            "name": "test_automatic_calibration",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "List[List[Any]]",
                    "bytes",
                    "list[list[typing.Any]]",
                    "List[List[str]]",
                    "list[list[str]]"
                ]
            }
        }
    },
    "datawig-master/test/test_column_encoders.py": {
        "test_categorical_encoder_unfitted_fail": {
            "name": "test_categorical_encoder_unfitted_fail",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_fit_categorical_encoder": {
            "name": "test_fit_categorical_encoder",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_transform": {
            "name": "test_categorical_encoder_transform",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_transform_missing_token": {
            "name": "test_categorical_encoder_transform_missing_token",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_max_token": {
            "name": "test_categorical_encoder_max_token",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_decode_token": {
            "name": "test_categorical_encoder_decode_token",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_decode_missing_token": {
            "name": "test_categorical_encoder_decode_missing_token",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_decode": {
            "name": "test_categorical_encoder_decode",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_decode_missing": {
            "name": "test_categorical_encoder_decode_missing",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_non_negative_embedding_indices": {
            "name": "test_categorical_encoder_non_negative_embedding_indices",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sequential_encoder_unfitted_fail": {
            "name": "test_sequential_encoder_unfitted_fail",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_fit_sequential_encoder": {
            "name": "test_fit_sequential_encoder",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sequential_encoder_transform": {
            "name": "test_sequential_encoder_transform",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sequential_encoder_transform_missing_token": {
            "name": "test_sequential_encoder_transform_missing_token",
            "location": 105,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sequential_encoder_max_token": {
            "name": "test_sequential_encoder_max_token",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sequential_encoder_non_negative_embedding_indices": {
            "name": "test_sequential_encoder_non_negative_embedding_indices",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_bow_encoder": {
            "name": "test_bow_encoder",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_bow_encoder_multicol": {
            "name": "test_bow_encoder_multicol",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_numeric": {
            "name": "test_categorical_encoder_numeric",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_numeric_transform": {
            "name": "test_categorical_encoder_numeric_transform",
            "location": 148,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_categorical_encoder_numeric_nan": {
            "name": "test_categorical_encoder_numeric_nan",
            "location": 154,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_column_encoder_no_list_input_column": {
            "name": "test_column_encoder_no_list_input_column",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_numeric_encoder": {
            "name": "test_numeric_encoder",
            "location": 171,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_tfidf_encoder": {
            "name": "test_tfidf_encoder",
            "location": 199,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "datawig-master/test/test_evaluation.py": {
        "test_evaluation_single": {
            "name": "test_evaluation_single",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_evaluation": {
            "name": "test_evaluation",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "datawig-master/test/test_imputer.py": {
        "test_drop_missing": {
            "name": "test_drop_missing",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ]
            }
        },
        "test_imputer_init": {
            "name": "test_imputer_init",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_imputer_duplicate_encoder_output_columns": {
            "name": "test_imputer_duplicate_encoder_output_columns",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "bool"
                ],
                "data_frame": [
                    "pandas.DataFrame"
                ]
            }
        },
        "test_imputer_real_data_all_featurizers": {
            "name": "test_imputer_real_data_all_featurizers",
            "location": 217,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "Callable[[str], str]",
                    "typing.Callable[str, str]"
                ],
                "data_frame": [
                    "Dict[str, Sequence[Any]]",
                    "dict[str, typing.Sequence[typing.Any]]"
                ]
            }
        },
        "test_imputer_without_train_df": {
            "name": "test_imputer_without_train_df",
            "location": 339,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ]
            }
        },
        "test_imputer_without_test_set_random_split": {
            "name": "test_imputer_without_test_set_random_split",
            "location": 374,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "Callable[[str], str]",
                    "typing.Callable[str, str]"
                ],
                "data_frame": [
                    "int",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_imputer_load_read_exec_only_dir": {
            "name": "test_imputer_load_read_exec_only_dir",
            "location": 430,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "data_frame": []
            }
        },
        "test_imputer_load_with_invalid_context": {
            "name": "test_imputer_load_with_invalid_context",
            "location": 459,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "data_frame": [
                    "Optional[List[str]]",
                    "list[str]",
                    "str",
                    "List[str]",
                    "None"
                ]
            }
        },
        "test_imputer_fit_fail_non_writable_output_dir": {
            "name": "test_imputer_fit_fail_non_writable_output_dir",
            "location": 483,
            "return": [
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Mapping[str, Any]",
                    "typing.Mapping"
                ],
                "data_frame": []
            }
        },
        "test_imputer_numeric_data": {
            "name": "test_imputer_numeric_data",
            "location": 508,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ]
            }
        },
        "test_imputer_unrepresentative_test_df": {
            "name": "test_imputer_unrepresentative_test_df",
            "location": 552,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "Callable[[str], str]",
                    "typing.Callable[str, str]"
                ],
                "data_frame": [
                    "bytes",
                    "bool"
                ]
            }
        },
        "test_imputer_tfidf": {
            "name": "test_imputer_tfidf",
            "location": 589,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "int",
                    "Mapping[str, str]",
                    "typing.Mapping"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_mxnet_module_wrapper": {
            "name": "test_mxnet_module_wrapper",
            "location": 610,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "bool",
                    "str",
                    "pandas.DataFrame",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_inplace_prediction": {
            "name": "test_inplace_prediction",
            "location": 630,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "int",
                    "Mapping[str, str]",
                    "typing.Mapping"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_not_explainable": {
            "name": "test_not_explainable",
            "location": 652,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "int",
                    "Mapping[str, str]",
                    "typing.Mapping"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_explain_instance_without_label": {
            "name": "test_explain_instance_without_label",
            "location": 685,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "Callable[[str], str]",
                    "typing.Callable[str, str]"
                ],
                "data_frame": [
                    "str"
                ]
            }
        },
        "test_explain_method_synthetic": {
            "name": "test_explain_method_synthetic",
            "location": 710,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ]
            }
        },
        "test_non_writable_output_path": {
            "name": "test_non_writable_output_path",
            "location": 773,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "typing.Callable[str, str]",
                    "str",
                    "Callable[[str], str]",
                    "typing.Mapping",
                    "Mapping[str, str]",
                    "tuple[typing.Union[str,str,str]]",
                    "Tuple[str, str, str]",
                    "Iterable[str]"
                ],
                "data_frame": []
            }
        },
        "test_fit_resumes": {
            "name": "test_fit_resumes",
            "location": 822,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "None",
                    "raiden.utils.TokenNetworkRegistryAddress",
                    "Optional[Iterable[T]]"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "datawig-master/test/test_imputer_iterators.py": {
        "test_iter_next_df": {
            "name": "test_iter_next_df",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "str",
                    "pandas.DataFrame",
                    "float",
                    "int",
                    "None",
                    "Optional[float]",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "dict[str, object]",
                    "Dict[str, object]",
                    "Optional[str]"
                ]
            }
        },
        "test_iter_df_bow": {
            "name": "test_iter_df_bow",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "bool",
                    "str",
                    "pandas.DataFrame",
                    "list[]",
                    "dict[str, typing.Any]",
                    "list",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_iter_provide_label_or_data_df": {
            "name": "test_iter_provide_label_or_data_df",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "float",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "test_iter_index_df": {
            "name": "test_iter_index_df",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "tuple[]",
                    "float",
                    "tuple",
                    "int",
                    "bytes",
                    "str",
                    "Optional[int]",
                    "None",
                    "bool"
                ]
            }
        },
        "test_iter_decoder_df": {
            "name": "test_iter_decoder_df",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_iter_padding_offset": {
            "name": "test_iter_padding_offset",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "get_new_iterator_df_bow": {
            "name": "get_new_iterator_df_bow",
            "location": 96,
            "return": [
                "datawig.iterators.ImputerIterDf"
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ]
            }
        },
        "get_new_iterator_df": {
            "name": "get_new_iterator_df",
            "location": 103,
            "return": [
                "datawig.iterators.ImputerIterDf"
            ],
            "arguments": {
                "df": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "list[int]",
                    "List[int]",
                    "bool"
                ]
            }
        }
    },
    "datawig-master/test/test_simple_imputer.py": {
        "test_simple_imputer_no_string_column_name": {
            "name": "test_simple_imputer_no_string_column_name",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_simple_imputer_label_shift": {
            "name": "test_simple_imputer_label_shift",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "Mapping[str, Any]",
                    "typing.Mapping"
                ]
            }
        },
        "test_label_shift_weight_computation": {
            "name": "test_label_shift_weight_computation",
            "location": 93,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_simple_imputer_real_data_default_args": {
            "name": "test_simple_imputer_real_data_default_args",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "pandas.DataFrame"
                ]
            }
        },
        "test_numeric_or_text_imputer": {
            "name": "test_numeric_or_text_imputer",
            "location": 220,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "str",
                    "tuple[]",
                    "tuple",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_imputer_hpo_numeric": {
            "name": "test_imputer_hpo_numeric",
            "location": 295,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ]
            }
        },
        "test_imputer_hpo_text": {
            "name": "test_imputer_hpo_text",
            "location": 338,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "str",
                    "int",
                    "Callable[[T], List[T]]",
                    "typing.Callable[T, list[T]]",
                    "Optional[int]",
                    "None",
                    "Tuple[bytes, bytes]",
                    "tuple[typing.Union[bytes,bytes]]"
                ]
            }
        },
        "test_hpo_all_input_types": {
            "name": "test_hpo_all_input_types",
            "location": 384,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "bool"
                ],
                "data_frame": [
                    "bool"
                ]
            }
        },
        "test_hpo_defaults": {
            "name": "test_hpo_defaults",
            "location": 481,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "bool",
                    "Mapping[str, str]",
                    "typing.Mapping"
                ],
                "data_frame": [
                    "Callable[[T], List[T]]",
                    "str",
                    "typing.Callable[T, list[T]]",
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "test_hpo_num_evals_empty_hps": {
            "name": "test_hpo_num_evals_empty_hps",
            "location": 515,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "data_frame": [
                    "str"
                ]
            }
        },
        "test_hpo_num_evals_given_hps": {
            "name": "test_hpo_num_evals_given_hps",
            "location": 534,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "data_frame": [
                    "str"
                ]
            }
        },
        "test_hpo_many_columns": {
            "name": "test_hpo_many_columns",
            "location": 554,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [],
                "data_frame": [
                    "str",
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "test_imputer_categorical_heuristic": {
            "name": "test_imputer_categorical_heuristic",
            "location": 583,
            "return": [
                "None"
            ],
            "arguments": {
                "data_frame": [
                    "int",
                    "Callable[[Any], tuple]",
                    "typing.Callable[typing.Any, tuple[]]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "test_imputer_complete": {
            "name": "test_imputer_complete",
            "location": 607,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_default_no_explainable_simple_imputer": {
            "name": "test_default_no_explainable_simple_imputer",
            "location": 658,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_explainable_simple_imputer_unfitted": {
            "name": "test_explainable_simple_imputer_unfitted",
            "location": 666,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_explainable_simple_imputer": {
            "name": "test_explainable_simple_imputer",
            "location": 691,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str",
                    "int",
                    "Mapping[str, str]",
                    "typing.Mapping"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_hpo_runs": {
            "name": "test_hpo_runs",
            "location": 717,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "List[List[Any]]",
                    "str",
                    "list[list[typing.Any]]",
                    "int",
                    "List[cmk.gui.plugins.visuals.utils.Filter]",
                    "list[cmk.gui.plugins.visuals.utils.Filter]"
                ],
                "data_frame": [
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_hpo_single_column_encoder_parameter": {
            "name": "test_hpo_single_column_encoder_parameter",
            "location": 745,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "str"
                ]
            }
        },
        "test_hpo_multiple_columns_only_one_used": {
            "name": "test_hpo_multiple_columns_only_one_used",
            "location": 769,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": []
            }
        },
        "test_hpo_mixed_hps_and_kwargs": {
            "name": "test_hpo_mixed_hps_and_kwargs",
            "location": 795,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "Sequence[str]",
                    "str",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_hpo_mixed_hps_and_kwargs_precedence": {
            "name": "test_hpo_mixed_hps_and_kwargs_precedence",
            "location": 814,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "Sequence[str]",
                    "str",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_hpo_similar_input_col_mixed_types": {
            "name": "test_hpo_similar_input_col_mixed_types",
            "location": 834,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [],
                "data_frame": [
                    "str"
                ]
            }
        },
        "test_hpo_kwargs_only_support": {
            "name": "test_hpo_kwargs_only_support",
            "location": 854,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "bool",
                    "str",
                    "Union[str, List[str]]",
                    "list[str]"
                ],
                "data_frame": [
                    "bool",
                    "str",
                    "Union[str, List[str]]",
                    "list[str]"
                ]
            }
        },
        "test_hpo_numeric_best_pick": {
            "name": "test_hpo_numeric_best_pick",
            "location": 902,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_fit_resumes": {
            "name": "test_fit_resumes",
            "location": 933,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_hpo_explainable": {
            "name": "test_hpo_explainable",
            "location": 956,
            "return": [
                "None"
            ],
            "arguments": {
                "test_dir": [
                    "str"
                ],
                "data_frame": [
                    "str",
                    "Sequence[str]",
                    "typing.Sequence[str]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_hpo_all_input_types.calibration_check": {
            "name": "calibration_check",
            "location": 446,
            "return": [
                "tuple[]",
                "bool",
                "Optional[int]",
                "int",
                "str",
                "Optional[bool]"
            ],
            "arguments": {
                "true": [
                    "str",
                    "List[str]",
                    "Iterable[str]",
                    "dict"
                ],
                "predicted": [
                    "str",
                    "List[str]",
                    "Iterable[str]",
                    "dict"
                ],
                "confidence": [
                    "str",
                    "List[str]",
                    "Iterable[str]",
                    "dict"
                ]
            }
        },
        "test_hpo_all_input_types.coverage_check": {
            "name": "coverage_check",
            "location": 454,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "true": [
                    "str",
                    "bool",
                    "List[Dict[str, str]]",
                    "List[Dict[str, Any]]",
                    "List[str]"
                ],
                "predicted": [
                    "str",
                    "bool",
                    "List[Dict[str, str]]",
                    "List[Dict[str, Any]]",
                    "List[str]"
                ],
                "confidence": [
                    "int",
                    "str",
                    "List[Dict]",
                    "List[int]",
                    "Type['DataclassT']"
                ]
            }
        },
        "test_hpo_kwargs_only_support.assert_val": {
            "name": "assert_val",
            "location": 884,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "col": [
                    "dict",
                    "Dict[bytes, bytes]",
                    "Optional[dict]",
                    "bytes",
                    "bool"
                ],
                "value": [
                    "dict",
                    "Dict[bytes, bytes]",
                    "Optional[dict]",
                    "bytes",
                    "bool"
                ]
            }
        }
    },
    "datawig-master/test/test_utils.py": {
        "test_random_split": {
            "name": "test_random_split",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_normalize_dataframe": {
            "name": "test_normalize_dataframe",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_merge_dicts": {
            "name": "test_merge_dicts",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_random_cartesian_product": {
            "name": "test_random_cartesian_product",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "datawig-master/test/__init__.py": {}
}
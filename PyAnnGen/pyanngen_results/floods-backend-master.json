{
    "floods-backend-master/ccai/config.py": {
        "ConfigSingleton.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "floods-backend-master/ccai/singleton.py": {
        "Singleton.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Singleton.__new__": {
            "name": "__new__",
            "location": 17,
            "return": [
                "str",
                "Callable[[str], T]"
            ],
            "arguments": {
                "cls": [
                    "Type",
                    "bool",
                    "type",
                    "Type[T]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/__init__.py": {},
    "floods-backend-master/ccai/bin/webserver.py": {
        "flood": {
            "name": "flood",
            "location": 44,
            "return": [
                "List[str]",
                "Dict[str, Any]",
                "Dict[str, dict]",
                "str",
                "bool"
            ],
            "arguments": {
                "model": [
                    "str",
                    "List[tuple[Union[int,int,float]]]",
                    "torch.nn.Module",
                    "List[Tuple[int,int,float]]"
                ],
                "address": []
            }
        }
    },
    "floods-backend-master/ccai/climate/climatizer.py": {
        "waterize": {
            "name": "waterize",
            "location": 16,
            "return": [
                "int"
            ],
            "arguments": {
                "coords": [
                    "int",
                    "Dict[int,Any]",
                    "str"
                ],
                "band": [
                    "int",
                    "Dict[int,Any]",
                    "str"
                ]
            }
        },
        "spiralize": {
            "name": "spiralize",
            "location": 30,
            "return": [
                "Tuple[(int, _T0)]"
            ],
            "arguments": {
                "coords": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "distansize": {
            "name": "distansize",
            "location": 79,
            "return": [
                "float"
            ],
            "arguments": {
                "init_lat": [
                    "int",
                    "Dict",
                    "Set",
                    "IO",
                    "IO[str]",
                    "bool"
                ],
                "init_lon": [
                    "int",
                    "Dict",
                    "Set",
                    "IO",
                    "IO[str]",
                    "bool"
                ],
                "coords": [
                    "int",
                    "Dict",
                    "Set",
                    "IO",
                    "IO[str]",
                    "bool"
                ]
            }
        },
        "revolutionize": {
            "name": "revolutionize",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "coords": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "climatize": {
            "name": "climatize",
            "location": 102,
            "return": [
                "Tuple[(Any, Union[(float, str)])]"
            ],
            "arguments": {
                "coords": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "floods-backend-master/ccai/climate/coastal.py": {
        "fetch_coastal": {
            "name": "fetch_coastal",
            "location": 8,
            "return": [
                "str"
            ],
            "arguments": {
                "coordinates": [
                    "str",
                    "List[str]",
                    "Iterable[str]",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/climate/extractor.py": {
        "Extractor.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Extractor.coordinates_from_address": {
            "name": "coordinates_from_address",
            "location": 44,
            "return": [
                "Coordinates"
            ],
            "arguments": {
                "self": [],
                "address": [
                    "str",
                    "Optional[int]",
                    "bool"
                ]
            }
        },
        "Extractor.metadata_for_address": {
            "name": "metadata_for_address",
            "location": 49,
            "return": [
                "ClimateMetadata"
            ],
            "arguments": {
                "self": [],
                "address": [
                    "str",
                    "Sequence[str]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/climate/frequency.py": {
        "shift_frequency": {
            "name": "shift_frequency",
            "location": 10,
            "return": [
                "float"
            ],
            "arguments": {
                "coordinates": [
                    "str",
                    "List[str]",
                    "int",
                    "Dict[str,Any]",
                    "Iterable[str]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/climate/historic.py": {
        "fetch_history": {
            "name": "fetch_history",
            "location": 8,
            "return": [
                "str"
            ],
            "arguments": {
                "coordinates": [
                    "str",
                    "List[str]",
                    "Iterable[str]",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/climate/process_climate.py": {
        "fetch_climate_data": {
            "name": "fetch_climate_data",
            "location": 18,
            "return": [
                "Tuple[(Union[(int, str)], Union[(float, str)], Union[(str, _T1)], Union[(int, str)], str, _T0)]"
            ],
            "arguments": {
                "address": [
                    "str"
                ],
                "RP": [
                    "str",
                    "int",
                    "bytes",
                    "Generator"
                ]
            }
        },
        "fetch_water_level": {
            "name": "fetch_water_level",
            "location": 53,
            "return": [
                "Tuple[(Union[(int, str)], _T1)]"
            ],
            "arguments": {
                "coordinates": [
                    "Tuple[int, int]"
                ],
                "address": [
                    "str",
                    "float",
                    "List[str]",
                    "Optional[opentrons.types.Location]"
                ],
                "band": [
                    "Tuple[int, int]"
                ]
            }
        },
        "fetch_places": {
            "name": "fetch_places",
            "location": 72,
            "return": [
                "str"
            ],
            "arguments": {
                "coordinates": [
                    "dict",
                    "type",
                    "bool",
                    "List[Dict[str, Any]]",
                    "mypy.types.Instance",
                    "List[str]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/climate/__init__.py": {},
    "floods-backend-master/ccai/climate/data/__init__.py": {},
    "floods-backend-master/ccai/image_processing/process_image.py": {
        "create_temp_dir": {
            "name": "create_temp_dir",
            "location": 8,
            "return": [
                "Dict[str,Union[Any,Any,str]]",
                "Dict",
                "int",
                "List",
                "Dict[str,str]",
                "Dict[str,int]",
                "Dict[str,Union[str,Set]]",
                "str",
                "Exception",
                "Mapping[str,Any]"
            ],
            "arguments": {
                "images": [
                    "List[str]",
                    "str",
                    "Tuple[str, str]",
                    "bytes",
                    "IO[str]"
                ],
                "temp_dir": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "fetch_image": {
            "name": "fetch_image",
            "location": 18,
            "return": [
                "str",
                "int",
                "Dict[str,str]"
            ],
            "arguments": {
                "address": [
                    "int",
                    "bool"
                ]
            }
        },
        "encode_image": {
            "name": "encode_image",
            "location": 36,
            "return": [
                "Tuple[(str, str)]"
            ],
            "arguments": {
                "temp_dir": [
                    "str"
                ]
            }
        },
        "decode_image": {
            "name": "decode_image",
            "location": 49,
            "return": [
                "str"
            ],
            "arguments": {
                "temp_dir": [
                    "str",
                    "bool"
                ],
                "path_to_flooded_image": [
                    "str",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "floods-backend-master/ccai/image_processing/streetview.py": {
        "fetch_street_view_image": {
            "name": "fetch_street_view_image",
            "location": 10,
            "return": [
                "bool",
                "Tuple[int, Dict[str, Any]]",
                "List[object]",
                "str"
            ],
            "arguments": {
                "address": [
                    "str"
                ],
                "geocoder_api_key": [
                    "int",
                    "bool"
                ],
                "streetview_api_key": [
                    "bool",
                    "Optional[Exception]",
                    "int",
                    "defaultdict",
                    "Optional[str]",
                    "Optional[bytes]",
                    "Optional[\"AbstractPurpose\"]"
                ]
            }
        }
    },
    "floods-backend-master/ccai/image_processing/watermark.py": {
        "apply_watermark": {
            "name": "apply_watermark",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "input_image_path": [
                    "str"
                ],
                "output_image_path": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        }
    },
    "floods-backend-master/ccai/image_processing/__init__.py": {},
    "floods-backend-master/ccai/nn/process_model.py": {
        "cuda_check": {
            "name": "cuda_check",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "MODEL": [
                    "List[Tuple[int, int, float]]",
                    "Type[T]"
                ]
            }
        },
        "model_validation": {
            "name": "model_validation",
            "location": 30,
            "return": [
                "Dict[str, Any]",
                "Optional[Dict[str, Any]]",
                "str",
                "dict"
            ],
            "arguments": {
                "ROUTE_MODEL": [
                    "str",
                    "Dict[str, str]",
                    "Optional[Dict]",
                    "Optional[dict]"
                ],
                "VALID_MODELS": [
                    "Dict[str, str]",
                    "bool",
                    "Dict[str, int]",
                    "dict",
                    "str"
                ]
            }
        },
        "model_launch": {
            "name": "model_launch",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "MODEL": [
                    "int",
                    "bool"
                ],
                "MODEL_NEW_SIZE": [
                    "int",
                    "bool"
                ],
                "MASK_MODEL": [
                    "int",
                    "bool"
                ],
                "temp_dir": [
                    "int",
                    "bool"
                ],
                "path_to_gsv_image": [
                    "int",
                    "bool"
                ]
            }
        },
        "model_spade": {
            "name": "model_spade",
            "location": 46,
            "return": [
                "str"
            ],
            "arguments": {
                "MODEL": [
                    "bool",
                    "flask.Response",
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "str",
                    "List[dict]"
                ],
                "MODEL_NEW_SIZE": [
                    "int",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "List[AnyStr]"
                ],
                "MASK_MODEL": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "Optional[bool]"
                ],
                "temp_dir": [
                    "Optional[str]",
                    "str",
                    "int"
                ],
                "path_to_gsv_image": [
                    "bool",
                    "str",
                    "Dict[str, Union[str, bool]]"
                ]
            }
        },
        "model_deeplab": {
            "name": "model_deeplab",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "temp_dir": [
                    "str",
                    "Optional[str]"
                ],
                "MASK_MODEL": [
                    "str",
                    "int",
                    "bool",
                    "Optional[str]"
                ],
                "MODEL_NEW_SIZE": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "floods-backend-master/ccai/nn/__init__.py": {},
    "floods-backend-master/ccai/nn/model/data.py": {
        "default_loader": {
            "name": "default_loader",
            "location": 9,
            "return": [
                "Image.Image"
            ],
            "arguments": {
                "path": [
                    "str",
                    "os.PathLike"
                ]
            }
        },
        "default_flist_reader": {
            "name": "default_flist_reader",
            "location": 13,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "flist": [
                    "Callable[[Mapping], T]",
                    "int",
                    "float"
                ]
            }
        },
        "is_image_file": {
            "name": "is_image_file",
            "location": 86,
            "return": [
                "bool"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "make_dataset": {
            "name": "make_dataset",
            "location": 90,
            "return": [
                "list"
            ],
            "arguments": {
                "dir": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "ImageFilelist.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "Optional[str]",
                    "IO"
                ],
                "flist": [
                    "Optional[str]",
                    "IO"
                ],
                "transform": [
                    "None",
                    "Optional[str]",
                    "IO"
                ],
                "flist_reader": [
                    "Optional[str]",
                    "IO"
                ],
                "loader": [
                    "Optional[str]",
                    "IO"
                ]
            }
        },
        "ImageFilelist.__getitem__": {
            "name": "__getitem__",
            "location": 35,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "ImageFilelist.__len__": {
            "name": "__len__",
            "location": 43,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageLabelFilelist.__init__": {
            "name": "__init__",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "str",
                    "Optional[List]"
                ],
                "flist": [
                    "str"
                ],
                "transform": [
                    "None",
                    "Optional[str]",
                    "IO"
                ],
                "flist_reader": [
                    "str"
                ],
                "loader": [
                    "Optional[str]",
                    "IO"
                ]
            }
        },
        "ImageLabelFilelist.__getitem__": {
            "name": "__getitem__",
            "location": 59,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "tuple",
                    "float",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "ImageLabelFilelist.__len__": {
            "name": "__len__",
            "location": 66,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "ImageFolder.__init__": {
            "name": "__init__",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "List[str]",
                    "Optional[str]"
                ],
                "transform": [
                    "None",
                    "str",
                    "int",
                    "bool",
                    "List[str]",
                    "TextIO"
                ],
                "return_paths": [
                    "bool",
                    "str",
                    "int"
                ],
                "loader": [
                    "str",
                    "int",
                    "bool",
                    "List[str]",
                    "TextIO"
                ]
            }
        },
        "ImageFolder.__getitem__": {
            "name": "__getitem__",
            "location": 120,
            "return": [
                "Tuple",
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "Optional[str]",
                    "Callable"
                ]
            }
        },
        "ImageFolder.__len__": {
            "name": "__len__",
            "location": 130,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "floods-backend-master/ccai/nn/model/networks.py": {
        "get_norm_layer": {
            "name": "get_norm_layer",
            "location": 792,
            "return": [
                "Optional[functools.partial]"
            ],
            "arguments": {
                "norm_type": [
                    "str",
                    "Text"
                ]
            }
        },
        "l2normalize": {
            "name": "l2normalize",
            "location": 878,
            "return": [
                "zam_repondeur.models.Lecture",
                "List[str]",
                "Callable[..., None]",
                "str",
                "Callable[[KT], VT]"
            ],
            "arguments": {
                "v": [
                    "int",
                    "str"
                ],
                "eps": [
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "MsImageDis.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "float",
                    "bool"
                ],
                "params": [
                    "str",
                    "Dict[str,Any]",
                    "bool"
                ]
            }
        },
        "MsImageDis._make_net": {
            "name": "_make_net",
            "location": 41,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MsImageDis.forward": {
            "name": "forward",
            "location": 74,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bytes",
                    "T",
                    "List",
                    "str",
                    "Union[numpy.ndarray,pandas.DataFrame]",
                    "None",
                    "Optional[str]"
                ]
            }
        },
        "MsImageDis.calc_dis_loss": {
            "name": "calc_dis_loss",
            "location": 81,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "input_real": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "comet_exp": [
                    "bool",
                    "None",
                    "bytes",
                    "Optional[GraphLogger]",
                    "Callable"
                ],
                "mode": [
                    "str",
                    "Optional[str]",
                    "Sequence[str]",
                    "db.models.Article",
                    "bool"
                ]
            }
        },
        "MsImageDis.calc_gradient_penalty": {
            "name": "calc_gradient_penalty",
            "location": 124,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "real_data": [
                    "Dict[str, Any]",
                    "dict",
                    "IO[bytes]",
                    "str"
                ],
                "fake_data": [
                    "str",
                    "Optional[Dict]",
                    "Dict[str, Any]",
                    "djmoney.contrib.exchange.models.Rate",
                    "bytes"
                ]
            }
        },
        "MsImageDis.calc_gen_loss": {
            "name": "calc_gen_loss",
            "location": 157,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "input_real": [
                    "List[str]",
                    "bool"
                ],
                "comet_exp": [
                    "float",
                    "bool",
                    "None",
                    "str"
                ],
                "mode": [
                    "str",
                    "Sequence[str]",
                    "bool",
                    "float",
                    "Optional[Tuple[str,str]]"
                ]
            }
        },
        "MsImageDis.calc_dis_loss_sr": {
            "name": "calc_dis_loss_sr",
            "location": 177,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_sim": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ],
                "input_real": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "MsImageDis.calc_gen_loss_sr": {
            "name": "calc_gen_loss_sr",
            "location": 201,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ]
            }
        },
        "MultiscaleDiscriminator.__init__": {
            "name": "__init__",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_nc": [
                    "int",
                    "float",
                    "bool"
                ],
                "params": []
            }
        },
        "MultiscaleDiscriminator.singleD_forward": {
            "name": "singleD_forward",
            "location": 253,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "List[int]",
                    "Dict[str, Any]"
                ],
                "input": [
                    "Type",
                    "List[tuple[Union[int,int,float]]]",
                    "models.Model",
                    "Type[T]",
                    "models.cf_recommend_models.ICfRecommendationModel",
                    "List[Tuple[int,int,float]]",
                    "allennlp.models.Model"
                ]
            }
        },
        "MultiscaleDiscriminator.forward": {
            "name": "forward",
            "location": 262,
            "return": [
                "List[list]"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ]
            }
        },
        "MultiscaleDiscriminator.calc_dis_loss": {
            "name": "calc_dis_loss",
            "location": 279,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "input_real": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "comet_exp": [
                    "List[str]",
                    "bool",
                    "None"
                ],
                "mode": [
                    "List[str]",
                    "bool",
                    "None"
                ]
            }
        },
        "MultiscaleDiscriminator.calc_gen_loss": {
            "name": "calc_gen_loss",
            "location": 304,
            "return": [
                "int",
                "float",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "input_real": [
                    "float",
                    "int",
                    "str",
                    "numpy.ndarray",
                    "bool"
                ],
                "comet_exp": [
                    "float",
                    "bool",
                    "None",
                    "str"
                ],
                "mode": [
                    "str",
                    "Optional[str]",
                    "Sequence[str]",
                    "Iterable[str]",
                    "db.models.Article",
                    "bool"
                ]
            }
        },
        "NLayerDiscriminator.__init__": {
            "name": "__init__",
            "location": 345,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_nc": [
                    "int",
                    "float",
                    "None",
                    "torch.Tensor",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "params": []
            }
        },
        "NLayerDiscriminator.forward": {
            "name": "forward",
            "location": 400,
            "return": [
                "str",
                "int",
                "List[dict[str,Any]]",
                "Iterable[str]",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "str",
                    "int",
                    "List[Dict[str,Any]]",
                    "List[dict[str,Any]]"
                ]
            }
        },
        "VAEGen.__init__": {
            "name": "__init__",
            "location": 418,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "str",
                    "int",
                    "float"
                ],
                "params": [
                    "List[str]",
                    "core.models.Grouping",
                    "core.models.Registration",
                    "Sequence[str]"
                ]
            }
        },
        "VAEGen.forward": {
            "name": "forward",
            "location": 440,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "List[Dict]",
                    "List[dict]"
                ]
            }
        },
        "VAEGen.encode": {
            "name": "encode",
            "location": 450,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "int",
                    "torch.Tensor",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "VAEGen.decode": {
            "name": "decode",
            "location": 455,
            "return": [
                "int",
                "str",
                "Dict[int,int]",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "hiddens": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ]
            }
        },
        "StyleEncoder.__init__": {
            "name": "__init__",
            "location": 466,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_downsample": [
                    "int"
                ],
                "input_dim": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "None",
                    "Optional[str]",
                    "T"
                ],
                "dim": [
                    "int",
                    "str",
                    "T",
                    "Optional[str]"
                ],
                "style_dim": [
                    "int"
                ],
                "norm": [
                    "int",
                    "str",
                    "None",
                    "T",
                    "Optional[str]"
                ],
                "activ": [
                    "int",
                    "str",
                    "None",
                    "T",
                    "Optional[str]"
                ],
                "pad_type": [
                    "int",
                    "str",
                    "None",
                    "T",
                    "Optional[str]"
                ]
            }
        },
        "StyleEncoder.forward": {
            "name": "forward",
            "location": 486,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "ContentEncoder.__init__": {
            "name": "__init__",
            "location": 491,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_downsample": [
                    "int",
                    "str",
                    "Tuple[Union[int,int]]",
                    "Union[fonduer.candidates.models.Candidate,fonduer.candidates.models.Mention,fonduer.candidates.models.span_mention.TemporarySpanMention]",
                    "Tuple[int,int]"
                ],
                "n_res": [
                    "int",
                    "float",
                    "str",
                    "Union[int,float]",
                    "torch.Tensor",
                    "Union[str,int]",
                    "bool"
                ],
                "input_dim": [
                    "int",
                    "OrderedDict",
                    "torch.Tensor",
                    "str",
                    "None",
                    "numpy.ndarray",
                    "Optional[str]"
                ],
                "dim": [
                    "int",
                    "OrderedDict",
                    "numpy.ndarray"
                ],
                "norm": [
                    "int",
                    "OrderedDict",
                    "numpy.ndarray"
                ],
                "activ": [
                    "int",
                    "OrderedDict",
                    "numpy.ndarray"
                ],
                "pad_type": [
                    "int",
                    "OrderedDict",
                    "numpy.ndarray"
                ]
            }
        },
        "ContentEncoder.forward": {
            "name": "forward",
            "location": 509,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "Decoder.__init__": {
            "name": "__init__",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_upsample": [
                    "float",
                    "bool",
                    "numpy.ndarray",
                    "int"
                ],
                "n_res": [
                    "str",
                    "List[Tuple[int,int]]",
                    "List[tuple[Union[int,int]]]"
                ],
                "dim": [
                    "float",
                    "int",
                    "str",
                    "Optional[float]"
                ],
                "output_dim": [
                    "int",
                    "Sequence[str]",
                    "numpy.ndarray",
                    "str",
                    "float",
                    "None",
                    "Optional[float]",
                    "Union[int,slice]",
                    "bytes",
                    "Union[str,bytes]"
                ],
                "res_norm": [
                    "Text",
                    "str",
                    "List[Tuple[int,int]]"
                ],
                "activ": [
                    "Text",
                    "str",
                    "float",
                    "int",
                    "Optional[float]"
                ],
                "pad_type": [
                    "Text",
                    "str",
                    "float",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "Decoder.forward": {
            "name": "forward",
            "location": 535,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "ResBlocks.__init__": {
            "name": "__init__",
            "location": 543,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_blocks": [
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "dim": [
                    "Optional[int]",
                    "int",
                    "Type",
                    "str",
                    "None",
                    "deeplearning.ml4pl.models.epoch.Type"
                ],
                "norm": [
                    "Text",
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ],
                "activation": [
                    "Text",
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ],
                "pad_type": [
                    "Text",
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ]
            }
        },
        "ResBlocks.forward": {
            "name": "forward",
            "location": 550,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "MLP.__init__": {
            "name": "__init__",
            "location": 555,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "None",
                    "Optional[int]",
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "output_dim": [
                    "int",
                    "str",
                    "List[str]",
                    "Sequence[int]",
                    "List[list[str]]",
                    "List[List[str]]",
                    "bool"
                ],
                "dim": [
                    "int",
                    "List[int]",
                    "numpy.ndarray",
                    "complex",
                    "None",
                    "taxonomy.db.models.Location",
                    "torch.FloatTensor",
                    "Optional[complex]"
                ],
                "n_blk": [
                    "int",
                    "float",
                    "List",
                    "numpy.random.RandomState"
                ],
                "norm": [
                    "Text",
                    "int",
                    "numpy.ndarray",
                    "taxonomy.db.models.Location",
                    "torch.FloatTensor",
                    "List[int]",
                    "Optional[complex]"
                ],
                "activ": [
                    "Text",
                    "torch.FloatTensor",
                    "numpy.ndarray",
                    "Optional[str]",
                    "taxonomy.db.models.Location",
                    "int",
                    "List[int]"
                ]
            }
        },
        "MLP.forward": {
            "name": "forward",
            "location": 567,
            "return": [
                "bool",
                "str",
                "Mapping",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Variable",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ]
            }
        },
        "ResBlock.__init__": {
            "name": "__init__",
            "location": 575,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ],
                "norm": [
                    "int",
                    "Text"
                ],
                "activation": [
                    "int",
                    "Text"
                ],
                "pad_type": [
                    "int",
                    "Text"
                ]
            }
        },
        "ResBlock.forward": {
            "name": "forward",
            "location": 585,
            "return": [
                "int",
                "str",
                "Optional[Union[str,Any]]",
                "Set[str]",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "Conv2dBlock.__init__": {
            "name": "__init__",
            "location": 593,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "float",
                    "None",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "output_dim": [
                    "int"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "None",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "stride": [
                    "int",
                    "float",
                    "None",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "padding": [
                    "int",
                    "bool",
                    "torch.nn.modules.rnn.GRUCell",
                    "bytes",
                    "float",
                    "pynn.nn.NeuralNetwork",
                    "torch.LongTensor",
                    "torch.utils.data.DataLoader"
                ],
                "norm": [
                    "Text",
                    "bool",
                    "torch.nn.modules.rnn.GRUCell",
                    "bytes",
                    "float",
                    "int",
                    "pynn.nn.NeuralNetwork",
                    "torch.LongTensor",
                    "torch.utils.data.DataLoader"
                ],
                "activation": [
                    "Text",
                    "bool",
                    "float",
                    "int",
                    "Optional[float]"
                ],
                "pad_type": [
                    "Text",
                    "str",
                    "bool",
                    "int",
                    "List[str]"
                ]
            }
        },
        "Conv2dBlock.forward": {
            "name": "forward",
            "location": 656,
            "return": [
                "str",
                "float",
                "int",
                "List[list[int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "LinearBlock.__init__": {
            "name": "__init__",
            "location": 666,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "str",
                    "List[float]",
                    "None",
                    "List[str]",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "output_dim": [
                    "str",
                    "List[float]",
                    "None",
                    "List[str]",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "norm": [
                    "Text",
                    "bytes",
                    "Tuple[int,int]",
                    "List[torch.Tensor]",
                    "int",
                    "List[int]",
                    "float"
                ],
                "activation": [
                    "Text",
                    "str",
                    "int",
                    "bytes",
                    "bool",
                    "Tuple[torch.Tensor]"
                ]
            }
        },
        "LinearBlock.forward": {
            "name": "forward",
            "location": 704,
            "return": [
                "str",
                "List[float]",
                "Optional[Union[str,Any]]",
                "List[int]",
                "Set[str]",
                "Dict",
                "Dict[str,int]",
                "List[list[Any]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "List[numpy.ndarray]",
                    "torch.Tensor",
                    "Union[numpy.ndarray,List[numpy.ndarray]]",
                    "Iterable[Iterable[float]]",
                    "numpy.ndarray"
                ]
            }
        },
        "Vgg19.__init__": {
            "name": "__init__",
            "location": 720,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "requires_grad": [
                    "bool",
                    "int",
                    "str",
                    "torch.Tensor"
                ]
            }
        },
        "Vgg19.forward": {
            "name": "forward",
            "location": 742,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "VGGLoss.__init__": {
            "name": "__init__",
            "location": 754,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VGGLoss.forward": {
            "name": "forward",
            "location": 760,
            "return": [
                "int",
                "float",
                "Callable",
                "str",
                "Set[int]",
                "models.Question"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "y": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "TVLoss.__init__": {
            "name": "__init__",
            "location": 769,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "TVLoss_weight": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "TVLoss.forward": {
            "name": "forward",
            "location": 773,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "List[int]",
                    "int",
                    "numpy.ndarray",
                    "Union[fonduer.parser.models.table.Cell, fonduer.parser.models.sentence.Sentence]"
                ]
            }
        },
        "TVLoss._tensor_size": {
            "name": "_tensor_size",
            "location": 783,
            "return": [
                "float",
                "Optional[int]",
                "Optional[Tuple[int, int]]",
                "numpy.dtype",
                "bool"
            ],
            "arguments": {
                "self": [],
                "t": [
                    "int",
                    "numpy.random.RandomState"
                ]
            }
        },
        "AdaptiveInstanceNorm2d.__init__": {
            "name": "__init__",
            "location": 808,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_features": [
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "eps": [
                    "float",
                    "int",
                    "Union[str,float]"
                ],
                "momentum": [
                    "float",
                    "int",
                    "Union[str,float]"
                ]
            }
        },
        "AdaptiveInstanceNorm2d.forward": {
            "name": "forward",
            "location": 820,
            "return": [
                "str",
                "MutableMapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "AdaptiveInstanceNorm2d.__repr__": {
            "name": "__repr__",
            "location": 844,
            "return": [
                "str",
                "bool",
                "Sequence[str]",
                "List[\"Taxon\"]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayerNorm.__init__": {
            "name": "__init__",
            "location": 849,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_features": [
                    "int",
                    "str",
                    "List[Tuple[int,int]]",
                    "List[tuple[Union[int,int]]]"
                ],
                "eps": [
                    "float",
                    "int",
                    "Union[str,float]"
                ],
                "affine": [
                    "bool",
                    "int",
                    "Union[str,float]",
                    "float"
                ]
            }
        },
        "LayerNorm.forward": {
            "name": "forward",
            "location": 859,
            "return": [
                "str",
                "int",
                "float",
                "Tuple[Union[int,int]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "Tuple[int]",
                    "Union[pandas.Series, numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "SpectralNorm.__init__": {
            "name": "__init__",
            "location": 888,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "int",
                    "Sequence",
                    "str",
                    "bool"
                ],
                "name": [
                    "Text",
                    "str",
                    "Dict[str,Any]",
                    "List[str]",
                    "Dict"
                ],
                "power_iterations": [
                    "int",
                    "Sequence",
                    "bool",
                    "str"
                ]
            }
        },
        "SpectralNorm._update_u_v": {
            "name": "_update_u_v",
            "location": 896,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpectralNorm._made_params": {
            "name": "_made_params",
            "location": 910,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpectralNorm._make_params": {
            "name": "_make_params",
            "location": 919,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpectralNorm.forward": {
            "name": "forward",
            "location": 937,
            "return": [
                "bool",
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "SPADE.__init__": {
            "name": "__init__",
            "location": 943,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "param_free_norm_type": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "Union[Literal,str]"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "bool",
                    "str",
                    "numpy.ndarray",
                    "List[float]"
                ],
                "norm_nc": [
                    "bool",
                    "float",
                    "Optional[numpy.ndarray]",
                    "str",
                    "None"
                ],
                "cond_nc": [
                    "int",
                    "float"
                ]
            }
        },
        "SPADE.forward": {
            "name": "forward",
            "location": 967,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "float",
                    "numpy.array"
                ],
                "segmap": [
                    "int",
                    "Tuple[Union[int,int,int]]",
                    "Tuple[int,int,int]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "SPADEResnetBlock.__init__": {
            "name": "__init__",
            "location": 987,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fin": [
                    "int",
                    "float",
                    "str",
                    "bool"
                ],
                "fout": [
                    "int",
                    "float",
                    "str",
                    "bool"
                ],
                "cond_nc": [
                    "int",
                    "None",
                    "bool",
                    "Optional[int]"
                ],
                "spade_use_spectral_norm": [
                    "str",
                    "List[str]",
                    "torch.Tensor",
                    "bool",
                    "None",
                    "int",
                    "Optional[bool]"
                ],
                "spade_param_free_norm": [
                    "int",
                    "float",
                    "bool"
                ],
                "spade_kernel_size": [
                    "Tuple[int]",
                    "int",
                    "str",
                    "Optional[int]",
                    "float",
                    "None",
                    "torch.Tensor"
                ]
            }
        },
        "SPADEResnetBlock.forward": {
            "name": "forward",
            "location": 1022,
            "return": [
                "str",
                "int",
                "Optional[Union[str,Any]]",
                "Set[str]",
                "float",
                "Dict",
                "List[Union[bytes,str,int]]",
                "List[str]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ],
                "seg": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "SPADEResnetBlock.shortcut": {
            "name": "shortcut",
            "location": 1031,
            "return": [
                "Dict[str,Any]",
                "float",
                "List[Dict[str,Any]]",
                "List[list[T]]",
                "int",
                "str",
                "List[T]",
                "jumeaux.models.DumpAddOnPayload",
                "List[float]",
                "bool",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "List[list[T]]",
                    "List[T]",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "List[List[T]]"
                ],
                "seg": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "numpy.array"
                ]
            }
        },
        "SPADEResnetBlock.activation": {
            "name": "activation",
            "location": 1038,
            "return": [
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ]
            }
        },
        "SPADEResnetBlock.__str__": {
            "name": "__str__",
            "location": 1041,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpadeDecoder.__init__": {
            "name": "__init__",
            "location": 1046,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "bool"
                ],
                "cond_nc": [],
                "spade_n_up": [
                    "int",
                    "float",
                    "str",
                    "Optional[Union[int,slice]]",
                    "Union[int,float]",
                    "numpy.ndarray"
                ],
                "spade_use_spectral_norm": [],
                "spade_param_free_norm": [],
                "spade_kernel_size": [],
                "fullspade": [
                    "bool",
                    "float"
                ]
            }
        },
        "SpadeDecoder._apply": {
            "name": "_apply",
            "location": 1135,
            "return": [
                "SpadeDecoder"
            ],
            "arguments": {
                "self": [
                    "_TSpadeDecoder@@SpadeDecoder@@"
                ],
                "fn": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ]
            }
        },
        "SpadeDecoder.forward": {
            "name": "forward",
            "location": 1146,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ],
                "cond": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "abilian.core.models.subjects.Principal"
                ]
            }
        },
        "SpadeDecoder.__str__": {
            "name": "__str__",
            "location": 1162,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpadeGen.__init__": {
            "name": "__init__",
            "location": 1167,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "str"
                ],
                "params": [
                    "str",
                    "List[str]",
                    "core.models.Grouping",
                    "core.models.Registration",
                    "bool",
                    "Dict"
                ]
            }
        },
        "SpadeGen.forward": {
            "name": "forward",
            "location": 1204,
            "return": [
                "str",
                "int",
                "Dict",
                "List[int]",
                "Dict[str,dict[str,Any]]",
                "bool",
                "Dict[int,Type]"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "bytes",
                    "Callable[[Dict],Any]",
                    "int",
                    "Callable[dict,Any]"
                ],
                "masks": [
                    "bool",
                    "str",
                    "Dict",
                    "Optional[str]",
                    "None",
                    "int"
                ],
                "encoder_name": [
                    "str",
                    "Sequence[str]",
                    "int",
                    "None",
                    "Set[str]",
                    "Optional[str]",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "bool"
                ]
            }
        },
        "SpadeGen.encode": {
            "name": "encode",
            "location": 1210,
            "return": [
                "Optional[str]",
                "None",
                "Optional[int]",
                "str",
                "Optional[List[Any]]",
                "Dict[str,dict[str,Any]]",
                "Dict",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "bool",
                    "IO",
                    "Dict[str,str]"
                ],
                "encoder_name": [
                    "str",
                    "int",
                    "None",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "SpadeGen.decode": {
            "name": "decode",
            "location": 1221,
            "return": [
                "str",
                "Optional[str]",
                "None",
                "purplship.core.models.RateDetails",
                "int",
                "List[str]",
                "Dict[bytes,str]",
                "Dict[str,list]"
            ],
            "arguments": {
                "self": [],
                "content": [
                    "str",
                    "List[str]",
                    "Dict",
                    "tracim.models.data.Content"
                ],
                "mask": [
                    "str",
                    "List[str]",
                    "Dict",
                    "tracim.models.data.Content"
                ],
                "encoder_name": [
                    "str",
                    "Optional[str]",
                    "Dict[str,Any]",
                    "None"
                ]
            }
        },
        "SpadeTestGen.__init__": {
            "name": "__init__",
            "location": 1234,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "Callable",
                    "None",
                    "Dict",
                    "bool",
                    "Optional[int]"
                ],
                "size": [
                    "int",
                    "float",
                    "bytes",
                    "numpy.ndarray",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "None",
                    "bool",
                    "Tuple[Union[int,int,int]]",
                    "Optional[int]",
                    "Tuple[int,int,int]"
                ],
                "params": [
                    "Tuple[Union[str,str,str]]",
                    "str",
                    "Dict",
                    "Tuple[str,str,str]",
                    "bool",
                    "Optional[int]",
                    "Optional[ShippingInfo]",
                    "int"
                ]
            }
        },
        "SpadeTestGen.forward": {
            "name": "forward",
            "location": 1257,
            "return": [
                "int",
                "Tuple[Union[Literal,Literal,Literal,Literal,Literal,Literal,Literal,Literal,Literal,Literal,Literal,Literal,Literal]]",
                "Callable",
                "Type",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ],
                "cond": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ]
            }
        },
        "SpadeAdaINGen.__init__": {
            "name": "__init__",
            "location": 1263,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "Callable",
                    "None",
                    "Dict",
                    "bool",
                    "Optional[int]"
                ],
                "size": [
                    "int",
                    "Callable",
                    "None",
                    "Dict",
                    "bool",
                    "Optional[int]"
                ],
                "batch_size": [
                    "int",
                    "None",
                    "bool",
                    "Tuple[Union[int,int,int]]",
                    "Optional[int]",
                    "Tuple[int,int,int]"
                ],
                "params": [
                    "str",
                    "Tuple[Union[str,str,str]]",
                    "Dict[str,Any]",
                    "Tuple[str,str,str]",
                    "Optional[ShippingInfo]"
                ]
            }
        },
        "SpadeAdaINGen.forward": {
            "name": "forward",
            "location": 1302,
            "return": [
                "int",
                "float",
                "Callable",
                "models.Question",
                "List[int]",
                "str",
                "Dict[str,Any]"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ],
                "cond": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ],
                "style_im": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ]
            }
        },
        "SpadeAdaINGen.assign_adain_params": {
            "name": "assign_adain_params",
            "location": 1309,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "adain_params": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "str"
                ],
                "model": [
                    "List[str]",
                    "str",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "SpadeAdaINGen.get_num_adain_params": {
            "name": "get_num_adain_params",
            "location": 1320,
            "return": [
                "int",
                "str",
                "bool",
                "Dict[str,Any]",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "bool",
                    "float",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "SpadeAdaINGen.get_adain_param": {
            "name": "get_adain_param",
            "location": 1328,
            "return": [
                "str",
                "bool",
                "Dict[str,str]",
                "List[tuple[Union[str,str,Any]]]",
                "Dict[str,Union[dict,Any]]",
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "style": [
                    "str",
                    "bool"
                ]
            }
        },
        "SpadeGenBasic.__init__": {
            "name": "__init__",
            "location": 1338,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "List",
                    "None",
                    "Optional[ShippingRateInputType]",
                    "bool"
                ],
                "size": [
                    "int",
                    "Callable",
                    "None",
                    "Dict",
                    "bool",
                    "Optional[int]"
                ],
                "batch_size": [
                    "int",
                    "None",
                    "bool",
                    "Tuple[Union[int,int,int]]",
                    "Optional[int]",
                    "Tuple[int,int,int]"
                ],
                "params": [
                    "str",
                    "bool",
                    "Type[Model]"
                ]
            }
        },
        "SpadeGenBasic.forward": {
            "name": "forward",
            "location": 1361,
            "return": [
                "int",
                "Dict[str,Any]",
                "Callable",
                "Pattern",
                "models.Question",
                "float",
                "str",
                "List"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "bool",
                    "str",
                    "float",
                    "Sequence[int]",
                    "int"
                ],
                "cond": [
                    "str",
                    "bool",
                    "Container",
                    "Container[T]",
                    "Union[int,numpy.ndarray]"
                ]
            }
        },
        "FullSpadeGen.__init__": {
            "name": "__init__",
            "location": 1368,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "Callable",
                    "None",
                    "Dict",
                    "bool",
                    "Optional[int]"
                ],
                "size": [
                    "int",
                    "float",
                    "bytes",
                    "numpy.ndarray",
                    "List[Any]",
                    "Optional[List[Any]]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "None",
                    "bool",
                    "Tuple[Union[int,int,int]]",
                    "Optional[int]",
                    "Tuple[int,int,int]"
                ],
                "params": [
                    "Tuple[Union[str,str,str]]",
                    "str",
                    "Dict",
                    "Tuple[str,str,str]",
                    "bool",
                    "Optional[int]",
                    "Optional[ShippingInfo]",
                    "int"
                ]
            }
        },
        "FullSpadeGen.forward": {
            "name": "forward",
            "location": 1391,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ],
                "cond": [
                    "int",
                    "Callable",
                    "str",
                    "models.Question"
                ]
            }
        }
    },
    "floods-backend-master/ccai/nn/model/newtorks.py": {
        "get_norm_layer": {
            "name": "get_norm_layer",
            "location": 773,
            "return": [
                "Optional[functools.partial]"
            ],
            "arguments": {
                "norm_type": [
                    "str",
                    "Text"
                ]
            }
        },
        "l2normalize": {
            "name": "l2normalize",
            "location": 859,
            "return": [
                "zam_repondeur.models.Lecture",
                "List[str]",
                "Callable[..., None]",
                "str",
                "Callable[[KT], VT]"
            ],
            "arguments": {
                "v": [
                    "int",
                    "str"
                ],
                "eps": [
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "MsImageDis.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "bool",
                    "float"
                ],
                "params": [
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "MsImageDis._make_net": {
            "name": "_make_net",
            "location": 41,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MsImageDis.forward": {
            "name": "forward",
            "location": 74,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "T",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "bytes",
                    "list",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "MsImageDis.calc_dis_loss": {
            "name": "calc_dis_loss",
            "location": 81,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "input_real": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "comet_exp": [
                    "None",
                    "bool",
                    "Optional[GraphLogger]",
                    "bytes",
                    "Callable"
                ],
                "mode": [
                    "Optional[str]",
                    "Sequence[str]",
                    "db.models.Article",
                    "bool"
                ]
            }
        },
        "MsImageDis.calc_gradient_penalty": {
            "name": "calc_gradient_penalty",
            "location": 124,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "real_data": [
                    "Dict[str, Any]",
                    "dict",
                    "IO[bytes]",
                    "str"
                ],
                "fake_data": [
                    "str",
                    "Optional[Dict]",
                    "Dict[str, Any]",
                    "djmoney.contrib.exchange.models.Rate",
                    "bytes"
                ]
            }
        },
        "MsImageDis.calc_gen_loss": {
            "name": "calc_gen_loss",
            "location": 157,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "input_real": [
                    "List[str]",
                    "bool"
                ],
                "comet_exp": [
                    "None",
                    "float",
                    "bool",
                    "str"
                ],
                "mode": [
                    "Sequence[str]",
                    "bool",
                    "float",
                    "str",
                    "Optional[Tuple[str, str]]"
                ]
            }
        },
        "MsImageDis.calc_dis_loss_sr": {
            "name": "calc_dis_loss_sr",
            "location": 177,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_sim": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ],
                "input_real": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "MsImageDis.calc_gen_loss_sr": {
            "name": "calc_gen_loss_sr",
            "location": 201,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "MultiscaleDiscriminator.__init__": {
            "name": "__init__",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_nc": [
                    "int",
                    "bool",
                    "float"
                ],
                "params": []
            }
        },
        "MultiscaleDiscriminator.singleD_forward": {
            "name": "singleD_forward",
            "location": 253,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "List[int]",
                    "Dict[str, Any]"
                ],
                "input": [
                    "models.Model",
                    "Type[T]",
                    "models.cf_recommend_models.ICfRecommendationModel",
                    "List[Tuple[int, int, float]]",
                    "allennlp.models.Model"
                ]
            }
        },
        "MultiscaleDiscriminator.forward": {
            "name": "forward",
            "location": 262,
            "return": [
                "List[list]"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "MultiscaleDiscriminator.calc_dis_loss": {
            "name": "calc_dis_loss",
            "location": 279,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "input_real": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "comet_exp": [
                    "None",
                    "List[str]",
                    "bool"
                ],
                "mode": [
                    "None",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "MultiscaleDiscriminator.calc_gen_loss": {
            "name": "calc_gen_loss",
            "location": 304,
            "return": [
                "int",
                "float",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_fake": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "input_real": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ],
                "comet_exp": [
                    "None",
                    "float",
                    "bool",
                    "str"
                ],
                "mode": [
                    "Optional[str]",
                    "Sequence[str]",
                    "Iterable[str]",
                    "db.models.Article",
                    "bool"
                ]
            }
        },
        "NLayerDiscriminator.__init__": {
            "name": "__init__",
            "location": 345,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_nc": [
                    "int",
                    "torch.Tensor",
                    "float",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "params": []
            }
        },
        "NLayerDiscriminator.forward": {
            "name": "forward",
            "location": 400,
            "return": [
                "str",
                "int",
                "Iterable[str]",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "str",
                    "int",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "VAEGen.__init__": {
            "name": "__init__",
            "location": 418,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "str",
                    "int",
                    "float"
                ],
                "params": [
                    "List[str]",
                    "core.models.Grouping",
                    "core.models.Registration",
                    "Sequence[str]"
                ]
            }
        },
        "VAEGen.forward": {
            "name": "forward",
            "location": 440,
            "return": [
                "Tuple[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "List[Dict]"
                ]
            }
        },
        "VAEGen.encode": {
            "name": "encode",
            "location": 450,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "torch.Tensor",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "VAEGen.decode": {
            "name": "decode",
            "location": 455,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "hiddens": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "StyleEncoder.__init__": {
            "name": "__init__",
            "location": 466,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_downsample": [
                    "int"
                ],
                "input_dim": [
                    "int",
                    "numpy.ndarray",
                    "Optional[str]",
                    "T"
                ],
                "dim": [
                    "int",
                    "str",
                    "T",
                    "Optional[str]"
                ],
                "style_dim": [
                    "int"
                ],
                "norm": [
                    "int",
                    "str",
                    "T",
                    "Optional[str]"
                ],
                "activ": [
                    "int",
                    "str",
                    "T",
                    "Optional[str]"
                ],
                "pad_type": [
                    "int",
                    "str",
                    "T",
                    "Optional[str]"
                ]
            }
        },
        "StyleEncoder.forward": {
            "name": "forward",
            "location": 486,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "ContentEncoder.__init__": {
            "name": "__init__",
            "location": 491,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_downsample": [
                    "int",
                    "str",
                    "Union[fonduer.candidates.models.Candidate, fonduer.candidates.models.Mention, fonduer.candidates.models.span_mention.TemporarySpanMention]",
                    "Tuple[int, int]"
                ],
                "n_res": [
                    "int",
                    "Union[int, float]",
                    "torch.Tensor",
                    "Union[str, int]",
                    "bool"
                ],
                "input_dim": [
                    "int",
                    "torch.Tensor",
                    "OrderedDict",
                    "numpy.ndarray",
                    "Optional[str]"
                ],
                "dim": [
                    "int",
                    "numpy.ndarray",
                    "OrderedDict"
                ],
                "norm": [
                    "int",
                    "numpy.ndarray",
                    "OrderedDict"
                ],
                "activ": [
                    "int",
                    "numpy.ndarray",
                    "OrderedDict"
                ],
                "pad_type": [
                    "int",
                    "numpy.ndarray",
                    "OrderedDict"
                ]
            }
        },
        "ContentEncoder.forward": {
            "name": "forward",
            "location": 509,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "Decoder.__init__": {
            "name": "__init__",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_upsample": [
                    "float",
                    "bool",
                    "numpy.ndarray",
                    "int"
                ],
                "n_res": [
                    "str",
                    "List[Tuple[int, int]]"
                ],
                "dim": [
                    "str",
                    "float",
                    "int",
                    "Optional[float]"
                ],
                "output_dim": [
                    "int",
                    "numpy.ndarray",
                    "Sequence[str]",
                    "Optional[float]",
                    "Union[int, slice]",
                    "str",
                    "Union[str, bytes]"
                ],
                "res_norm": [
                    "Text",
                    "str",
                    "List[Tuple[int,int]]"
                ],
                "activ": [
                    "Text",
                    "str",
                    "float",
                    "int",
                    "Optional[float]"
                ],
                "pad_type": [
                    "Text",
                    "str",
                    "float",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "Decoder.forward": {
            "name": "forward",
            "location": 535,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "ResBlocks.__init__": {
            "name": "__init__",
            "location": 543,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_blocks": [
                    "int",
                    "Optional[int]"
                ],
                "dim": [
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ],
                "norm": [
                    "Text",
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ],
                "activation": [
                    "Text",
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ],
                "pad_type": [
                    "Text",
                    "Optional[int]",
                    "Type",
                    "deeplearning.ml4pl.models.epoch.Type",
                    "str"
                ]
            }
        },
        "ResBlocks.forward": {
            "name": "forward",
            "location": 550,
            "return": [
                "str",
                "int",
                "bool",
                "Dict[str, Tuple[int, int]]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "MLP.__init__": {
            "name": "__init__",
            "location": 555,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "Optional[int]",
                    "torch.Tensor",
                    "numpy.ndarray"
                ],
                "output_dim": [
                    "int",
                    "str",
                    "List[str]",
                    "List[List[str]]",
                    "Sequence[int]",
                    "bool"
                ],
                "dim": [
                    "int",
                    "numpy.ndarray",
                    "taxonomy.db.models.Location",
                    "torch.FloatTensor",
                    "List[int]",
                    "Optional[complex]"
                ],
                "n_blk": [
                    "int",
                    "float",
                    "list",
                    "numpy.random.RandomState"
                ],
                "norm": [
                    "Text",
                    "int",
                    "numpy.ndarray",
                    "taxonomy.db.models.Location",
                    "torch.FloatTensor",
                    "List[int]",
                    "Optional[complex]"
                ],
                "activ": [
                    "Text",
                    "torch.FloatTensor",
                    "numpy.ndarray",
                    "Optional[str]",
                    "taxonomy.db.models.Location",
                    "int",
                    "List[int]"
                ]
            }
        },
        "MLP.forward": {
            "name": "forward",
            "location": 567,
            "return": [
                "bool",
                "str",
                "Mapping",
                "int"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Variable",
                    "numpy.ndarray",
                    "str",
                    "bool"
                ]
            }
        },
        "ResBlock.__init__": {
            "name": "__init__",
            "location": 575,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int"
                ],
                "norm": [
                    "int",
                    "Text"
                ],
                "activation": [
                    "int",
                    "Text"
                ],
                "pad_type": [
                    "int",
                    "Text"
                ]
            }
        },
        "ResBlock.forward": {
            "name": "forward",
            "location": 585,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "Conv2dBlock.__init__": {
            "name": "__init__",
            "location": 593,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "float",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "output_dim": [
                    "int"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "stride": [
                    "int",
                    "float",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "padding": [
                    "int",
                    "bool",
                    "torch.nn.modules.rnn.GRUCell",
                    "bytes",
                    "float",
                    "pynn.nn.NeuralNetwork",
                    "torch.LongTensor",
                    "torch.utils.data.DataLoader"
                ],
                "norm": [
                    "Text",
                    "bool",
                    "torch.nn.modules.rnn.GRUCell",
                    "bytes",
                    "float",
                    "int",
                    "pynn.nn.NeuralNetwork",
                    "torch.LongTensor",
                    "torch.utils.data.DataLoader"
                ],
                "activation": [
                    "Text",
                    "bool",
                    "float",
                    "int",
                    "Optional[float]"
                ],
                "pad_type": [
                    "Text",
                    "str",
                    "bool",
                    "int",
                    "List[str]"
                ]
            }
        },
        "Conv2dBlock.forward": {
            "name": "forward",
            "location": 656,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "LinearBlock.__init__": {
            "name": "__init__",
            "location": 666,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "str",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray",
                    "List[float]",
                    "List[str]"
                ],
                "output_dim": [
                    "str",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray",
                    "List[float]",
                    "List[str]"
                ],
                "norm": [
                    "Text",
                    "bytes",
                    "Tuple[int,int]",
                    "List[torch.Tensor]",
                    "int",
                    "List[int]",
                    "float"
                ],
                "activation": [
                    "Text",
                    "str",
                    "int",
                    "bytes",
                    "bool",
                    "Tuple[torch.Tensor]"
                ]
            }
        },
        "LinearBlock.forward": {
            "name": "forward",
            "location": 704,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "Union[numpy.ndarray, List[numpy.ndarray]]",
                    "Iterable[Iterable[float]]",
                    "numpy.ndarray"
                ]
            }
        },
        "Vgg19.__init__": {
            "name": "__init__",
            "location": 720,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "requires_grad": [
                    "bool",
                    "int",
                    "str",
                    "torch.Tensor"
                ]
            }
        },
        "Vgg19.forward": {
            "name": "forward",
            "location": 742,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "VGGLoss.__init__": {
            "name": "__init__",
            "location": 754,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VGGLoss.forward": {
            "name": "forward",
            "location": 760,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ],
                "y": [
                    "numpy.ndarray",
                    "int",
                    "float"
                ]
            }
        },
        "AdaptiveInstanceNorm2d.__init__": {
            "name": "__init__",
            "location": 789,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_features": [
                    "int",
                    "Optional[int]"
                ],
                "eps": [
                    "float",
                    "int",
                    "Union[str,float]"
                ],
                "momentum": [
                    "float",
                    "int",
                    "Union[str,float]"
                ]
            }
        },
        "AdaptiveInstanceNorm2d.forward": {
            "name": "forward",
            "location": 801,
            "return": [
                "str",
                "MutableMapping[str, Any]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "AdaptiveInstanceNorm2d.__repr__": {
            "name": "__repr__",
            "location": 825,
            "return": [
                "str",
                "bool",
                "Sequence[str]",
                "List[\"Taxon\"]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LayerNorm.__init__": {
            "name": "__init__",
            "location": 830,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_features": [
                    "int",
                    "str",
                    "List[Tuple[int, int]]"
                ],
                "eps": [
                    "float",
                    "int",
                    "Union[str,float]"
                ],
                "affine": [
                    "bool",
                    "int",
                    "Union[str,float]",
                    "float"
                ]
            }
        },
        "LayerNorm.forward": {
            "name": "forward",
            "location": 840,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "torch.Tensor",
                    "Tuple[int]",
                    "Union[pandas.Series, numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "SpectralNorm.__init__": {
            "name": "__init__",
            "location": 869,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "module": [
                    "int",
                    "Sequence",
                    "bool",
                    "str"
                ],
                "name": [
                    "Text",
                    "str",
                    "Dict[str,Any]",
                    "List[str]",
                    "Dict"
                ],
                "power_iterations": [
                    "int",
                    "Sequence",
                    "bool",
                    "str"
                ]
            }
        },
        "SpectralNorm._update_u_v": {
            "name": "_update_u_v",
            "location": 877,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpectralNorm._made_params": {
            "name": "_made_params",
            "location": 891,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpectralNorm._make_params": {
            "name": "_make_params",
            "location": 900,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpectralNorm.forward": {
            "name": "forward",
            "location": 918,
            "return": [
                "bool",
                "int",
                "str",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "SPADE.__init__": {
            "name": "__init__",
            "location": 924,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "param_free_norm_type": [
                    "str",
                    "Optional[str]",
                    "int",
                    "Union[Literal, str]"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "bool",
                    "str",
                    "numpy.ndarray",
                    "List[float]"
                ],
                "norm_nc": [
                    "bool",
                    "Optional[numpy.ndarray]",
                    "float",
                    "str"
                ],
                "cond_nc": [
                    "int",
                    "float"
                ]
            }
        },
        "SPADE.forward": {
            "name": "forward",
            "location": 948,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "float",
                    "numpy.array"
                ],
                "segmap": [
                    "int",
                    "Tuple[int, int, int]",
                    "numpy.ndarray",
                    "torch.Tensor"
                ]
            }
        },
        "SPADEResnetBlock.__init__": {
            "name": "__init__",
            "location": 968,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fin": [
                    "int",
                    "float",
                    "bool",
                    "str"
                ],
                "fout": [
                    "int",
                    "float",
                    "bool",
                    "str"
                ],
                "cond_nc": [
                    "int",
                    "bool",
                    "Optional[int]"
                ],
                "spade_use_spectral_norm": [
                    "torch.Tensor",
                    "str",
                    "List[str]",
                    "bool",
                    "int",
                    "Optional[bool]"
                ],
                "spade_param_free_norm": [
                    "int",
                    "float",
                    "bool"
                ],
                "spade_kernel_size": [
                    "Tuple[int]",
                    "Optional[int]",
                    "str",
                    "float",
                    "torch.Tensor",
                    "int"
                ]
            }
        },
        "SPADEResnetBlock.forward": {
            "name": "forward",
            "location": 1003,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float",
                    "torch.Tensor"
                ],
                "seg": [
                    "numpy.ndarray",
                    "float",
                    "torch.Tensor"
                ]
            }
        },
        "SPADEResnetBlock.shortcut": {
            "name": "shortcut",
            "location": 1012,
            "return": [
                "Dict[str, Any]",
                "List[Dict[str, Any]]",
                "str",
                "jumeaux.models.DumpAddOnPayload",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "List[List[T]]",
                    "List[T]"
                ],
                "seg": [
                    "numpy.ndarray",
                    "float",
                    "int",
                    "numpy.array"
                ]
            }
        },
        "SPADEResnetBlock.activation": {
            "name": "activation",
            "location": 1019,
            "return": [
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "SPADEResnetBlock.__str__": {
            "name": "__str__",
            "location": 1022,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpadeDecoder.__init__": {
            "name": "__init__",
            "location": 1027,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "latent_dim": [
                    "bool"
                ],
                "cond_nc": [],
                "spade_n_up": [
                    "str",
                    "Optional[Union[int, slice]]",
                    "Union[int, float]",
                    "float",
                    "numpy.ndarray"
                ],
                "spade_use_spectral_norm": [],
                "spade_param_free_norm": [],
                "spade_kernel_size": []
            }
        },
        "SpadeDecoder._apply": {
            "name": "_apply",
            "location": 1106,
            "return": [
                "SpadeDecoder"
            ],
            "arguments": {
                "self": [
                    "_TSpadeDecoder@@SpadeDecoder@@"
                ],
                "fn": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "SpadeDecoder.forward": {
            "name": "forward",
            "location": 1117,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ],
                "cond": [
                    "float",
                    "abilian.core.models.subjects.Principal",
                    "torch.Tensor",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "SpadeDecoder.__str__": {
            "name": "__str__",
            "location": 1133,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpadeGen.__init__": {
            "name": "__init__",
            "location": 1138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "str"
                ],
                "params": [
                    "str",
                    "core.models.Grouping",
                    "core.models.Registration",
                    "bool",
                    "List[str]",
                    "dict"
                ]
            }
        },
        "SpadeGen.forward": {
            "name": "forward",
            "location": 1175,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "Callable[[Dict], Any]",
                    "bytes",
                    "int"
                ],
                "masks": [
                    "bool",
                    "Optional[str]",
                    "int",
                    "str",
                    "dict"
                ],
                "encoder_name": [
                    "str",
                    "Sequence[str]",
                    "Optional[str]",
                    "int",
                    "Optional[List[Any]]",
                    "bool",
                    "Set[str]"
                ]
            }
        },
        "SpadeGen.encode": {
            "name": "encode",
            "location": 1181,
            "return": [
                "None",
                "Optional[str]",
                "Optional[int]",
                "Optional[List[Any]]",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "images": [
                    "str",
                    "bool",
                    "IO",
                    "Dict[str, str]"
                ],
                "encoder_name": [
                    "str",
                    "Optional[str]",
                    "int",
                    "bool"
                ]
            }
        },
        "SpadeGen.decode": {
            "name": "decode",
            "location": 1192,
            "return": [
                "None",
                "str",
                "Optional[str]",
                "purplship.core.models.RateDetails"
            ],
            "arguments": {
                "self": [],
                "content": [
                    "str",
                    "List[str]",
                    "tracim.models.data.Content",
                    "dict"
                ],
                "mask": [
                    "str",
                    "List[str]",
                    "tracim.models.data.Content",
                    "dict"
                ],
                "encoder_name": [
                    "Optional[str]",
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "SpadeTestGen.__init__": {
            "name": "__init__",
            "location": 1205,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Callable",
                    "dict"
                ],
                "size": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "bytes",
                    "Optional[List[Any]]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Tuple[int, int, int]"
                ],
                "params": [
                    "dict",
                    "Tuple[str, str, str]",
                    "bool",
                    "str",
                    "Optional[int]",
                    "Optional[\"ShippingInfo\"]",
                    "int"
                ]
            }
        },
        "SpadeTestGen.forward": {
            "name": "forward",
            "location": 1228,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "cond": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "SpadeAdaINGen.__init__": {
            "name": "__init__",
            "location": 1233,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Callable",
                    "dict"
                ],
                "size": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Callable",
                    "dict"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Tuple[int, int, int]"
                ],
                "params": [
                    "str",
                    "Dict[str, Any]",
                    "Tuple[str, str, str]",
                    "Optional[\"ShippingInfo\"]"
                ]
            }
        },
        "SpadeAdaINGen.forward": {
            "name": "forward",
            "location": 1272,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ],
                "cond": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ],
                "style_im": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "SpadeAdaINGen.assign_adain_params": {
            "name": "assign_adain_params",
            "location": 1279,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "adain_params": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "str"
                ],
                "model": [
                    "List[str]",
                    "str",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "SpadeAdaINGen.get_num_adain_params": {
            "name": "get_num_adain_params",
            "location": 1290,
            "return": [
                "int",
                "str",
                "bool",
                "Dict[str,Any]",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "bool",
                    "float",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "SpadeAdaINGen.get_adain_param": {
            "name": "get_adain_param",
            "location": 1298,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "style": [
                    "str",
                    "bool"
                ]
            }
        },
        "SpadeAdaINGenII.__init__": {
            "name": "__init__",
            "location": 1308,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "Optional[\"ShippingRateInputType\"]",
                    "bool",
                    "list"
                ],
                "size": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Callable",
                    "dict"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Tuple[int, int, int]"
                ],
                "params": [
                    "str",
                    "Dict[str, Any]",
                    "Tuple[str, str, str]",
                    "Optional[\"ShippingInfo\"]"
                ]
            }
        },
        "SpadeAdaINGenII.forward": {
            "name": "forward",
            "location": 1344,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]"
                ],
                "cond": [
                    "str",
                    "bool",
                    "Container[T]",
                    "Union[int, numpy.ndarray]"
                ],
                "style_im": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "SpadeAdaINGenII.assign_adain_params": {
            "name": "assign_adain_params",
            "location": 1353,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "adain_params": [
                    "int",
                    "numpy.ndarray",
                    "torch.Tensor",
                    "str"
                ],
                "model": [
                    "List[str]",
                    "str",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "SpadeAdaINGenII.get_num_adain_params": {
            "name": "get_num_adain_params",
            "location": 1364,
            "return": [
                "int",
                "str",
                "bool",
                "Dict[str,Any]",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "bool",
                    "float",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "SpadeAdaINGenII.get_adain_param": {
            "name": "get_adain_param",
            "location": 1372,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "style": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "floods-backend-master/ccai/nn/model/resnet.py": {
        "conv3x3": {
            "name": "conv3x3",
            "location": 17,
            "return": [
                "bool"
            ],
            "arguments": {
                "in_planes": [
                    "int",
                    "float",
                    "str",
                    "bool"
                ],
                "out_planes": [
                    "int",
                    "float",
                    "str",
                    "bool"
                ],
                "stride": [
                    "int",
                    "bool",
                    "float",
                    "str"
                ],
                "dilation": [
                    "int",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "resnet18": {
            "name": "resnet18",
            "location": 264,
            "return": [
                "ResNet"
            ],
            "arguments": {
                "pretrained": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "resnet34": {
            "name": "resnet34",
            "location": 284,
            "return": [
                "ResNet"
            ],
            "arguments": {
                "pretrained": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "resnet50": {
            "name": "resnet50",
            "location": 304,
            "return": [
                "ResNet"
            ],
            "arguments": {
                "pretrained": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "resnet101": {
            "name": "resnet101",
            "location": 324,
            "return": [
                "ResNet"
            ],
            "arguments": {
                "pretrained": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "resnet152": {
            "name": "resnet152",
            "location": 344,
            "return": [
                "ResNet"
            ],
            "arguments": {
                "pretrained": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "BasicBlock.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inplanes": [
                    "int",
                    "float",
                    "bool"
                ],
                "planes": [
                    "int",
                    "float",
                    "bool"
                ],
                "stride": [
                    "int",
                    "bool",
                    "float"
                ],
                "downsample": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ],
                "dilation": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "BasicBlock.forward": {
            "name": "forward",
            "location": 57,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray"
                ]
            }
        },
        "Bottleneck.__init__": {
            "name": "__init__",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inplanes": [
                    "int",
                    "numpy.ndarray"
                ],
                "planes": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "List[list[T]]",
                    "bytes",
                    "List[List[T]]"
                ],
                "stride": [
                    "int",
                    "bool",
                    "float"
                ],
                "downsample": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ],
                "dilation": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Bottleneck.forward": {
            "name": "forward",
            "location": 93,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray"
                ]
            }
        },
        "ResNet.__init__": {
            "name": "__init__",
            "location": 117,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "block": [
                    "int",
                    "Hashable",
                    "str",
                    "bool",
                    "numpy.ndarray"
                ],
                "layers": [
                    "str",
                    "int",
                    "bool",
                    "Hashable",
                    "numpy.ndarray"
                ],
                "num_classes": [
                    "int",
                    "bool",
                    "Dict",
                    "float",
                    "Dict[str,Tuple[int,int]]"
                ],
                "fully_conv": [
                    "bool",
                    "float",
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "int"
                ],
                "remove_avg_pool_layer": [
                    "bool",
                    "Optional[List[str]]",
                    "Optional[Callable[[bool],None]]"
                ],
                "output_stride": [
                    "int",
                    "str",
                    "bytes"
                ],
                "additional_blocks": [
                    "str",
                    "int"
                ],
                "multi_grid": [
                    "Tuple[int]",
                    "bool",
                    "int",
                    "Hashable",
                    "float"
                ]
            }
        },
        "ResNet._make_layer": {
            "name": "_make_layer",
            "location": 183,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "block": [
                    "List[numpy.ndarray]",
                    "bool"
                ],
                "planes": [
                    "List[numpy.ndarray]",
                    "bool"
                ],
                "blocks": [
                    "int",
                    "Dict[str,Any]",
                    "bool",
                    "numpy.array",
                    "float"
                ],
                "stride": [
                    "List[numpy.ndarray]",
                    "int"
                ],
                "multi_grid": [
                    "str",
                    "Dict",
                    "Dict[str,int]"
                ]
            }
        },
        "ResNet.forward": {
            "name": "forward",
            "location": 230,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "List",
                    "numpy.ndarray",
                    "List[float]",
                    "float"
                ]
            }
        }
    },
    "floods-backend-master/ccai/nn/model/segmentation.py": {
        "Resnet34_8s.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_classes": [
                    "int",
                    "str",
                    "Generator",
                    "float",
                    "Set[str]",
                    "Tuple[float,float]"
                ]
            }
        },
        "Resnet34_8s._normal_initialization": {
            "name": "_normal_initialization",
            "location": 58,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "layer": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "Resnet34_8s.forward": {
            "name": "forward",
            "location": 62,
            "return": [
                "str",
                "int",
                "utils.Node",
                "List",
                "float"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float",
                    "int"
                ],
                "feature_alignment": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "List",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "MyDataset.__init__": {
            "name": "__init__",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "root": [
                    "List[str]",
                    "Callable"
                ],
                "transform": [
                    "Optional[str]",
                    "IO",
                    "None",
                    "str"
                ]
            }
        },
        "MyDataset.__getitem__": {
            "name": "__getitem__",
            "location": 82,
            "return": [
                "str",
                "List[int]",
                "List[str]",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "str"
                ]
            }
        },
        "MyDataset.__len__": {
            "name": "__len__",
            "location": 89,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MyDataset.getPaths": {
            "name": "getPaths",
            "location": 92,
            "return": [
                "list"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "floods-backend-master/ccai/nn/model/trainer.py": {
        "MUNIT_Trainer.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "hyperparameters": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "MUNIT_Trainer.recon_criterion": {
            "name": "recon_criterion",
            "location": 212,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "int",
                    "Callable",
                    "str"
                ],
                "target": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "MUNIT_Trainer.recon_criterion_mask": {
            "name": "recon_criterion_mask",
            "location": 225,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input": [
                    "torch.Tensor",
                    "Tuple[int, int]",
                    "float",
                    "List[torch.Tensor]"
                ],
                "target": [
                    "torch.Tensor",
                    "Tuple[int, int]",
                    "float",
                    "List[torch.Tensor]"
                ],
                "mask": [
                    "torch.Tensor",
                    "Tuple[int, int]",
                    "float",
                    "List[torch.Tensor]"
                ]
            }
        },
        "MUNIT_Trainer.forward": {
            "name": "forward",
            "location": 240,
            "return": [
                "str",
                "utils.Node"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "int"
                ],
                "x_b": [
                    "bytes",
                    "str",
                    "memoryview",
                    "bool"
                ],
                "m_a": [
                    "int"
                ],
                "m_b": [
                    "bytes",
                    "str",
                    "memoryview",
                    "bool"
                ]
            }
        },
        "MUNIT_Trainer.gen_update": {
            "name": "gen_update",
            "location": 278,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "gluonts.model.common.Tensor",
                    "int",
                    "float",
                    "Union[int, float]"
                ],
                "x_b": [
                    "bytes",
                    "int",
                    "Optional[bytes]",
                    "gluonts.model.common.Tensor",
                    "TextIO"
                ],
                "hyperparameters": [
                    "gluonts.model.common.Tensor",
                    "int",
                    "Optional[int]",
                    "str",
                    "float",
                    "bool"
                ],
                "mask_a": [
                    "gluonts.model.common.Tensor",
                    "int",
                    "Union[int, float]",
                    "float"
                ],
                "mask_b": [
                    "bytes",
                    "int",
                    "Optional[bytes]",
                    "gluonts.model.common.Tensor",
                    "TextIO"
                ],
                "comet_exp": [
                    "None",
                    "Optional[int]",
                    "Optional[str]",
                    "bool",
                    "str",
                    "int"
                ],
                "synth": [
                    "bool",
                    "float",
                    "str",
                    "gluonts.model.common.Tensor"
                ],
                "semantic_gt_a": [
                    "None",
                    "bool",
                    "int"
                ],
                "semantic_gt_b": [
                    "None",
                    "bool",
                    "int"
                ]
            }
        },
        "MUNIT_Trainer.compute_vgg_loss": {
            "name": "compute_vgg_loss",
            "location": 426,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "img": [
                    "int",
                    "Callable",
                    "str"
                ],
                "target": [
                    "int",
                    "bytes"
                ],
                "mask": [
                    "str",
                    "None"
                ],
                "preprocess": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "MUNIT_Trainer.compute_classifier_sr_loss": {
            "name": "compute_classifier_sr_loss",
            "location": 454,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "c_a": [
                    "int",
                    "str"
                ],
                "c_b": [
                    "int"
                ],
                "domain_synth": [
                    "bool",
                    "1",
                    "int",
                    "str",
                    "List",
                    "float"
                ],
                "fool": [
                    "bool",
                    "1",
                    "int",
                    "str",
                    "List",
                    "float"
                ]
            }
        },
        "MUNIT_Trainer.compute_domain_adv_loss": {
            "name": "compute_domain_adv_loss",
            "location": 485,
            "return": [
                "Tuple",
                "int",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "c_a": [
                    "str",
                    "int",
                    "float"
                ],
                "c_b": [
                    "int",
                    "Variable"
                ],
                "compute_accuracy": [
                    "bool",
                    "List[str]",
                    "int",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ],
                "minimize": [
                    "bool",
                    "List[str]",
                    "int",
                    "Optional[List[Any]]",
                    "List[List[str]]"
                ]
            }
        },
        "MUNIT_Trainer.compute_semantic_seg_loss": {
            "name": "compute_semantic_seg_loss",
            "location": 522,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "img1": [
                    "int",
                    "Callable",
                    "str"
                ],
                "img2": [
                    "int",
                    "Callable",
                    "str"
                ],
                "mask": [
                    "None",
                    "Optional[torch.LongTensor]",
                    "Optional[torch.Tensor]",
                    "int",
                    "Optional[int]"
                ],
                "ground_truth": [
                    "None",
                    "Optional[int]",
                    "Optional[str]",
                    "str",
                    "bool"
                ]
            }
        },
        "MUNIT_Trainer.merge_seg_with_mask": {
            "name": "merge_seg_with_mask",
            "location": 585,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "img": [
                    "int",
                    "Callable",
                    "str"
                ],
                "mask": [
                    "str",
                    "torch.Tensor"
                ]
            }
        },
        "MUNIT_Trainer.average_mask": {
            "name": "average_mask",
            "location": 619,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "img": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "mask": [
                    "bool",
                    "torch.Tensor",
                    "float",
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "MUNIT_Trainer.sample": {
            "name": "sample",
            "location": 636,
            "return": [
                "Tuple[(_T0, Any, Any, Any, _T1, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "int",
                    "float"
                ],
                "x_b": [
                    "gluonts.model.common.Tensor"
                ],
                "m_a": [
                    "int",
                    "torch.Tensor"
                ],
                "m_b": [
                    "gluonts.model.common.Tensor"
                ]
            }
        },
        "MUNIT_Trainer.sample_syn": {
            "name": "sample_syn",
            "location": 681,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "int",
                    "float"
                ],
                "x_b": [
                    "bytes",
                    "bool",
                    "dict"
                ],
                "m_a": [
                    "str",
                    "torch.Tensor",
                    "int",
                    "dict",
                    "list"
                ],
                "m_b": [
                    "gluonts.model.common.Tensor",
                    "int"
                ]
            }
        },
        "MUNIT_Trainer.dis_update": {
            "name": "dis_update",
            "location": 783,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "float",
                    "str",
                    "int"
                ],
                "x_b": [
                    "gluonts.model.common.Tensor",
                    "int",
                    "Callable",
                    "bytes"
                ],
                "m_a": [
                    "float",
                    "str",
                    "int"
                ],
                "m_b": [
                    "bytes",
                    "str",
                    "memoryview",
                    "Callable[[bytes], bytes]"
                ],
                "hyperparameters": [
                    "int",
                    "float",
                    "gluonts.model.common.Tensor"
                ],
                "comet_exp": [
                    "Optional[float]",
                    "None"
                ]
            }
        },
        "MUNIT_Trainer.domain_classifier_update": {
            "name": "domain_classifier_update",
            "location": 825,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "str",
                    "bytes"
                ],
                "x_b": [
                    "str",
                    "float",
                    "int",
                    "List[int]"
                ],
                "hyperparameters": [
                    "bool",
                    "Optional[Exception]",
                    "list",
                    "List[str]"
                ],
                "comet_exp": [
                    "None",
                    "int",
                    "Optional[List[Any]]"
                ]
            }
        },
        "MUNIT_Trainer.domain_classifier_sr_update": {
            "name": "domain_classifier_sr_update",
            "location": 856,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "str",
                    "int",
                    "Optional[bytes]",
                    "bool"
                ],
                "x_b": [
                    "int",
                    "str",
                    "List[int]",
                    "float",
                    "Union[Literal[False], str]"
                ],
                "m_a": [
                    "float",
                    "bool",
                    "int"
                ],
                "m_b": [
                    "float",
                    "bool",
                    "int"
                ],
                "domain_synth": [
                    "str"
                ],
                "lambda_classifier": [
                    "gluonts.model.common.Tensor",
                    "List[float]"
                ],
                "step": [
                    "float",
                    "gluonts.model.common.Tensor",
                    "Optional[int]"
                ],
                "comet_exp": [
                    "None",
                    "List",
                    "int",
                    "Optional[int]",
                    "Callable"
                ]
            }
        },
        "MUNIT_Trainer.output_domain_classifier_sr_update": {
            "name": "output_domain_classifier_sr_update",
            "location": 875,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_ar": [
                    "int",
                    "Collection[int]",
                    "bool",
                    "float",
                    "set"
                ],
                "x_as": [
                    "int",
                    "Collection[int]",
                    "bool",
                    "float",
                    "set"
                ],
                "x_br": [
                    "int",
                    "Collection[int]",
                    "bool",
                    "float",
                    "set"
                ],
                "x_bs": [
                    "int",
                    "Collection[int]",
                    "bool",
                    "float",
                    "set"
                ],
                "hyperparameters": [
                    "int",
                    "Optional[Collection[int]]",
                    "bool",
                    "float"
                ],
                "step": [
                    "raiden.utils.PrivateKey",
                    "int"
                ],
                "comet_exp": [
                    "None",
                    "Optional[List[int]]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "MUNIT_Trainer.segmentation_head_update": {
            "name": "segmentation_head_update",
            "location": 892,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x_a": [
                    "str",
                    "Optional[Iterable]"
                ],
                "x_b": [
                    "str",
                    "int",
                    "property",
                    "float",
                    "List[int]"
                ],
                "target_a": [
                    "torch.Tensor",
                    "float"
                ],
                "target_b": [
                    "Dict[str, Any]",
                    "bool",
                    "torch.Tensor",
                    "str"
                ],
                "lamb": [
                    "int",
                    "str",
                    "gluonts.model.common.Tensor"
                ],
                "comet_exp": [
                    "None",
                    "float",
                    "int",
                    "Callable"
                ]
            }
        },
        "MUNIT_Trainer.update_learning_rate": {
            "name": "update_learning_rate",
            "location": 919,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MUNIT_Trainer.resume": {
            "name": "resume",
            "location": 930,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "checkpoint_dir": [
                    "str"
                ],
                "hyperparameters": [
                    "str",
                    "Callable"
                ]
            }
        },
        "MUNIT_Trainer.save": {
            "name": "save",
            "location": 973,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "snapshot_dir": [
                    "str"
                ],
                "iterations": [
                    "str"
                ]
            }
        }
    },
    "floods-backend-master/ccai/nn/model/utils.py": {
        "get_all_data_loaders": {
            "name": "get_all_data_loaders",
            "location": 51,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "conf": [
                    "float",
                    "src.main.core.models.area.Area",
                    "List[allennlp.data.Instance]"
                ]
            }
        },
        "seg_batch_transform": {
            "name": "seg_batch_transform",
            "location": 160,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "img_batch": [
                    "float",
                    "numpy.ndarray",
                    "Optional[int]",
                    "List[str]",
                    "torch.Tensor"
                ]
            }
        },
        "seg_transform": {
            "name": "seg_transform",
            "location": 167,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {}
        },
        "transform_torchVar": {
            "name": "transform_torchVar",
            "location": 178,
            "return": [
                "str",
                "Iterable[T]"
            ],
            "arguments": {}
        },
        "get_data_loader_list": {
            "name": "get_data_loader_list",
            "location": 193,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "root": [
                    "str",
                    "Optional[str]"
                ],
                "file_list": [
                    "str",
                    "Optional[str]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "str"
                ],
                "train": [
                    "int",
                    "Optional[int]",
                    "List[List[bool]]",
                    "bool",
                    "Callable[[str, str], float]"
                ],
                "new_size": [
                    "Optional[int]",
                    "Dict[str, str]"
                ],
                "height": [
                    "int",
                    "bool"
                ],
                "width": [
                    "int",
                    "bool"
                ],
                "num_workers": [
                    "int",
                    "float",
                    "str"
                ],
                "crop": [
                    "int",
                    "bool"
                ]
            }
        },
        "default_txt_reader": {
            "name": "default_txt_reader",
            "location": 247,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "flist": [
                    "str",
                    "float",
                    "int",
                    "Union[float, int]"
                ]
            }
        },
        "get_fid_data_loader": {
            "name": "get_fid_data_loader",
            "location": 554,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "file_list_a": [
                    "bool",
                    "int",
                    "Optional[float]",
                    "raiden.utils.Secret",
                    "hackathon.utils.utils.ResultsMessage",
                    "str"
                ],
                "file_list_b": [
                    "bool",
                    "int",
                    "Optional[float]",
                    "raiden.utils.Secret",
                    "hackathon.utils.utils.ResultsMessage",
                    "str"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "str"
                ],
                "train": [
                    "list",
                    "bool",
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any, Any]]"
                ],
                "new_size": [
                    "bool",
                    "int",
                    "Optional[float]",
                    "raiden.utils.Secret",
                    "hackathon.utils.utils.ResultsMessage",
                    "str"
                ],
                "num_workers": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "get_synthetic_data_loader": {
            "name": "get_synthetic_data_loader",
            "location": 705,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "file_list_a": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "file_list_b": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "mask_list": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "sem_list_a": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "sem_list_b": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "str"
                ],
                "train": [
                    "int",
                    "bool",
                    "str"
                ],
                "new_size": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "height": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "width": [
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "Callable[[str, str], float]"
                ],
                "num_workers": [
                    "int",
                    "bool",
                    "str"
                ],
                "crop": [
                    "bool",
                    "list",
                    "int",
                    "tuple",
                    "List[str]",
                    "str"
                ]
            }
        },
        "get_data_loader_mask_and_im": {
            "name": "get_data_loader_mask_and_im",
            "location": 753,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "file_list": [
                    "bool",
                    "str",
                    "int",
                    "dict"
                ],
                "mask_list": [
                    "bool",
                    "str",
                    "int",
                    "dict"
                ],
                "batch_size": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str"
                ],
                "train": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str"
                ],
                "new_size": [
                    "bool",
                    "str",
                    "int",
                    "dict"
                ],
                "height": [
                    "bool",
                    "str",
                    "int",
                    "dict"
                ],
                "width": [
                    "bool",
                    "str",
                    "int",
                    "dict"
                ],
                "num_workers": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str"
                ],
                "crop": [
                    "bool",
                    "str",
                    "Callable",
                    "int"
                ]
            }
        },
        "get_data_loader_mask_and_im_and_rect": {
            "name": "get_data_loader_mask_and_im_and_rect",
            "location": 795,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "file_list": [
                    "list",
                    "tuple",
                    "dict"
                ],
                "mask_list": [
                    "list",
                    "tuple",
                    "dict"
                ],
                "rect_list": [
                    "list",
                    "tuple",
                    "dict"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Union[Tuple[int, int], int]"
                ],
                "train": [
                    "int",
                    "bool",
                    "Union[Tuple[int, int], int]"
                ],
                "new_size": [
                    "list",
                    "tuple",
                    "dict"
                ],
                "height": [
                    "list",
                    "tuple",
                    "dict"
                ],
                "width": [
                    "list",
                    "tuple",
                    "dict"
                ],
                "num_workers": [
                    "int",
                    "bool",
                    "Union[Tuple[int, int], int]"
                ],
                "crop": [
                    "bool",
                    "str",
                    "List[int]",
                    "Optional[Sequence['cirq.Qid']]",
                    "Optional[str]",
                    "dict"
                ]
            }
        },
        "get_data_loader_folder": {
            "name": "get_data_loader_folder",
            "location": 838,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "input_folder": [
                    "str",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "Tuple[int, int]"
                ],
                "train": [
                    "int",
                    "Tuple[float, float]"
                ],
                "new_size": [
                    "str",
                    "numpy.array",
                    "stiff.models.TokenizedTagging",
                    "List[str]",
                    "List[int]",
                    "tensorflow.python.keras.models.Model"
                ],
                "height": [
                    "int",
                    "torch.IntTensor",
                    "str"
                ],
                "width": [
                    "int",
                    "torch.IntTensor",
                    "str"
                ],
                "num_workers": [
                    "int",
                    "Tuple[int, int]"
                ],
                "crop": [
                    "int",
                    "torch.IntTensor",
                    "str"
                ]
            }
        },
        "get_config": {
            "name": "get_config",
            "location": 887,
            "return": [
                "str",
                "Any",
                "dict"
            ],
            "arguments": {
                "config": [
                    "Dict[str, Any]",
                    "str",
                    "Optional[dict]",
                    "cmk.utils.type_defs.OptionalConfigSerial",
                    "List[Tuple[str, str, str, str, str, str, str]]"
                ]
            }
        },
        "eformat": {
            "name": "eformat",
            "location": 900,
            "return": [
                "str"
            ],
            "arguments": {
                "f": [
                    "Callable",
                    "str",
                    "bool",
                    "\"SpeciesNameComplex\""
                ],
                "prec": [
                    "Callable",
                    "str",
                    "bool",
                    "\"SpeciesNameComplex\""
                ]
            }
        },
        "__write_images": {
            "name": "__write_images",
            "location": 907,
            "return": [
                "None"
            ],
            "arguments": {
                "image_outputs": [
                    "List[str]",
                    "str",
                    "Optional[str]",
                    "Dict[str, Any]"
                ],
                "display_image_num": [
                    "str",
                    "flambe.cluster.utils.RemoteCommand",
                    "bool"
                ],
                "file_name": [
                    "str",
                    "dict"
                ]
            }
        },
        "write_2images": {
            "name": "write_2images",
            "location": 924,
            "return": [
                "None"
            ],
            "arguments": {
                "image_outputs": [
                    "int",
                    "List[Dict]",
                    "Sequence[Sequence[float]]",
                    "List[Tuple[int, int]]",
                    "numpy.ndarray",
                    "List[str]",
                    "Dict[str, str]"
                ],
                "display_image_num": [
                    "str",
                    "List[str]",
                    "hackathon.utils.utils.ResultsMessage",
                    "Union[bool, str]",
                    "bool",
                    "dict"
                ],
                "image_directory": [
                    "str",
                    "List[str]",
                    "hackathon.utils.utils.ResultsMessage",
                    "Union[bool, str]",
                    "bool",
                    "dict"
                ],
                "postfix": [
                    "str",
                    "List[str]",
                    "hackathon.utils.utils.ResultsMessage",
                    "Union[bool, str]",
                    "bool",
                    "dict"
                ],
                "comet_exp": [
                    "Optional[numpy.ndarray]",
                    "Optional[int]",
                    "bool",
                    "Match",
                    "numpy.ndarray"
                ]
            }
        },
        "prepare_sub_folder": {
            "name": "prepare_sub_folder",
            "location": 952,
            "return": [
                "Tuple[(str, str)]"
            ],
            "arguments": {
                "output_directory": [
                    "str",
                    "bytes"
                ]
            }
        },
        "write_loss": {
            "name": "write_loss",
            "location": 972,
            "return": [
                "None"
            ],
            "arguments": {
                "iterations": [
                    "autorecurse.gnumake.data.Makefile",
                    "gluonts.model.common.Tensor",
                    "dict"
                ],
                "trainer": [
                    "dict",
                    "Dict[str, Any]",
                    "int"
                ],
                "train_writer": [
                    "autorecurse.gnumake.data.Makefile",
                    "gluonts.model.common.Tensor",
                    "dict"
                ]
            }
        },
        "slerp": {
            "name": "slerp",
            "location": 984,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "val": [
                    "numpy.ndarray",
                    "bool"
                ],
                "low": [
                    "int",
                    "str",
                    "float"
                ],
                "high": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "get_slerp_interp": {
            "name": "get_slerp_interp",
            "location": 1002,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "nb_latents": [
                    "str",
                    "bool"
                ],
                "nb_interp": [
                    "int",
                    "autorecurse.gnumake.data.Makefile",
                    "str"
                ],
                "z_dim": [
                    "str",
                    "zam_repondeur.models.phase.Phase",
                    "numpy.array"
                ]
            }
        },
        "get_model_list": {
            "name": "get_model_list",
            "location": 1020,
            "return": [
                "Optional[int]",
                "Optional[str]",
                "bool",
                "str",
                "dict"
            ],
            "arguments": {
                "dirname": [
                    "str"
                ],
                "key": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "load_vgg16": {
            "name": "load_vgg16",
            "location": 1044,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "model_dir": [
                    "bool",
                    "List[str]",
                    "str"
                ]
            }
        },
        "load_flood_classifier": {
            "name": "load_flood_classifier",
            "location": 1050,
            "return": [
                "model.Model",
                "GPy.models.GPRegression",
                "model.SockeyeModel",
                "invgp.model.GP",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "ckpt_path": [
                    "str",
                    "dict"
                ]
            }
        },
        "load_segmentation_model": {
            "name": "load_segmentation_model",
            "location": 1104,
            "return": [
                "model.Model",
                "GPy.models.GPRegression",
                "model.SockeyeModel",
                "invgp.model.GP",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "ckpt_path": [
                    "Dict[str, Any]",
                    "str",
                    "asyncpg_migrate.model.Config",
                    "Dict[str, str]",
                    "dict"
                ],
                "classes": [
                    "Optional[int]",
                    "str",
                    "bool",
                    "List[str]",
                    "List[src.core.model.scripScript]"
                ]
            }
        },
        "decode_segmap": {
            "name": "decode_segmap",
            "location": 1119,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "torch.Tensor",
                    "PIL.Image.Image",
                    "int"
                ],
                "nc": [
                    "torch.Tensor",
                    "str",
                    "numpy.ndarray",
                    "int",
                    "docker_push_latest_if_changed.Image",
                    "float"
                ]
            }
        },
        "load_inception": {
            "name": "load_inception",
            "location": 1162,
            "return": [
                "model.Model",
                "GPy.models.GPRegression",
                "model.SockeyeModel",
                "invgp.model.GP",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "model_path": [
                    "str",
                    "dict"
                ]
            }
        },
        "vgg_preprocess": {
            "name": "vgg_preprocess",
            "location": 1182,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "batch": [
                    "str",
                    "Callable",
                    "list"
                ]
            }
        },
        "get_scheduler": {
            "name": "get_scheduler",
            "location": 1197,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "optimizer": [
                    "List[int]",
                    "int",
                    "float",
                    "str"
                ],
                "hyperparameters": [
                    "torch.Tensor",
                    "float",
                    "int",
                    "List[int]",
                    "Optional[int]"
                ],
                "iterations": [
                    "List[int]",
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "weights_init": {
            "name": "weights_init",
            "location": 1224,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "init_type": [
                    "str",
                    "Tuple[str]",
                    "Type[object]",
                    "Optional[Any]"
                ]
            }
        },
        "pytorch03_to_pytorch04": {
            "name": "pytorch03_to_pytorch04",
            "location": 1259,
            "return": [
                "typing.Dict[(str, Any)]"
            ],
            "arguments": {
                "state_dict_base": [
                    "str",
                    "BaseException",
                    "T"
                ],
                "trainer_name": [
                    "str",
                    "BaseException",
                    "T"
                ]
            }
        },
        "conv_block": {
            "name": "conv_block",
            "location": 1349,
            "return": [
                "int",
                "Iterable[str]"
            ],
            "arguments": {
                "in_channels": [
                    "int",
                    "numpy.ndarray",
                    "List[float]",
                    "float",
                    "busboy.model.Stop",
                    "bytes",
                    "Optional[int]"
                ],
                "out_channels": [
                    "int",
                    "numpy.ndarray",
                    "List[float]",
                    "float",
                    "busboy.model.Stop",
                    "bytes",
                    "Optional[int]"
                ]
            }
        },
        "conv3x3": {
            "name": "conv3x3",
            "location": 1367,
            "return": [
                "bool"
            ],
            "arguments": {
                "in_planes": [
                    "int",
                    "bool",
                    "float",
                    "torch.Tensor",
                    "str"
                ],
                "out_planes": [
                    "int",
                    "bool",
                    "float",
                    "torch.Tensor",
                    "str"
                ],
                "stride": [
                    "int",
                    "bool",
                    "float",
                    "torch.Tensor",
                    "str"
                ],
                "groups": [
                    "int",
                    "bool",
                    "float",
                    "torch.Tensor",
                    "str"
                ],
                "dilation": [
                    "int",
                    "bool",
                    "float",
                    "torch.Tensor",
                    "str"
                ]
            }
        },
        "conv1x1": {
            "name": "conv1x1",
            "location": 1394,
            "return": [
                "bool"
            ],
            "arguments": {
                "in_planes": [
                    "int",
                    "torch.IntTensor",
                    "bool"
                ],
                "out_planes": [
                    "int",
                    "torch.IntTensor",
                    "bool"
                ],
                "stride": [
                    "int",
                    "torch.IntTensor",
                    "bool"
                ]
            }
        },
        "merge_classes": {
            "name": "merge_classes",
            "location": 1457,
            "return": [
                "int",
                "str",
                "Callable[..., T]"
            ],
            "arguments": {
                "output": [
                    "hypothesis.strategies.SearchStrategy[bankroll.model.Currency]",
                    "bytes",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "mapping": {
            "name": "mapping",
            "location": 1483,
            "return": [
                "str",
                "List[str]",
                "bool",
                "torch.Tensor",
                "bytes"
            ],
            "arguments": {
                "im": [
                    "str",
                    "List[str]",
                    "bool",
                    "torch.Tensor",
                    "bytes"
                ]
            }
        },
        "flatten_opts": {
            "name": "flatten_opts",
            "location": 1522,
            "return": [
                "typing.Dict[(str, Any)]"
            ],
            "arguments": {
                "opts": [
                    "str",
                    "Callable",
                    "Callable[[str], None]"
                ]
            }
        },
        "sorted_nicely": {
            "name": "sorted_nicely",
            "location": 1565,
            "return": [
                "list"
            ],
            "arguments": {
                "l": [
                    "int",
                    "Dict[str, Set[str]]"
                ]
            }
        },
        "load_opts": {
            "name": "load_opts",
            "location": 1572,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "default": [
                    "str",
                    "Optional[IO[bytes]]",
                    "int",
                    "Optional[str]",
                    "bytes"
                ]
            }
        },
        "tv_loss": {
            "name": "tv_loss",
            "location": 1599,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "img": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ],
                "tv_weight": [
                    "int",
                    "Callable",
                    "models.Question",
                    "str"
                ]
            }
        },
        "normalize_batch": {
            "name": "normalize_batch",
            "location": 1615,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "batch": []
            }
        },
        "gram_matrix": {
            "name": "gram_matrix",
            "location": 1623,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "y": [
                    "Optional[int]",
                    "int",
                    "models.data_frames.data_frame.GUIInterface",
                    "Iterable[zam_repondeur.models.Amendement]"
                ]
            }
        },
        "MyDatasetRect.__init__": {
            "name": "__init__",
            "location": 278,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_list": [
                    "str",
                    "int",
                    "bool",
                    "TextIO",
                    "Optional[str]"
                ],
                "mask_list": [
                    "bool",
                    "str",
                    "Optional[Union[str, Any]]",
                    "Optional[Dict[str, Any]]"
                ],
                "rect_list": [
                    "Optional[str]",
                    "Optional[Union[str, Any]]",
                    "Optional[List[str]]",
                    "bool",
                    "str",
                    "Optional[Set[int]]"
                ],
                "new_size": [
                    "bool",
                    "int",
                    "Tuple[int, int]"
                ],
                "height": [
                    "int",
                    "bool",
                    "str"
                ],
                "width": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "MyDatasetRect.transform": {
            "name": "transform",
            "location": 297,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "numpy.ndarray",
                    "int",
                    "PIL.Image.Image",
                    "Image"
                ],
                "mask": [
                    "numpy.ndarray",
                    "int",
                    "PIL.Image.Image",
                    "float"
                ],
                "rect": [
                    "numpy.ndarray",
                    "List[str]",
                    "_types.Image",
                    "List[numpy.ndarray]",
                    "numpy.array",
                    "Optional[gluonts.model.common.Tensor]",
                    "str"
                ]
            }
        },
        "MyDatasetRect.__getitem__": {
            "name": "__getitem__",
            "location": 355,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "cmk.utils.type_defs.HostName"
                ]
            }
        },
        "MyDatasetRect.__len__": {
            "name": "__len__",
            "location": 382,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MyDataset.__init__": {
            "name": "__init__",
            "location": 396,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_list": [
                    "bool",
                    "str",
                    "Union[str, bytes, int]",
                    "Callable[[float], None]",
                    "TextIO",
                    "int",
                    "Optional[str]"
                ],
                "mask_list": [
                    "str",
                    "bool",
                    "Optional[Union[Any, Any]]",
                    "Optional[Dict[str, Any]]",
                    "Optional[bool]"
                ],
                "new_size": [
                    "bool",
                    "Tuple[int, int]",
                    "int"
                ],
                "height": [
                    "bool",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "int"
                ],
                "width": [
                    "bool",
                    "Dict[str, Tuple[str, int, int]]",
                    "Dict[str, Tuple[str, str, Any]]",
                    "int"
                ]
            }
        },
        "MyDataset.transform": {
            "name": "transform",
            "location": 408,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "numpy.ndarray",
                    "int",
                    "PIL.Image.Image",
                    "Image"
                ],
                "mask": [
                    "numpy.ndarray",
                    "int",
                    "PIL.Image.Image",
                    "float"
                ]
            }
        },
        "MyDataset.__getitem__": {
            "name": "__getitem__",
            "location": 462,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "list"
                ]
            }
        },
        "MyDataset.__len__": {
            "name": "__len__",
            "location": 484,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "DatasetInferenceFID.__init__": {
            "name": "__init__",
            "location": 498,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_list_a": [
                    "str",
                    "List[str]",
                    "Union[str, os.PathLike]",
                    "bool",
                    "Optional[str]"
                ],
                "file_list_b": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "new_size": [
                    "int",
                    "List[int]",
                    "List[str]",
                    "Collection[fonduer.parser.models.Document]"
                ]
            }
        },
        "DatasetInferenceFID.transform": {
            "name": "transform",
            "location": 503,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "image_a": [
                    "bool",
                    "int",
                    "torch.Tensor",
                    "str",
                    "Union[int, float]"
                ],
                "image_b": [
                    "int",
                    "str"
                ]
            }
        },
        "DatasetInferenceFID.__getitem__": {
            "name": "__getitem__",
            "location": 531,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "bool"
                ]
            }
        },
        "DatasetInferenceFID.__len__": {
            "name": "__len__",
            "location": 545,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MyDatasetSynthetic.__init__": {
            "name": "__init__",
            "location": 588,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_list_a": [
                    "Union[str, bytes, int]",
                    "List[str]",
                    "str",
                    "Union[str, os.PathLike]",
                    "TextIO",
                    "Callable[[float], None]",
                    "Container[str]",
                    "bool"
                ],
                "file_list_b": [
                    "str",
                    "Union[str, bytes, int]",
                    "List[str]",
                    "TextIO"
                ],
                "mask_list": [
                    "str",
                    "Container[str]",
                    "Union[str, os.PathLike]",
                    "bool",
                    "int"
                ],
                "semantic_a_list": [
                    "bool",
                    "int",
                    "float"
                ],
                "semantic_b_list": [
                    "int",
                    "str",
                    "bool"
                ],
                "new_size": [
                    "bool",
                    "int",
                    "str"
                ],
                "height": [
                    "bool",
                    "int",
                    "float"
                ],
                "width": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "MyDatasetSynthetic.transform": {
            "name": "transform",
            "location": 608,
            "return": [
                "Tuple[(Any, Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "image_a": [
                    "gluonts.model.common.Tensor",
                    "float",
                    "bool"
                ],
                "image_b": [
                    "int",
                    "Tuple[int, int, int, int]",
                    "float"
                ],
                "mask": [
                    "str",
                    "Optional[Union[int, slice]]",
                    "numpy.ndarray",
                    "Union[int, float]",
                    "bool",
                    "gluonts.model.common.Tensor"
                ],
                "semantic_a": [
                    "gluonts.model.common.Tensor",
                    "int",
                    "float",
                    "Callable",
                    "numpy.random.RandomState",
                    "numpy.ndarray"
                ],
                "semantic_b": [
                    "int",
                    "Optional[int]",
                    "float",
                    "Optional[float]",
                    "Union[int, float]"
                ]
            }
        },
        "MyDatasetSynthetic.__getitem__": {
            "name": "__getitem__",
            "location": 680,
            "return": [
                "Tuple[(Any, Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        },
        "MyDatasetSynthetic.__len__": {
            "name": "__len__",
            "location": 697,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Resnet34_8s.__init__": {
            "name": "__init__",
            "location": 1067,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_classes": [
                    "str",
                    "int",
                    "Generator",
                    "float",
                    "Set[str]",
                    "Tuple[float, float]"
                ]
            }
        },
        "Resnet34_8s._normal_initialization": {
            "name": "_normal_initialization",
            "location": 1083,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "layer": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "Resnet34_8s.forward": {
            "name": "forward",
            "location": 1087,
            "return": [
                "str",
                "utils.Node"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "float",
                    "int"
                ],
                "feature_alignment": [
                    "bool",
                    "float",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "str",
                    "T",
                    "bytes"
                ]
            }
        },
        "weights_init.init_fun": {
            "name": "init_fun",
            "location": 1225,
            "return": [],
            "arguments": {
                "m": [
                    "List[Exception]",
                    "list",
                    "Hashable",
                    "Sequence[str]",
                    "Tuple[str, str]",
                    "float"
                ]
            }
        },
        "Timer.__init__": {
            "name": "__init__",
            "location": 1248,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "msg": [
                    "str",
                    "IO",
                    "bool",
                    "Optional[int]",
                    "hackathon.utils.utils.DataMessage"
                ]
            }
        },
        "Timer.__enter__": {
            "name": "__enter__",
            "location": 1252,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Timer.__exit__": {
            "name": "__exit__",
            "location": 1255,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "exc_type": [
                    "Optional[Type[BaseException]]"
                ],
                "exc_value": [
                    "Optional[BaseException]"
                ],
                "exc_tb": [
                    "Optional[Type[BaseException]]",
                    "type",
                    "Optional[BaseException]",
                    "Optional[Type]"
                ]
            }
        },
        "pytorch03_to_pytorch04.__conversion_core": {
            "name": "__conversion_core",
            "location": 1260,
            "return": [
                "bool",
                "Callable",
                "dict",
                "List[str]",
                "str",
                "salon.models.ServiceCategory"
            ],
            "arguments": {
                "state_dict_base": [
                    "str",
                    "Optional[Any]",
                    "Set[str]",
                    "bytes",
                    "Optional[float]",
                    "int"
                ],
                "trainer_name": [
                    "str",
                    "Optional[Any]",
                    "Set[str]",
                    "bytes",
                    "Optional[float]",
                    "int"
                ]
            }
        },
        "BasicBlock.__init__": {
            "name": "__init__",
            "location": 1409,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inplanes": [
                    "bool",
                    "int",
                    "float",
                    "List[utils.CWLObjectType]",
                    "Union[float, Tuple[float, float]]"
                ],
                "planes": [
                    "bool",
                    "int",
                    "float",
                    "List[utils.CWLObjectType]",
                    "Union[float, Tuple[float, float]]"
                ],
                "stride": [
                    "bool",
                    "int",
                    "float",
                    "List[utils.CWLObjectType]",
                    "Union[float, Tuple[float, float]]"
                ],
                "downsample": [
                    "bool",
                    "int",
                    "float",
                    "List[utils.CWLObjectType]",
                    "Union[float, Tuple[float, float]]"
                ],
                "groups": [
                    "bool",
                    "Dict[str, Dict]",
                    "\"Cash\""
                ],
                "base_width": [
                    "bool",
                    "Dict[str, Dict]",
                    "\"Cash\""
                ],
                "dilation": [
                    "Optional[bool]",
                    "raiden.utils.Callable",
                    "bool",
                    "Dict[str, Any]",
                    "float"
                ],
                "norm_layer": [
                    "Optional[int]",
                    "bool",
                    "Optional[Type[Any]]",
                    "Optional[Tuple[float, float]]",
                    "Optional[Callable[[str], bool]]",
                    "Tuple[numpy.dtype]"
                ]
            }
        },
        "BasicBlock.forward": {
            "name": "forward",
            "location": 1438,
            "return": [
                "str",
                "Optional[Union[str, Any]]",
                "Set[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Variable",
                    "gluonts.model.common.Tensor",
                    "numpy.ndarray"
                ]
            }
        },
        "domainClassifier.__init__": {
            "name": "__init__",
            "location": 1498,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "input_dim": [
                    "int",
                    "float",
                    "bool"
                ],
                "dim": [
                    "str",
                    "bool"
                ]
            }
        },
        "domainClassifier.forward": {
            "name": "forward",
            "location": 1509,
            "return": [
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "Tuple[float, float]",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "flatten_opts.p": {
            "name": "p",
            "location": 1548,
            "return": [],
            "arguments": {
                "d": [
                    "dict",
                    "\"QuerySet[MODEL]\"",
                    "numpy.ndarray",
                    "str"
                ],
                "prefix": [
                    "str",
                    "Dict[str, Dict[str, str]]",
                    "dict",
                    "trezor.utils.BufferReader",
                    "bytes"
                ],
                "vals": [
                    "str",
                    "Dict[str, Dict[str, str]]",
                    "dict",
                    "trezor.utils.BufferReader",
                    "bytes"
                ]
            }
        },
        "pytorch03_to_pytorch04.__conversion_core.__conversion_core": {
            "name": "__conversion_core",
            "location": 1293,
            "return": [],
            "arguments": {
                "state_dict_base": []
            }
        }
    },
    "floods-backend-master/tests/test_climate.py": {
        "TestClimate.setUp": {
            "name": "setUp",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClimate.test_lat_long": {
            "name": "test_lat_long",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClimate.test_metadata": {
            "name": "test_metadata",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "floods-backend-master/tests/test_config.py": {
        "TestConfig.test_config": {
            "name": "test_config",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "floods-backend-master/tests/__init__.py": {}
}
{
    "formatml-master/setup.py": {},
    "formatml-master/codrep/visualizer/serve.py": {
        "_list_tasks": {
            "name": "_list_tasks",
            "location": 13,
            "return": [
                "Tuple[(List[str], List[int])]"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path"
                ]
            }
        },
        "_parse_output": {
            "name": "_parse_output",
            "location": 31,
            "return": [
                "collections.defaultdict[(str, list)]"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "Iterable[str]"
                ],
                "task_names": [
                    "str",
                    "Dict[str, Any]",
                    "dict",
                    "Callable[[str], str]"
                ]
            }
        },
        "_parse_metadata": {
            "name": "_parse_metadata",
            "location": 54,
            "return": [
                "dict"
            ],
            "arguments": {
                "path": [
                    "Optional[pathlib.Path]",
                    "str",
                    "int",
                    "Optional[str]",
                    "pathlib.Path"
                ]
            }
        },
        "_create_app": {
            "name": "_create_app",
            "location": 73,
            "return": [
                "flask.Flask"
            ],
            "arguments": {}
        },
        "main": {
            "name": "main",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "_create_app.index": {
            "name": "index",
            "location": 82,
            "return": [
                "str",
                "Optional[Any]"
            ],
            "arguments": {}
        },
        "_create_app.tasks": {
            "name": "tasks",
            "location": 86,
            "return": [
                "Dict[str, Any]",
                "dict",
                "Dict[str, Dict[str, Any]]",
                "str",
                "Callable"
            ],
            "arguments": {}
        },
        "_create_app.task": {
            "name": "task",
            "location": 96,
            "return": [
                "Dict[str, Any]",
                "bool",
                "dict"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/__init__.py": {},
    "formatml-master/formatml/__main__.py": {
        "main": {
            "name": "main",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/data/instance.py": {
        "Instance.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fields": [
                    "Dict[str,Any]",
                    "str",
                    "Optional[Dict[str,Any]]"
                ]
            }
        },
        "Instance.index": {
            "name": "index",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str"
                ]
            }
        },
        "Instance.tensorize": {
            "name": "tensorize",
            "location": 39,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str",
                    "Tuple[Union[str,str]]",
                    "bool",
                    "Tuple[Type]",
                    "Tuple[str,str]",
                    "Tuple[type]"
                ]
            }
        },
        "Instance.collate": {
            "name": "collate",
            "location": 51,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "List[dict[str,Any]]",
                    "Dict",
                    "List[Dict[str,Any]]",
                    "int",
                    "Type",
                    "float"
                ]
            }
        },
        "Instance.to": {
            "name": "to",
            "location": 63,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "List[dict[str,Any]]",
                    "List[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "Dict",
                    "Type",
                    "torch.device",
                    "str"
                ],
                "device": [
                    "List[dict[str,Any]]",
                    "List[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "Dict",
                    "Type",
                    "torch.device",
                    "str"
                ]
            }
        },
        "Instance.save": {
            "name": "save",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "pathlib.Path",
                    "Union[str,pathlib.Path]"
                ]
            }
        },
        "Instance.get_field_by_type": {
            "name": "get_field_by_type",
            "location": 72,
            "return": [
                "Mapping[str, Any]",
                "rflx.model.Field",
                "type",
                "Type[T]"
            ],
            "arguments": {
                "self": [],
                "field_type": [
                    "str",
                    "Type"
                ]
            }
        },
        "Instance.get_fields_by_type": {
            "name": "get_fields_by_type",
            "location": 75,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "field_type": [
                    "str",
                    "Type"
                ]
            }
        },
        "Instance._select_input": {
            "name": "_select_input",
            "location": 78,
            "return": [
                "str",
                "List",
                "ValueError",
                "List[str]",
                "int",
                "float",
                "Dict[str,str]",
                "Tuple"
            ],
            "arguments": {
                "self": [],
                "field": [
                    "Callable",
                    "str",
                    "int"
                ],
                "inputs": [
                    "str",
                    "ValueError",
                    "int",
                    "Dict[str,str]",
                    "rflx.model.Field",
                    "Field",
                    "dataclasses.Field[Any]"
                ]
            }
        },
        "Instance.__getitem__": {
            "name": "__getitem__",
            "location": 89,
            "return": [
                "str",
                "Dict[str, Any]",
                "list"
            ],
            "arguments": {
                "self": [],
                "field_name": [
                    "str",
                    "cmk.gui.plugins.views.utils.Command"
                ]
            }
        }
    },
    "formatml-master/formatml/data/vocabulary.py": {
        "Vocabulary.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "unknown": [
                    "Dict",
                    "None",
                    "bool",
                    "Optional[bool]"
                ],
                "initial_words": [
                    "Tuple",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Vocabulary.add_item": {
            "name": "add_item",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "T"
                ]
            }
        },
        "Vocabulary.add_items": {
            "name": "add_items",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "str",
                    "Iterable[T]",
                    "Dict"
                ]
            }
        },
        "Vocabulary.get_index": {
            "name": "get_index",
            "location": 50,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "bool",
                    "Sequence[str]",
                    "Tuple[str,str]",
                    "Tuple[Union[str,str]]"
                ]
            }
        },
        "Vocabulary.get_indexes": {
            "name": "get_indexes",
            "location": 61,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "str",
                    "Iterable[T]",
                    "Type[object]",
                    "List",
                    "Dict",
                    "Union[int,slice]"
                ]
            }
        },
        "Vocabulary.get_item": {
            "name": "get_item",
            "location": 70,
            "return": [
                "int",
                "Dict[str, str]",
                "dict",
                "Optional[Dict[str, Any]]",
                "Exception"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "Tuple[bytes]",
                    "Dict[str,Any]",
                    "str"
                ]
            }
        },
        "Vocabulary.get_items": {
            "name": "get_items",
            "location": 79,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "indexes": [
                    "str",
                    "int"
                ]
            }
        },
        "Vocabulary.__contains__": {
            "name": "__contains__",
            "location": 88,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str"
                ]
            }
        },
        "Vocabulary.__len__": {
            "name": "__len__",
            "location": 97,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/data/__init__.py": {},
    "formatml-master/formatml/data/fields/binary_label_field.py": {
        "BinaryLabelsField.tensorize": {
            "name": "tensorize",
            "location": 10,
            "return": [
                "str",
                "bool",
                "Iterable[str]",
                "List[List[str]]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str"
                ]
            }
        },
        "BinaryLabelsField.collate": {
            "name": "collate",
            "location": 15,
            "return": [
                "List[Dict]",
                "List[str]",
                "str",
                "List[int]",
                "List[List[Any]]",
                "float"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "Iterable[str]",
                    "Sequence[T]"
                ]
            }
        },
        "BinaryLabelsField.to": {
            "name": "to",
            "location": 18,
            "return": [
                "Dict[str, Any]",
                "float"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.device",
                    "torch.Tensor",
                    "int",
                    "str"
                ],
                "device": [
                    "int",
                    "str",
                    "torch.device",
                    "torch.Tensor"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/field.py": {
        "Field.__init__": {
            "name": "__init__",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Dict[str,Any]",
                    "Type[T]",
                    "Type",
                    "Optional[str]",
                    "None"
                ],
                "type": [
                    "str",
                    "bool",
                    "Type",
                    "int"
                ]
            }
        },
        "Field.index": {
            "name": "index",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Field.tensorize": {
            "name": "tensorize",
            "location": 27,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Field.collate": {
            "name": "collate",
            "location": 36,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Field.to": {
            "name": "to",
            "location": 45,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Dict",
                    "IO",
                    "List[str]",
                    "int",
                    "Iterator",
                    "Iterator[Dict[str,str]]",
                    "torch.device"
                ],
                "device": [
                    "Dict",
                    "IO",
                    "List[str]",
                    "int",
                    "Iterator",
                    "Iterator[Dict[str,str]]",
                    "torch.device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/indexes_field.py": {
        "IndexesField.tensorize": {
            "name": "tensorize",
            "location": 16,
            "return": [
                "str",
                "IndexesFieldOutput"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "Optional[str]",
                    "bool",
                    "str",
                    "None"
                ]
            }
        },
        "IndexesField.collate": {
            "name": "collate",
            "location": 26,
            "return": [
                "IndexesFieldOutput",
                "List[str]",
                "str",
                "Awaitable"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "List[int]",
                    "Set[str]",
                    "int",
                    "Sequence[str]"
                ]
            }
        },
        "IndexesField.to": {
            "name": "to",
            "location": 39,
            "return": [
                "IndexesFieldOutput",
                "str",
                "bytes",
                "int",
                "Union[str,bytes]"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "int",
                    "torch.device"
                ],
                "device": [
                    "int",
                    "torch.device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/internal_type_field.py": {
        "InternalTypeField.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "InternalTypeField.index": {
            "name": "index",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "InternalTypeField.tensorize": {
            "name": "tensorize",
            "location": 25,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "AbstractSet",
                    "Type",
                    "AbstractSet[str]",
                    "Type[Frame]"
                ]
            }
        },
        "InternalTypeField.collate": {
            "name": "collate",
            "location": 31,
            "return": [
                "torch.FloatTensor",
                "str",
                "List[allennlp.data.iterators.data_iterator.TensorDict]",
                "List[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "float",
                    "int"
                ]
            }
        },
        "InternalTypeField.to": {
            "name": "to",
            "location": 34,
            "return": [
                "Dict[str, Any]",
                "float"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.device",
                    "torch.Tensor",
                    "int",
                    "str"
                ],
                "device": [
                    "int",
                    "str",
                    "torch.device",
                    "torch.Tensor"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/label_field.py": {
        "LabelField.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "LabelField.index": {
            "name": "index",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "LabelField.tensorize": {
            "name": "tensorize",
            "location": 36,
            "return": [
                "LabelFieldOutput",
                "str",
                "List[int]",
                "int",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "formatml.parsing.parser.Nodes"
                ]
            }
        },
        "LabelField.collate": {
            "name": "collate",
            "location": 62,
            "return": [
                "LabelFieldOutput",
                "str",
                "List[int]",
                "int",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "LabelField.to": {
            "name": "to",
            "location": 82,
            "return": [
                "LabelFieldOutput",
                "str",
                "Union[str,bytes]"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "int",
                    "torch.device"
                ],
                "device": [
                    "int",
                    "torch.device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/length_field.py": {
        "LengthField.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LengthField.tensorize": {
            "name": "tensorize",
            "location": 23,
            "return": [
                "int",
                "bool",
                "tuple",
                "list",
                "Union[List[str], str]",
                "List[str]",
                "List[Tuple]"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "str"
                ]
            }
        },
        "LengthField.collate": {
            "name": "collate",
            "location": 26,
            "return": [
                "utils.Node",
                "torch.FloatTensor",
                "str",
                "List[allennlp.data.iterators.data_iterator.TensorDict]",
                "List[int]",
                "int"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "float",
                    "int"
                ]
            }
        },
        "LengthField.to": {
            "name": "to",
            "location": 29,
            "return": [
                "Dict[str, Any]",
                "float"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "torch.device",
                    "torch.Tensor",
                    "int",
                    "str"
                ],
                "device": [
                    "int",
                    "str",
                    "torch.device",
                    "torch.Tensor"
                ]
            }
        },
        "LengthField._length": {
            "name": "_length",
            "location": 32,
            "return": [
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "node": [
                    "None",
                    "Optional[Node]",
                    "src.evalg.encoding.BinaryTree.Node"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/metadata_field.py": {
        "MetadataField.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MetadataField.tensorize": {
            "name": "tensorize",
            "location": 13,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Callable[[None],None]",
                    "str",
                    "Callable[None,None]",
                    "int",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "MetadataField.collate": {
            "name": "collate",
            "location": 17,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "MetadataField.to": {
            "name": "to",
            "location": 20,
            "return": [
                "Dict",
                "float",
                "int",
                "IO",
                "str",
                "List[str]",
                "Iterator"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Dict",
                    "IO",
                    "List[str]",
                    "int",
                    "Iterator",
                    "Iterator[Dict[str,str]]",
                    "torch.device"
                ],
                "device": [
                    "Dict",
                    "IO",
                    "List[str]",
                    "int",
                    "Iterator",
                    "Iterator[Dict[str,str]]",
                    "torch.device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/roles_field.py": {
        "RolesField.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "type": [
                    "str"
                ]
            }
        },
        "RolesField.index": {
            "name": "index",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "RolesField.tensorize": {
            "name": "tensorize",
            "location": 26,
            "return": [
                "RolesFieldOutput",
                "List[str]",
                "str",
                "Awaitable"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "RolesField.collate": {
            "name": "collate",
            "location": 37,
            "return": [
                "RolesFieldOutput",
                "str",
                "int",
                "List"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "Callable[,None]",
                    "int"
                ]
            }
        },
        "RolesField.to": {
            "name": "to",
            "location": 49,
            "return": [
                "RolesFieldOutput",
                "str",
                "bytes",
                "int",
                "Union[str,bytes]"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "Optional[int]",
                    "int",
                    "gluonts.model.common.Tensor",
                    "None"
                ],
                "device": [
                    "Optional[int]",
                    "int",
                    "gluonts.model.common.Tensor",
                    "None"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/typed_dgl_graph_field.py": {
        "TypedDGLGraphField.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Callable"
                ],
                "type": [
                    "str",
                    "Callable"
                ],
                "edge_types": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "TypedDGLGraphField.tensorize": {
            "name": "tensorize",
            "location": 25,
            "return": [
                "TypedDGLGraphFieldOutput",
                "Dict[str,Any]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "bool",
                    "str",
                    "formatml.parsing.parser.Nodes",
                    "int",
                    "tensorflow.Tensor"
                ]
            }
        },
        "TypedDGLGraphField.collate": {
            "name": "collate",
            "location": 61,
            "return": [
                "TypedDGLGraphFieldOutput",
                "Dict[str,Any]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "str",
                    "Dict",
                    "T",
                    "Union[Callable,Coroutine]",
                    "Callable"
                ]
            }
        },
        "TypedDGLGraphField.to": {
            "name": "to",
            "location": 70,
            "return": [
                "TypedDGLGraphFieldOutput",
                "bool",
                "List[Dict[str,Any]]",
                "Dict[str,Any]"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "bool",
                    "float",
                    "torch.device"
                ],
                "device": [
                    "bool",
                    "float",
                    "torch.device"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/__init__.py": {},
    "formatml-master/formatml/data/fields/tests/conftest.py": {
        "nodes": {
            "name": "nodes",
            "location": 10,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "other_nodes": {
            "name": "other_nodes",
            "location": 16,
            "return": [
                "bool",
                "pathlib.Path"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/data/fields/tests/test_dgl_graph_field.py": {
        "_make_field": {
            "name": "_make_field",
            "location": 7,
            "return": [
                "formatml.data.fields.typed_dgl_graph_field.TypedDGLGraphField"
            ],
            "arguments": {
                "edge_types": [
                    "List[str]",
                    "str",
                    "Dict[str,str]",
                    "Dict[int,str]",
                    "int"
                ]
            }
        },
        "test_graph_field": {
            "name": "test_graph_field",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "float",
                    "int",
                    "str",
                    "Sequence[float]",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "test_no_edge_types": {
            "name": "test_no_edge_types",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "int",
                    "float",
                    "List",
                    "List[allennlp.data.fields.production_rule_field.ProductionRule]",
                    "str",
                    "Callable",
                    "bool"
                ]
            }
        },
        "test_symmetric_edge_types": {
            "name": "test_symmetric_edge_types",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "Callable",
                    "str",
                    "int"
                ]
            }
        },
        "test_collate": {
            "name": "test_collate",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "nodes": [
                    "bool",
                    "str",
                    "Hashable",
                    "Union[str,int]"
                ],
                "other_nodes": [
                    "bool",
                    "str",
                    "Hashable",
                    "Union[str,int]"
                ]
            }
        }
    },
    "formatml-master/formatml/data/fields/tests/__init__.py": {},
    "formatml-master/formatml/data/types/codrep_label.py": {
        "CodRepLabel.to_tree": {
            "name": "to_tree",
            "location": 8,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "CodRepLabel.from_tree": {
            "name": "from_tree",
            "location": 14,
            "return": [
                "CodRepLabel",
                "Optional[Dict[str,str]]",
                "Dict",
                "int",
                "Dict[str,Any]"
            ],
            "arguments": {
                "tree": [
                    "str",
                    "Dict[str,Any]",
                    "List",
                    "List[str]"
                ]
            }
        }
    },
    "formatml-master/formatml/data/types/__init__.py": {},
    "formatml-master/formatml/datasets/codrep_dataset.py": {
        "CodRepDataset.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CodRepDataset.__getitem__": {
            "name": "__getitem__",
            "location": 14,
            "return": [
                "int",
                "bool",
                "Optional[float]",
                "Dict[str, str]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "int"
                ]
            }
        },
        "CodRepDataset.__len__": {
            "name": "__len__",
            "location": 18,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/datasets/dataset.py": {
        "Dataset.download": {
            "name": "download",
            "location": 7,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.pre_tensorize": {
            "name": "pre_tensorize",
            "location": 10,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.tensorize": {
            "name": "tensorize",
            "location": 13,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.collate": {
            "name": "collate",
            "location": 16,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        }
    },
    "formatml-master/formatml/datasets/repositories_dataset.py": {
        "RepositoriesDataset.__init__": {
            "name": "__init__",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "download_dir": [
                    "str",
                    "int",
                    "Callable",
                    "List[Tuple[str,str,str]]",
                    "List[tuple[Union[str,str,str]]]"
                ],
                "parse_dir": [
                    "str",
                    "int",
                    "Callable",
                    "List[Tuple[str,str,str]]",
                    "List[tuple[Union[str,str,str]]]"
                ],
                "tensor_dir": [
                    "str",
                    "int",
                    "Callable",
                    "List[Tuple[str,str,str]]",
                    "List[tuple[Union[str,str,str]]]"
                ],
                "repositories": [
                    "str",
                    "List[tuple[Union[str,str,str]]]",
                    "int",
                    "List[Tuple[str,str,str]]",
                    "Callable"
                ],
                "instance": [
                    "str",
                    "int",
                    "formatml.data.instance.Instance",
                    "List[tuple[Union[str,str,str]]]",
                    "List[Tuple[str,str,str]]"
                ],
                "parser": [
                    "str",
                    "int",
                    "Callable",
                    "List[Tuple[str,str,str]]",
                    "List[tuple[Union[str,str,str]]]"
                ],
                "parallel_downloads": [
                    "int",
                    "Optional[str]",
                    "Optional[Dict[str,Any]]",
                    "Container[str]",
                    "bool",
                    "Optional[List[Any]]",
                    "Iterable[str]",
                    "str"
                ],
                "bblfsh_endpoint": [
                    "Text",
                    "str",
                    "int",
                    "List[Tuple[str,str,str]]",
                    "Callable"
                ],
                "n_workers": [
                    "str",
                    "bool",
                    "Callable",
                    "None",
                    "int",
                    "Optional[str]"
                ],
                "pickle_protocol": [
                    "int",
                    "str",
                    "List[Tuple[str,str,str]]",
                    "Callable"
                ]
            }
        },
        "RepositoriesDataset.download": {
            "name": "download",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset.pre_tensorize": {
            "name": "pre_tensorize",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset.tensorize": {
            "name": "tensorize",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset.collate": {
            "name": "collate",
            "location": 66,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "RepositoriesDataset.__getitem__": {
            "name": "__getitem__",
            "location": 69,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "int",
                    "Sequence[float]",
                    "str",
                    "List[int]",
                    "List",
                    "List[float]"
                ]
            }
        },
        "RepositoriesDataset.__len__": {
            "name": "__len__",
            "location": 83,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoriesDataset._compute_cumulative_lengths": {
            "name": "_compute_cumulative_lengths",
            "location": 89,
            "return": [
                "List[int]"
            ],
            "arguments": {
                "sequences": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "RepositoriesDataset._download_repository": {
            "name": "_download_repository",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "repository": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/datasets/repository_dataset.py": {
        "RepositoryDataset.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.download": {
            "name": "download",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.pre_tensorize": {
            "name": "pre_tensorize",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.tensorize": {
            "name": "tensorize",
            "location": 116,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset.collate": {
            "name": "collate",
            "location": 147,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "tensors": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "RepositoryDataset.__getitem__": {
            "name": "__getitem__",
            "location": 150,
            "return": [
                "int",
                "List[List[int]]",
                "List[str]",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "str",
                    "int"
                ]
            }
        },
        "RepositoryDataset.__len__": {
            "name": "__len__",
            "location": 154,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "RepositoryDataset._tensorize_worker": {
            "name": "_tensorize_worker",
            "location": 157,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str",
                    "pathlib.Path"
                ]
            }
        }
    },
    "formatml-master/formatml/datasets/__init__.py": {},
    "formatml-master/formatml/models/codrep_model.py": {
        "CodRepModel.__init__": {
            "name": "__init__",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "graph_embedder": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "float",
                    "Hashable",
                    "str"
                ],
                "graph_encoder": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "float",
                    "Hashable",
                    "str"
                ],
                "class_projection": [
                    "bool",
                    "Sequence[Sequence[float]]",
                    "float",
                    "Hashable",
                    "str"
                ],
                "graph_field_name": [
                    "bool",
                    "str",
                    "int"
                ],
                "feature_field_names": [
                    "bool",
                    "str",
                    "int"
                ],
                "indexes_field_name": [
                    "bool",
                    "str",
                    "int"
                ],
                "label_field_name": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "CodRepModel.forward": {
            "name": "forward",
            "location": 45,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "str",
                    "Dict"
                ]
            }
        },
        "CodRepModel.decode": {
            "name": "decode",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CodRepModel.build_metadata": {
            "name": "build_metadata",
            "location": 101,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/models/gnn_rnn_model.py": {
        "GNNRNNModel.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "graph_embedder": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "Optional[str]"
                ],
                "graph_encoder": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "Optional[str]"
                ],
                "output_embedder": [
                    "int",
                    "Dict[str,Any]",
                    "Tuple",
                    "Callable",
                    "List[AnyStr]"
                ],
                "decoder": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "Optional[str]"
                ],
                "class_projection": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "Optional[str]"
                ],
                "graph_field_name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Optional[Dict]",
                    "Dict",
                    "Optional[List[str]]",
                    "List[str]"
                ],
                "feature_field_names": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Optional[Dict]",
                    "Dict",
                    "Optional[List[str]]",
                    "List[str]"
                ],
                "label_field_name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Optional[Dict]",
                    "Dict",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "GNNRNNModel.forward": {
            "name": "forward",
            "location": 46,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "Type"
                ]
            }
        }
    },
    "formatml-master/formatml/models/model.py": {
        "Model.forward": {
            "name": "forward",
            "location": 9,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        }
    },
    "formatml-master/formatml/models/__init__.py": {},
    "formatml-master/formatml/modules/__init__.py": {},
    "formatml-master/formatml/modules/decoders/concat_conditioning_decoder.py": {
        "ConcatConditioningDecoder.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "recurrent": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ConcatConditioningDecoder.forward": {
            "name": "forward",
            "location": 15,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "torch.Tensor",
                    "torch.nn.utils.rnn.PackedSequence"
                ],
                "conditions": [
                    "int",
                    "Tuple[float,float]",
                    "Tuple[Union[float,float]]"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/decoders/decoder.py": {},
    "formatml-master/formatml/modules/decoders/__init__.py": {},
    "formatml-master/formatml/modules/graph_encoders/ggnn.py": {
        "GGNN.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "in_feats": [
                    "int",
                    "float",
                    "bool"
                ],
                "out_feats": [
                    "int",
                    "float",
                    "Sequence"
                ],
                "n_steps": [
                    "int",
                    "float",
                    "bool"
                ],
                "n_etypes": [
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "bias": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "GGNN.forward": {
            "name": "forward",
            "location": 36,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "graph": [],
                "feat": [
                    "float"
                ],
                "etypes": [
                    "int"
                ]
            }
        },
        "GGNN._message": {
            "name": "_message",
            "location": 65,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "edge_type": [
                    "str",
                    "bool",
                    "ForwardRef",
                    "torch.Tensor"
                ],
                "edge_batch": [
                    "str",
                    "bool",
                    "ForwardRef",
                    "torch.Tensor"
                ]
            }
        },
        "GGNN._update": {
            "name": "_update",
            "location": 68,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "node_batch": [
                    "str",
                    "Callable[T,None]",
                    "tensorflow.Tensor",
                    "Callable[[T],None]"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/graph_encoders/graph_encoder.py": {
        "GraphEncoder.forward": {
            "name": "forward",
            "location": 9,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/modules/graph_encoders/__init__.py": {},
    "formatml-master/formatml/modules/misc/graph_embedding.py": {
        "GraphEmbedding.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dimensions": [
                    "int",
                    "float",
                    "bool"
                ],
                "vocabularies": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "GraphEmbedding.forward": {
            "name": "forward",
            "location": 24,
            "return": [
                "int",
                "Callable",
                "str",
                "float",
                "Callable[g,collections.abc.Awaitable[Any]]",
                "bool",
                "Tuple[Union[float,float,float]]",
                "List"
            ],
            "arguments": {
                "self": [],
                "graph": [
                    "float",
                    "str",
                    "Callable[g,collections.abc.Awaitable[Any]]",
                    "Callable[...,Awaitable[Any]]",
                    "bool",
                    "List",
                    "dgl.DGLGraph",
                    "Tuple[Union[float,float,float]]",
                    "Tuple[float,float,float]"
                ],
                "features": [
                    "bool",
                    "List[torch.Tensor]",
                    "dgl.DGLGraph"
                ]
            }
        },
        "GraphEmbedding._configure": {
            "name": "_configure",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "example_features": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/item_getter.py": {
        "ItemGetter.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "index": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "ItemGetter.forward": {
            "name": "forward",
            "location": 12,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/packed_embedding.py": {
        "PackedEmbedding.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dimension": [
                    "List[int]",
                    "int",
                    "str"
                ],
                "vocabulary": [
                    "List[int]",
                    "int",
                    "str"
                ]
            }
        },
        "PackedEmbedding.forward": {
            "name": "forward",
            "location": 14,
            "return": [
                "PackedSequence",
                "str",
                "List[dict]",
                "int"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "raiden.utils.Address"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/selector.py": {
        "Selector.forward": {
            "name": "forward",
            "location": 8,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/modules/misc/squeezer.py": {
        "Squeezer.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ]
            }
        },
        "Squeezer.forward": {
            "name": "forward",
            "location": 14,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/unsqueezer.py": {
        "Unsqueezer.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dim": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Unsqueezer.forward": {
            "name": "forward",
            "location": 12,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "tensor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "formatml-master/formatml/modules/misc/vocabulary_linear.py": {
        "VocabularyLinear.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/modules/misc/__init__.py": {},
    "formatml-master/formatml/parsing/javascript_parser.py": {},
    "formatml-master/formatml/parsing/java_parser.py": {
        "_remove_children": {
            "name": "_remove_children",
            "location": 114,
            "return": [
                "Dict",
                "float",
                "str"
            ],
            "arguments": {
                "bblfsh_node": [
                    "Dict",
                    "bblfsh.Node"
                ]
            }
        },
        "_exclude_if_empty": {
            "name": "_exclude_if_empty",
            "location": 122,
            "return": [
                "Optional[_T0]"
            ],
            "arguments": {
                "bblfsh_node": [
                    "Dict",
                    "bblfsh.Node"
                ]
            }
        }
    },
    "formatml-master/formatml/parsing/parser.py": {
        "Node.__init__": {
            "name": "__init__",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Node.__repr__": {
            "name": "__repr__",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Nodes.to_tree": {
            "name": "to_tree",
            "location": 72,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "file_content": []
            }
        },
        "Nodes.from_token_nodes": {
            "name": "from_token_nodes",
            "location": 108,
            "return": [
                "Any"
            ],
            "arguments": {
                "token_nodes": []
            }
        },
        "Nodes.from_tree": {
            "name": "from_tree",
            "location": 135,
            "return": [
                "Any"
            ],
            "arguments": {
                "tree": []
            }
        },
        "BblfshNodeConverter.__init__": {
            "name": "__init__",
            "location": 182,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "file_content": [],
                "convert_to_utf8": []
            }
        },
        "BblfshNodeConverter.bblfsh_node_to_node": {
            "name": "bblfsh_node_to_node",
            "location": 193,
            "return": [
                "Node"
            ],
            "arguments": {
                "self": [],
                "bblfsh_node": [],
                "parent": []
            }
        },
        "Parser.__init_subclass__": {
            "name": "__init_subclass__",
            "location": 227,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [],
                "bblfsh_language": [],
                "reserved": [],
                "uast_fixers": [],
                "convert_to_utf8": []
            }
        },
        "Parser.__init__": {
            "name": "__init__",
            "location": 243,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "bblfshd_endpoint": [],
                "split_formatting": []
            }
        },
        "Parser.split_formatting": {
            "name": "split_formatting",
            "location": 265,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Parser.parse": {
            "name": "parse",
            "location": 268,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "repository_path": [],
                "file_path": []
            }
        },
        "Parser._augment_tokens": {
            "name": "_augment_tokens",
            "location": 405,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "tokens": []
            }
        },
        "Parser._find_parent": {
            "name": "_find_parent",
            "location": 456,
            "return": [
                "Any"
            ],
            "arguments": {
                "node_index": [],
                "nodes": [],
                "closest_left_node": []
            }
        },
        "Parser._perform_split_formatting": {
            "name": "_perform_split_formatting",
            "location": 487,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "nodes": []
            }
        },
        "Parser.__del__": {
            "name": "__del__",
            "location": 512,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/parsing/__init__.py": {},
    "formatml-master/formatml/pipelines/pipeline.py": {
        "register_step": {
            "name": "register_step",
            "location": 18,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "pipeline_name": [
                    "bool",
                    "str",
                    "Callable[[argparse.ArgumentParser], None]",
                    "list",
                    "Sequence[str]"
                ],
                "parser_definer": [
                    "bool",
                    "str",
                    "Callable[[argparse.ArgumentParser], None]",
                    "list",
                    "Sequence[str]"
                ],
                "graceful_keyboard_interruption": [
                    "bool",
                    "str",
                    "Callable[[argparse.ArgumentParser],None]",
                    "List",
                    "Sequence[str]"
                ]
            }
        },
        "_define_parser": {
            "name": "_define_parser",
            "location": 40,
            "return": [
                "argparse.ArgumentParser"
            ],
            "arguments": {}
        },
        "parse_args": {
            "name": "parse_args",
            "location": 64,
            "return": [
                "Tuple[(Any, Dict[(str, Any)], Any)]"
            ],
            "arguments": {}
        },
        "register_step.wrapper": {
            "name": "wrapper",
            "location": 23,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "handler": [
                    "Callable",
                    "dict",
                    "Optional[Union[str, Any, Any, Any]]"
                ]
            }
        }
    },
    "formatml-master/formatml/pipelines/__init__.py": {},
    "formatml-master/formatml/pipelines/codrep/cli_builder.py": {
        "CLIBuilder.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "parser": [
                    "str",
                    "argparse.ArgumentParser"
                ]
            }
        },
        "CLIBuilder.add_configs_dir": {
            "name": "add_configs_dir",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_raw_dir": {
            "name": "add_raw_dir",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_tensors_dir": {
            "name": "add_tensors_dir",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_uasts_dir": {
            "name": "add_uasts_dir",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CLIBuilder.add_instance_file": {
            "name": "add_instance_file",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "formatml-master/formatml/pipelines/codrep/index.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ]
            }
        },
        "index": {
            "name": "index",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/pipelines/codrep/parse.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser",
                    "str"
                ]
            }
        },
        "parse": {
            "name": "parse",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/pipelines/codrep/run.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ]
            }
        },
        "run": {
            "name": "run",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/pipelines/codrep/tensorize.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ]
            }
        },
        "tensorize": {
            "name": "tensorize",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "_tensorize_worker": {
            "name": "_tensorize_worker",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ],
                "instance": [
                    "float"
                ],
                "logger": [
                    "str",
                    "Optional[str]"
                ],
                "uasts_dir_path": [
                    "str",
                    "bool",
                    "pathlib.Path"
                ],
                "output_dir_path": [
                    "str"
                ],
                "pickle_protocol": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Optional[int]",
                    "int"
                ]
            }
        }
    },
    "formatml-master/formatml/pipelines/codrep/train.py": {
        "add_arguments_to_parser": {
            "name": "add_arguments_to_parser",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ]
            }
        },
        "train": {
            "name": "train",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "build_model": {
            "name": "build_model",
            "location": 237,
            "return": [
                "formatml.models.codrep_model.CodRepModel"
            ],
            "arguments": {
                "instance": [
                    "str",
                    "float",
                    "type",
                    "raiden.utils.ChainID",
                    "bool"
                ],
                "model_encoder_iterations": [
                    "int",
                    "str"
                ],
                "model_encoder_output_dim": [
                    "int",
                    "Union[int, None]"
                ],
                "model_encoder_message_dim": [
                    "int",
                    "bool",
                    "Callable"
                ],
                "model_decoder_type": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "formatml-master/formatml/pipelines/codrep/__init__.py": {},
    "formatml-master/formatml/resources/resource.py": {
        "Context.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cache_dir": [
                    "None",
                    "str",
                    "pathlib.Path",
                    "Optional[str]",
                    "Optional[pathlib.Path]"
                ]
            }
        },
        "Context.register_resource": {
            "name": "register_resource",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "resource": [
                    "str",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "Context.get_resource": {
            "name": "get_resource",
            "location": 39,
            "return": [
                "str",
                "dict",
                "List[str]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Context.save_resources": {
            "name": "save_resources",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Context.save_resource": {
            "name": "save_resource",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "resource": [
                    "str",
                    "float",
                    "int",
                    "Union[float, int]"
                ]
            }
        },
        "Context._name_cache_path": {
            "name": "_name_cache_path",
            "location": 63,
            "return": [
                "str",
                "pypi2nix.path.Path",
                "Dict[str, pathlib.Path]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "BinaryIO",
                    "norfs.fs.base.Path",
                    "Union[str, pathlib.Path]"
                ]
            }
        },
        "Context._resource_cache_path": {
            "name": "_resource_cache_path",
            "location": 66,
            "return": [
                "str",
                "pathlib.Path",
                "dict",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "resource": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "formatml-master/formatml/resources/__init__.py": {},
    "formatml-master/formatml/training/trainer.py": {
        "register_metric": {
            "name": "register_metric",
            "location": 35,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "typing.Iterable[str]",
                    "bool"
                ]
            }
        },
        "_cross_entropy": {
            "name": "_cross_entropy",
            "location": 44,
            "return": [
                "Any"
            ],
            "arguments": {
                "sample": []
            }
        },
        "_perplexity": {
            "name": "_perplexity",
            "location": 49,
            "return": [
                "int"
            ],
            "arguments": {
                "sample": []
            }
        },
        "_mrr": {
            "name": "_mrr",
            "location": 54,
            "return": [
                "float"
            ],
            "arguments": {
                "sample": []
            }
        },
        "_accuracy_max_decoding": {
            "name": "_accuracy_max_decoding",
            "location": 79,
            "return": [
                "Any"
            ],
            "arguments": {
                "sample": []
            }
        },
        "register_metric.wrapper": {
            "name": "wrapper",
            "location": 36,
            "return": [],
            "arguments": {
                "metric": []
            }
        },
        "Trainer.__init__": {
            "name": "__init__",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "instance": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "model": [],
                "optimizer": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "scheduler": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "epochs": [
                    "str",
                    "int",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "tuple[typing.Union[float,float]]",
                    "tuple[typing.Union[int,int,int]]",
                    "str"
                ],
                "run_dir_path": [
                    "int"
                ],
                "eval_every": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "limit_epochs_at": [
                    "str",
                    "bool",
                    "None",
                    "dict[str, str]"
                ],
                "train_eval_split": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "metric_names": [
                    "list[]",
                    "dict[, ]",
                    "list[str]"
                ],
                "selection_metric": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "kept_checkpoints": [
                    "str",
                    "list[list[str]]",
                    "bool",
                    "float"
                ],
                "cuda_device": [
                    "str",
                    "None",
                    "bool",
                    "list[str]"
                ]
            }
        },
        "Trainer.train": {
            "name": "train",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._train_epoch": {
            "name": "_train_epoch",
            "location": 185,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ]
            }
        },
        "Trainer._eval_epoch": {
            "name": "_eval_epoch",
            "location": 213,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int"
                ]
            }
        },
        "Trainer._save_checkpoint": {
            "name": "_save_checkpoint",
            "location": 235,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "bool",
                    "dict[, ]",
                    "str",
                    "tuple[tuple[typing.Union[str,...]]]"
                ],
                "score": [
                    "str",
                    "bool",
                    "typing.BinaryIO",
                    "bytes"
                ],
                "iteration": [
                    "None",
                    "bool",
                    "dict[, ]",
                    "str",
                    "tuple[tuple[typing.Union[str,...]]]"
                ]
            }
        },
        "Trainer._compute_metrics": {
            "name": "_compute_metrics",
            "location": 274,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "bool",
                    "str",
                    "dict[str, int]"
                ],
                "data_type": [
                    "bool",
                    "str",
                    "dict[str, int]"
                ],
                "accumulate": [
                    "bool",
                    "str",
                    "dict[str, int]"
                ],
                "send_event": [
                    "bool",
                    "str",
                    "dict[str, int]"
                ],
                "epoch": [
                    "bool",
                    "str",
                    "dict[str, int]"
                ],
                "iteration": [
                    "bool",
                    "str",
                    "dict[str, int]"
                ]
            }
        },
        "Trainer._log_accumulated_metrics": {
            "name": "_log_accumulated_metrics",
            "location": 293,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "data_type": [
                    "int",
                    "None",
                    "str"
                ],
                "send_event": [
                    "str"
                ],
                "epoch": [
                    "str"
                ],
                "iteration": [
                    "str"
                ],
                "dont_reset_accumulated": [
                    "bool"
                ]
            }
        },
        "Trainer._log_values": {
            "name": "_log_values",
            "location": 318,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._average": {
            "name": "_average",
            "location": 354,
            "return": [
                "float",
                "None"
            ],
            "arguments": {
                "values": []
            }
        },
        "Trainer._reset_accumulated": {
            "name": "_reset_accumulated",
            "location": 357,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data_type": [
                    "str",
                    "typing.Type",
                    "bool",
                    "list[list[str]]"
                ]
            }
        },
        "Trainer.__del__": {
            "name": "__del__",
            "location": 360,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Trainer._save_checkpoint.save": {
            "name": "save",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "formatml-master/formatml/training/__init__.py": {},
    "formatml-master/formatml/utils/config.py": {
        "Config.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Config.save": {
            "name": "save",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "pathlib.Path"
                ]
            }
        },
        "Config.from_arguments": {
            "name": "from_arguments",
            "location": 20,
            "return": [
                "Config"
            ],
            "arguments": {
                "arguments": [
                    "bool",
                    "Optional[bool]",
                    "List[dict]"
                ],
                "data_arguments": [
                    "Iterable[str]",
                    "bool",
                    "dict"
                ],
                "config_argument": [
                    "Dict[str, Any]",
                    "Optional[str]",
                    "Dict[Any, pathlib.Path]"
                ]
            }
        },
        "Config.from_json": {
            "name": "from_json",
            "location": 31,
            "return": [
                "Config"
            ],
            "arguments": {
                "json_path": [
                    "pathlib.Path",
                    "Union[pathlib.Path, str]"
                ]
            }
        }
    },
    "formatml-master/formatml/utils/helpers.py": {
        "setup_logging": {
            "name": "setup_logging",
            "location": 20,
            "return": [
                "logging.Logger"
            ],
            "arguments": {
                "name": [
                    "str"
                ],
                "log_level": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "get_sha_and_dirtiness": {
            "name": "get_sha_and_dirtiness",
            "location": 30,
            "return": [
                "Optional[Tuple[(Any, bool)]]"
            ],
            "arguments": {
                "prompt_on_dirty": [
                    "bool",
                    "str",
                    "T",
                    "Dict"
                ]
            }
        },
        "date_template_to_path": {
            "name": "date_template_to_path",
            "location": 68,
            "return": [
                "pathlib.Path"
            ],
            "arguments": {
                "date_template": [
                    "str",
                    "datetime.timezone",
                    "datetime.datetime",
                    "datetime.date"
                ]
            }
        },
        "get_generic_arguments": {
            "name": "get_generic_arguments",
            "location": 72,
            "return": [
                "tuple"
            ],
            "arguments": {
                "cls": [
                    "Type[Any]",
                    "List",
                    "Type"
                ],
                "subclass": [
                    "Type[Any]",
                    "int",
                    "Type"
                ]
            }
        },
        "istypevar": {
            "name": "istypevar",
            "location": 113,
            "return": [
                "Tuple",
                "bool"
            ],
            "arguments": {
                "obj": [
                    "int",
                    "bytes"
                ]
            }
        },
        "ShortNameFilter.filter": {
            "name": "filter",
            "location": 15,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "record": [
                    "List[pathlib.Path]",
                    "str",
                    "logging.LogRecord",
                    "int",
                    "pathlib.Path"
                ]
            }
        },
        "get_sha_and_dirtiness.to_str": {
            "name": "to_str",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "string": [
                    "Union[str, bytes]",
                    "str"
                ]
            }
        },
        "get_sha_and_dirtiness.print_files": {
            "name": "print_files",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "filenames": [
                    "str",
                    "Optional[str]",
                    "Path"
                ]
            }
        }
    },
    "formatml-master/formatml/utils/torch_helpers.py": {
        "unpack_packed_sequence": {
            "name": "unpack_packed_sequence",
            "location": 15,
            "return": [
                "list"
            ],
            "arguments": {
                "packed_sequence": [
                    "int",
                    "List[tuple[Union[float,Any]]]",
                    "torch.nn.utils.rnn.PackedSequence",
                    "List[Tuple[float,Any]]",
                    "bool"
                ]
            }
        },
        "data_if_packed": {
            "name": "data_if_packed",
            "location": 29,
            "return": [
                "str",
                "PackedSequence",
                "raiden.utils.signer.Signer",
                "Optional[float]",
                "IO[bytes]",
                "bool",
                "Dict",
                "Optional[Dict[str,Any]]"
            ],
            "arguments": {
                "input": [
                    "str"
                ]
            }
        },
        "log_grad_flow": {
            "name": "log_grad_flow",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "named_parameters": [
                    "str",
                    "Set[str]",
                    "Optional[dict]",
                    "Dict"
                ],
                "writer": [
                    "int",
                    "str",
                    "Dict[str,Any]",
                    "Optional[List[str]]",
                    "List[str]",
                    "None"
                ],
                "iteration": [
                    "int",
                    "str",
                    "Dict[str,Any]",
                    "Optional[List[str]]",
                    "List[str]",
                    "None"
                ]
            }
        }
    },
    "formatml-master/formatml/utils/__init__.py": {}
}
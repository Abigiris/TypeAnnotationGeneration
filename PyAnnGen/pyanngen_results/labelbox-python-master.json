{
    "labelbox-python-master/setup.py": {},
    "labelbox-python-master/docs/source/conf.py": {},
    "labelbox-python-master/examples/format_notebooks.py": {
        "format_cell": {
            "name": "format_cell",
            "location": 40,
            "return": [
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "source": [
                    "str",
                    "int"
                ]
            }
        },
        "add_headers": {
            "name": "add_headers",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "file_name": [
                    "str"
                ]
            }
        },
        "format_file": {
            "name": "format_file",
            "location": 67,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "file_name": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/examples/integrations/databricks/labelbox_databricks_example.py": {},
    "labelbox-python-master/examples/integrations/detectron2/coco_utils.py": {
        "get_annotations": {
            "name": "get_annotations",
            "location": 15,
            "return": [
                "list",
                "bool",
                "Optional[dict]",
                "List[Dict[str, Any]]",
                "frozenset",
                "str",
                "int",
                "Counter"
            ],
            "arguments": {
                "images": [
                    "numpy.ndarray",
                    "Tuple[float, float]",
                    "float"
                ],
                "all_annotations": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "partition_indices": {
            "name": "partition_indices",
            "location": 22,
            "return": [
                "",
                "typing.Generator[tuple[int]]"
            ],
            "arguments": {
                "total_n": [
                    "int",
                    "str"
                ],
                "splits": [
                    "int",
                    "str"
                ]
            }
        },
        "partition_coco": {
            "name": "partition_coco",
            "location": 37,
            "return": [
                "list[dict[typing.Text, ]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "coco_instance_data": [
                    "int",
                    "list",
                    "str",
                    "dict",
                    "List[int]",
                    "List[Dict[str, Any]]"
                ],
                "coco_panoptic_data": [
                    "None",
                    "int",
                    "Optional[Sequence]",
                    "bool"
                ],
                "splits": [
                    "None",
                    "List[str]",
                    "bytes",
                    "Callable",
                    "Sequence[Sequence[float]]",
                    "numpy.ndarray"
                ]
            }
        },
        "visualize_object_inferences": {
            "name": "visualize_object_inferences",
            "location": 61,
            "return": [
                "str",
                "numpy.ndarray",
                "float",
                "PIL.Image",
                "Optional[numpy.ndarray]"
            ],
            "arguments": {
                "metadata_catalog": [
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]"
                ],
                "coco_examples": [
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]"
                ],
                "predictor": [
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]"
                ],
                "scale": [
                    "float",
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]"
                ],
                "max_images": [
                    "int",
                    "str",
                    "Optional[int]",
                    "bool",
                    "float",
                    "Sequence[int]"
                ],
                "resize_dims": [
                    "tuple[int]",
                    "List[List[int]]",
                    "List[dict]",
                    "List[str]",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "visualize_coco_examples": {
            "name": "visualize_coco_examples",
            "location": 79,
            "return": [
                "str",
                "numpy.ndarray",
                "float",
                "PIL.Image",
                "Optional[numpy.ndarray]"
            ],
            "arguments": {
                "metadata_catalog": [
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]",
                    "List[utils.CWLObjectType]"
                ],
                "object_examples": [
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]",
                    "List[utils.CWLObjectType]"
                ],
                "panoptic_examples": [
                    "Optional[float]",
                    "None"
                ],
                "scale": [
                    "float",
                    "str",
                    "bool",
                    "Optional[Callable[[Any], None]]",
                    "List[utils.CWLObjectType]"
                ],
                "max_images": [
                    "int",
                    "str",
                    "Optional[int]",
                    "bool",
                    "float",
                    "Sequence[int]"
                ],
                "resize_dims": [
                    "tuple[int]",
                    "List[List[int]]",
                    "List[int]",
                    "List[str]",
                    "List[dict]",
                    "numpy.array"
                ]
            }
        },
        "_process_panoptic_to_semantic": {
            "name": "_process_panoptic_to_semantic",
            "location": 103,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "input_panoptic": [
                    "str",
                    "bytes",
                    "int"
                ],
                "output_semantic": [
                    "int",
                    "str",
                    "bytes",
                    "Dict[str, str]"
                ],
                "segments": [
                    "str",
                    "Optional[str]",
                    "int",
                    "bool",
                    "List[str]"
                ],
                "id_map": [
                    "str",
                    "int",
                    "list",
                    "set",
                    "Dict[str, int]"
                ]
            }
        },
        "separate_coco_semantic_from_panoptic": {
            "name": "separate_coco_semantic_from_panoptic",
            "location": 116,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "panoptic_json": [
                    "bool"
                ],
                "panoptic_root": [
                    "bool"
                ],
                "sem_seg_root": [
                    "bool"
                ],
                "categories": [
                    "bool"
                ]
            }
        },
        "separate_coco_semantic_from_panoptic.iter_annotations": {
            "name": "iter_annotations",
            "location": 148,
            "return": [
                "",
                "typing.Generator[tuple]"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/examples/model_assisted_labeling/image_mal_utils.py": {
        "visualize_bbox_ndjsons": {
            "name": "visualize_bbox_ndjsons",
            "location": 9,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "int"
                ],
                "bbox_ndjsons": [
                    "numpy.ndarray",
                    "PIL.Image.Image",
                    "str",
                    "numpy.array",
                    "PIL.Image",
                    "int",
                    "Tuple[int, int, int]"
                ],
                "color": [
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "visualize_poly_ndjsons": {
            "name": "visualize_poly_ndjsons",
            "location": 36,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "image": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "io.BytesIO"
                ],
                "poly_ndjsons": [
                    "numpy.ndarray",
                    "PIL.Image.Image",
                    "str",
                    "numpy.array",
                    "PIL.Image",
                    "int",
                    "Tuple[int, int, int]"
                ],
                "color": [
                    "str",
                    "numpy.ndarray",
                    "int",
                    "io.BytesIO"
                ]
            }
        },
        "visualize_point_ndjsons": {
            "name": "visualize_point_ndjsons",
            "location": 57,
            "return": [
                "str",
                "int",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "int",
                    "Image"
                ],
                "point_ndjsons": [
                    "numpy.ndarray",
                    "PIL.Image.Image",
                    "str",
                    "numpy.array",
                    "PIL.Image",
                    "int",
                    "Tuple[int, int, int]"
                ],
                "color": [
                    "numpy.ndarray",
                    "int",
                    "Image"
                ]
            }
        },
        "visualize_mask_ndjsons": {
            "name": "visualize_mask_ndjsons",
            "location": 80,
            "return": [
                "str",
                "numpy.ndarray",
                "float"
            ],
            "arguments": {
                "image": [
                    "numpy.ndarray",
                    "io.BytesIO",
                    "_types.Image",
                    "str"
                ],
                "mask_ndjsons": [
                    "numpy.ndarray",
                    "PIL.Image.Image",
                    "str",
                    "numpy.array",
                    "PIL.Image",
                    "int",
                    "Tuple[int, int, int]"
                ]
            }
        }
    },
    "labelbox-python-master/examples/model_assisted_labeling/image_model.py": {
        "load_model": {
            "name": "load_model",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "predict": {
            "name": "predict",
            "location": 21,
            "return": [
                "dict[typing.Text, ]",
                "bytes",
                "dict"
            ],
            "arguments": {
                "np_image_string": [
                    "str",
                    "int"
                ],
                "min_score": [
                    "int",
                    "float",
                    "bool"
                ],
                "height": [
                    "int",
                    "dict",
                    "Optional[float]",
                    "Optional[Set[str]]",
                    "Optional[str]"
                ],
                "width": [
                    "int",
                    "dict",
                    "Optional[float]",
                    "Optional[Set[str]]",
                    "Optional[str]"
                ]
            }
        },
        "expand_boxes": {
            "name": "expand_boxes",
            "location": 65,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "boxes": [
                    "List['cirq.Qid']",
                    "str"
                ],
                "scale": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "generate_segmentation_from_masks": {
            "name": "generate_segmentation_from_masks",
            "location": 87,
            "return": [
                "Set[str]",
                "Tuple[str]",
                "Dict[str, Any]",
                "int",
                "Sequence[float]"
            ],
            "arguments": {
                "masks": [
                    "int",
                    "bool",
                    "float",
                    "str",
                    "bytes",
                    "Optional[str]"
                ],
                "detected_boxes": [
                    "bool",
                    "numpy.array",
                    "Exception",
                    "str"
                ],
                "image_height": [],
                "image_width": [
                    "int",
                    "Optional[numpy.ndarray]",
                    "numpy.array",
                    "bool"
                ],
                "is_image_mask": [
                    "bool",
                    "tensorflow.Tensor"
                ]
            }
        }
    },
    "labelbox-python-master/examples/model_assisted_labeling/ndjson_utils.py": {
        "create_boxes_ndjson": {
            "name": "create_boxes_ndjson",
            "location": 11,
            "return": [
                "str",
                "dict[typing.Text, typing.Union[str,dict[typing.Text, int]]]"
            ],
            "arguments": {
                "datarow_id": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Optional[int]"
                ],
                "schema_id": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Optional[int]"
                ],
                "top": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Optional[int]"
                ],
                "left": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Optional[int]"
                ],
                "bottom": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Optional[int]"
                ],
                "right": [
                    "int",
                    "Iterable[int]",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "create_polygon_ndjson": {
            "name": "create_polygon_ndjson",
            "location": 39,
            "return": [
                "str",
                "dict[typing.Text, typing.Union[str,dict[typing.Text, ],list[dict[typing.Text, int]]]]"
            ],
            "arguments": {
                "datarow_id": [
                    "str",
                    "uuid.UUID",
                    "int"
                ],
                "schema_id": [
                    "str",
                    "uuid.UUID",
                    "int"
                ],
                "segmentation_mask": [
                    "str",
                    "int",
                    "bool",
                    "Optional[int]",
                    "Dict[str, int]"
                ]
            }
        },
        "create_mask_ndjson": {
            "name": "create_mask_ndjson",
            "location": 67,
            "return": [
                "str",
                "dict[typing.Text, typing.Union[str,dict[typing.Text, ]]]"
            ],
            "arguments": {
                "client": [
                    "int",
                    "Optional[str]",
                    "str",
                    "Union[int, str]"
                ],
                "datarow_id": [
                    "str",
                    "List[int]",
                    "int"
                ],
                "schema_id": [
                    "str",
                    "List[int]",
                    "int"
                ],
                "segmentation_mask": [
                    "bool",
                    "int",
                    "List[float]",
                    "list",
                    "str"
                ],
                "color": [
                    "int",
                    "Optional[int]",
                    "list"
                ]
            }
        },
        "create_point_ndjson": {
            "name": "create_point_ndjson",
            "location": 104,
            "return": [
                "str",
                "dict[typing.Text, typing.Union[str,dict[typing.Text, int]]]"
            ],
            "arguments": {
                "datarow_id": [
                    "int"
                ],
                "schema_id": [
                    "int"
                ],
                "top": [
                    "int"
                ],
                "left": [
                    "int"
                ],
                "bottom": [
                    "int"
                ],
                "right": [
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/examples/scripts/upload_documentation.py": {
        "upload_doc": {
            "name": "upload_doc",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "path": [
                    "str"
                ],
                "section": [
                    "str"
                ]
            }
        },
        "make_sections": {
            "name": "make_sections",
            "location": 55,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "sections": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "change_name": {
            "name": "change_name",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "slug": [
                    "Optional[dict]",
                    "str",
                    "Dict[str, str]",
                    "bool"
                ],
                "title": [
                    "Optional[dict]",
                    "str",
                    "Dict[str, str]",
                    "bool"
                ],
                "headers": [
                    "Optional[dict]",
                    "str",
                    "Dict[str, str]",
                    "bool"
                ],
                "hidden": [
                    "bool",
                    "Optional[dict]",
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "erase_category_docs": {
            "name": "erase_category_docs",
            "location": 92,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "cat_slug": [
                    "str",
                    "int"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 111,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "config_path": [
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/client.py": {
        "Client.__init__": {
            "name": "__init__",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "api_key": [
                    "None",
                    "Optional[bytes]",
                    "Optional[str]",
                    "bytes",
                    "Optional[int]",
                    "Optional[float]",
                    "dict"
                ],
                "endpoint": [
                    "typing.Text",
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "range",
                    "bool",
                    "int"
                ],
                "enable_experimental": [
                    "bool",
                    "Optional[datetime.datetime]",
                    "int",
                    "float",
                    "bytes"
                ],
                "app_url": [
                    "typing.Text",
                    "Optional[str]",
                    "Optional[bool]",
                    "bytes",
                    "str",
                    "datetime"
                ]
            }
        },
        "Client.execute": {
            "name": "execute",
            "location": 97,
            "return": [
                "None",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "None",
                    "str",
                    "List[str]",
                    "int"
                ],
                "params": [
                    "None",
                    "str",
                    "List[str]",
                    "int"
                ],
                "data": [
                    "None",
                    "str",
                    "List[str]",
                    "int"
                ],
                "files": [
                    "None",
                    "str",
                    "List[str]",
                    "int"
                ],
                "timeout": [
                    "float",
                    "str",
                    "List[str]",
                    "int"
                ],
                "experimental": [
                    "bool",
                    "str",
                    "List[str]",
                    "int"
                ]
            }
        },
        "Client.upload_file": {
            "name": "upload_file",
            "location": 305,
            "return": [
                "Union[str, IO]",
                "Optional[str]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        },
        "Client.upload_data": {
            "name": "upload_data",
            "location": 326,
            "return": [
                "dict",
                "str",
                "bytes",
                "Tuple[str, str]",
                "Optional[Dict[str, Any]]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "content": [
                    "str",
                    "int"
                ],
                "filename": [
                    "None",
                    "str",
                    "Dict[str, Any]"
                ],
                "content_type": [
                    "None",
                    "str",
                    "Dict[str, Any]"
                ],
                "sign": [
                    "str",
                    "bool"
                ]
            }
        },
        "Client._get_single": {
            "name": "_get_single",
            "location": 390,
            "return": [
                "str",
                "Optional[str]",
                "Type[BaseException]",
                "Sequence",
                "Type[T]",
                "Optional[Type[BaseException]]"
            ],
            "arguments": {
                "self": [],
                "db_object_type": [
                    "str",
                    "Optional[str]"
                ],
                "uid": [
                    "str",
                    "bytes",
                    "int"
                ]
            }
        },
        "Client.get_project": {
            "name": "get_project",
            "location": 411,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "project_id": [
                    "str",
                    "int"
                ]
            }
        },
        "Client.get_dataset": {
            "name": "get_dataset",
            "location": 426,
            "return": [
                "str",
                "Optional[List[str]]",
                "Optional[str]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "dataset_id": [
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "Client.get_user": {
            "name": "get_user",
            "location": 441,
            "return": [
                "Optional[str]",
                "str",
                "Dict[str, Any]",
                "Callable[[], None]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Client.get_organization": {
            "name": "get_organization",
            "location": 448,
            "return": [
                "Optional[str]",
                "bool",
                "str",
                "Callable[[], None]",
                "Optional[cmk.utils.diagnostics.DiagnosticsOptionalParameters]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Client._get_all": {
            "name": "_get_all",
            "location": 456,
            "return": [
                "PaginatedCollection",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "db_object_type": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "where": [
                    "Union[str, int]",
                    "Dict[str, Any]",
                    "Optional[Mapping[str, Any]]",
                    "Set[str]",
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[Dict]"
                ],
                "filter_deleted": [
                    "bool",
                    "str",
                    "List[str]",
                    "Optional[Dict[str, Any]]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "Client.get_projects": {
            "name": "get_projects",
            "location": 476,
            "return": [
                "str",
                "List[str]",
                "bool",
                "cmk.utils.type_defs.OptionalConfigSerial"
            ],
            "arguments": {
                "self": [],
                "where": [
                    "None",
                    "List[str]",
                    "Set[str]",
                    "Union[utils.CWLObjectType, List[utils.CWLObjectType]]",
                    "projects.models.Project"
                ]
            }
        },
        "Client.get_datasets": {
            "name": "get_datasets",
            "location": 489,
            "return": [
                "dict",
                "int",
                "tuple",
                "User",
                "Iterable[str]",
                "tracim.models.auth.User",
                "str"
            ],
            "arguments": {
                "self": [],
                "where": [
                    "None",
                    "str",
                    "int",
                    "datetime.datetime",
                    "List[str]",
                    "Sequence[T]",
                    "Callable[[T], bool]"
                ]
            }
        },
        "Client.get_labeling_frontends": {
            "name": "get_labeling_frontends",
            "location": 502,
            "return": [
                "Optional[str]",
                "bool",
                "int",
                "raiden.utils.Dict",
                "Dict[str, str]",
                "User",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "where": [
                    "None",
                    "Pattern[str]",
                    "str",
                    "dict",
                    "bytes",
                    "bool"
                ]
            }
        },
        "Client._create": {
            "name": "_create",
            "location": 515,
            "return": [
                "bool",
                "Callable[[KT], VT]",
                "models.User"
            ],
            "arguments": {
                "self": [],
                "db_object_type": [
                    "str",
                    "type",
                    "Sequence[type]",
                    "dict",
                    "bankroll.model.Option"
                ],
                "data": [
                    "str",
                    "type",
                    "Sequence[type]",
                    "dict",
                    "bankroll.model.Option"
                ]
            }
        },
        "Client.create_dataset": {
            "name": "create_dataset",
            "location": 542,
            "return": [
                "bool",
                "float"
            ],
            "arguments": {
                "self": [],
                "iam_integration": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "Client.create_project": {
            "name": "create_project",
            "location": 602,
            "return": [
                "str",
                "dict",
                "cmk.utils.type_defs.SectionName"
            ],
            "arguments": {
                "self": []
            }
        },
        "Client.get_roles": {
            "name": "get_roles",
            "location": 628,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Client.get_data_row": {
            "name": "get_data_row",
            "location": 636,
            "return": [
                "str",
                "dict",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data_row_id": [
                    "str",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        },
        "Client.get_data_row_metadata_ontology": {
            "name": "get_data_row_metadata_ontology",
            "location": 645,
            "return": [
                "DataRowMetadataOntology",
                "List[str]",
                "str",
                "int",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Client.get_model": {
            "name": "get_model",
            "location": 656,
            "return": [
                "str",
                "bool",
                "Optional[List[str]]",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "model_id": [
                    "int",
                    "str"
                ]
            }
        },
        "Client.get_models": {
            "name": "get_models",
            "location": 671,
            "return": [
                "str",
                "tuple",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": [],
                "where": [
                    "None",
                    "str",
                    "Optional[List[str]]",
                    "Optional[str]"
                ]
            }
        },
        "Client.create_model": {
            "name": "create_model",
            "location": 684,
            "return": [
                "Model",
                "bool",
                "arxiv.users.domain.User",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "bool",
                    "Sequence[str]",
                    "int",
                    "List[Tuple[int, int]]",
                    "AsyncContextManager[None]"
                ],
                "ontology_id": [
                    "str",
                    "bool",
                    "Sequence[str]",
                    "int",
                    "List[Tuple[int, int]]",
                    "AsyncContextManager[None]"
                ]
            }
        },
        "Client.get_data_row_ids_for_external_ids": {
            "name": "get_data_row_ids_for_external_ids",
            "location": 710,
            "return": [
                "Dict[str, Any]",
                "dict",
                "list",
                "str"
            ],
            "arguments": {
                "self": [],
                "external_ids": [
                    "int"
                ]
            }
        },
        "Client.get_ontology": {
            "name": "get_ontology",
            "location": 735,
            "return": [
                "str",
                "Optional[List[str]]",
                "Optional[str]",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "ontology_id": [
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "Client.get_ontologies": {
            "name": "get_ontologies",
            "location": 746,
            "return": [
                "PaginatedCollection",
                "str",
                "Optional[int]",
                "int",
                "dict"
            ],
            "arguments": {
                "self": [],
                "name_contains": [
                    "Optional[str]",
                    "str",
                    "int"
                ]
            }
        },
        "Client.get_feature_schema": {
            "name": "get_feature_schema",
            "location": 767,
            "return": [
                "str",
                "Optional[str]",
                "list",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "feature_schema_id": [
                    "str",
                    "int"
                ]
            }
        },
        "Client.get_feature_schemas": {
            "name": "get_feature_schemas",
            "location": 788,
            "return": [
                "PaginatedCollection",
                "str",
                "int",
                "cmk.utils.type_defs.UserId"
            ],
            "arguments": {
                "self": [],
                "name_contains": [
                    "str",
                    "int",
                    "Iterable[str]"
                ]
            }
        },
        "Client.create_ontology_from_feature_schemas": {
            "name": "create_ontology_from_feature_schemas",
            "location": 817,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "bool",
                    "List[str]"
                ],
                "feature_schema_ids": [
                    "str",
                    "int",
                    "bool",
                    "list"
                ]
            }
        },
        "Client.create_ontology": {
            "name": "create_ontology",
            "location": 857,
            "return": [
                "Ontology",
                "bool",
                "Optional[str]",
                "Optional[List[Any]]",
                "Optional[Iterable[int]]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[Union[str, int]]"
                ],
                "normalized": [
                    "str",
                    "Optional[Union[str, int]]"
                ]
            }
        },
        "Client.create_feature_schema": {
            "name": "create_feature_schema",
            "location": 884,
            "return": [
                "bool",
                "Optional[Iterable[int]]",
                "Optional[Exception]",
                "Sequence[str]",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "normalized": [
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "Client.get_model_run": {
            "name": "get_model_run",
            "location": 926,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "model_run_id": [
                    "str",
                    "int",
                    "Optional[bool]",
                    "bytes"
                ]
            }
        },
        "Client.execute.convert_value": {
            "name": "convert_value",
            "location": 138,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "value": [
                    "str",
                    "datetime.datetime",
                    "int",
                    "float",
                    "datetime.timedelta"
                ]
            }
        },
        "Client.execute.check_errors": {
            "name": "check_errors",
            "location": 197,
            "return": [
                "None",
                "str",
                "int",
                "Tuple[str, str]",
                "Iterable[str]"
            ],
            "arguments": {
                "keywords": [
                    "bool",
                    "int",
                    "List[Dict[str, Any]]",
                    "rflx.model.Model",
                    "str"
                ]
            }
        },
        "Client.execute.get_error_status_code": {
            "name": "get_error_status_code",
            "location": 209,
            "return": [
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "error": [
                    "List[Dict[str, Any]]",
                    "Optional[List[Any]]",
                    "int"
                ]
            }
        },
        "Client.get_feature_schemas.rootSchemaPayloadToFeatureSchema": {
            "name": "rootSchemaPayloadToFeatureSchema",
            "location": 806,
            "return": [
                "str",
                "bool",
                "qutebrowser.utils.usertypes.Backend",
                "Tuple[int, int]"
            ],
            "arguments": {
                "client": [],
                "payload": [
                    "asgard.models.user.User"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/exceptions.py": {
        "LabelboxError.__init__": {
            "name": "__init__",
            "location": 4,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "str",
                    "int"
                ],
                "cause": [
                    "None",
                    "str",
                    "bool"
                ]
            }
        },
        "LabelboxError.__str__": {
            "name": "__str__",
            "location": 15,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ResourceNotFoundError.__init__": {
            "name": "__init__",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "db_object_type": [
                    "str",
                    "dict",
                    "List['PydanticModelField']",
                    "Dict[str, str]"
                ],
                "params": [
                    "str",
                    "dict"
                ]
            }
        },
        "NetworkError.__init__": {
            "name": "__init__",
            "location": 83,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "cause": [
                    "int"
                ]
            }
        },
        "InvalidAttributeError.__init__": {
            "name": "__init__",
            "location": 97,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "db_object_type": [
                    "str",
                    "bool"
                ],
                "field": [
                    "str",
                    "Type",
                    "Callable",
                    "Optional[str]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/pagination.py": {
        "PaginatedCollection.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "str",
                    "bool",
                    "Client",
                    "dict",
                    "Dict[str, Any]"
                ],
                "query": [
                    "str",
                    "bool",
                    "Client",
                    "dict",
                    "Dict[str, Any]"
                ],
                "params": [
                    "str",
                    "bool",
                    "Client",
                    "dict",
                    "Dict[str, Any]"
                ],
                "dereferencing": [
                    "str",
                    "bool",
                    "Client",
                    "dict",
                    "Dict[str, Any]"
                ],
                "obj_class": [
                    "str",
                    "bool",
                    "Client",
                    "dict",
                    "Dict[str, Any]"
                ],
                "cursor_path": [
                    "None",
                    "str",
                    "Optional[str]",
                    "dict",
                    "List[str]"
                ],
                "experimental": [
                    "bool",
                    "str",
                    "Client",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "PaginatedCollection.__iter__": {
            "name": "__iter__",
            "location": 64,
            "return": [
                "PaginatedCollection",
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PaginatedCollection.__next__": {
            "name": "__next__",
            "location": 68,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Pagination.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "int",
                    "Set[str]",
                    "str"
                ],
                "obj_class": [
                    "str",
                    "Callable[[], str]"
                ],
                "dereferencing": [
                    "int",
                    "Set[str]",
                    "str"
                ],
                "query": [
                    "int",
                    "Set[str]",
                    "str"
                ],
                "params": [
                    "int",
                    "Set[str]",
                    "str"
                ],
                "experimental": [
                    "int",
                    "Set[str]",
                    "str"
                ]
            }
        },
        "_Pagination.get_page_data": {
            "name": "get_page_data",
            "location": 95,
            "return": [
                "list",
                "str",
                "List[str]",
                "Union[List, Dict]",
                "Tuple[Any, Any, Any]"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "Dict[str, Any]",
                    "dict",
                    "tuple"
                ]
            }
        },
        "_Pagination.get_next_page": {
            "name": "get_next_page",
            "location": 102,
            "return": [
                "typing.Tuple[typing.Dict[builtins.str, typing.Any], builtins.bool]",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CursorPagination.__init__": {
            "name": "__init__",
            "location": 108,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "cursor_path": [
                    "str",
                    "Iterable[str]"
                ]
            }
        },
        "_CursorPagination.increment_page": {
            "name": "increment_page",
            "location": 113,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "results": [
                    "dict",
                    "Optional[int]",
                    "str",
                    "Optional[str]",
                    "List[Union[\"PipeChain\", str]]",
                    "Optional[List[str]]"
                ]
            }
        },
        "_CursorPagination.fetched_all": {
            "name": "fetched_all",
            "location": 118,
            "return": [
                "bool",
                "int",
                "str",
                "Set[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CursorPagination.fetch_results": {
            "name": "fetch_results",
            "location": 121,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CursorPagination.get_next_page": {
            "name": "get_next_page",
            "location": 127,
            "return": [
                "tuple",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OffsetPagination.__init__": {
            "name": "__init__",
            "location": 137,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OffsetPagination.increment_page": {
            "name": "increment_page",
            "location": 141,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OffsetPagination.fetched_all": {
            "name": "fetched_all",
            "location": 144,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "n_items": [
                    "int",
                    "str",
                    "List[int]",
                    "List[List[int]]"
                ]
            }
        },
        "_OffsetPagination.fetch_results": {
            "name": "fetch_results",
            "location": 147,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_OffsetPagination.get_next_page": {
            "name": "get_next_page",
            "location": 153,
            "return": [
                "tuple",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/utils.py": {
        "_convert": {
            "name": "_convert",
            "location": 4,
            "return": [
                "str",
                "List[str]",
                "int",
                "bytes"
            ],
            "arguments": {
                "s": [
                    "str",
                    "bytes",
                    "Set[int]",
                    "Optional[str]"
                ],
                "sep": [
                    "str",
                    "List[str]"
                ],
                "title": [
                    "str"
                ]
            }
        },
        "camel_case": {
            "name": "camel_case",
            "location": 13,
            "return": [
                "str"
            ],
            "arguments": {
                "s": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "title_case": {
            "name": "title_case",
            "location": 18,
            "return": [
                "str",
                "int",
                "Optional[str]",
                "bytes",
                "Iterable[str]"
            ],
            "arguments": {
                "s": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bytes"
                ]
            }
        },
        "snake_case": {
            "name": "snake_case",
            "location": 23,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "s": [
                    "str",
                    "Tuple[str, str]",
                    "FrozenSet[int]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/__init__.py": {},
    "labelbox-python-master/labelbox/data/generator.py": {
        "ThreadSafeGen.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "iterable": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "ThreadSafeGen.__iter__": {
            "name": "__iter__",
            "location": 22,
            "return": [
                "ThreadSafeGen",
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "ThreadSafeGen.__next__": {
            "name": "__next__",
            "location": 25,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "PrefetchGenerator.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict",
                    "int",
                    "list",
                    "Sequence[Sequence[float]]",
                    "List[List[int]]",
                    "bytes"
                ],
                "prefetch_limit": [
                    "int",
                    "List[int]",
                    "str"
                ],
                "num_executors": [
                    "int",
                    "Optional[int]",
                    "float"
                ]
            }
        },
        "PrefetchGenerator._process": {
            "name": "_process",
            "location": 61,
            "return": [
                "typing.Any",
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "int",
                    "Tuple[str, int]",
                    "complex",
                    "list"
                ]
            }
        },
        "PrefetchGenerator.fill_queue": {
            "name": "fill_queue",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PrefetchGenerator.__iter__": {
            "name": "__iter__",
            "location": 77,
            "return": [
                "PrefetchGenerator",
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PrefetchGenerator.__next__": {
            "name": "__next__",
            "location": 80,
            "return": [
                "Exception",
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/ontology.py": {
        "get_feature_schema_lookup": {
            "name": "get_feature_schema_lookup",
            "location": 9,
            "return": [
                "tuple[dict[, None]]",
                "List[str]",
                "Optional[List[str]]"
            ],
            "arguments": {
                "ontology_builder": [
                    "str",
                    "float",
                    "Optional[int]",
                    "dict",
                    "bool"
                ]
            }
        },
        "_get_options": {
            "name": "_get_options",
            "location": 44,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "annotation": [
                    "int",
                    "Mapping[str, str]",
                    "Optional[Dict]",
                    "str"
                ],
                "existing_options": [
                    "dict",
                    "Iterable[str]",
                    "Pattern",
                    "Dict[str, Any]"
                ]
            }
        },
        "get_classifications": {
            "name": "get_classifications",
            "location": 65,
            "return": [
                "list[list]",
                "List[str]",
                "str",
                "List[Dict]",
                "List[int]"
            ],
            "arguments": {
                "annotations": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ],
                "existing_classifications": [
                    "List[str]",
                    "str"
                ]
            }
        },
        "get_tools": {
            "name": "get_tools",
            "location": 87,
            "return": [
                "list[list]",
                "List[str]",
                "str",
                "int",
                "Optional[Type]",
                "list"
            ],
            "arguments": {
                "annotations": [
                    "str",
                    "bool",
                    "Optional[List[str]]"
                ],
                "existing_tools": [
                    "str"
                ]
            }
        },
        "tool_mapping": {
            "name": "tool_mapping",
            "location": 107,
            "return": [
                "None",
                "str",
                "List[str]",
                "bool",
                "dict"
            ],
            "arguments": {
                "annotation": [
                    "List[str]",
                    "Dict[str, Any]",
                    "bool",
                    "Optional[Union[str, Any, Any, Any]]"
                ]
            }
        },
        "classification_mapping": {
            "name": "classification_mapping",
            "location": 126,
            "return": [
                "None",
                "Tuple[int, Dict[str, Any]]",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "annotation": [
                    "List[str]",
                    "str",
                    "Dict[str, Any]",
                    "bool"
                ]
            }
        },
        "get_feature_schema_lookup.flatten_classification": {
            "name": "flatten_classification",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "classifications": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/__init__.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/annotation.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/collection.py": {
        "LabelList.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "None",
                    "Union[None, int, str]",
                    "Dict[str, Optional[str]]",
                    "schema.Schema",
                    "Optional[Dict[str, str]]",
                    "Optional[bool]"
                ]
            }
        },
        "LabelList.assign_feature_schema_ids": {
            "name": "assign_feature_schema_ids",
            "location": 33,
            "return": [
                "LabelList",
                "int",
                "Iterable[Any]",
                "Tuple[int, int, int, int]"
            ],
            "arguments": {
                "self": [],
                "ontology_builder": [
                    "str",
                    "List['Product']",
                    "int"
                ]
            }
        },
        "LabelList.add_to_dataset": {
            "name": "add_to_dataset",
            "location": 48,
            "return": [
                "LabelList",
                "int",
                "set",
                "Tuple[int, int, int, int]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "str"
                ],
                "signer": [
                    "int",
                    "str"
                ],
                "max_concurrency": [
                    "int",
                    "str"
                ]
            }
        },
        "LabelList.add_url_to_masks": {
            "name": "add_url_to_masks",
            "location": 82,
            "return": [
                "LabelList",
                "Dict[str, Any]",
                "str",
                "Tuple[int, int, int]",
                "int",
                "complex",
                "list"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "int"
                ],
                "max_concurrency": [
                    "int"
                ]
            }
        },
        "LabelList.add_url_to_data": {
            "name": "add_url_to_data",
            "location": 101,
            "return": [
                "LabelList",
                "Dict[int, Dict[str, Any]]",
                "dict",
                "Dict[str, Any]",
                "List[Dict]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "int",
                    "dict"
                ],
                "max_concurrency": [
                    "int",
                    "dict"
                ]
            }
        },
        "LabelList.get_ontology": {
            "name": "get_ontology",
            "location": 119,
            "return": [
                "OntologyBuilder",
                "str",
                "int",
                "Dict[str, str]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelList._ensure_unique_external_ids": {
            "name": "_ensure_unique_external_ids",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelList.append": {
            "name": "append",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "label": [
                    "str",
                    "bool",
                    "List[str]"
                ]
            }
        },
        "LabelList.__iter__": {
            "name": "__iter__",
            "location": 144,
            "return": [
                "LabelList",
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelList.__next__": {
            "name": "__next__",
            "location": 148,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelList.__len__": {
            "name": "__len__",
            "location": 157,
            "return": [
                "int",
                "str",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelList.__getitem__": {
            "name": "__getitem__",
            "location": 160,
            "return": [
                "Dict[str, List[int]]",
                "Dict[str, str]",
                "Callable",
                "Sequence['cirq.Qid']",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "Mapping[str, object]",
                    "tuple",
                    "dict",
                    "bool",
                    "str"
                ]
            }
        },
        "LabelList._apply_threaded": {
            "name": "_apply_threaded",
            "location": 163,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "self": [],
                "fns": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "max_concurrency": [
                    "int",
                    "List[int]"
                ]
            }
        },
        "LabelGenerator.__init__": {
            "name": "__init__",
            "location": 180,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "float",
                    "Callable[..., None]",
                    "type",
                    "Callable[..., T]",
                    "Callable"
                ]
            }
        },
        "LabelGenerator.as_list": {
            "name": "as_list",
            "location": 184,
            "return": [
                "LabelList",
                "Dict[str, Any]",
                "int",
                "Dict[str, Dict[str, Any]]",
                "Optional[Dict[str, Any]]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelGenerator.assign_feature_schema_ids": {
            "name": "assign_feature_schema_ids",
            "location": 187,
            "return": [
                "LabelGenerator",
                "int",
                "Iterable[Any]",
                "Tuple[int, int, int, int]"
            ],
            "arguments": {
                "self": [],
                "ontology_builder": [
                    "bool",
                    "Callable",
                    "ClassVar",
                    "list",
                    "str"
                ]
            }
        },
        "LabelGenerator.add_url_to_data": {
            "name": "add_url_to_data",
            "location": 198,
            "return": [
                "LabelGenerator",
                "Dict[int, Dict[str, Any]]",
                "dict",
                "Dict[str, Any]",
                "List[Dict]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "dict",
                    "List[str]",
                    "Callable",
                    "str"
                ]
            }
        },
        "LabelGenerator.add_to_dataset": {
            "name": "add_to_dataset",
            "location": 217,
            "return": [
                "LabelGenerator",
                "int",
                "set",
                "Tuple[int, int, int, int]"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "bool",
                    "Sequence[Dict[str, Any]]",
                    "Tuple[float, int]",
                    "Awaitable[Any]"
                ],
                "signer": [
                    "bool",
                    "Sequence[Dict[str, Any]]",
                    "Tuple[float, int]",
                    "Awaitable[Any]"
                ]
            }
        },
        "LabelGenerator.add_url_to_masks": {
            "name": "add_url_to_masks",
            "location": 239,
            "return": [
                "LabelGenerator",
                "Dict[str, Any]",
                "str",
                "Tuple[int, int, int]",
                "int",
                "complex",
                "list"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "Iterable[str]",
                    "str",
                    "django.db.backends.postgresql_psycopg2.schema.DatabaseSchemaEditor",
                    "Dict[str, List[str]]",
                    "List[str]",
                    "Callable"
                ]
            }
        },
        "LabelGenerator.register_background_fn": {
            "name": "register_background_fn",
            "location": 261,
            "return": [
                "LabelGenerator",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "str",
                    "List[str]",
                    "Optional[List[str]]"
                ],
                "name": [
                    "str",
                    "List[str]",
                    "Optional[List[str]]"
                ]
            }
        },
        "LabelGenerator.__iter__": {
            "name": "__iter__",
            "location": 275,
            "return": [
                "LabelGenerator",
                "int",
                "Iterable[str]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelGenerator._process": {
            "name": "_process",
            "location": 278,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "list",
                    "float",
                    "int",
                    "str",
                    "Optional[Sequence[T]]",
                    "List[float]"
                ]
            }
        },
        "LabelGenerator.__next__": {
            "name": "__next__",
            "location": 283,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelGenerator.assign_feature_schema_ids._assign_ids": {
            "name": "_assign_ids",
            "location": 191,
            "return": [
                "str",
                "bool",
                "List[List[str]]",
                "Iterable[str]",
                "int",
                "dict"
            ],
            "arguments": {
                "label": [
                    "str",
                    "Dict[\"core.Edge\", \"state.State\"]",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "bytes"
                ]
            }
        },
        "LabelGenerator.add_url_to_data._add_url_to_data": {
            "name": "_add_url_to_data",
            "location": 210,
            "return": [
                "str",
                "dict",
                "List[Optional[Any]]",
                "Optional[str]"
            ],
            "arguments": {
                "label": [
                    "int",
                    "str"
                ]
            }
        },
        "LabelGenerator.add_to_dataset._add_to_dataset": {
            "name": "_add_to_dataset",
            "location": 232,
            "return": [
                "bool",
                "List[List[str]]",
                "Iterable[str]",
                "int",
                "dict"
            ],
            "arguments": {
                "label": [
                    "str",
                    "T",
                    "dict",
                    "Callable[[], None]",
                    "Callable[[T], bool]"
                ]
            }
        },
        "LabelGenerator.add_url_to_masks._add_url_to_masks": {
            "name": "_add_url_to_masks",
            "location": 254,
            "return": [
                "str"
            ],
            "arguments": {
                "label": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/feature.py": {
        "FeatureSchema.must_set_one": {
            "name": "must_set_one",
            "location": 21,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "str",
                    "Callable",
                    "List[int]",
                    "int"
                ],
                "values": [
                    "str",
                    "apistar.types.ParamAnnotation",
                    "Optional[str]",
                    "bytes",
                    "Optional[Any]",
                    "T"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/label.py": {
        "Label.object_annotations": {
            "name": "object_annotations",
            "location": 46,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Label.classification_annotations": {
            "name": "classification_annotations",
            "location": 49,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Label._get_annotations_by_type": {
            "name": "_get_annotations_by_type",
            "location": 52,
            "return": [
                "list",
                "int",
                "List[str]",
                "Tuple[str]",
                "str"
            ],
            "arguments": {
                "self": [],
                "annotation_type": [
                    "types.TracebackType",
                    "Type[Any]",
                    "BaseException",
                    "Exception",
                    "Type[BaseException]",
                    "type",
                    "mypy.types.FunctionLike"
                ]
            }
        },
        "Label.frame_annotations": {
            "name": "frame_annotations",
            "location": 58,
            "return": [
                "Dict[str, Any]",
                "dict",
                "Dict[str, Dict[str, str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Label.add_url_to_data": {
            "name": "add_url_to_data",
            "location": 69,
            "return": [
                "Label",
                "Dict[int, Dict[str, Any]]",
                "dict",
                "Dict[str, Any]",
                "List[Dict]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "str",
                    "bytes",
                    "dict"
                ]
            }
        },
        "Label.add_url_to_masks": {
            "name": "add_url_to_masks",
            "location": 82,
            "return": [
                "Label",
                "Dict[str, Any]",
                "str",
                "Tuple[int, int, int]",
                "int",
                "complex",
                "list"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "str",
                    "Tuple[Dict[str, Any], Any]",
                    "int"
                ]
            }
        },
        "Label.create_data_row": {
            "name": "create_data_row",
            "location": 107,
            "return": [
                "Label",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "dataset": [
                    "Callable[[Any], bool]",
                    "list",
                    "str"
                ],
                "signer": [
                    "int",
                    "bytes"
                ]
            }
        },
        "Label.assign_feature_schema_ids": {
            "name": "assign_feature_schema_ids",
            "location": 129,
            "return": [
                "Label",
                "int",
                "Iterable[Any]",
                "Tuple[int, int, int, int]"
            ],
            "arguments": {
                "self": [],
                "ontology_builder": [
                    "str",
                    "List[List[Any]]"
                ]
            }
        },
        "Label._assign_or_raise": {
            "name": "_assign_or_raise",
            "location": 156,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "annotation": [
                    "Optional[str]",
                    "Union[metrics.Metric, pings.Ping]",
                    "Optional[Any]"
                ],
                "lookup": [
                    "dict",
                    "Dict[str, Any]",
                    "Dict[str, Dict[str, str]]"
                ]
            }
        },
        "Label._assign_option": {
            "name": "_assign_option",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "classification": [
                    "dict"
                ],
                "lookup": [
                    "bytes",
                    "Dict[str, str]",
                    "Mapping[str, str]",
                    "List[str]"
                ]
            }
        },
        "Label.validate_union": {
            "name": "validate_union",
            "location": 181,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str"
                ],
                "value": [
                    "str",
                    "Optional[str]",
                    "pydantic.fields.ModelField",
                    "Union[int, slice]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/ner.py": {
        "TextEntity.validate_start_end": {
            "name": "validate_start_end",
            "location": 13,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Pattern[str]",
                    "int",
                    "list",
                    "dict"
                ],
                "values": [
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/types.py": {
        "_TypedArray.__get_validators__": {
            "name": "__get_validators__",
            "location": 19,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "List[int]",
                    "Type['DataclassT']",
                    "str",
                    "List[str]"
                ]
            }
        },
        "_TypedArray.validate": {
            "name": "validate",
            "location": 23,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "Union[str, int]",
                    "Iterable[Any]",
                    "float",
                    "dict",
                    "int",
                    "List[str]",
                    "Type[object]"
                ],
                "val": [
                    "Dict[str, Any]",
                    "str"
                ],
                "field": [
                    "type",
                    "ModelField",
                    "str",
                    "rflx.model.Field",
                    "Exception"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/__init__.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/classification/classification.py": {
        "_TempName.dict": {
            "name": "dict",
            "location": 17,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "ClassificationAnswer.dict": {
            "name": "dict",
            "location": 37,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dropdown.__init__": {
            "name": "__init__",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/classification/__init__.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/data/base_data.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/data/raster.py": {
        "RasterData.from_2D_arr": {
            "name": "from_2D_arr",
            "location": 25,
            "return": [
                "SendCh[trio.abc.Stream]",
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "List[str]",
                    "Type[T]",
                    "int",
                    "Optional[float]",
                    "Optional[int]",
                    "Sequence[Any]"
                ],
                "arr": [
                    "str",
                    "int",
                    "bool",
                    "Dict[str, str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "RasterData.bytes_to_np": {
            "name": "bytes_to_np",
            "location": 55,
            "return": [
                "numpy.ndarray",
                "Union[str, int, float]",
                "List[int]",
                "float",
                "Dict[str, numpy.ndarray]"
            ],
            "arguments": {
                "self": [],
                "image_bytes": [
                    "int",
                    "bytes",
                    "bytearray"
                ]
            }
        },
        "RasterData.np_to_bytes": {
            "name": "np_to_bytes",
            "location": 68,
            "return": [
                "float",
                "str",
                "numpy.ndarray",
                "numpy.dtype",
                "bool"
            ],
            "arguments": {
                "self": [],
                "arr": [
                    "bool",
                    "str",
                    "float",
                    "Optional[str]"
                ]
            }
        },
        "RasterData.value": {
            "name": "value",
            "location": 89,
            "return": [
                "Dict[str, Any]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RasterData.set_fetch_fn": {
            "name": "set_fetch_fn",
            "location": 113,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "str",
                    "Callable[[T], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "RasterData.fetch_remote": {
            "name": "fetch_remote",
            "location": 117,
            "return": [
                "bytes",
                "Union[str, List[str]]",
                "List[str]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RasterData.create_url": {
            "name": "create_url",
            "location": 129,
            "return": [
                "str",
                "None"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "Optional[Dict]",
                    "Hashable",
                    "str",
                    "int"
                ]
            }
        },
        "RasterData.validate_args": {
            "name": "validate_args",
            "location": 153,
            "return": [
                "str",
                "Type[T]",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Union[int, str]"
                ],
                "values": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "Optional[Union[Any, str]]"
                ]
            }
        },
        "RasterData.__repr__": {
            "name": "__repr__",
            "location": 174,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/data/text.py": {
        "TextData.value": {
            "name": "value",
            "location": 26,
            "return": [
                "str",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextData.set_fetch_fn": {
            "name": "set_fetch_fn",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "str",
                    "Callable[[T], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "TextData.fetch_remote": {
            "name": "fetch_remote",
            "location": 51,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TextData.create_url": {
            "name": "create_url",
            "location": 63,
            "return": [
                "str",
                "None"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "str",
                    "dict",
                    "IO",
                    "bytes"
                ]
            }
        },
        "TextData.validate_date": {
            "name": "validate_date",
            "location": 85,
            "return": [
                "str",
                "int",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[list]",
                    "List[str]",
                    "Set[str]"
                ],
                "values": [
                    "str"
                ]
            }
        },
        "TextData.__repr__": {
            "name": "__repr__",
            "location": 95,
            "return": [
                "typing.Text",
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/data/tiled_image.py": {
        "TiledBounds.validate_bounds_not_equal": {
            "name": "validate_bounds_not_equal",
            "location": 59,
            "return": [
                "str",
                "Union[int, float]",
                "float"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "SupportsFloat",
                    "T",
                    "bool",
                    "Literal[False]",
                    "Iterable[Any]"
                ],
                "bounds": [
                    "str",
                    "Callable",
                    "bool"
                ]
            }
        },
        "TiledBounds.validate_bounds_lat_lng": {
            "name": "validate_bounds_lat_lng",
            "location": 71,
            "return": [
                "str",
                "int",
                "list",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "dict",
                    "Pattern[str]",
                    "list",
                    "int",
                    "T",
                    "Optional[str]"
                ],
                "values": [
                    "str",
                    "dict"
                ]
            }
        },
        "TileLayer.asdict": {
            "name": "asdict",
            "location": 99,
            "return": [
                "dict[typing.Text, ]",
                "Hashable",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TileLayer.validate_url": {
            "name": "validate_url",
            "location": 103,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "url": [
                    "str",
                    "bytes"
                ]
            }
        },
        "TiledImageData.__post_init__": {
            "name": "__post_init__",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TiledImageData.asdict": {
            "name": "asdict",
            "location": 142,
            "return": [
                "dict[typing.Text, list[list]]",
                "str",
                "bool",
                "Iterable[int]",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TiledImageData.raster_data": {
            "name": "raster_data",
            "location": 159,
            "return": [
                "RasterData",
                "dict",
                "Dict[str, List[int]]",
                "IO[bytes]",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "zoom": [
                    "int",
                    "Optional[bool]",
                    "Optional[int]",
                    "float"
                ],
                "max_tiles": [
                    "int",
                    "bytes"
                ],
                "multithread": [
                    "bool",
                    "int",
                    "str",
                    "float",
                    "Optional[str]"
                ]
            }
        },
        "TiledImageData.value": {
            "name": "value",
            "location": 198,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TiledImageData._get_simple_image_params": {
            "name": "_get_simple_image_params",
            "location": 204,
            "return": [
                "tuple[list]",
                "Optional[dict]",
                "list",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "zoom": [
                    "numpy.ndarray",
                    "bool",
                    "Set[Optional[str]]",
                    "Iterable[dict]",
                    "int"
                ]
            }
        },
        "TiledImageData._get_3857_image_params": {
            "name": "_get_3857_image_params",
            "location": 223,
            "return": [
                "tuple[list[float]]",
                "bool",
                "Optional[dict]",
                "List[Tuple[str, Any]]",
                "List[Tuple[int, str, str]]",
                "Tuple[int]",
                "List[str]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "zoom": [
                    "int",
                    "str",
                    "Iterable[str]",
                    "list",
                    "numpy.ndarray",
                    "float"
                ],
                "bounds": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "TiledImageData._latlng_to_tile": {
            "name": "_latlng_to_tile",
            "location": 241,
            "return": [
                "str",
                "tuple[float]"
            ],
            "arguments": {
                "self": [],
                "lat": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ],
                "lng": [
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ],
                "zoom": [
                    "int",
                    "bytes",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "TiledImageData._tile_to_pixel": {
            "name": "_tile_to_pixel",
            "location": 255,
            "return": [
                "tuple[int]",
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "self": [],
                "tile": [
                    "str",
                    "float",
                    "bool",
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "TiledImageData._fetch_image_for_bounds": {
            "name": "_fetch_image_for_bounds",
            "location": 263,
            "return": [
                "str",
                "int",
                "bool",
                "Sequence[float]",
                "Tuple[int, int]",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": [],
                "x_tile_start": [
                    "int",
                    "float"
                ],
                "y_tile_start": [
                    "int",
                    "List[int]",
                    "Optional[int]",
                    "Optional[str]",
                    "Union[int, Sequence[int]]"
                ],
                "x_tile_end": [
                    "int",
                    "float"
                ],
                "y_tile_end": [
                    "int",
                    "List[int]",
                    "Optional[int]",
                    "Optional[str]",
                    "Union[int, Sequence[int]]"
                ],
                "zoom": [
                    "int",
                    "str",
                    "list"
                ],
                "multithread": [
                    "bool",
                    "int",
                    "Tuple[int, int]",
                    "bytes"
                ]
            }
        },
        "TiledImageData._fetch_tile": {
            "name": "_fetch_tile",
            "location": 301,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "dict",
                    "List[str]",
                    "float",
                    "Dict[str, Any]"
                ],
                "y": [
                    "dict",
                    "List[str]",
                    "float",
                    "Dict[str, Any]"
                ],
                "z": [
                    "dict",
                    "List[str]",
                    "float",
                    "Dict[str, Any]"
                ]
            }
        },
        "TiledImageData._crop_to_bounds": {
            "name": "_crop_to_bounds",
            "location": 312,
            "return": [
                "Tuple[int, int]",
                "numpy.matrix",
                "Sequence['cirq.Qid']",
                "int"
            ],
            "arguments": {
                "self": [],
                "image": [
                    "int",
                    "bool",
                    "list",
                    "Sequence[str]"
                ],
                "x_px_start": [
                    "int",
                    "bool",
                    "list",
                    "Sequence[str]"
                ],
                "y_px_start": [
                    "int",
                    "bool",
                    "list",
                    "Sequence[str]"
                ],
                "x_px_end": [
                    "numpy.ndarray",
                    "int"
                ],
                "y_px_end": [
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "TiledImageData._validate_num_tiles": {
            "name": "_validate_num_tiles",
            "location": 335,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "xstart": [
                    "str",
                    "int"
                ],
                "ystart": [
                    "str",
                    "int"
                ],
                "xend": [
                    "str",
                    "int"
                ],
                "yend": [
                    "str",
                    "int"
                ],
                "max_tiles": [
                    "int",
                    "str"
                ]
            }
        },
        "TiledImageData.validate_zoom_levels": {
            "name": "validate_zoom_levels",
            "location": 348,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "List[cbc_casper_simulator.validator.Validator]",
                    "bool",
                    "str"
                ],
                "zoom_levels": [
                    "str",
                    "bytes",
                    "Callable",
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, str]"
                ]
            }
        },
        "EPSGTransformer._is_simple": {
            "name": "_is_simple",
            "location": 367,
            "return": [
                "bool",
                "str",
                "numpy.ndarray",
                "int"
            ],
            "arguments": {
                "epsg": [
                    "str",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "EPSGTransformer._get_ranges": {
            "name": "_get_ranges",
            "location": 371,
            "return": [
                "tuple",
                "int",
                "List[int]",
                "str"
            ],
            "arguments": {
                "bounds": [
                    "float",
                    "Optional[int]",
                    "numpy.dtype",
                    "List[int]",
                    "int"
                ]
            }
        },
        "EPSGTransformer._min_max_x_y": {
            "name": "_min_max_x_y",
            "location": 380,
            "return": [
                "tuple",
                "int",
                "str",
                "Union[complex, float, int]",
                "float"
            ],
            "arguments": {
                "bounds": [
                    "str",
                    "List[List]"
                ]
            }
        },
        "EPSGTransformer.geo_and_pixel": {
            "name": "geo_and_pixel",
            "location": 387,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str"
                ],
                "src_epsg": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str"
                ],
                "pixel_bounds": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str"
                ],
                "geo_bounds": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str"
                ],
                "zoom": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "str"
                ]
            }
        },
        "EPSGTransformer.create_geo_to_geo_transformer": {
            "name": "create_geo_to_geo_transformer",
            "location": 461,
            "return": [
                "EPSGTransformer",
                "str",
                "numpy.ndarray",
                "bytes",
                "bool"
            ],
            "arguments": {
                "cls": [
                    "str"
                ],
                "src_epsg": [
                    "str"
                ],
                "tgt_epsg": [
                    "str"
                ]
            }
        },
        "EPSGTransformer.create_geo_to_pixel_transformer": {
            "name": "create_geo_to_pixel_transformer",
            "location": 477,
            "return": [
                "EPSGTransformer",
                "Dict[str, int]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int"
                ],
                "src_epsg": [
                    "str",
                    "int"
                ],
                "pixel_bounds": [
                    "str",
                    "int"
                ],
                "geo_bounds": [
                    "str",
                    "int"
                ],
                "zoom": [
                    "int",
                    "str"
                ]
            }
        },
        "EPSGTransformer.create_pixel_to_geo_transformer": {
            "name": "create_pixel_to_geo_transformer",
            "location": 492,
            "return": [
                "EPSGTransformer",
                "Dict[str, int]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int"
                ],
                "src_epsg": [
                    "str",
                    "int"
                ],
                "pixel_bounds": [
                    "str",
                    "int"
                ],
                "geo_bounds": [
                    "str",
                    "int"
                ],
                "zoom": [
                    "int",
                    "str"
                ]
            }
        },
        "EPSGTransformer._get_point_obj": {
            "name": "_get_point_obj",
            "location": 505,
            "return": [
                "Point",
                "int",
                "List[int]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "point": [
                    "numpy.ndarray",
                    "int",
                    "str"
                ]
            }
        },
        "EPSGTransformer.__call__": {
            "name": "__call__",
            "location": 509,
            "return": [
                "list",
                "Line",
                "Optional[int]",
                "Polygon",
                "Rectangle",
                "tuple",
                "Tuple[str]",
                "Optional[Iterable[str]]",
                "Union[List[float], List[int]]",
                "allennlp.data.vocabulary.Vocabulary",
                "float",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Optional[numpy.ndarray]"
                ]
            }
        },
        "TiledImageData._crop_to_bounds.invert_point": {
            "name": "invert_point",
            "location": 324,
            "return": [
                "int",
                "str",
                "None",
                "Exception",
                "Optional[str]"
            ],
            "arguments": {
                "pt": [
                    "int",
                    "dict"
                ]
            }
        },
        "EPSGTransformer.geo_and_pixel.transform": {
            "name": "transform",
            "location": 448,
            "return": [
                "int",
                "float",
                "List[float]",
                "str",
                "List[str]"
            ],
            "arguments": {
                "x": [
                    "float",
                    "numpy.ndarray",
                    "Sequence[int]",
                    "Sequence[float]"
                ],
                "y": [
                    "float",
                    "numpy.ndarray",
                    "Sequence[int]",
                    "Sequence[float]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/data/video.py": {
        "VideoData.load_frames": {
            "name": "load_frames",
            "location": 27,
            "return": [
                "str",
                "None"
            ],
            "arguments": {
                "self": [],
                "overwrite": [
                    "bool",
                    "str"
                ]
            }
        },
        "VideoData.value": {
            "name": "value",
            "location": 44,
            "return": [
                "numpy.ndarray",
                "Union[str, int, float]",
                "float",
                "Dict[str, numpy.ndarray]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "VideoData.frame_generator": {
            "name": "frame_generator",
            "location": 47,
            "return": [
                "typing.Generator[tuple]",
                "Union[tuple, list]",
                "None",
                "List[int]",
                "typing.Generator[tuple[int]]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "cache_frames": [
                    "bool",
                    "str",
                    "List[List[str]]"
                ],
                "download_dir": [
                    "typing.Text",
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "VideoData.__getitem__": {
            "name": "__getitem__",
            "location": 83,
            "return": [
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "idx": [
                    "str",
                    "Tuple[int]",
                    "List[T]",
                    "T",
                    "List[str]",
                    "int"
                ]
            }
        },
        "VideoData.set_fetch_fn": {
            "name": "set_fetch_fn",
            "location": 90,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "str",
                    "Callable[[T], bool]",
                    "Sequence[str]"
                ]
            }
        },
        "VideoData.fetch_remote": {
            "name": "fetch_remote",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "local_path": [
                    "str"
                ]
            }
        },
        "VideoData.create_url": {
            "name": "create_url",
            "location": 107,
            "return": [
                "str",
                "None"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "str",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "dict",
                    "IO"
                ]
            }
        },
        "VideoData.frames_to_video": {
            "name": "frames_to_video",
            "location": 128,
            "return": [
                "None",
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "self": [],
                "frames": [
                    "str",
                    "Dict[Any, list]",
                    "bytes",
                    "bool",
                    "Dict[str, str]"
                ],
                "fps": [
                    "int",
                    "str",
                    "bool",
                    "Optional[int]"
                ],
                "save_dir": [
                    "str",
                    "typing.Text"
                ]
            }
        },
        "VideoData.validate_data": {
            "name": "validate_data",
            "location": 151,
            "return": [
                "str",
                "int",
                "float",
                "bool"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "types.MethodType",
                    "dict",
                    "List[str]",
                    "str"
                ],
                "values": [
                    "str",
                    "dict",
                    "Optional[str]",
                    "Optional[Union[Any, str]]"
                ]
            }
        },
        "VideoData.__repr__": {
            "name": "__repr__",
            "location": 162,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/data/__init__.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/geometry/geometry.py": {
        "Geometry.shapely": {
            "name": "shapely",
            "location": 16,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Geometry.get_or_create_canvas": {
            "name": "get_or_create_canvas",
            "location": 22,
            "return": [
                "List[str]",
                "int",
                "str",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "int",
                    "Optional[int]",
                    "Union[int, None]",
                    "float",
                    "Optional[float]"
                ],
                "width": [
                    "int",
                    "Optional[int]",
                    "Union[int, None]",
                    "float",
                    "Optional[float]"
                ],
                "canvas": [
                    "int",
                    "bool"
                ]
            }
        },
        "Geometry.geometry": {
            "name": "geometry",
            "location": 34,
            "return": [
                "geojson",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Geometry.draw": {
            "name": "draw",
            "location": 38,
            "return": [
                "numpy.ndarray",
                "None"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "None",
                    "Iterable[T]",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable"
                ],
                "width": [
                    "None",
                    "Iterable[T]",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable"
                ],
                "canvas": [
                    "None",
                    "Iterable[T]",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable"
                ],
                "color": [
                    "None",
                    "Iterable[T]",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable"
                ],
                "thickness": [
                    "int",
                    "Iterable[T]",
                    "bool",
                    "List[str]",
                    "Iterable"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/geometry/line.py": {
        "Line.geometry": {
            "name": "geometry",
            "location": 25,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Line.from_shapely": {
            "name": "from_shapely",
            "location": 30,
            "return": [
                "Line",
                "Union[List, Dict]",
                "Tuple[Dict, Dict]",
                "list",
                "Point",
                "List[Tuple[str, ...]]",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "shapely_obj": [
                    "str"
                ]
            }
        },
        "Line.draw": {
            "name": "draw",
            "location": 40,
            "return": [
                "int",
                "List[int]",
                "str"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "int",
                    "None"
                ],
                "width": [
                    "int",
                    "None"
                ],
                "canvas": [
                    "None",
                    "List[str]",
                    "int",
                    "str",
                    "bool",
                    "numpy.ndarray"
                ],
                "color": [
                    "tuple[int]",
                    "List[numpy.array]",
                    "int",
                    "geometry.Point",
                    "str",
                    "set"
                ],
                "thickness": [
                    "int",
                    "List[numpy.array]",
                    "geometry.Point",
                    "str",
                    "set"
                ]
            }
        },
        "Line.is_geom_valid": {
            "name": "is_geom_valid",
            "location": 67,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable",
                    "Type[T]",
                    "Type[Any]",
                    "int"
                ],
                "points": [
                    "str",
                    "Optional[str]",
                    "Dict[str, object]",
                    "Type",
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/geometry/mask.py": {
        "Mask.geometry": {
            "name": "geometry",
            "location": 39,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Mask.draw": {
            "name": "draw",
            "location": 59,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "None",
                    "Optional[int]",
                    "Union[int, None]",
                    "int",
                    "float"
                ],
                "width": [
                    "None",
                    "Optional[int]",
                    "Union[int, None]",
                    "int",
                    "float"
                ],
                "canvas": [
                    "None",
                    "Optional[numpy.ndarray]",
                    "Optional[numpy.array]",
                    "Optional[Dict]",
                    "numpy.ndarray"
                ],
                "color": [
                    "None",
                    "int",
                    "list"
                ],
                "thickness": [
                    "None",
                    "Iterable[T]",
                    "bool",
                    "int",
                    "List[str]",
                    "Iterable"
                ]
            }
        },
        "Mask._extract_polygons_from_contours": {
            "name": "_extract_polygons_from_contours",
            "location": 99,
            "return": [
                "MultiPolygon",
                "Set[str]",
                "Tuple[str]",
                "Dict[str, Any]",
                "int",
                "Sequence[float]"
            ],
            "arguments": {
                "self": [],
                "contours": [
                    "float",
                    "numpy.array",
                    "numpy.ndarray",
                    "List[Mapping[str, Any]]"
                ]
            }
        },
        "Mask.create_url": {
            "name": "create_url",
            "location": 105,
            "return": [
                "dict",
                "str",
                "Callable",
                "Optional[str]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "signer": [
                    "str"
                ]
            }
        },
        "Mask.is_valid_color": {
            "name": "is_valid_color",
            "location": 118,
            "return": [
                "list",
                "str",
                "float"
            ],
            "arguments": {
                "cls": [
                    "Type[T]",
                    "Callable",
                    "T",
                    "str",
                    "List[dict]"
                ],
                "color": [
                    "List[T]",
                    "int",
                    "float",
                    "Sequence[Dict[str, Any]]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/geometry/point.py": {
        "Point.geometry": {
            "name": "geometry",
            "location": 25,
            "return": [
                "Point",
                "bool",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": []
            }
        },
        "Point.from_shapely": {
            "name": "from_shapely",
            "location": 29,
            "return": [
                "Point",
                "int",
                "List[int]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "shapely_obj": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "Point.draw": {
            "name": "draw",
            "location": 38,
            "return": [
                "numpy.ndarray",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "int",
                    "None"
                ],
                "width": [
                    "int",
                    "None"
                ],
                "canvas": [
                    "None",
                    "str",
                    "bool",
                    "int",
                    "numpy.ndarray"
                ],
                "color": [
                    "tuple[int]",
                    "int",
                    "str"
                ],
                "thickness": [
                    "int",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/geometry/polygon.py": {
        "Polygon.geometry": {
            "name": "geometry",
            "location": 29,
            "return": [
                "Polygon",
                "Optional[int]",
                "numpy.ndarray",
                "int",
                "float",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Polygon.from_shapely": {
            "name": "from_shapely",
            "location": 35,
            "return": [
                "Polygon",
                "str",
                "dict",
                "bool",
                "float"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "shapely_obj": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "Polygon.draw": {
            "name": "draw",
            "location": 45,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "int",
                    "None"
                ],
                "width": [
                    "int",
                    "None"
                ],
                "canvas": [
                    "None",
                    "numpy.ndarray",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "color": [
                    "tuple[int]",
                    "int",
                    "Dict[int, dict]"
                ],
                "thickness": [
                    "int",
                    "str",
                    "bool",
                    "bytearray",
                    "Optional[str]"
                ]
            }
        },
        "Polygon.is_geom_valid": {
            "name": "is_geom_valid",
            "location": 70,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable",
                    "Type[T]",
                    "Type[Any]",
                    "int"
                ],
                "points": [
                    "str",
                    "Sequence[Any]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/geometry/rectangle.py": {
        "Rectangle.geometry": {
            "name": "geometry",
            "location": 25,
            "return": [
                "Polygon",
                "Sequence['cirq.Qid']",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Rectangle.from_shapely": {
            "name": "from_shapely",
            "location": 35,
            "return": [
                "Rectangle",
                "str",
                "Generator",
                "Dict[str, int]",
                "Optional[str]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "shapely_obj": [
                    "int",
                    "str"
                ]
            }
        },
        "Rectangle.draw": {
            "name": "draw",
            "location": 52,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "height": [
                    "int",
                    "None"
                ],
                "width": [
                    "int",
                    "None"
                ],
                "canvas": [
                    "None",
                    "numpy.ndarray",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "color": [
                    "tuple[int]",
                    "int",
                    "Dict[int, dict]"
                ],
                "thickness": [
                    "int",
                    "str",
                    "bool",
                    "bytearray",
                    "Optional[str]"
                ]
            }
        },
        "Rectangle.from_xyhw": {
            "name": "from_xyhw",
            "location": 77,
            "return": [
                "int",
                "bool",
                "Union[str, bool, None]",
                "float",
                "str"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "bool"
                ],
                "x": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "bool"
                ],
                "y": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "bool"
                ],
                "h": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "bool"
                ],
                "w": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "Tuple[int, int, int]",
                    "bool"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/geometry/__init__.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/metrics/base.py": {
        "BaseMetric.dict": {
            "name": "dict",
            "location": 18,
            "return": [
                "dict",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseMetric.validate_value": {
            "name": "validate_value",
            "location": 23,
            "return": [
                "dict",
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "\"ks.Series[str]\"",
                    "int"
                ],
                "value": [
                    "dict",
                    "list",
                    "VT"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/metrics/confusion_matrix.py": {},
    "labelbox-python-master/labelbox/data/annotation_types/metrics/scalar.py": {
        "ScalarMetric.dict": {
            "name": "dict",
            "location": 31,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/annotation_types/metrics/__init__.py": {},
    "labelbox-python-master/labelbox/data/metrics/group.py": {
        "get_identifying_key": {
            "name": "get_identifying_key",
            "location": 18,
            "return": [
                "typing.Text",
                "Optional[str]",
                "dict",
                "str"
            ],
            "arguments": {
                "features_a": [
                    "str",
                    "dict",
                    "List[Tuple[bytes, bytes]]",
                    "List[Dict]",
                    "Dict[Type, Callable]"
                ],
                "features_b": [
                    "str",
                    "dict",
                    "List[Tuple[bytes, bytes]]",
                    "List[Dict]",
                    "Dict[Type, Callable]"
                ]
            }
        },
        "all_have_key": {
            "name": "all_have_key",
            "location": 51,
            "return": [
                "tuple[bool]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "features": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "get_label_pairs": {
            "name": "get_label_pairs",
            "location": 82,
            "return": [
                "str",
                "float",
                "bool"
            ],
            "arguments": {
                "labels_a": [
                    "Dict[str, Set[str]]",
                    "Dict[str, Any]",
                    "Optional[Optional]",
                    "list",
                    "dict"
                ],
                "labels_b": [
                    "dict",
                    "Dict[str, Any]",
                    "Optional[Optional]",
                    "bool",
                    "Callable",
                    "str",
                    "List[str]"
                ],
                "match_on": [
                    "typing.Text",
                    "Dict[str, Set[str]]",
                    "List[str]",
                    "Dict[str, Any]",
                    "Optional[Optional]",
                    "bool",
                    "int"
                ],
                "filter_mismatch": [
                    "bool",
                    "Sequence[str]",
                    "int",
                    "str"
                ]
            }
        },
        "get_feature_pairs": {
            "name": "get_feature_pairs",
            "location": 135,
            "return": [
                "str",
                "bool",
                "dict",
                "set",
                "List[str]"
            ],
            "arguments": {
                "features_a": [
                    "int",
                    "Tuple[int, int]"
                ],
                "features_b": [
                    "int",
                    "Tuple[int, int]"
                ]
            }
        },
        "_create_feature_lookup": {
            "name": "_create_feature_lookup",
            "location": 161,
            "return": [
                "bool",
                "allennlp.data.dataseDataset",
                "float"
            ],
            "arguments": {
                "features": [
                    "bytes",
                    "Sequence[T]",
                    "List[T]"
                ],
                "key": [
                    "int",
                    "bool",
                    "KT",
                    "T"
                ]
            }
        },
        "has_no_matching_annotations": {
            "name": "has_no_matching_annotations",
            "location": 196,
            "return": [
                "bool"
            ],
            "arguments": {
                "ground_truths": [
                    "list",
                    "str",
                    "List[List[str]]",
                    "List[str]"
                ],
                "predictions": [
                    "list",
                    "str",
                    "List[List[str]]",
                    "List[str]"
                ]
            }
        },
        "has_no_annotations": {
            "name": "has_no_annotations",
            "location": 207,
            "return": [
                "bool",
                "tuple",
                "Tuple[str, str, str]"
            ],
            "arguments": {
                "ground_truths": [
                    "List[int]",
                    "List[str]",
                    "list",
                    "int"
                ],
                "predictions": [
                    "List[int]",
                    "List[str]",
                    "list",
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/metrics/__init__.py": {},
    "labelbox-python-master/labelbox/data/metrics/confusion_matrix/calculation.py": {
        "confusion_matrix": {
            "name": "confusion_matrix",
            "location": 13,
            "return": [
                "None",
                "Optional[str]",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool",
                    "int"
                ],
                "predictions": [
                    "str",
                    "bool",
                    "int"
                ],
                "include_subclasses": [
                    "str",
                    "float"
                ],
                "iou": [
                    "str",
                    "float"
                ]
            }
        },
        "feature_confusion_matrix": {
            "name": "feature_confusion_matrix",
            "location": 44,
            "return": [
                "list[int]",
                "int",
                "None",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "list",
                    "Sequence[str]",
                    "dict",
                    "int"
                ],
                "predictions": [
                    "numpy.ndarray",
                    "numpy.array",
                    "Union[astropy.units.quantity.Quantity, numpy.ndarray]",
                    "Tuple['cirq.Qid']",
                    "list"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ],
                "iou": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "classification_confusion_matrix": {
            "name": "classification_confusion_matrix",
            "location": 81,
            "return": [
                "list[int]",
                "int",
                "None",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "Sequence[float]",
                    "int",
                    "List[Dict]",
                    "Sequence['cirq.Qid']",
                    "List[int]"
                ],
                "predictions": [
                    "Sequence[float]",
                    "int",
                    "List[Dict]",
                    "Sequence['cirq.Qid']",
                    "List[int]"
                ]
            }
        },
        "vector_confusion_matrix": {
            "name": "vector_confusion_matrix",
            "location": 123,
            "return": [
                "list[int]",
                "int",
                "None",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "numpy.array",
                    "numpy.ndarray",
                    "bool"
                ],
                "predictions": [
                    "numpy.array",
                    "numpy.ndarray",
                    "bool"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ],
                "iou": [
                    "int",
                    "Callable",
                    "str"
                ],
                "buffer": [
                    "float",
                    "str",
                    "int",
                    "list"
                ]
            }
        },
        "object_pair_confusion_matrix": {
            "name": "object_pair_confusion_matrix",
            "location": 152,
            "return": [
                "list[int]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "pairs": [
                    "List[Tuple[int, int]]",
                    "List[Tuple[Any, Any]]",
                    "List[tuple]",
                    "Iterable[Tuple[str, str]]",
                    "list",
                    "dict"
                ],
                "include_subclasses": [],
                "iou": [
                    "List[str]",
                    "Optional[Callable]",
                    "bool",
                    "int"
                ]
            }
        },
        "radio_confusion_matrix": {
            "name": "radio_confusion_matrix",
            "location": 201,
            "return": [
                "list[int]",
                "bool",
                "int",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "ground_truth": [],
                "prediction": [
                    "str",
                    "bool",
                    "List[str]",
                    "Dict[str, Any]",
                    "Callable"
                ]
            }
        },
        "checklist_confusion_matrix": {
            "name": "checklist_confusion_matrix",
            "location": 222,
            "return": [
                "list[int]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truth": [
                    "str",
                    "dict",
                    "MutableMapping[str, Any]",
                    "Dict[str, Any]"
                ],
                "prediction": [
                    "dict",
                    "str",
                    "Dict[str, Any]",
                    "MutableMapping[str, Any]"
                ]
            }
        },
        "mask_confusion_matrix": {
            "name": "mask_confusion_matrix",
            "location": 249,
            "return": [
                "int",
                "list[int]",
                "Callable",
                "None",
                "str",
                "list"
            ],
            "arguments": {
                "ground_truths": [
                    "numpy.array",
                    "numpy.ndarray",
                    "bool"
                ],
                "predictions": [
                    "numpy.array",
                    "numpy.ndarray",
                    "bool"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ],
                "iou": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "ner_confusion_matrix": {
            "name": "ner_confusion_matrix",
            "location": 296,
            "return": [
                "list[int]",
                "int",
                "None",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "numpy.array",
                    "numpy.ndarray",
                    "bool"
                ],
                "predictions": [
                    "numpy.array",
                    "numpy.ndarray",
                    "bool"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ],
                "iou": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/metrics/confusion_matrix/confusion_matrix.py": {
        "confusion_matrix_metric": {
            "name": "confusion_matrix_metric",
            "location": 15,
            "return": [
                "bool",
                "list",
                "Dict[str, str]",
                "list[ConfusionMatrixMetric]"
            ],
            "arguments": {
                "ground_truths": [
                    "sideeye.data.Trial",
                    "bool"
                ],
                "predictions": [
                    "sideeye.data.Trial",
                    "bool"
                ],
                "include_subclasses": [
                    "bool",
                    "Iterable[T]",
                    "str",
                    "numpy.ndarray",
                    "int"
                ],
                "iou": [
                    "float",
                    "sideeye.data.Trial",
                    "bool"
                ]
            }
        },
        "feature_confusion_matrix_metric": {
            "name": "feature_confusion_matrix_metric",
            "location": 47,
            "return": [
                "list[ConfusionMatrixMetric]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool",
                    "int"
                ],
                "predictions": [
                    "str",
                    "bool",
                    "int"
                ],
                "include_subclasses": [
                    "bool",
                    "numpy.ndarray",
                    "dict",
                    "Optional[str]"
                ],
                "iou": [
                    "float",
                    "dict",
                    "numpy.ndarray"
                ]
            }
        },
        "_get_metric_name": {
            "name": "_get_metric_name",
            "location": 86,
            "return": [
                "typing.Text",
                "int",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ],
                "predictions": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ],
                "iou": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "_is_classification": {
            "name": "_is_classification",
            "location": 98,
            "return": [
                "int",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "ground_truths": [],
                "predictions": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/metrics/confusion_matrix/__init__.py": {},
    "labelbox-python-master/labelbox/data/metrics/iou/calculation.py": {
        "miou": {
            "name": "miou",
            "location": 13,
            "return": [
                "None",
                "Optional[str]",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool",
                    "int"
                ],
                "predictions": [
                    "str",
                    "bool",
                    "int"
                ],
                "include_subclasses": []
            }
        },
        "feature_miou": {
            "name": "feature_miou",
            "location": 38,
            "return": [
                "float",
                "Optional[str]",
                "None",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "ground_truths": [
                    "int",
                    "Callable",
                    "str"
                ],
                "predictions": [
                    "Optional[numpy.ndarray]",
                    "numpy.array",
                    "shapely.geometry.base.BaseGeometry",
                    "float",
                    "str",
                    "Iterable[str]",
                    "Union[numpy.ndarray, astropy.units.quantity.Quantity]"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "vector_miou": {
            "name": "vector_miou",
            "location": 71,
            "return": [
                "float",
                "Optional[str]",
                "None",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "ground_truths": [
                    "List[Point]",
                    "str"
                ],
                "predictions": [
                    "List[Point]",
                    "str"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ],
                "buffer": [
                    "float",
                    "str",
                    "int",
                    "list"
                ]
            }
        },
        "object_pair_miou": {
            "name": "object_pair_miou",
            "location": 94,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "pairs": [
                    "List[Tuple[int, int]]",
                    "List[Tuple[Any, Any]]",
                    "List[tuple]",
                    "Iterable[Tuple[str, str]]",
                    "list",
                    "dict"
                ],
                "include_subclasses": [
                    "Callable",
                    "numpy.ndarray",
                    "int",
                    "str"
                ]
            }
        },
        "mask_miou": {
            "name": "mask_miou",
            "location": 122,
            "return": [
                "float",
                "Optional[str]",
                "None",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "ground_truths": [
                    "List[Point]",
                    "str"
                ],
                "predictions": [
                    "List[Point]",
                    "str"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "classification_miou": {
            "name": "classification_miou",
            "location": 157,
            "return": [
                "float",
                "Dict[str, int]",
                "int",
                "dict",
                "Iterable[str]"
            ],
            "arguments": {
                "ground_truths": [
                    "List[int]",
                    "list",
                    "bool",
                    "List[float]",
                    "str",
                    "int"
                ],
                "predictions": [
                    "List[int]",
                    "list",
                    "bool",
                    "List[float]",
                    "str",
                    "int"
                ]
            }
        },
        "radio_iou": {
            "name": "radio_iou",
            "location": 190,
            "return": [
                "float",
                "int"
            ],
            "arguments": {
                "ground_truth": [
                    "bool"
                ],
                "prediction": [
                    "bool"
                ]
            }
        },
        "text_iou": {
            "name": "text_iou",
            "location": 199,
            "return": [
                "float",
                "str",
                "int",
                "Sequence[str]"
            ],
            "arguments": {
                "ground_truth": [
                    "str",
                    "bool"
                ],
                "prediction": [
                    "str",
                    "bool"
                ]
            }
        },
        "checklist_iou": {
            "name": "checklist_iou",
            "location": 206,
            "return": [
                "float",
                "int",
                "Iterable[str]",
                "dict",
                "bool"
            ],
            "arguments": {
                "ground_truth": [
                    "str",
                    "dict",
                    "MutableMapping[str, Any]",
                    "Dict[str, Any]"
                ],
                "prediction": [
                    "dict",
                    "str",
                    "Dict[str, Any]",
                    "MutableMapping[str, Any]"
                ]
            }
        },
        "_get_vector_pairs": {
            "name": "_get_vector_pairs",
            "location": 219,
            "return": [
                "list[tuple]",
                "str",
                "bool"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool"
                ],
                "predictions": [
                    "str",
                    "bool"
                ],
                "buffer": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "_get_mask_pairs": {
            "name": "_get_mask_pairs",
            "location": 241,
            "return": [
                "list[tuple]",
                "str",
                "bool"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool"
                ],
                "predictions": [
                    "str",
                    "bool"
                ]
            }
        },
        "_polygon_iou": {
            "name": "_polygon_iou",
            "location": 257,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "poly1": [
                    "int",
                    "bool",
                    "str"
                ],
                "poly2": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "_ensure_valid_poly": {
            "name": "_ensure_valid_poly",
            "location": 265,
            "return": [
                "int",
                "str",
                "Dict[str, str]",
                "bytes",
                "Sequence[Tuple[float, float]]"
            ],
            "arguments": {
                "poly": [
                    "int",
                    "str",
                    "Dict[str, str]",
                    "bytes",
                    "Sequence[Tuple[float, float]]"
                ]
            }
        },
        "_mask_iou": {
            "name": "_mask_iou",
            "location": 271,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "mask1": [
                    "int",
                    "Callable",
                    "str"
                ],
                "mask2": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "_get_ner_pairs": {
            "name": "_get_ner_pairs",
            "location": 276,
            "return": [
                "list[tuple]",
                "str",
                "bool"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool"
                ],
                "predictions": [
                    "str",
                    "bool"
                ]
            }
        },
        "_ner_iou": {
            "name": "_ner_iou",
            "location": 287,
            "return": [
                "int",
                "str",
                "Dict[str, Any]",
                "float"
            ],
            "arguments": {
                "ner1": [
                    "Dict[str, Any]"
                ],
                "ner2": [
                    "Dict[str, Any]"
                ]
            }
        },
        "ner_miou": {
            "name": "ner_miou",
            "location": 302,
            "return": [
                "float",
                "Optional[str]",
                "None",
                "str",
                "Optional[int]"
            ],
            "arguments": {
                "ground_truths": [
                    "List[Point]",
                    "str"
                ],
                "predictions": [
                    "List[Point]",
                    "str"
                ],
                "include_subclasses": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/metrics/iou/iou.py": {
        "miou_metric": {
            "name": "miou_metric",
            "location": 12,
            "return": [
                "list",
                "bool",
                "list[ScalarMetric]",
                "Callable",
                "str",
                "List[Exception]"
            ],
            "arguments": {
                "ground_truths": [
                    "int",
                    "Callable",
                    "str"
                ],
                "predictions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "include_subclasses": [
                    "bool",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "feature_miou_metric": {
            "name": "feature_miou_metric",
            "location": 37,
            "return": [
                "list[ScalarMetric]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "ground_truths": [
                    "str",
                    "bool",
                    "int"
                ],
                "predictions": [
                    "str",
                    "bool",
                    "int"
                ],
                "include_subclasses": [
                    "bool",
                    "str",
                    "Optional[Tuple[str, ...]]",
                    "dict",
                    "bytes",
                    "List[float]"
                ]
            }
        },
        "data_row_miou": {
            "name": "data_row_miou",
            "location": 69,
            "return": [
                "int",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "ground_truth": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ],
                "prediction": [
                    "int",
                    "Dict[str, Any]",
                    "str"
                ],
                "include_subclasses": [
                    "bool",
                    "int",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/metrics/iou/__init__.py": {},
    "labelbox-python-master/labelbox/data/serialization/__init__.py": {},
    "labelbox-python-master/labelbox/data/serialization/coco/annotation.py": {
        "rle_decoding": {
            "name": "rle_decoding",
            "location": 11,
            "return": [
                "Tuple[numpy.ndarray]",
                "str",
                "Tuple[Any, Any, Any]",
                "int"
            ],
            "arguments": {
                "rle_arr": [
                    "int",
                    "Callable",
                    "str"
                ],
                "w": [
                    "bool",
                    "float",
                    "int"
                ],
                "h": [
                    "bool",
                    "float",
                    "int"
                ]
            }
        },
        "get_annotation_lookup": {
            "name": "get_annotation_lookup",
            "location": 21,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "annotations": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/categories.py": {
        "hash_category_name": {
            "name": "hash_category_name",
            "location": 13,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "List[str]",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/converter.py": {
        "create_path_if_not_exists": {
            "name": "create_path_if_not_exists",
            "location": 10,
            "return": [
                "Path",
                "pathlib.Path",
                "str",
                "bool"
            ],
            "arguments": {
                "path": [
                    "pathlib.Path",
                    "str"
                ],
                "ignore_existing_data": [
                    "bool",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "validate_path": {
            "name": "validate_path",
            "location": 22,
            "return": [
                "Path",
                "str",
                "pathlib.Path",
                "List[int]",
                "bool"
            ],
            "arguments": {
                "path": [
                    "str",
                    "Union[List, str]"
                ],
                "name": [
                    "str",
                    "pathlib.Path"
                ]
            }
        },
        "COCOConverter.serialize_instances": {
            "name": "serialize_instances",
            "location": 39,
            "return": [
                "str"
            ],
            "arguments": {
                "labels": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Optional[str]",
                    "str"
                ],
                "image_root": [
                    "str",
                    "bytes",
                    "dict"
                ],
                "ignore_existing_data": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "bytes",
                    "Union[pathlib.Path, str, None]",
                    "Dict[str, Any]"
                ],
                "max_workers": [
                    "int",
                    "bool",
                    "Optional[int]",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "COCOConverter.serialize_panoptic": {
            "name": "serialize_panoptic",
            "location": 64,
            "return": [
                "str"
            ],
            "arguments": {
                "labels": [
                    "Optional[str]",
                    "bool",
                    "Union[bool, List, Tuple]"
                ],
                "image_root": [
                    "str",
                    "Optional[str]",
                    "Optional[bytes]",
                    "pathlib.Path"
                ],
                "mask_root": [
                    "str",
                    "Optional[str]",
                    "Path"
                ],
                "all_stuff": [
                    "bool",
                    "Optional[str]",
                    "Union[bool, List, Tuple]"
                ],
                "ignore_existing_data": [
                    "bool",
                    "str",
                    "pathlib.Path",
                    "int",
                    "Optional[str]"
                ],
                "max_workers": [
                    "int",
                    "Optional[str]",
                    "bool",
                    "Union[bool, List, Tuple]"
                ]
            }
        },
        "COCOConverter.deserialize_panoptic": {
            "name": "deserialize_panoptic",
            "location": 97,
            "return": [
                "LabelGenerator",
                "str",
                "Iterable[str]",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "json_data": [
                    "str",
                    "int"
                ],
                "image_root": [
                    "pathlib.Path",
                    "pypi2nix.path.Path",
                    "cerulean.Path"
                ],
                "mask_root": [
                    "pathlib.Path",
                    "pypi2nix.path.Path",
                    "cerulean.Path"
                ]
            }
        },
        "COCOConverter.deserialize_instances": {
            "name": "deserialize_instances",
            "location": 117,
            "return": [
                "LabelGenerator",
                "str",
                "Iterable[str]",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "json_data": [
                    "str",
                    "bytes",
                    "bool",
                    "Dict[str, Any]",
                    "pathlib.Path"
                ],
                "image_root": [
                    "pathlib.Path",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/image.py": {
        "get_image_id": {
            "name": "get_image_id",
            "location": 21,
            "return": [
                "str",
                "pathlib.Path",
                "List[str]"
            ],
            "arguments": {
                "label": [
                    "str"
                ],
                "idx": [
                    "bool",
                    "str",
                    "float",
                    "int",
                    "Sequence[int]",
                    "List[str]"
                ]
            }
        },
        "get_image": {
            "name": "get_image",
            "location": 29,
            "return": [
                "CocoImage",
                "str",
                "list",
                "type"
            ],
            "arguments": {
                "label": [
                    "int",
                    "bytes",
                    "bool"
                ],
                "image_root": [
                    "str",
                    "pathlib.Path",
                    "IO[Any]"
                ],
                "image_id": [
                    "str",
                    "IO[Any]",
                    "pathlib.Path",
                    "List[str]"
                ]
            }
        },
        "id_to_rgb": {
            "name": "id_to_rgb",
            "location": 40,
            "return": [
                "list[int]",
                "str",
                "Optional[int]",
                "dict",
                "bool"
            ],
            "arguments": {
                "id": [
                    "int",
                    "list",
                    "str",
                    "tuple",
                    "List[str]"
                ]
            }
        },
        "rgb_to_id": {
            "name": "rgb_to_id",
            "location": 48,
            "return": [
                "int",
                "str",
                "Union[str, int]"
            ],
            "arguments": {
                "red": [
                    "Dict[str, Dict[str, int]]",
                    "str"
                ],
                "green": [
                    "Dict[str, Dict[str, int]]",
                    "str"
                ],
                "blue": [
                    "Dict[str, Dict[str, int]]",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/instance_dataset.py": {
        "mask_to_coco_object_annotation": {
            "name": "mask_to_coco_object_annotation",
            "location": 18,
            "return": [
                "bool",
                "COCOObjectAnnotation"
            ],
            "arguments": {
                "annotation": [
                    "int",
                    "str",
                    "bytes",
                    "List[str]"
                ],
                "annot_idx": [
                    "bool",
                    "Optional[int]",
                    "Optional[str]",
                    "int"
                ],
                "image_id": [
                    "bool",
                    "Optional[int]",
                    "Optional[str]",
                    "int"
                ],
                "category_id": [
                    "bool",
                    "Optional[int]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "vector_to_coco_object_annotation": {
            "name": "vector_to_coco_object_annotation",
            "location": 44,
            "return": [
                "bool",
                "COCOObjectAnnotation"
            ],
            "arguments": {
                "annotation": [
                    "int",
                    "dict",
                    "bool",
                    "str"
                ],
                "annot_idx": [
                    "Optional[str]",
                    "int",
                    "str",
                    "Optional[Dict[str, str]]",
                    "Sequence[str]"
                ],
                "image_id": [
                    "Optional[str]",
                    "int",
                    "str",
                    "Optional[Dict[str, str]]",
                    "Sequence[str]"
                ],
                "category_id": [
                    "Optional[str]",
                    "int",
                    "str",
                    "Optional[Dict[str, str]]",
                    "Sequence[str]"
                ]
            }
        },
        "rle_to_common": {
            "name": "rle_to_common",
            "location": 69,
            "return": [
                "ObjectAnnotation",
                "str",
                "type",
                "Container[\"Taxon\"]"
            ],
            "arguments": {
                "class_annotations": [
                    "int",
                    "str"
                ],
                "class_name": [
                    "str",
                    "bool",
                    "Optional[Dict[str, str]]",
                    "Callable[..., T]",
                    "Type[pydantic.BaseModel]"
                ]
            }
        },
        "segmentations_to_common": {
            "name": "segmentations_to_common",
            "location": 78,
            "return": [
                "list[ObjectAnnotation]",
                "bytes",
                "int",
                "IO",
                "List[str]",
                "str"
            ],
            "arguments": {
                "class_annotations": [
                    "str",
                    "bool",
                    "type"
                ],
                "class_name": [
                    "list",
                    "List[str]",
                    "List[float]",
                    "bool"
                ]
            }
        },
        "process_label": {
            "name": "process_label",
            "location": 92,
            "return": [
                "tuple[typing.Union[list,dict]]",
                "int",
                "tuple",
                "str"
            ],
            "arguments": {
                "label": [
                    "Optional[bool]",
                    "str",
                    "Optional[str]"
                ],
                "idx": [
                    "str",
                    "bool",
                    "int",
                    "Optional[Mapping[str, Any]]",
                    "Iterable"
                ],
                "image_root": [
                    "str",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "max_annotations_per_image": [
                    "int",
                    "bool",
                    "Optional[Any]",
                    "List[str]"
                ]
            }
        },
        "CocoInstanceDataset.from_common": {
            "name": "from_common",
            "location": 130,
            "return": [
                "CocoInstanceDataset",
                "str",
                "numpy.ndarray",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "IO[str]"
                ],
                "labels": [
                    "str",
                    "Optional[str]",
                    "Union[Callable, str]",
                    "List[str]",
                    "Dict[str, Any]",
                    "pathlib.Path"
                ],
                "image_root": [
                    "str",
                    "Optional[str]",
                    "Union[Callable, str]",
                    "List[str]",
                    "Dict[str, Any]",
                    "pathlib.Path"
                ],
                "max_workers": [
                    "int",
                    "str",
                    "List[str]"
                ]
            }
        },
        "CocoInstanceDataset.to_common": {
            "name": "to_common",
            "location": 178,
            "return": [
                "",
                "typing.Generator[Label]"
            ],
            "arguments": {
                "self": [],
                "image_root": [
                    "pathlib.Path",
                    "str",
                    "pathlib.PurePath",
                    "List[pypi2nix.path.Path]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/panoptic_dataset.py": {
        "vector_to_coco_segment_info": {
            "name": "vector_to_coco_segment_info",
            "location": 21,
            "return": [
                "str",
                "tuple[SegmentInfo]"
            ],
            "arguments": {
                "canvas": [
                    "dict",
                    "Sequence[str]",
                    "int",
                    "List[str]"
                ],
                "annotation": [
                    "bool",
                    "int",
                    "Optional[int]"
                ],
                "annotation_idx": [
                    "dict",
                    "Sequence[str]",
                    "int",
                    "List[str]"
                ],
                "image": [
                    "dict",
                    "Optional[bytes]",
                    "List[str]",
                    "float",
                    "Optional[int]",
                    "str"
                ],
                "category_id": [
                    "Optional[str]",
                    "int",
                    "str"
                ]
            }
        },
        "mask_to_coco_segment_info": {
            "name": "mask_to_coco_segment_info",
            "location": 38,
            "return": [
                "str",
                "tuple[SegmentInfo]"
            ],
            "arguments": {
                "canvas": [
                    "int",
                    "str",
                    "Optional[str]"
                ],
                "annotation": [
                    "str",
                    "float",
                    "numpy.ndarray",
                    "List[int]"
                ],
                "annotation_idx": [
                    "int",
                    "bool"
                ],
                "category_id": [
                    "Optional[str]",
                    "int",
                    "dict",
                    "str"
                ]
            }
        },
        "process_label": {
            "name": "process_label",
            "location": 51,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "label": [
                    "str"
                ],
                "idx": [
                    "str",
                    "Optional[str]",
                    "Optional[\"LocalizedString\"]",
                    "bool"
                ],
                "image_root": [
                    "str",
                    "Optional[str]"
                ],
                "mask_root": [
                    "Optional[str]",
                    "Union[str, pathlib.Path]",
                    "str"
                ],
                "all_stuff": [
                    "Callable"
                ]
            }
        },
        "CocoPanopticDataset.from_common": {
            "name": "from_common",
            "location": 106,
            "return": [
                "CocoPanopticDataset",
                "str",
                "numpy.ndarray",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "List[List[str]]",
                    "Optional[List[str]]",
                    "Optional[bool]",
                    "List[pathlib.Path]",
                    "List[str]"
                ],
                "labels": [
                    "str",
                    "Mapping",
                    "List[str]",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "dict",
                    "bool",
                    "List[allennlp.data.tokenizers.Token]"
                ],
                "image_root": [
                    "str",
                    "Mapping",
                    "List[str]",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "dict",
                    "bool",
                    "List[allennlp.data.tokenizers.Token]"
                ],
                "mask_root": [
                    "str",
                    "Mapping",
                    "List[str]",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "dict",
                    "bool",
                    "List[allennlp.data.tokenizers.Token]"
                ],
                "all_stuff": [
                    "str",
                    "Mapping",
                    "List[str]",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "dict",
                    "bool",
                    "List[allennlp.data.tokenizers.Token]"
                ],
                "max_workers": [
                    "int",
                    "str",
                    "Optional[float]",
                    "bool"
                ]
            }
        },
        "CocoPanopticDataset.to_common": {
            "name": "to_common",
            "location": 162,
            "return": [
                "",
                "typing.Generator[Label]"
            ],
            "arguments": {
                "self": [],
                "image_root": [
                    "Optional[pathlib.Path]",
                    "pathlib.Path",
                    "TextIO",
                    "str",
                    "bool",
                    "Union[str, pathlib.Path]"
                ],
                "mask_root": [
                    "str",
                    "pathlib.Path",
                    "bytes",
                    "Union[pathlib3x.Path, IO[str], None]",
                    "Optional[pathlib.Path]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/path.py": {
        "PathSerializerMixin.dict": {
            "name": "dict",
            "location": 7,
            "return": [
                "dict[, str]",
                "Optional[str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/coco/__init__.py": {},
    "labelbox-python-master/labelbox/data/serialization/labelbox_v1/classification.py": {
        "LBV1ClassificationAnswer.to_common": {
            "name": "to_common",
            "location": 13,
            "return": [
                "ClassificationAnswer",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1ClassificationAnswer.from_common": {
            "name": "from_common",
            "location": 23,
            "return": [
                "bool",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "dict",
                    "Optional[Iterable[str]]"
                ],
                "answer": [
                    "str",
                    "dict",
                    "Optional[Iterable[str]]"
                ]
            }
        },
        "LBV1Radio.to_common": {
            "name": "to_common",
            "location": 36,
            "return": [
                "Radio"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Radio.from_common": {
            "name": "from_common",
            "location": 40,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, Any]",
                    "Callable[[str], bool]",
                    "int",
                    "Dict[str, str]",
                    "Union[Dict, List]"
                ],
                "radio": [
                    "str",
                    "Dict[str, Any]",
                    "Callable[[str], bool]",
                    "int",
                    "Dict[str, str]",
                    "Union[Dict, List]"
                ],
                "feature_schema_id": [
                    "str",
                    "Dict[str, Any]",
                    "Callable[[str], bool]",
                    "int",
                    "Dict[str, str]",
                    "Union[Dict, List]"
                ]
            }
        },
        "LBV1Checklist.to_common": {
            "name": "to_common",
            "location": 50,
            "return": [
                "Checklist",
                "bool",
                "Optional[int]",
                "int",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Checklist.from_common": {
            "name": "from_common",
            "location": 54,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]",
                    "str",
                    "int"
                ],
                "checklist": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]",
                    "str",
                    "int"
                ],
                "feature_schema_id": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]",
                    "str",
                    "int"
                ]
            }
        },
        "LBV1Dropdown.to_common": {
            "name": "to_common",
            "location": 67,
            "return": [
                "Dropdown",
                "bool",
                "Optional[int]",
                "int",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Dropdown.from_common": {
            "name": "from_common",
            "location": 71,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]",
                    "str",
                    "int"
                ],
                "dropdown": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]",
                    "str",
                    "int"
                ],
                "feature_schema_id": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]",
                    "str",
                    "int"
                ]
            }
        },
        "LBV1Text.to_common": {
            "name": "to_common",
            "location": 84,
            "return": [
                "Text",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Text.from_common": {
            "name": "from_common",
            "location": 88,
            "return": [
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, Any]",
                    "Set[str]",
                    "Tuple[int, str]"
                ],
                "text": [
                    "str",
                    "Dict[str, Any]",
                    "Set[str]",
                    "Tuple[int, str]"
                ],
                "feature_schema_id": [
                    "str",
                    "Dict[str, Any]",
                    "Set[str]",
                    "Tuple[int, str]"
                ]
            }
        },
        "LBV1Classifications.to_common": {
            "name": "to_common",
            "location": 97,
            "return": [
                "list[ClassificationAnnotation]",
                "float",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Classifications.from_common": {
            "name": "from_common",
            "location": 111,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "float",
                    "Optional[int]",
                    "str",
                    "bool",
                    "Callable[..., None]"
                ],
                "annotations": [
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "LBV1Classifications.lookup_classification": {
            "name": "lookup_classification",
            "location": 127,
            "return": [
                "str",
                "LBV1Text",
                "mypy.types.Type",
                "LBV1Dropdown",
                "int",
                "LBV1Checklist",
                "LBV1Radio"
            ],
            "arguments": {
                "annotation": [
                    "Dict[str, float]",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/labelbox_v1/converter.py": {
        "LBV1Converter.deserialize_video": {
            "name": "deserialize_video",
            "location": 22,
            "return": [
                "LabelGenerator",
                "List[int]",
                "dict",
                "str"
            ],
            "arguments": {
                "json_data": [
                    "str",
                    "int"
                ],
                "client": [
                    "str",
                    "int"
                ]
            }
        },
        "LBV1Converter.deserialize": {
            "name": "deserialize",
            "location": 39,
            "return": [
                "LabelGenerator",
                "List[int]",
                "dict",
                "str"
            ],
            "arguments": {
                "json_data": [
                    "bool",
                    "str"
                ]
            }
        },
        "LBV1Converter.serialize": {
            "name": "serialize",
            "location": 64,
            "return": [
                "typing.Generator[typing.Dict[builtins.str, typing.Any], None, None]",
                "typing.Generator"
            ],
            "arguments": {
                "labels": [
                    "List[int]",
                    "str",
                    "List[str]",
                    "Tuple[Sequence[Any], Sequence[Any]]",
                    "Set[str]"
                ]
            }
        },
        "LBV1VideoIterator.__init__": {
            "name": "__init__",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "int",
                    "str"
                ],
                "client": [
                    "float",
                    "bool"
                ]
            }
        },
        "LBV1VideoIterator._process": {
            "name": "_process",
            "location": 90,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "dict",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "Union[bytes, str]",
                    "Sequence[Any]"
                ]
            }
        },
        "LBV1VideoIterator._request": {
            "name": "_request",
            "location": 98,
            "return": [
                "str",
                "int",
                "google.protobuf.message.Message"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "dict",
                    "Dict[str, Any]",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "Sequence[str]",
                    "List[str]",
                    "str"
                ]
            }
        },
        "LBV1Converter.deserialize.label_generator": {
            "name": "label_generator",
            "location": 50,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/labelbox/data/serialization/labelbox_v1/feature.py": {
        "LBV1Feature.check_ids": {
            "name": "check_ids",
            "location": 17,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "List[Union[Any, Any]]",
                    "Pattern[str]",
                    "int",
                    "list",
                    "Dict[str, Any]"
                ],
                "values": [
                    "str",
                    "Dict[str, str]",
                    "set",
                    "tests.utils.Strategy[paradigm.hints.Domain]",
                    "Dict[Any, list]"
                ]
            }
        },
        "LBV1Feature.dict": {
            "name": "dict",
            "location": 22,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/labelbox_v1/label.py": {
        "LBV1LabelAnnotations.to_common": {
            "name": "to_common",
            "location": 19,
            "return": [
                "list",
                "float",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1LabelAnnotations.from_common": {
            "name": "from_common",
            "location": 26,
            "return": [
                "Dict[str, Any]",
                "Optional[Dict[str, str]]",
                "bytes",
                "Dict[int, List[str]]",
                "Mapping[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Any]",
                    "str",
                    "List[Dict[str, Any]]",
                    "allennlp.data.Vocabulary",
                    "dict"
                ],
                "annotations": [
                    "Optional[Iterable[T]]"
                ]
            }
        },
        "LBV1LabelAnnotationsVideo.to_common": {
            "name": "to_common",
            "location": 41,
            "return": [
                "list[typing.Union[list[VideoClassificationAnnotation],list[VideoObjectAnnotation]]]",
                "float",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1LabelAnnotationsVideo.from_common": {
            "name": "from_common",
            "location": 81,
            "return": [
                "list[LBV1LabelAnnotationsVideo]",
                "Dict[str, Any]",
                "dict",
                "Tuple[int, Dict[str, Any]]",
                "list"
            ],
            "arguments": {
                "cls": [
                    "allennlp.data.Vocabulary",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ],
                "annotations": [
                    "str",
                    "cmk.utils.type_defs.UserId",
                    "Dict[str, Any]"
                ]
            }
        },
        "LBV1Label.to_common": {
            "name": "to_common",
            "location": 150,
            "return": [
                "Label",
                "int",
                "List[str]",
                "Dict[str, str]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Label.from_common": {
            "name": "from_common",
            "location": 168,
            "return": [
                "LBV1Label",
                "List[Callable]",
                "int",
                "List[str]",
                "Tuple[str, str]",
                "bool",
                "cmk.utils.type_defs.HostName",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "list",
                    "Tuple[str]",
                    "List[str]"
                ],
                "label": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "int",
                    "float",
                    "raiden.utils.TokenNetworkAddress",
                    "raiden.utils.TokenAddress"
                ]
            }
        },
        "LBV1Label._data_row_to_common": {
            "name": "_data_row_to_common",
            "location": 183,
            "return": [
                "List[int]",
                "cmk.utils.type_defs.HostName"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Label._infer_media_type": {
            "name": "_infer_media_type",
            "location": 206,
            "return": [
                "int",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Label._has_object_annotations": {
            "name": "_has_object_annotations",
            "location": 230,
            "return": [
                "bool",
                "str",
                "List[Dict]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Label._has_text_annotations": {
            "name": "_has_text_annotations",
            "location": 233,
            "return": [
                "bool",
                "str",
                "Optional[dict]",
                "List[Tuple[str, Any]]",
                "Tuple[int]",
                "List[Tuple[int, str, str]]",
                "list",
                "List[str]",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Label._row_contains": {
            "name": "_row_contains",
            "location": 239,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "substrs": [
                    "bool",
                    "int"
                ]
            }
        },
        "LBV1Label._is_url": {
            "name": "_is_url",
            "location": 242,
            "return": [
                "bool",
                "hackathon.utils.utils.DataMessage",
                "raiden.utils.Any",
                "int",
                "str",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/labelbox_v1/objects.py": {
        "LBV1ObjectBase.dict": {
            "name": "dict",
            "location": 26,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1ObjectBase.validate_subclasses": {
            "name": "validate_subclasses",
            "location": 34,
            "return": [
                "list",
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "T",
                    "int",
                    "str"
                ],
                "value": [
                    "Union[str, list]",
                    "list",
                    "Callable",
                    "Iterable[int]",
                    "int",
                    "List[numpy.ndarray]",
                    "str",
                    "List[int]"
                ],
                "field": [
                    "bool",
                    "T",
                    "int",
                    "str"
                ]
            }
        },
        "LBV1TIPoint.to_common": {
            "name": "to_common",
            "location": 70,
            "return": [
                "Point",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1TILine.to_common": {
            "name": "to_common",
            "location": 79,
            "return": [
                "Line",
                "List[str]",
                "Sequence[str]",
                "Dict[str, Any]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1TIPolygon.to_common": {
            "name": "to_common",
            "location": 89,
            "return": [
                "Polygon",
                "float",
                "List[int]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1TIRectangle.to_common": {
            "name": "to_common",
            "location": 99,
            "return": [
                "Rectangle",
                "str",
                "Union[int, float]",
                "int",
                "float",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Rectangle.to_common": {
            "name": "to_common",
            "location": 127,
            "return": [
                "Rectangle",
                "str",
                "Callable",
                "numpy.array",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Rectangle.from_common": {
            "name": "from_common",
            "location": 133,
            "return": [
                "str",
                "int",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "rectangle": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "classifications": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "feature_schema_id": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "title": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "extra": [
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "LBV1Polygon.to_common": {
            "name": "to_common",
            "location": 152,
            "return": [
                "Polygon",
                "int",
                "Optional[int]",
                "List[int]",
                "str",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Polygon.from_common": {
            "name": "from_common",
            "location": 156,
            "return": [
                "bool",
                "int",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "float",
                    "Callable[[str], float]",
                    "list",
                    "numpy.ndarray"
                ],
                "polygon": [
                    "float",
                    "Callable[[str], float]",
                    "list",
                    "numpy.ndarray"
                ],
                "classifications": [
                    "float",
                    "Callable[[str], float]",
                    "list",
                    "numpy.ndarray"
                ],
                "feature_schema_id": [
                    "float",
                    "Callable[[str], float]",
                    "list",
                    "numpy.ndarray"
                ],
                "title": [
                    "float",
                    "Callable[[str], float]",
                    "list",
                    "numpy.ndarray"
                ],
                "extra": [
                    "float",
                    "Callable[[str], float]",
                    "list",
                    "numpy.ndarray"
                ]
            }
        },
        "LBV1Point.to_common": {
            "name": "to_common",
            "location": 173,
            "return": [
                "Point",
                "int",
                "numpy.ndarray",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Point.from_common": {
            "name": "from_common",
            "location": 177,
            "return": [
                "bool",
                "int",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "float",
                    "list",
                    "numpy.ndarray",
                    "int",
                    "Dict[str, Any]"
                ],
                "point": [
                    "float",
                    "list",
                    "numpy.ndarray",
                    "int",
                    "Dict[str, Any]"
                ],
                "classifications": [
                    "float",
                    "list",
                    "numpy.ndarray",
                    "int",
                    "Dict[str, Any]"
                ],
                "feature_schema_id": [
                    "float",
                    "list",
                    "numpy.ndarray",
                    "int",
                    "Dict[str, Any]"
                ],
                "title": [
                    "float",
                    "list",
                    "numpy.ndarray",
                    "int",
                    "Dict[str, Any]"
                ],
                "extra": [
                    "float",
                    "list",
                    "numpy.ndarray",
                    "int",
                    "Dict[str, Any]"
                ]
            }
        },
        "LBV1Line.to_common": {
            "name": "to_common",
            "location": 191,
            "return": [
                "Line",
                "str",
                "bool",
                "types.Resolver"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Line.from_common": {
            "name": "from_common",
            "location": 195,
            "return": [
                "int",
                "List[int]",
                "str",
                "float",
                "bytes"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "bool",
                    "bytes"
                ],
                "polygon": [
                    "int",
                    "bool",
                    "bytes"
                ],
                "classifications": [
                    "int",
                    "bool",
                    "bytes"
                ],
                "feature_schema_id": [
                    "int",
                    "bool",
                    "bytes"
                ],
                "title": [
                    "int",
                    "bool",
                    "bytes"
                ],
                "extra": [
                    "int",
                    "bool",
                    "bytes"
                ]
            }
        },
        "LBV1Mask.to_common": {
            "name": "to_common",
            "location": 210,
            "return": [
                "Mask",
                "str",
                "float",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Mask.from_common": {
            "name": "from_common",
            "location": 214,
            "return": [
                "str",
                "apistar.types.WSGIEnviron",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "Sequence[str]"
                ],
                "mask": [
                    "bool",
                    "int",
                    "str",
                    "Mapping[Any, str]"
                ],
                "classifications": [
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "Sequence[str]"
                ],
                "feature_schema_id": [
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "Sequence[str]"
                ],
                "title": [
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "Sequence[str]"
                ],
                "extra": [
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "Sequence[str]"
                ]
            }
        },
        "LBV1TextEntity.to_common": {
            "name": "to_common",
            "location": 243,
            "return": [
                "mypy.types.Type",
                "TextEntity"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1TextEntity.from_common": {
            "name": "from_common",
            "location": 250,
            "return": [
                "bool",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Dict[int, int]"
                ],
                "text_entity": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Dict[int, int]"
                ],
                "classifications": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Dict[int, int]"
                ],
                "feature_schema_id": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Dict[int, int]"
                ],
                "title": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Dict[int, int]"
                ],
                "extra": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Dict[int, int]"
                ]
            }
        },
        "LBV1Objects.to_common": {
            "name": "to_common",
            "location": 267,
            "return": [
                "list[ObjectAnnotation]",
                "numpy.ndarray",
                "float",
                "Dict[str, numpy.ndarray]",
                "dict",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LBV1Objects.from_common": {
            "name": "from_common",
            "location": 293,
            "return": [
                "str",
                "Callable",
                "Callable[[None, None], bool]",
                "numpy.ndarray"
            ],
            "arguments": {
                "cls": [
                    "Union[int, float, complex]",
                    "Type",
                    "dict",
                    "str",
                    "bool"
                ],
                "annotations": [
                    "allennlp.data.Vocabulary",
                    "int",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "LBV1Objects.lookup_object": {
            "name": "lookup_object",
            "location": 310,
            "return": [
                "bool",
                "List[pydantic.fields.ModelField]",
                "LBV1Line",
                "Optional[Union[str, Any]]",
                "LBV1Point",
                "LBV1Polygon",
                "LBV1Rectangle",
                "LBV1Mask",
                "LBV1TextEntity",
                "None"
            ],
            "arguments": {
                "annotation": [
                    "str",
                    "int",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/labelbox_v1/__init__.py": {},
    "labelbox-python-master/labelbox/data/serialization/ndjson/base.py": {
        "DataRow.validate_id": {
            "name": "validate_id",
            "location": 12,
            "return": [
                "None",
                "Dict[str, Dict[str, int]]",
                "Iterable[str]",
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Union[Set[str], List[str]]",
                    "list",
                    "List[list]"
                ],
                "v": [
                    "Optional[str]",
                    "Optional[Iterable[str]]",
                    "str",
                    "Dict[str, Dict[str, str]]",
                    "Optional[Any]",
                    "Optional[int]"
                ]
            }
        },
        "NDJsonBase.set_id": {
            "name": "set_id",
            "location": 26,
            "return": [
                "str",
                "bool",
                "int",
                "list"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "dict",
                    "int",
                    "List[str]",
                    "Callable",
                    "Iterable[str]"
                ],
                "v": [
                    "str",
                    "int",
                    "T",
                    "Callable[[], Any]",
                    "tuple",
                    "Optional[int]"
                ]
            }
        },
        "NDAnnotation.validate_id": {
            "name": "validate_id",
            "location": 38,
            "return": [
                "None",
                "Dict[str, Dict[str, int]]",
                "Iterable[str]",
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Union[Set[str], List[str]]",
                    "list",
                    "List[list]"
                ],
                "v": [
                    "Optional[str]",
                    "Optional[Iterable[str]]",
                    "str",
                    "Dict[str, Dict[str, str]]",
                    "Optional[Any]",
                    "Optional[int]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/ndjson/classification.py": {
        "NDFeature.validate_id": {
            "name": "validate_id",
            "location": 17,
            "return": [
                "None",
                "Dict[str, Dict[str, int]]",
                "Iterable[str]",
                "bool",
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Union[Set[str], List[str]]",
                    "list",
                    "List[list]"
                ],
                "v": [
                    "Optional[str]",
                    "Optional[Iterable[str]]",
                    "str",
                    "Dict[str, Dict[str, str]]",
                    "Optional[Any]",
                    "Optional[int]"
                ]
            }
        },
        "VideoSupported.dict": {
            "name": "dict",
            "location": 38,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDTextSubclass.to_common": {
            "name": "to_common",
            "location": 49,
            "return": [
                "Text",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDTextSubclass.from_common": {
            "name": "from_common",
            "location": 53,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "text": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "feature_schema_id": [
                    "str",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "NDChecklistSubclass.to_common": {
            "name": "to_common",
            "location": 61,
            "return": [
                "Checklist",
                "str",
                "bool",
                "Optional[cmk.utils.type_defs.HostAddress]",
                "List[int]",
                "raiden.utils.TokenAmount"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDChecklistSubclass.from_common": {
            "name": "from_common",
            "location": 68,
            "return": [
                "str",
                "OrderedDict",
                "bool",
                "Callable"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "int",
                    "Optional[dict]",
                    "Dict[str, Any]"
                ],
                "checklist": [
                    "str",
                    "bool",
                    "int",
                    "Optional[dict]",
                    "Dict[str, Any]"
                ],
                "feature_schema_id": [
                    "str",
                    "bool",
                    "int",
                    "Optional[dict]",
                    "Dict[str, Any]"
                ]
            }
        },
        "NDChecklistSubclass.dict": {
            "name": "dict",
            "location": 76,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDRadioSubclass.to_common": {
            "name": "to_common",
            "location": 86,
            "return": [
                "Radio",
                "str",
                "bool",
                "Optional[cmk.utils.type_defs.HostAddress]",
                "List[int]",
                "raiden.utils.TokenAmount"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDRadioSubclass.from_common": {
            "name": "from_common",
            "location": 91,
            "return": [
                "str",
                "bool",
                "Callable",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "radio": [
                    "str",
                    "int",
                    "Optional[float]"
                ],
                "feature_schema_id": [
                    "str",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "NDText.from_common": {
            "name": "from_common",
            "location": 103,
            "return": [
                "str",
                "dict",
                "tuple"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, str]",
                    "Optional[str]",
                    "dict"
                ],
                "text": [
                    "str",
                    "Dict[str, str]",
                    "Optional[str]",
                    "dict"
                ],
                "feature_schema_id": [
                    "str",
                    "Dict[str, str]",
                    "Optional[str]",
                    "dict"
                ],
                "extra": [
                    "str",
                    "Dict[str, str]",
                    "Optional[str]",
                    "dict"
                ],
                "data": [
                    "str",
                    "Dict[str, str]",
                    "Optional[str]",
                    "dict"
                ]
            }
        },
        "NDChecklist.from_common": {
            "name": "from_common",
            "location": 117,
            "return": [
                "str",
                "OrderedDict",
                "bool",
                "Callable"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "Dict[int, dict]",
                    "Optional[str]"
                ],
                "checklist": [
                    "bool",
                    "Dict[int, dict]",
                    "Optional[str]"
                ],
                "feature_schema_id": [
                    "bool",
                    "Dict[int, dict]",
                    "Optional[str]"
                ],
                "extra": [
                    "bool",
                    "Dict[int, dict]",
                    "Optional[str]"
                ],
                "data": [
                    "bool",
                    "Dict[int, dict]",
                    "Optional[str]"
                ]
            }
        },
        "NDRadio.from_common": {
            "name": "from_common",
            "location": 134,
            "return": [
                "str",
                "bool",
                "Callable",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[int, dict]"
                ],
                "radio": [
                    "str",
                    "Dict[int, dict]"
                ],
                "feature_schema_id": [
                    "str",
                    "Dict[int, dict]"
                ],
                "extra": [
                    "str",
                    "Dict[int, dict]"
                ],
                "data": [
                    "str",
                    "Dict[int, dict]"
                ]
            }
        },
        "NDSubclassification.from_common": {
            "name": "from_common",
            "location": 147,
            "return": [
                "Dict[str, Any]",
                "bool",
                "Optional[str]",
                "Tuple[bool, str]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "str",
                    "bool"
                ],
                "annotation": [
                    "str",
                    "Dict[str, Iterable[Any]]",
                    "List[str]",
                    "golem_messages.message.base.Message",
                    "type"
                ]
            }
        },
        "NDSubclassification.to_common": {
            "name": "to_common",
            "location": 159,
            "return": [
                "ClassificationAnnotation",
                "Dict[str, int]",
                "int",
                "dict",
                "str",
                "Generator"
            ],
            "arguments": {
                "annotation": [
                    "str",
                    "Callable",
                    "dict",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "NDSubclassification.lookup_subclassification": {
            "name": "lookup_subclassification",
            "location": 165,
            "return": [
                "str",
                "NDTextSubclass",
                "mypy.types.Type",
                "NDChecklistSubclass",
                "int",
                "NDRadioSubclass"
            ],
            "arguments": {
                "annotation": [
                    "str",
                    "Tuple['cirq.Qid']"
                ]
            }
        },
        "NDClassification.to_common": {
            "name": "to_common",
            "location": 180,
            "return": [
                "list[ClassificationAnnotation]",
                "List[int]",
                "list[VideoClassificationAnnotation]",
                "Dict[str, int]",
                "List[dict]",
                "dict"
            ],
            "arguments": {
                "annotation": [
                    "str",
                    "mode.utils.imports.SymbolArg[Type[mode.SupervisorStrategyT]]",
                    "Callable",
                    "bool",
                    "dict"
                ]
            }
        },
        "NDClassification.from_common": {
            "name": "from_common",
            "location": 197,
            "return": [
                "Dict[str, Any]",
                "bool",
                "Optional[str]",
                "Tuple[bool, str]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "str",
                    "int",
                    "Type"
                ],
                "annotation": [
                    "dict",
                    "Dict[str, Iterable[Any]]",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "List[str]",
                    "str"
                ],
                "data": [
                    "dict",
                    "Dict[str, Any]",
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Type['Declared']",
                    "int",
                    "str"
                ]
            }
        },
        "NDClassification.lookup_classification": {
            "name": "lookup_classification",
            "location": 212,
            "return": [
                "str",
                "NDText",
                "mypy.types.Type",
                "NDChecklist",
                "int",
                "NDRadio"
            ],
            "arguments": {
                "annotation": [
                    "mypy.types.TypeVarDef",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/ndjson/converter.py": {
        "NDJsonConverter.deserialize": {
            "name": "deserialize",
            "location": 13,
            "return": [
                "List[int]",
                "Iterable[str]",
                "Iterable[T]",
                "int"
            ],
            "arguments": {
                "json_data": [
                    "dict",
                    "bytes",
                    "Dict[str, Any]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "NDJsonConverter.serialize": {
            "name": "serialize",
            "location": 27,
            "return": [
                "typing.Generator[typing.Dict[builtins.str, typing.Any], None, None]",
                "typing.Generator"
            ],
            "arguments": {
                "labels": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/ndjson/label.py": {
        "NDLabel.to_common": {
            "name": "to_common",
            "location": 27,
            "return": [
                "LabelGenerator",
                "str",
                "Iterable[str]",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDLabel.from_common": {
            "name": "from_common",
            "location": 35,
            "return": [
                "typing.Generator[\"NDLabel\", None, None]",
                "typing.Generator"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bytes",
                    "dict",
                    "bool"
                ],
                "data": [
                    "dict",
                    "Type[T]",
                    "Dict[str, Any]",
                    "List[Dict]",
                    "memoryview",
                    "str"
                ]
            }
        },
        "NDLabel._generate_annotations": {
            "name": "_generate_annotations",
            "location": 41,
            "return": [
                "typing.Generator[annotation_types.label.Label, None, None]",
                "typing.Generator[Label]"
            ],
            "arguments": {
                "self": [],
                "grouped_annotations": [
                    "dict",
                    "Dict[Tuple[int, ...], float]"
                ]
            }
        },
        "NDLabel._infer_media_type": {
            "name": "_infer_media_type",
            "location": 68,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "annotations": []
            }
        },
        "NDLabel._get_consecutive_frames": {
            "name": "_get_consecutive_frames",
            "location": 80,
            "return": [
                "list[tuple]",
                "str",
                "bool"
            ],
            "arguments": {
                "frames_indices": [
                    "float",
                    "str",
                    "List[str]",
                    "int",
                    "list",
                    "bool"
                ]
            }
        },
        "NDLabel._create_video_annotations": {
            "name": "_create_video_annotations",
            "location": 89,
            "return": [
                "typing.Generator[typing.Union[classification.NDChecklistSubclass, classification.NDRadioSubclass], None, None]",
                "typing.Generator"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "label": [
                    "Callable"
                ]
            }
        },
        "NDLabel._create_non_video_annotations": {
            "name": "_create_non_video_annotations",
            "location": 127,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "List[str]",
                    "Union[str, bytes]",
                    "int",
                    "bool"
                ],
                "label": [
                    "int",
                    "routemaster_sdk.types.Label",
                    "Callable"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/ndjson/metric.py": {
        "BaseNDMetric.dict": {
            "name": "dict",
            "location": 21,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDConfusionMatrixMetric.to_common": {
            "name": "to_common",
            "location": 35,
            "return": [
                "ConfusionMatrixMetric",
                "Optional[int]",
                "int",
                "str",
                "float",
                "tuple",
                "List[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDConfusionMatrixMetric.from_common": {
            "name": "from_common",
            "location": 44,
            "return": [
                "Iterable[str]",
                "str",
                "Tuple[str]",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str"
                ],
                "metric": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str"
                ],
                "data": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "NDScalarMetric.to_common": {
            "name": "to_common",
            "location": 61,
            "return": [
                "ScalarMetric",
                "bool",
                "str",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDScalarMetric.from_common": {
            "name": "from_common",
            "location": 70,
            "return": [
                "Iterable[str]",
                "str",
                "Tuple[str]",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str"
                ],
                "metric": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str"
                ],
                "data": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "NDScalarMetric.dict": {
            "name": "dict",
            "location": 80,
            "return": [
                "str",
                "bytes",
                "Union[int, float, complex]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDMetricAnnotation.to_common": {
            "name": "to_common",
            "location": 92,
            "return": [
                "eth.chains.base.MiningChain",
                "Dict[str, Any]",
                "float"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "Iterable[Tuple[int, int]]",
                    "Dict[str, str]",
                    "str"
                ],
                "annotation": [
                    "str",
                    "Type"
                ]
            }
        },
        "NDMetricAnnotation.from_common": {
            "name": "from_common",
            "location": 98,
            "return": [
                "Optional[str]",
                "List[str]",
                "str",
                "Dict[str, str]",
                "Iterable[Tuple[str, int]]",
                "Dict[str, Any]",
                "float",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "type",
                    "Dict[str, Any]",
                    "str",
                    "list"
                ],
                "annotation": [
                    "Dict[str, Any]",
                    "bool"
                ],
                "data": [
                    "Dict[str, Any]",
                    "str",
                    "Optional[Dict[str, Any]]",
                    "bytes"
                ]
            }
        },
        "NDMetricAnnotation.lookup_object": {
            "name": "lookup_object",
            "location": 107,
            "return": [
                "bool",
                "NDScalarMetric",
                "Optional[Union[str, Any]]",
                "NDConfusionMatrixMetric",
                "None"
            ],
            "arguments": {
                "annotation": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/ndjson/objects.py": {
        "NDPoint.to_common": {
            "name": "to_common",
            "location": 45,
            "return": [
                "Point",
                "int",
                "numpy.ndarray",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDPoint.from_common": {
            "name": "from_common",
            "location": 49,
            "return": [
                "str",
                "bytes",
                "int",
                "bool",
                "Union[str, bool, None]"
            ],
            "arguments": {
                "cls": [
                    "bytes",
                    "List[hydrand.ed25519.Point]",
                    "List[allennlp.data.Instance]"
                ],
                "point": [
                    "bytes",
                    "List[hydrand.ed25519.Point]",
                    "List[allennlp.data.Instance]"
                ],
                "classifications": [
                    "bytes",
                    "List[hydrand.ed25519.Point]",
                    "List[allennlp.data.Instance]"
                ],
                "feature_schema_id": [
                    "bytes",
                    "List[hydrand.ed25519.Point]",
                    "List[allennlp.data.Instance]"
                ],
                "extra": [
                    "bytes",
                    "List[hydrand.ed25519.Point]",
                    "List[allennlp.data.Instance]"
                ],
                "data": [
                    "bytes",
                    "List[hydrand.ed25519.Point]",
                    "List[allennlp.data.Instance]"
                ]
            }
        },
        "NDLine.to_common": {
            "name": "to_common",
            "location": 66,
            "return": [
                "Line",
                "str",
                "bool",
                "types.Resolver"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDLine.from_common": {
            "name": "from_common",
            "location": 70,
            "return": [
                "str",
                "Callable"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int"
                ],
                "line": [
                    "str",
                    "int"
                ],
                "classifications": [
                    "str",
                    "int"
                ],
                "feature_schema_id": [
                    "str",
                    "int"
                ],
                "extra": [
                    "str",
                    "int"
                ],
                "data": [
                    "str",
                    "int"
                ]
            }
        },
        "NDPolygon.to_common": {
            "name": "to_common",
            "location": 87,
            "return": [
                "Polygon",
                "int",
                "Optional[int]",
                "List[int]",
                "str",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDPolygon.from_common": {
            "name": "from_common",
            "location": 91,
            "return": [
                "str",
                "bytes",
                "int",
                "bool",
                "Union[str, bool, None]"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ],
                "polygon": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ],
                "classifications": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ],
                "feature_schema_id": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ],
                "extra": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ],
                "data": [
                    "int",
                    "numpy.ndarray",
                    "bool",
                    "str"
                ]
            }
        },
        "NDRectangle.to_common": {
            "name": "to_common",
            "location": 108,
            "return": [
                "Rectangle",
                "str",
                "Callable",
                "numpy.array",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDRectangle.from_common": {
            "name": "from_common",
            "location": 114,
            "return": [
                "str",
                "int",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "rectangle": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "classifications": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "feature_schema_id": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "extra": [
                    "str",
                    "int",
                    "Optional[int]"
                ],
                "data": [
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "NDFrameRectangle.to_common": {
            "name": "to_common",
            "location": 131,
            "return": [
                "VideoObjectAnnotation",
                "bytearray",
                "numpy.ndarray",
                "float",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "feature_schema_id": [
                    "float"
                ]
            }
        },
        "NDFrameRectangle.from_common": {
            "name": "from_common",
            "location": 141,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [],
                "frame": [],
                "rectangle": []
            }
        },
        "NDSegment.lookup_segment_object_type": {
            "name": "lookup_segment_object_type",
            "location": 153,
            "return": [
                "NDFrameRectangle",
                "int",
                "List[str]",
                "\"Parameter\"",
                "mypy.types.Type"
            ],
            "arguments": {
                "segment": [
                    "mypy.types.CallableType",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "NDSegment.to_common": {
            "name": "to_common",
            "location": 159,
            "return": [
                "list",
                "Set[str]",
                "str",
                "MutableMapping[str, int]"
            ],
            "arguments": {
                "self": [],
                "feature_schema_id": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "NDSegment.from_common": {
            "name": "from_common",
            "location": 165,
            "return": [
                "bool",
                "Optional[Any]",
                "Callable[[KT], VT]",
                "str"
            ],
            "arguments": {
                "cls": [
                    "mypy.types.Type",
                    "Mapping[str, Any]",
                    "cmk.base.check_utils.Service",
                    "type"
                ],
                "segment": [
                    "mypy.types.Type",
                    "Mapping[str, Any]",
                    "cmk.base.check_utils.Service",
                    "type"
                ]
            }
        },
        "NDSegments.to_common": {
            "name": "to_common",
            "location": 178,
            "return": [
                "list",
                "bool",
                "Tuple[int, Dict[str, Any]]",
                "List[pydantic.fields.ModelField]"
            ],
            "arguments": {
                "self": [],
                "feature_schema_id": [
                    "int",
                    "str"
                ]
            }
        },
        "NDSegments.from_common": {
            "name": "from_common",
            "location": 185,
            "return": [
                "str",
                "bytes",
                "Optional[Union[Dict, str, int, bytes]]",
                "bool",
                "Dict[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "int"
                ],
                "segments": [
                    "int",
                    "allennlp.data.DataLoader",
                    "Sequence[str]"
                ],
                "data": [
                    "int"
                ],
                "feature_schema_id": [
                    "int"
                ],
                "extra": [
                    "int"
                ]
            }
        },
        "NDMask.to_common": {
            "name": "to_common",
            "location": 209,
            "return": [
                "Mask",
                "str",
                "float",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDMask.from_common": {
            "name": "from_common",
            "location": 224,
            "return": [
                "dict",
                "Optional[str]",
                "Dict[str, Any]",
                "str",
                "lambda_handlers.types.APIGatewayProxyResult"
            ],
            "arguments": {
                "cls": [
                    "bytes"
                ],
                "mask": [
                    "str",
                    "bool"
                ],
                "classifications": [
                    "bytes"
                ],
                "feature_schema_id": [
                    "bytes"
                ],
                "extra": [
                    "bytes"
                ],
                "data": [
                    "bytes"
                ]
            }
        },
        "NDTextEntity.to_common": {
            "name": "to_common",
            "location": 253,
            "return": [
                "mypy.types.Type",
                "TextEntity"
            ],
            "arguments": {
                "self": []
            }
        },
        "NDTextEntity.from_common": {
            "name": "from_common",
            "location": 257,
            "return": [
                "Dict[str, Any]",
                "Callable[..., None]",
                "authorityspoke.io.schemas.RawFactor",
                "dict",
                "List[Dict[str, object]]",
                "types.ChannelT[T]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "List[dict]"
                ],
                "text_entity": [
                    "str",
                    "int",
                    "List[dict]"
                ],
                "classifications": [
                    "str",
                    "int",
                    "List[dict]"
                ],
                "feature_schema_id": [
                    "str",
                    "int",
                    "List[dict]"
                ],
                "extra": [
                    "str",
                    "int",
                    "List[dict]"
                ],
                "data": [
                    "str",
                    "int",
                    "List[dict]"
                ]
            }
        },
        "NDObject.to_common": {
            "name": "to_common",
            "location": 274,
            "return": [
                "ObjectAnnotation",
                "str",
                "dict",
                "Iterable[numpy.dtype]",
                "Dict[str, Any]",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "annotation": [
                    "float",
                    "List[Point]",
                    "str"
                ]
            }
        },
        "NDObject.from_common": {
            "name": "from_common",
            "location": 286,
            "return": [
                "Optional[str]",
                "List[str]",
                "str",
                "Dict[str, str]",
                "Iterable[Tuple[str, int]]",
                "Dict[str, Any]",
                "float",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "type",
                    "Dict[str, Any]",
                    "str",
                    "list"
                ],
                "annotation": [
                    "Iterable[allennlp.data.instance.Instance]",
                    "Optional[Iterable[allennlp.data.instance.Instance]]",
                    "int",
                    "str",
                    "bytes"
                ],
                "data": [
                    "MutableMapping[str, Any]"
                ]
            }
        },
        "NDObject.lookup_object": {
            "name": "lookup_object",
            "location": 310,
            "return": [
                "bool",
                "List[pydantic.fields.ModelField]",
                "NDLine",
                "Optional[Union[str, Any]]",
                "NDPoint",
                "NDPolygon",
                "NDRectangle",
                "NDMask",
                "NDTextEntity",
                "NDSegments",
                "None"
            ],
            "arguments": {
                "annotation": [
                    "str",
                    "Set[str]",
                    "Counter[str]",
                    "List[str]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/data/serialization/ndjson/__init__.py": {},
    "labelbox-python-master/labelbox/orm/comparison.py": {
        "LogicalExpressionComponent.__and__": {
            "name": "__and__",
            "location": 14,
            "return": [],
            "arguments": {
                "self": [],
                "other": [
                    "T"
                ]
            }
        },
        "LogicalExpressionComponent.__or__": {
            "name": "__or__",
            "location": 19,
            "return": [],
            "arguments": {
                "self": [],
                "other": [
                    "T"
                ]
            }
        },
        "LogicalExpressionComponent.__invert__": {
            "name": "__invert__",
            "location": 24,
            "return": [
                "T",
                "SupportsFloat"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogicalExpression.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "op": [
                    "Callable",
                    "str",
                    "bool",
                    "Sequence",
                    "Callable[[str], bool]"
                ],
                "first": [
                    "Callable",
                    "str",
                    "bool",
                    "Sequence",
                    "Callable[[str], bool]"
                ],
                "second": [
                    "None",
                    "Callable",
                    "str",
                    "bool",
                    "Sequence",
                    "Callable[[str], bool]"
                ]
            }
        },
        "LogicalExpression.__eq__": {
            "name": "__eq__",
            "location": 55,
            "return": [
                "bool",
                "str",
                "List[str]",
                "int",
                "Iterable[str]"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "LogicalExpression.__hash__": {
            "name": "__hash__",
            "location": 60,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogicalExpression.__repr__": {
            "name": "__repr__",
            "location": 64,
            "return": [
                "typing.Text",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogicalExpression.__str__": {
            "name": "__str__",
            "location": 67,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "Comparison.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "op": [
                    "int",
                    "bool",
                    "str",
                    "float",
                    "Optional[List[Any]]"
                ],
                "field": [
                    "List[Type]",
                    "List[str]",
                    "list"
                ],
                "value": [
                    "str",
                    "float",
                    "Callable[[None], bool]",
                    "List[str]",
                    "Tuple[str, str]",
                    "int",
                    "IO[bytes]"
                ]
            }
        },
        "Comparison.__eq__": {
            "name": "__eq__",
            "location": 101,
            "return": [
                "bool",
                "str",
                "Mapping[str, str]",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "Comparison.__hash__": {
            "name": "__hash__",
            "location": 105,
            "return": [
                "int",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Comparison.__repr__": {
            "name": "__repr__",
            "location": 108,
            "return": [
                "typing.Text",
                "Dict[str, Any]",
                "dict",
                "Type",
                "int",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Comparison.__str__": {
            "name": "__str__",
            "location": 111,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "LogicalExpression.Op.__call__": {
            "name": "__call__",
            "location": 38,
            "return": [
                "LogicalExpression"
            ],
            "arguments": {
                "self": [],
                "first": [],
                "second": [
                    "None"
                ]
            }
        },
        "Comparison.Op.__call__": {
            "name": "__call__",
            "location": 84,
            "return": [
                "Comparison",
                "int",
                "Tuple[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/orm/db_object.py": {
        "experimental": {
            "name": "experimental",
            "location": 270,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "fn": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "DbObject.__init__": {
            "name": "__init__",
            "location": 35,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "client": [],
                "field_values": [
                    "set",
                    "dict",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "DbObject._set_field_values": {
            "name": "_set_field_values",
            "location": 54,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "field_values": [
                    "str",
                    "type",
                    "peewee.Field",
                    "dataclasses.Field"
                ]
            }
        },
        "DbObject.__repr__": {
            "name": "__repr__",
            "location": 84,
            "return": [
                "bool",
                "str",
                "Union[int, float, complex]",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "DbObject.__str__": {
            "name": "__str__",
            "location": 91,
            "return": [
                "str",
                "Tuple[Tuple[int, ...]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DbObject.__eq__": {
            "name": "__eq__",
            "location": 97,
            "return": [
                "str",
                "BaseException",
                "Exception",
                "Type[BaseException]"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "str",
                    "float"
                ]
            }
        },
        "DbObject.__hash__": {
            "name": "__hash__",
            "location": 101,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationshipManager.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "source": [
                    "bytes",
                    "str",
                    "List[Tuple[int, int]]"
                ],
                "relationship": [
                    "bool",
                    "str",
                    "Sequence",
                    "float"
                ],
                "value": [
                    "float",
                    "str",
                    "List[str]",
                    "IO[bytes]"
                ]
            }
        },
        "RelationshipManager.__call__": {
            "name": "__call__",
            "location": 125,
            "return": [
                "bool",
                "str",
                "raiden.utils.Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationshipManager._to_many": {
            "name": "_to_many",
            "location": 137,
            "return": [
                "str",
                "bytes",
                "datetime.date",
                "bool"
            ],
            "arguments": {
                "self": [],
                "where": [
                    "Type"
                ],
                "order_by": [
                    "Type",
                    "Match"
                ]
            }
        },
        "RelationshipManager._to_one": {
            "name": "_to_one",
            "location": 167,
            "return": [
                "bool",
                "Optional[Any]",
                "Optional[str]",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "RelationshipManager.connect": {
            "name": "connect",
            "location": 184,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "other": [
                    "dict",
                    "OrderedDict",
                    "List[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "RelationshipManager.disconnect": {
            "name": "disconnect",
            "location": 190,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "other": [
                    "dict",
                    "OrderedDict",
                    "List[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Updateable.update": {
            "name": "update",
            "location": 199,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "Deletable.delete": {
            "name": "delete",
            "location": 226,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "BulkDeletable._bulk_delete": {
            "name": "_bulk_delete",
            "location": 245,
            "return": [
                ""
            ],
            "arguments": {
                "objects": [
                    "str",
                    "bool",
                    "Collection[str]"
                ],
                "use_where_clause": [
                    "Dict[str, Any]",
                    "dict",
                    "Dict[str, str]",
                    "int",
                    "Optional[Dict[str, Any]]",
                    "Mapping[str, str]"
                ]
            }
        },
        "BulkDeletable.delete": {
            "name": "delete",
            "location": 263,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "experimental.wrapper": {
            "name": "wrapper",
            "location": 273,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/orm/model.py": {
        "Field.Int": {
            "name": "Int",
            "location": 83,
            "return": [
                "bool",
                "Field"
            ],
            "arguments": {}
        },
        "Field.Float": {
            "name": "Float",
            "location": 87,
            "return": [
                "bool",
                "Field"
            ],
            "arguments": {}
        },
        "Field.String": {
            "name": "String",
            "location": 91,
            "return": [
                "Field",
                "bool",
                "Sequence",
                "Mapping",
                "type",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "Field.Boolean": {
            "name": "Boolean",
            "location": 95,
            "return": [
                "bool",
                "Field"
            ],
            "arguments": {}
        },
        "Field.ID": {
            "name": "ID",
            "location": 99,
            "return": [
                "Field",
                "str",
                "Union[int, float]",
                "List[int]"
            ],
            "arguments": {}
        },
        "Field.DateTime": {
            "name": "DateTime",
            "location": 103,
            "return": [
                "Field",
                "Tuple[float, float]",
                "int",
                "str",
                "type"
            ],
            "arguments": {}
        },
        "Field.Enum": {
            "name": "Enum",
            "location": 107,
            "return": [
                "Field",
                "str",
                "int",
                "bool",
                "Sequence",
                "type",
                "Optional[str]"
            ],
            "arguments": {
                "enum_cls": [
                    "type",
                    "str",
                    "Dict[str, int]",
                    "Exception",
                    "Dict[str, Iterable[Any]]",
                    "Optional[Type]"
                ]
            }
        },
        "Field.Json": {
            "name": "Json",
            "location": 111,
            "return": [
                "bool",
                "Field"
            ],
            "arguments": {}
        },
        "Field.List": {
            "name": "List",
            "location": 115,
            "return": [
                "Field",
                "bool",
                "List[str]"
            ],
            "arguments": {
                "list_cls": [
                    "str",
                    "Type[Any]"
                ],
                "graphql_type": [
                    "None",
                    "str",
                    "Type[Any]"
                ]
            }
        },
        "Field.__init__": {
            "name": "__init__",
            "location": 118,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "field_type": [
                    "str",
                    "Type"
                ],
                "name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Union[str, List[str]]"
                ],
                "graphql_name": [
                    "None",
                    "Optional[str]",
                    "Optional[Sequence[str]]",
                    "Optional[int]",
                    "str"
                ],
                "result_subquery": [
                    "None",
                    "Optional[List[str]]",
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "Field.asc": {
            "name": "asc",
            "location": 141,
            "return": [
                "tuple[Field]",
                "List[str]",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.desc": {
            "name": "desc",
            "location": 149,
            "return": [
                "tuple[Field]",
                "List[str]",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.__eq__": {
            "name": "__eq__",
            "location": 156,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "raiden.utils.Any",
                    "Union[int, \"BitVec\"]"
                ]
            }
        },
        "Field.__ne__": {
            "name": "__ne__",
            "location": 166,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "raiden.utils.Any",
                    "Union[int, \"BitVec\"]"
                ]
            }
        },
        "Field.__hash__": {
            "name": "__hash__",
            "location": 176,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.__lt__": {
            "name": "__lt__",
            "location": 181,
            "return": [
                "str",
                "bool",
                "float",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Field.__gt__": {
            "name": "__gt__",
            "location": 184,
            "return": [
                "str",
                "bool",
                "float",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Field.__le__": {
            "name": "__le__",
            "location": 187,
            "return": [
                "str",
                "bool",
                "float",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Field.__ge__": {
            "name": "__ge__",
            "location": 190,
            "return": [
                "str",
                "bool",
                "float",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "other": []
            }
        },
        "Field.__str__": {
            "name": "__str__",
            "location": 193,
            "return": [
                "str",
                "Optional[Any]",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.__repr__": {
            "name": "__repr__",
            "location": 196,
            "return": [
                "typing.Text",
                "str",
                "BaseException",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Relationship.ToOne": {
            "name": "ToOne",
            "location": 227,
            "return": [
                "Relationship",
                "str",
                "dict"
            ],
            "arguments": {}
        },
        "Relationship.ToMany": {
            "name": "ToMany",
            "location": 231,
            "return": [
                "Relationship",
                "str",
                "dict"
            ],
            "arguments": {}
        },
        "Relationship.__init__": {
            "name": "__init__",
            "location": 234,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "relationship_type": [
                    "str"
                ],
                "destination_type_name": [
                    "str",
                    "int",
                    "enum.EnumMeta",
                    "Optional[str]",
                    "Type[Exception]"
                ],
                "filter_deleted": [
                    "str",
                    "bool"
                ],
                "name": [
                    "None",
                    "str",
                    "cmk.utils.type_defs.SourceType",
                    "Optional[str]",
                    "type",
                    "int"
                ],
                "graphql_name": [
                    "None",
                    "Optional[str]",
                    "str",
                    "float"
                ],
                "cache": [
                    "bool",
                    "str",
                    "Optional[str]"
                ],
                "deprecation_warning": [
                    "str",
                    "None"
                ]
            }
        },
        "Relationship.destination_type": {
            "name": "destination_type",
            "location": 258,
            "return": [
                "str",
                "Exception",
                "Callable[..., T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Relationship.__str__": {
            "name": "__str__",
            "location": 261,
            "return": [
                "str",
                "Optional[Any]",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Relationship.__repr__": {
            "name": "__repr__",
            "location": 264,
            "return": [
                "typing.Text",
                "type",
                "str",
                "Callable[[str], None]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EntityMeta.__setattr__": {
            "name": "__setattr__",
            "location": 276,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "T",
                    "str"
                ],
                "value": [
                    "T",
                    "str"
                ]
            }
        },
        "EntityMeta.__init__": {
            "name": "__init__",
            "location": 279,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "clsname": [
                    "bool",
                    "list",
                    "Mapping"
                ],
                "superclasses": [
                    "str",
                    "Mapping",
                    "Callable"
                ],
                "attributedict": [
                    "str",
                    "Mapping",
                    "Callable"
                ]
            }
        },
        "EntityMeta.raise_for_nested_cache": {
            "name": "raise_for_nested_cache",
            "location": 288,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "first": [
                    "str"
                ],
                "middle": [
                    "str"
                ],
                "last": [
                    "str"
                ]
            }
        },
        "EntityMeta.cached_entities": {
            "name": "cached_entities",
            "location": 294,
            "return": [
                "dict",
                "List[Tuple[int, int]]",
                "Set[str]",
                "Dict[str, Set[str]]",
                "Dict[str, Any]",
                "str",
                "object",
                "List[str]"
            ],
            "arguments": {
                "entity_name": [
                    "str"
                ]
            }
        },
        "EntityMeta.validate_cached_relationships": {
            "name": "validate_cached_relationships",
            "location": 303,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "bytes",
                    "Union[str]"
                ]
            }
        },
        "Entity._attributes_of_type": {
            "name": "_attributes_of_type",
            "location": 381,
            "return": [
                "",
                "typing.Generator[attr_type]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Any]",
                    "List[int]",
                    "set",
                    "Set[str]",
                    "List[Dict[str, Any]]"
                ],
                "attr_type": [
                    "str"
                ]
            }
        },
        "Entity.fields": {
            "name": "fields",
            "location": 389,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "cls": [
                    "Type[object]",
                    "tuple",
                    "dict",
                    "list",
                    "Dict[str, str]"
                ]
            }
        },
        "Entity.relationships": {
            "name": "relationships",
            "location": 398,
            "return": [
                "cmk.utils.type_defs.ServiceName",
                "cmk.utils.type_defs.HostName",
                "int"
            ],
            "arguments": {
                "cls": [
                    "Container[int]",
                    "tuple",
                    "Type[T]",
                    "dict"
                ]
            }
        },
        "Entity.field": {
            "name": "field",
            "location": 405,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bytes"
                ],
                "field_name": [
                    "str",
                    "bytes"
                ]
            }
        },
        "Entity.attribute": {
            "name": "attribute",
            "location": 421,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bytes",
                    "Optional[str]"
                ],
                "attribute_name": [
                    "str",
                    "bytes",
                    "Optional[str]"
                ]
            }
        },
        "Entity.type_name": {
            "name": "type_name",
            "location": 438,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Mapping[str, str]",
                    "Type"
                ]
            }
        },
        "Field.EnumType.__init__": {
            "name": "__init__",
            "location": 51,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "enum_cls": [
                    "int",
                    "list"
                ]
            }
        },
        "Field.EnumType.name": {
            "name": "name",
            "location": 55,
            "return": [
                "str",
                "list",
                "Type",
                "Type[BaseException]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Field.ListType.__init__": {
            "name": "__init__",
            "location": 66,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "list_cls": [
                    "str",
                    "Optional[List[str]]",
                    "int",
                    "Optional[int]"
                ],
                "graphql_type": [
                    "str",
                    "Optional[str]",
                    "Union[str, Callable]"
                ]
            }
        },
        "Field.ListType.name": {
            "name": "name",
            "location": 74,
            "return": [
                "typing.Text",
                "str",
                "Optional[BaseException]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/orm/query.py": {
        "format_param_declaration": {
            "name": "format_param_declaration",
            "location": 10,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "params": [
                    "str",
                    "cmk.utils.type_defs.HostName",
                    "Exception",
                    "Optional[str]"
                ]
            }
        },
        "results_query_part": {
            "name": "results_query_part",
            "location": 33,
            "return": [
                "str",
                "Union[List, Dict]",
                "Tuple[Any, Any, Any]",
                "bool",
                "int"
            ],
            "arguments": {
                "entity": [
                    "homeassistanhelpers.entity.Entity",
                    "Type"
                ]
            }
        },
        "get_single": {
            "name": "get_single",
            "location": 172,
            "return": [
                "dict",
                "Dict[str, Any]",
                "List[str]",
                "str"
            ],
            "arguments": {
                "entity": [
                    "str",
                    "Optional[Container[str]]",
                    "Optional[str]"
                ],
                "uid": [
                    "str",
                    "Optional[bytes]",
                    "Optional[str]",
                    "bool",
                    "guillotina.db.orm.interfaces.IBaseObject",
                    "bytes"
                ]
            }
        },
        "logical_ops": {
            "name": "logical_ops",
            "location": 187,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "where": [
                    "Iterable",
                    "int",
                    "src.core.model.profile.Profile"
                ]
            }
        },
        "check_where_clause": {
            "name": "check_where_clause",
            "location": 204,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "entity": [
                    "type",
                    "OrderedDict",
                    "rflx.model.Message",
                    "bool",
                    "rflx.model.Field",
                    "dict"
                ],
                "where": [
                    "dict",
                    "set"
                ]
            }
        },
        "check_order_by_clause": {
            "name": "check_order_by_clause",
            "location": 242,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "entity": [
                    "Dict[str, Any]"
                ],
                "order_by": [
                    "Optional[Dict[str, Any]]",
                    "List[\"Block\"]",
                    "ecs.Entity",
                    "float",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "get_all": {
            "name": "get_all",
            "location": 258,
            "return": [
                "str"
            ],
            "arguments": {
                "entity": [
                    "bool",
                    "cleancoderscom.entities.entity.Entity"
                ],
                "where": [
                    "bool",
                    "cleancoderscom.entities.entity.Entity",
                    "dict"
                ]
            }
        },
        "relationship": {
            "name": "relationship",
            "location": 277,
            "return": [
                "str",
                "bytes",
                "int"
            ],
            "arguments": {
                "source": [
                    "Optional[List[str]]"
                ],
                "relationship": [
                    "rflx.model.Type",
                    "rflx.model.Scalar",
                    "Optional[str]"
                ],
                "where": [
                    "rflx.model.Message"
                ],
                "order_by": [
                    "str",
                    "Set[str]"
                ]
            }
        },
        "create": {
            "name": "create",
            "location": 315,
            "return": [
                "tuple[typing.Union[typing.Text,dict]]",
                "str",
                "Callable",
                "dict",
                "bool"
            ],
            "arguments": {
                "entity": [
                    "Dict[str, Any]",
                    "str"
                ],
                "data": [
                    "Type[T]",
                    "Dict[str, int]",
                    "Dict[str, str]",
                    "str",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "update_relationship": {
            "name": "update_relationship",
            "location": 349,
            "return": [
                "tuple[typing.Union[typing.Text,dict]]",
                "str",
                "int",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {
                "a": [
                    "str",
                    "Dict[str, Any]",
                    "Dict[str, str]",
                    "tuple"
                ],
                "b": [
                    "Dict[str, Set[str]]",
                    "dict",
                    "bool",
                    "MutableMapping"
                ],
                "relationship": [
                    "int",
                    "bool",
                    "Callable",
                    "Dict[str, Callable]",
                    "dict"
                ],
                "update": [
                    "int",
                    "bool",
                    "Callable",
                    "Dict[str, Callable]",
                    "dict"
                ]
            }
        },
        "update_fields": {
            "name": "update_fields",
            "location": 389,
            "return": [
                "tuple[typing.Union[typing.Text,dict[tuple[typing.Union[typing.Text,tuple]], tuple[typing.Union[typing.Text,tuple]]]]]",
                "str",
                "bool",
                "Callable",
                "Optional[cmk.utils.type_defs.HostName]"
            ],
            "arguments": {
                "db_object": [
                    "Dict[str, Any]",
                    "dict",
                    "Optional[Dict[str, Any]]",
                    "str"
                ],
                "values": [
                    "str",
                    "dict",
                    "int"
                ]
            }
        },
        "delete": {
            "name": "delete",
            "location": 417,
            "return": [
                "tuple[typing.Union[typing.Text,dict[typing.Text, ]]]",
                "str",
                "cmk.utils.type_defs.UserId",
                "bytes",
                "int"
            ],
            "arguments": {
                "db_object": [
                    "sqlalchemy.orm.Session",
                    "Type[T]",
                    "str",
                    "Optional[Any]"
                ]
            }
        },
        "bulk_delete": {
            "name": "bulk_delete",
            "location": 432,
            "return": [
                "tuple[typing.Union[typing.Text,dict]]",
                "str",
                "int",
                "Optional[int]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "db_objects": [
                    "str",
                    "Iterable[str]",
                    "Iterable[Any]",
                    "dict",
                    "Dict[str, Any]",
                    "bool",
                    "Tuple[type]"
                ],
                "use_where_clause": [
                    "bool",
                    "Set[str]",
                    "Type[Exception]",
                    "List[str]",
                    "Iterable[bytes]",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "format_param_declaration.attr_type": {
            "name": "attr_type",
            "location": 23,
            "return": [
                "str"
            ],
            "arguments": {
                "attr": [
                    "Dict[str, Any]",
                    "dict",
                    "bytearray",
                    "dataclasses.Field"
                ]
            }
        },
        "Query.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "what": [
                    "float",
                    "int"
                ],
                "subquery": [
                    "int",
                    "bool",
                    "float"
                ],
                "where": [
                    "None",
                    "float",
                    "int"
                ],
                "paginate": [
                    "bool",
                    "int",
                    "float"
                ],
                "order_by": [
                    "None",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Query.format_subquery": {
            "name": "format_subquery",
            "location": 89,
            "return": [
                "tuple[dict]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Query.format_clauses": {
            "name": "format_clauses",
            "location": 98,
            "return": [
                "typing.Text",
                "str",
                "int",
                "List[List[str]]",
                "tuple"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "bool",
                    "List[Tuple[int, str]]",
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "Query.format": {
            "name": "format",
            "location": 142,
            "return": [
                "tuple[typing.Text]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Query.format_top": {
            "name": "format_top",
            "location": 154,
            "return": [
                "tuple[typing.Union[typing.Text,dict]]",
                "bool",
                "Dict[str, Union[str, int]]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "check_where_clause.fields": {
            "name": "fields",
            "location": 218,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "where": [
                    "str",
                    "Tuple[str]",
                    "Sequence[str]"
                ]
            }
        },
        "create.format_param_value": {
            "name": "format_param_value",
            "location": 328,
            "return": [
                "typing.Text",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "attribute": [
                    "Type",
                    "cmk.utils.type_defs.EventRule",
                    "dict",
                    "str"
                ],
                "param": [
                    "dict",
                    "Dict[str, Any]",
                    "Callable",
                    "Mapping[str, Any]"
                ]
            }
        },
        "Query.format_clauses.format_where": {
            "name": "format_where",
            "location": 104,
            "return": [
                "typing.Text",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "node": []
            }
        }
    },
    "labelbox-python-master/labelbox/orm/__init__.py": {},
    "labelbox-python-master/labelbox/schema/annotation_import.py": {
        "AnnotationImport.inputs": {
            "name": "inputs",
            "location": 34,
            "return": [
                "str",
                "Optional[int]",
                "Callable",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnnotationImport.errors": {
            "name": "errors",
            "location": 45,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnnotationImport.statuses": {
            "name": "statuses",
            "location": 57,
            "return": [
                "str",
                "float",
                "Mapping[str, Any]",
                "Iterable"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnnotationImport.wait_until_done": {
            "name": "wait_until_done",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sleep_time_seconds": [
                    "int",
                    "Union[int, float]",
                    "str"
                ],
                "show_progress": [
                    "bool",
                    "str",
                    "model.View",
                    "int"
                ]
            }
        },
        "AnnotationImport.__backoff_refresh": {
            "name": "__backoff_refresh",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnnotationImport._fetch_remote_ndjson": {
            "name": "_fetch_remote_ndjson",
            "location": 116,
            "return": [
                "str",
                "Optional[Dict]",
                "dict",
                "Mapping[str, Any]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "url": [
                    "str"
                ]
            }
        },
        "AnnotationImport._create_from_bytes": {
            "name": "_create_from_bytes",
            "location": 132,
            "return": [
                "dict",
                "bool",
                "Optional[type]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int",
                    "bytes",
                    "list",
                    "bool",
                    "Iterable[str]"
                ],
                "client": [
                    "bytes",
                    "int",
                    "str",
                    "Mapping[str, str]",
                    "List[Tuple[str, int]]"
                ],
                "variables": [
                    "str",
                    "int"
                ],
                "query_str": [
                    "str",
                    "int"
                ],
                "file_name": [
                    "str",
                    "bytes",
                    "Optional[Dict[str, str]]"
                ],
                "bytes_data": [
                    "str",
                    "Mapping[str, Any]",
                    "int"
                ]
            }
        },
        "AnnotationImport.refresh": {
            "name": "refresh",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AnnotationImport.from_name": {
            "name": "from_name",
            "location": 154,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable[[], None]",
                    "bool"
                ],
                "client": [
                    "str",
                    "Callable[[], None]",
                    "bool"
                ],
                "parent_id": [
                    "str",
                    "Callable[[], None]",
                    "bool"
                ],
                "name": [
                    "str",
                    "Callable[[], None]",
                    "bool"
                ],
                "as_json": [
                    "bool",
                    "str",
                    "Callable[[], None]"
                ]
            }
        },
        "AnnotationImport.parent_id": {
            "name": "parent_id",
            "location": 162,
            "return": [
                "builtins.str",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MEAPredictionImport.parent_id": {
            "name": "parent_id",
            "location": 170,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MEAPredictionImport.create_from_file": {
            "name": "create_from_file",
            "location": 177,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool",
                    "int"
                ],
                "client": [
                    "str",
                    "bool",
                    "int"
                ],
                "model_run_id": [
                    "str",
                    "bool",
                    "int"
                ],
                "name": [
                    "str",
                    "bool",
                    "int"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "MEAPredictionImport.create_from_objects": {
            "name": "create_from_objects",
            "location": 199,
            "return": [
                "str",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bytes",
                    "int"
                ],
                "client": [
                    "str",
                    "bytes",
                    "int"
                ],
                "model_run_id": [
                    "str",
                    "bytes",
                    "int"
                ],
                "name": [
                    "str",
                    "bytes",
                    "int"
                ],
                "predictions": [
                    "str"
                ]
            }
        },
        "MEAPredictionImport.create_from_url": {
            "name": "create_from_url",
            "location": 220,
            "return": [],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "client": [
                    "str",
                    "Optional[dict]"
                ],
                "model_run_id": [
                    "str",
                    "Optional[dict]"
                ],
                "name": [
                    "str",
                    "Optional[dict]"
                ],
                "url": [
                    "str",
                    "Dict[str, Any]",
                    "int",
                    "Dict[str, List[str]]"
                ]
            }
        },
        "MEAPredictionImport.from_name": {
            "name": "from_name",
            "location": 248,
            "return": [
                "dict",
                "Dict[str, str]",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, Any]"
                ],
                "client": [
                    "str",
                    "dict"
                ],
                "model_run_id": [
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "Optional[str]"
                ],
                "as_json": [
                    "bool",
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "MEAPredictionImport._get_url_mutation": {
            "name": "_get_url_mutation",
            "location": 282,
            "return": [
                "typing.Text",
                "str",
                "bool",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str"
                ]
            }
        },
        "MEAPredictionImport._get_file_mutation": {
            "name": "_get_file_mutation",
            "location": 292,
            "return": [
                "typing.Text",
                "str",
                "bool",
                "Optional[int]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Set[str]"
                ]
            }
        },
        "MEAPredictionImport._create_mea_import_from_bytes": {
            "name": "_create_mea_import_from_bytes",
            "location": 300,
            "return": [
                "Dict[str, Any]",
                "List['ValidatorRecord']",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "List[int]",
                    "Dict[str, Any]",
                    "Optional[Dict]"
                ],
                "client": [
                    "str",
                    "Callable",
                    "int",
                    "bytes"
                ],
                "model_run_id": [
                    "bool",
                    "Optional[str]",
                    "str",
                    "dict",
                    "List[str]"
                ],
                "name": [
                    "bool",
                    "Optional[str]",
                    "str",
                    "dict",
                    "List[str]"
                ],
                "bytes_data": [
                    "str",
                    "float"
                ],
                "content_len": [
                    "Optional[Dict[str, Any]]",
                    "Optional[str]",
                    "bool",
                    "str",
                    "Optional[List[str]]",
                    "Optional[Dict[str, str]]"
                ]
            }
        },
        "MALPredictionImport.parent_id": {
            "name": "parent_id",
            "location": 325,
            "return": [
                "List[str]",
                "str",
                "Dict[str, str]",
                "Dict[str, Set[str]]",
                "dict",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MALPredictionImport.create_from_file": {
            "name": "create_from_file",
            "location": 332,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[str]"
                ],
                "client": [
                    "str",
                    "Optional[str]"
                ],
                "project_id": [
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "Optional[str]"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "MALPredictionImport.create_from_objects": {
            "name": "create_from_objects",
            "location": 354,
            "return": [
                "str",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str"
                ],
                "client": [
                    "str"
                ],
                "project_id": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "predictions": [
                    "str"
                ]
            }
        },
        "MALPredictionImport.create_from_url": {
            "name": "create_from_url",
            "location": 376,
            "return": [],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "client": [
                    "str"
                ],
                "project_id": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "url": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "MALPredictionImport.from_name": {
            "name": "from_name",
            "location": 405,
            "return": [
                "dict",
                "Dict[str, str]",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "sqlalchemy.orm.session.Session",
                    "int"
                ],
                "client": [
                    "str"
                ],
                "project_id": [
                    "str",
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "List[List[str]]"
                ],
                "name": [
                    "str",
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "List[List[str]]"
                ],
                "as_json": [
                    "bool",
                    "str",
                    "Callable[[], None]",
                    "Dict[str, Any]"
                ]
            }
        },
        "MALPredictionImport._get_url_mutation": {
            "name": "_get_url_mutation",
            "location": 439,
            "return": [
                "typing.Text",
                "str",
                "bool",
                "Optional[int]",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str"
                ]
            }
        },
        "MALPredictionImport._get_file_mutation": {
            "name": "_get_file_mutation",
            "location": 449,
            "return": [
                "typing.Text",
                "str",
                "bool",
                "Optional[int]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Set[str]"
                ]
            }
        },
        "MALPredictionImport._create_mal_import_from_bytes": {
            "name": "_create_mal_import_from_bytes",
            "location": 457,
            "return": [],
            "arguments": {
                "cls": [
                    "bytes",
                    "str",
                    "int",
                    "Union[str, bytes]"
                ],
                "client": [
                    "str",
                    "IO[bytes]",
                    "Optional[str]",
                    "bytes",
                    "int",
                    "Callable"
                ],
                "project_id": [
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "Optional[str]"
                ],
                "bytes_data": [
                    "str",
                    "float",
                    "bytes"
                ],
                "content_len": [
                    "str",
                    "Optional[str]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "LabelImport.parent_id": {
            "name": "parent_id",
            "location": 477,
            "return": [
                "List[str]",
                "str",
                "Dict[str, str]",
                "Dict[str, Set[str]]",
                "dict",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "LabelImport.create_from_file": {
            "name": "create_from_file",
            "location": 484,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "int"
                ],
                "client": [
                    "str",
                    "int"
                ],
                "project_id": [
                    "str",
                    "int"
                ],
                "name": [
                    "str",
                    "int"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "LabelImport.create_from_objects": {
            "name": "create_from_objects",
            "location": 506,
            "return": [
                "str",
                "Mapping[str, Any]",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "sqlalchemy.orm.Session",
                    "int"
                ],
                "client": [
                    "str",
                    "sqlalchemy.orm.Session",
                    "int"
                ],
                "project_id": [
                    "str",
                    "sqlalchemy.orm.Session",
                    "int"
                ],
                "name": [
                    "str",
                    "sqlalchemy.orm.Session",
                    "int"
                ],
                "labels": [
                    "str"
                ]
            }
        },
        "LabelImport.create_from_url": {
            "name": "create_from_url",
            "location": 528,
            "return": [],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "client": [
                    "str"
                ],
                "project_id": [
                    "str"
                ],
                "name": [
                    "str"
                ],
                "url": [
                    "str",
                    "Dict[str, str]"
                ]
            }
        },
        "LabelImport.from_name": {
            "name": "from_name",
            "location": 556,
            "return": [
                "dict",
                "Dict[str, str]",
                "str",
                "bool",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "sqlalchemy.orm.session.Session",
                    "int"
                ],
                "client": [
                    "str"
                ],
                "project_id": [
                    "str",
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "List[List[str]]"
                ],
                "name": [
                    "str",
                    "Dict[str, object]",
                    "Dict[str, Any]",
                    "List[List[str]]"
                ],
                "as_json": [
                    "bool",
                    "str",
                    "Callable[[], None]",
                    "Dict[str, Any]"
                ]
            }
        },
        "LabelImport._get_url_mutation": {
            "name": "_get_url_mutation",
            "location": 589,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "cls": [
                    "str"
                ]
            }
        },
        "LabelImport._get_file_mutation": {
            "name": "_get_file_mutation",
            "location": 599,
            "return": [
                "typing.Text",
                "str",
                "Dict[str, Dict[str, Any]]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Set[str]"
                ]
            }
        },
        "LabelImport._create_label_import_from_bytes": {
            "name": "_create_label_import_from_bytes",
            "location": 607,
            "return": [
                "Dict[str, Any]",
                "int",
                "List['ValidatorRecord']"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bytes"
                ],
                "client": [
                    "str",
                    "bytes",
                    "int",
                    "Optional[str]"
                ],
                "project_id": [
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "Optional[str]"
                ],
                "bytes_data": [
                    "str",
                    "float",
                    "bytes"
                ],
                "content_len": [
                    "bool",
                    "dict",
                    "Dict[str, str]",
                    "Optional[str]",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/asset_attachment.py": {
        "AssetAttachment.validate_attachment_json": {
            "name": "validate_attachment_json",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Type[object]",
                    "type",
                    "dict",
                    "Type"
                ],
                "attachment_json": [
                    "Type[object]",
                    "type",
                    "bytes",
                    "dict",
                    "T",
                    "Collection[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "AssetAttachment.validate_attachment_type": {
            "name": "validate_attachment_type",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "set",
                    "Mapping[rflx.identifier.ID, rflx.model.Type]"
                ],
                "attachment_type": [
                    "str",
                    "Union[str, List[Any]]",
                    "Optional[str]"
                ]
            }
        },
        "AssetAttachment.delete": {
            "name": "delete",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/batch.py": {
        "Batch.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "dict",
                    "list"
                ],
                "project_id": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "Batch.project": {
            "name": "project",
            "location": 43,
            "return": [
                "Dict[str, float]",
                "Project"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.remove_queued_data_rows": {
            "name": "remove_queued_data_rows",
            "location": 62,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Batch.export_data_rows": {
            "name": "export_data_rows",
            "location": 80,
            "return": [
                "typing.Generator",
                "bool",
                "Dict[str, Any]",
                "Callable",
                "Mapping"
            ],
            "arguments": {
                "self": [],
                "timeout_seconds": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/benchmark.py": {
        "Benchmark.delete": {
            "name": "delete",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/bulk_import_request.py": {
        "_make_file_name": {
            "name": "_make_file_name",
            "location": 32,
            "return": [
                "typing.Text"
            ],
            "arguments": {
                "project_id": [],
                "name": []
            }
        },
        "_make_request_data": {
            "name": "_make_request_data",
            "location": 37,
            "return": [
                "dict[typing.Text, tuple[None]]"
            ],
            "arguments": {
                "project_id": [],
                "name": [],
                "content_length": [],
                "file_name": []
            }
        },
        "_send_create_file_command": {
            "name": "_send_create_file_command",
            "location": 67,
            "return": [],
            "arguments": {
                "client": [],
                "request_data": [],
                "file_name": [],
                "file_data": []
            }
        },
        "_validate_ndjson": {
            "name": "_validate_ndjson",
            "location": 392,
            "return": [
                "None"
            ],
            "arguments": {
                "lines": [],
                "project": []
            }
        },
        "parse_classification": {
            "name": "parse_classification",
            "location": 429,
            "return": [
                "dict[typing.Text, list]",
                "dict[typing.Text, ]"
            ],
            "arguments": {
                "tool": []
            }
        },
        "get_mal_schemas": {
            "name": "get_mal_schemas",
            "location": 452,
            "return": [
                "dict[, dict[typing.Text, dict]]"
            ],
            "arguments": {
                "ontology": []
            }
        },
        "BulkImportRequest.inputs": {
            "name": "inputs",
            "location": 106,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BulkImportRequest.errors": {
            "name": "errors",
            "location": 119,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BulkImportRequest.statuses": {
            "name": "statuses",
            "location": 133,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "BulkImportRequest._fetch_remote_ndjson": {
            "name": "_fetch_remote_ndjson",
            "location": 162,
            "return": [],
            "arguments": {
                "self": [],
                "url": []
            }
        },
        "BulkImportRequest.refresh": {
            "name": "refresh",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BulkImportRequest.wait_until_done": {
            "name": "wait_until_done",
            "location": 183,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sleep_time_seconds": [
                    "int"
                ]
            }
        },
        "BulkImportRequest.__exponential_backoff_refresh": {
            "name": "__exponential_backoff_refresh",
            "location": 203,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BulkImportRequest.from_name": {
            "name": "from_name",
            "location": 207,
            "return": [],
            "arguments": {
                "cls": [],
                "client": [],
                "project_id": [],
                "name": []
            }
        },
        "BulkImportRequest.create_from_url": {
            "name": "create_from_url",
            "location": 234,
            "return": [],
            "arguments": {
                "cls": [],
                "client": [],
                "project_id": [],
                "name": [],
                "url": [],
                "validate": [
                    "bool"
                ]
            }
        },
        "BulkImportRequest.create_from_objects": {
            "name": "create_from_objects",
            "location": 279,
            "return": [],
            "arguments": {
                "cls": [],
                "client": [],
                "project_id": [],
                "name": [],
                "predictions": [],
                "validate": [
                    "bool"
                ]
            }
        },
        "BulkImportRequest.create_from_local_file": {
            "name": "create_from_local_file",
            "location": 333,
            "return": [],
            "arguments": {
                "cls": [],
                "client": [],
                "project_id": [],
                "name": [],
                "file": [],
                "validate_file": [
                    "bool"
                ]
            }
        },
        "BulkImportRequest.delete": {
            "name": "delete",
            "location": 376,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SpecialUnion.__new__": {
            "name": "__new__",
            "location": 508,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "SpecialUnion.__get_validators__": {
            "name": "__get_validators__",
            "location": 512,
            "return": [
                "typing.Generator"
            ],
            "arguments": {
                "cls": []
            }
        },
        "SpecialUnion.get_union_types": {
            "name": "get_union_types",
            "location": 516,
            "return": [],
            "arguments": {
                "cls": []
            }
        },
        "SpecialUnion.build": {
            "name": "build",
            "location": 531,
            "return": [],
            "arguments": {
                "cls": [],
                "data": []
            }
        },
        "SpecialUnion.schema": {
            "name": "schema",
            "location": 574,
            "return": [
                "dict[typing.Text, dict]"
            ],
            "arguments": {
                "cls": []
            }
        },
        "NDBase.validate_feature_schemas": {
            "name": "validate_feature_schemas",
            "location": 596,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "valid_feature_schemas": []
            }
        },
        "NDBase.validate_instance": {
            "name": "validate_instance",
            "location": 607,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "valid_feature_schemas": []
            }
        },
        "NDChecklist.validate_answers": {
            "name": "validate_answers",
            "location": 637,
            "return": [],
            "arguments": {
                "cls": [],
                "value": [],
                "field": []
            }
        },
        "NDChecklist.validate_feature_schemas": {
            "name": "validate_feature_schemas",
            "location": 643,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "valid_feature_schemas": []
            }
        },
        "NDRadio.validate_feature_schemas": {
            "name": "validate_feature_schemas",
            "location": 663,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "valid_feature_schemas": []
            }
        },
        "NDBaseTool.validate_feature_schemas": {
            "name": "validate_feature_schemas",
            "location": 687,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "valid_feature_schemas": []
            }
        },
        "NDBaseTool.validate_subclasses": {
            "name": "validate_subclasses",
            "location": 694,
            "return": [
                "list[dict[typing.Text, typing.Union[dict[typing.Text, str],str]]]"
            ],
            "arguments": {
                "cls": [],
                "value": [],
                "field": []
            }
        },
        "NDPolygon.is_geom_valid": {
            "name": "is_geom_valid",
            "location": 714,
            "return": [],
            "arguments": {
                "cls": [],
                "v": []
            }
        },
        "NDPolyline.is_geom_valid": {
            "name": "is_geom_valid",
            "location": 726,
            "return": [],
            "arguments": {
                "cls": [],
                "v": []
            }
        },
        "NDTextEntity.is_valid_location": {
            "name": "is_valid_location",
            "location": 755,
            "return": [],
            "arguments": {
                "cls": [],
                "v": []
            }
        },
        "RLEMaskFeatures.validate_counts": {
            "name": "validate_counts",
            "location": 776,
            "return": [],
            "arguments": {
                "cls": [],
                "counts": []
            }
        },
        "RLEMaskFeatures.validate_size": {
            "name": "validate_size",
            "location": 784,
            "return": [],
            "arguments": {
                "cls": [],
                "size": []
            }
        },
        "URIMaskFeatures.validate_color": {
            "name": "validate_color",
            "location": 805,
            "return": [],
            "arguments": {
                "cls": [],
                "colorRGB": []
            }
        },
        "NDAnnotation.build": {
            "name": "build",
            "location": 842,
            "return": [],
            "arguments": {
                "cls": [],
                "data": []
            }
        },
        "NDAnnotation.schema": {
            "name": "schema",
            "location": 856,
            "return": [
                "dict[typing.Text, dict]"
            ],
            "arguments": {
                "cls": []
            }
        },
        "NDBase.Config.determinants": {
            "name": "determinants",
            "location": 615,
            "return": [
                "list"
            ],
            "arguments": {
                "parent_cls": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/dataset.py": {
        "Dataset.create_data_row": {
            "name": "create_data_row",
            "location": 55,
            "return": [
                "List[str]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "None",
                    "List[Dict]",
                    "type",
                    "dict",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "Dataset.create_data_rows_sync": {
            "name": "create_data_rows_sync",
            "location": 107,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "bytes",
                    "dict",
                    "List[int]",
                    "str"
                ]
            }
        },
        "Dataset.create_data_rows": {
            "name": "create_data_rows",
            "location": 148,
            "return": [
                "str",
                "Dict[str, Any]",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "dict",
                    "int",
                    "Dict[str, List[Any]]",
                    "Optional[Dict]"
                ]
            }
        },
        "Dataset._create_descriptor_file": {
            "name": "_create_descriptor_file",
            "location": 203,
            "return": [
                "str",
                "cmk.utils.type_defs.UserId"
            ],
            "arguments": {
                "self": [],
                "items": [
                    "List[Dict[str, Any]]",
                    "List[Dict]",
                    "str",
                    "int",
                    "List[int]",
                    "Dict[int, Dict[str, Any]]"
                ],
                "max_attachments_per_data_row": [
                    "None",
                    "bool",
                    "List[str]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Dataset.data_rows_for_external_id": {
            "name": "data_rows_for_external_id",
            "location": 364,
            "return": [
                "list",
                "str",
                "bool",
                "dict"
            ],
            "arguments": {
                "self": [],
                "external_id": [
                    "str"
                ],
                "limit": [
                    "int",
                    "List[str]",
                    "set",
                    "str",
                    "List[List[Any]]",
                    "list"
                ]
            }
        },
        "Dataset.data_row_for_external_id": {
            "name": "data_row_for_external_id",
            "location": 393,
            "return": [
                "str",
                "bool",
                "dict"
            ],
            "arguments": {
                "self": [],
                "external_id": [
                    "str",
                    "int"
                ]
            }
        },
        "Dataset.export_data_rows": {
            "name": "export_data_rows",
            "location": 416,
            "return": [
                "typing.Generator[DataRow]",
                "bool",
                "Dict[str, Any]",
                "Callable",
                "Mapping"
            ],
            "arguments": {
                "self": [],
                "timeout_seconds": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "Dataset.create_data_row.convert_field_keys": {
            "name": "convert_field_keys",
            "location": 76,
            "return": [
                "dict",
                "str",
                "Optional[str]",
                "Dict[str, 'LabwareDefinition']",
                "defaultdict"
            ],
            "arguments": {
                "items": [
                    "int",
                    "dict",
                    "Dict[str, Any]",
                    "Optional[str]",
                    "Type['Declared']"
                ]
            }
        },
        "Dataset._create_descriptor_file.upload_if_necessary": {
            "name": "upload_if_necessary",
            "location": 254,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "cmk.utils.type_defs.HostName",
                "List[str]"
            ],
            "arguments": {
                "item": [
                    "str",
                    "Mapping[str, str]",
                    "Dict[str, Any]",
                    "NamedTuple",
                    "dict"
                ]
            }
        },
        "Dataset._create_descriptor_file.validate_attachments": {
            "name": "validate_attachments",
            "location": 265,
            "return": [
                "list",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "item": [
                    "List[str]",
                    "object",
                    "dict",
                    "Dict[str, Any]",
                    "int"
                ]
            }
        },
        "Dataset._create_descriptor_file.parse_metadata_fields": {
            "name": "parse_metadata_fields",
            "location": 283,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "item": [
                    "Union[int, slice]",
                    "raiden.utils.Any",
                    "dict",
                    "bytes"
                ]
            }
        },
        "Dataset._create_descriptor_file.format_row": {
            "name": "format_row",
            "location": 290,
            "return": [
                "dict[typing.Text, str]",
                "List[str]",
                "cmk.utils.type_defs.HostName",
                "Tuple[Any, Any, Any]",
                "str",
                "Callable[[str], None]"
            ],
            "arguments": {
                "item": [
                    "str",
                    "List[str]",
                    "Dict[str, str]",
                    "object",
                    "list"
                ]
            }
        },
        "Dataset._create_descriptor_file.validate_keys": {
            "name": "validate_keys",
            "location": 307,
            "return": [
                "str",
                "cmk.utils.type_defs.HostName",
                "Callable[[str], None]",
                "Iterable[str]"
            ],
            "arguments": {
                "item": [
                    "List[Dict]",
                    "Optional[str]",
                    "Dict[int, Dict[str, Any]]",
                    "Sequence[str]",
                    "bool"
                ]
            }
        },
        "Dataset._create_descriptor_file.convert_item": {
            "name": "convert_item",
            "location": 319,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "item": [
                    "dict",
                    "str",
                    "Iterable[T]",
                    "List[T]",
                    "raiden.utils.Any"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/data_row.py": {
        "DataRow.__init__": {
            "name": "__init__",
            "location": 60,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataRow.bulk_delete": {
            "name": "bulk_delete",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "data_rows": [
                    "str",
                    "List[List[Any]]",
                    "int",
                    "List[str]",
                    "bytes"
                ]
            }
        },
        "DataRow.create_attachment": {
            "name": "create_attachment",
            "location": 74,
            "return": [
                "AssetAttachment",
                "Optional[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "attachment_type": [
                    "str",
                    "int",
                    "bytes",
                    "float"
                ],
                "attachment_value": [
                    "str",
                    "type"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/data_row_metadata.py": {
        "_batch_items": {
            "name": "_batch_items",
            "location": 508,
            "return": [
                "typing.Generator[typing.Any, None, None]",
                "typing.Generator"
            ],
            "arguments": {
                "iterable": [
                    "int",
                    "List[Dict]",
                    "Sequence[T]"
                ],
                "size": [
                    "int",
                    "str"
                ]
            }
        },
        "_batch_operations": {
            "name": "_batch_operations",
            "location": 514,
            "return": [
                "list",
                "bytes",
                "dict"
            ],
            "arguments": {
                "batch_function": [
                    "int",
                    "list",
                    "Dict[str, Any]"
                ],
                "items": [
                    "str",
                    "Union[Dict, List]",
                    "Dict[str, str]"
                ],
                "batch_size": [
                    "int",
                    "str",
                    "Union[Dict, List]",
                    "Dict[str, str]"
                ]
            }
        },
        "_validate_parse_embedding": {
            "name": "_validate_parse_embedding",
            "location": 526,
            "return": [
                "list",
                "Dict[str, int]",
                "Iterable[int]",
                "str",
                "int"
            ],
            "arguments": {
                "field": [
                    "str",
                    "Union[tuple, list]",
                    "Union[int, str]",
                    "list",
                    "T"
                ]
            }
        },
        "_validate_parse_number": {
            "name": "_validate_parse_number",
            "location": 544,
            "return": [
                "list",
                "Dict[str, int]",
                "Iterable[int]",
                "str",
                "int"
            ],
            "arguments": {
                "field": [
                    "str",
                    "Optional[str]",
                    "pydantic.fields.ModelField",
                    "Union[str, List[str]]",
                    "int"
                ]
            }
        },
        "_validate_parse_datetime": {
            "name": "_validate_parse_datetime",
            "location": 551,
            "return": [
                "list[dict[typing.Text, ]]",
                "bool",
                "Optional[Set[str]]"
            ],
            "arguments": {
                "field": [
                    "str",
                    "Type"
                ]
            }
        },
        "_validate_parse_text": {
            "name": "_validate_parse_text",
            "location": 568,
            "return": [
                "list",
                "bool",
                "Union[int, float, complex]",
                "Dict[str, int]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "field": [
                    "str"
                ]
            }
        },
        "_validate_enum_parse": {
            "name": "_validate_enum_parse",
            "location": 582,
            "return": [
                "list[dict[typing.Text, dict]]",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "schema": [
                    "Callable",
                    "Exception",
                    "Optional[Dict[str, str]]",
                    "str"
                ],
                "field": [
                    "str",
                    "Sequence[MutableMapping]",
                    "qutebrowser.utils.urlmatch.UrlPattern",
                    "bool",
                    "Type"
                ]
            }
        },
        "DataRowMetadataOntology.__init__": {
            "name": "__init__",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "str",
                    "float",
                    "utils.clienClient"
                ]
            }
        },
        "DataRowMetadataOntology._build_ontology": {
            "name": "_build_ontology",
            "location": 115,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataRowMetadataOntology._make_name_index": {
            "name": "_make_name_index",
            "location": 139,
            "return": [
                "dict[, dict]",
                "str",
                "int",
                "Dict[str, Any]",
                "Container[str]",
                "bool",
                "Union[List, Dict]"
            ],
            "arguments": {
                "fields": [
                    "str",
                    "Iterable[str]",
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "DataRowMetadataOntology._make_id_index": {
            "name": "_make_id_index",
            "location": 151,
            "return": [
                "str",
                "dict"
            ],
            "arguments": {
                "fields": [
                    "str",
                    "bool",
                    "Iterable[str]"
                ]
            }
        },
        "DataRowMetadataOntology._get_ontology": {
            "name": "_get_ontology",
            "location": 162,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataRowMetadataOntology._parse_ontology": {
            "name": "_parse_ontology",
            "location": 180,
            "return": [
                "list[DataRowMetadataSchema]",
                "List[str]",
                "str",
                "Sequence[str]"
            ],
            "arguments": {
                "raw_ontology": [
                    "str",
                    "List[List[int]]",
                    "bool"
                ]
            }
        },
        "DataRowMetadataOntology.refresh_ontology": {
            "name": "refresh_ontology",
            "location": 202,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "DataRowMetadataOntology.parse_metadata": {
            "name": "parse_metadata",
            "location": 206,
            "return": [
                "list[DataRowMetadata]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "unparsed": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "DataRowMetadataOntology.parse_metadata_fields": {
            "name": "parse_metadata_fields",
            "location": 232,
            "return": [
                "list[DataRowMetadataField]",
                "Optional[List[str]]",
                "str",
                "Union[int, float]"
            ],
            "arguments": {
                "self": [],
                "unparsed": [
                    "Optional[List[str]]",
                    "str",
                    "Union[int, float]"
                ]
            }
        },
        "DataRowMetadataOntology.bulk_upsert": {
            "name": "bulk_upsert",
            "location": 273,
            "return": [
                "List[int]",
                "Iterable[str]",
                "Iterable[T]",
                "int"
            ],
            "arguments": {
                "self": [],
                "metadata": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "DataRowMetadataOntology.bulk_delete": {
            "name": "bulk_delete",
            "location": 333,
            "return": [
                "str",
                "int",
                "Iterable[int]"
            ],
            "arguments": {
                "self": [],
                "deletes": [
                    "str",
                    "int"
                ]
            }
        },
        "DataRowMetadataOntology.bulk_export": {
            "name": "bulk_export",
            "location": 387,
            "return": [
                "List[str]",
                "Optional[cmk.utils.type_defs.HostAddress]",
                "str",
                "Sequence[int]",
                "bytes",
                "bug_buddy.schema.Diff",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data_row_ids": [
                    "bytes",
                    "int",
                    "str",
                    "Optional[int]"
                ]
            }
        },
        "DataRowMetadataOntology._parse_upsert": {
            "name": "_parse_upsert",
            "location": 425,
            "return": [
                "list[_UpsertDataRowMetadataInput]",
                "int",
                "Tuple[int, int]",
                "float"
            ],
            "arguments": {
                "self": [],
                "metadatum": [
                    "int",
                    "dict",
                    "str",
                    "list",
                    "List[str]",
                    "Dict[str, Dict[str, int]]"
                ]
            }
        },
        "DataRowMetadataOntology.parse_upsert_metadata": {
            "name": "parse_upsert_metadata",
            "location": 458,
            "return": [
                "list",
                "bytes",
                "dict",
                "str",
                "Dict[str, Set[str]]",
                "Dict[str, str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "metadata_fields": [
                    "Mapping[str, Any]",
                    "T",
                    "Callable"
                ]
            }
        },
        "DataRowMetadataOntology._validate_delete": {
            "name": "_validate_delete",
            "location": 483,
            "return": [
                "str",
                "Callable",
                "List[int]",
                "Mapping[int, str]",
                "Union[utils.CWLObjectType, MutableSequence[utils.CWLObjectType], None]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "delete": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "datetime.datetime",
                    "Optional[Any]",
                    "int"
                ]
            }
        },
        "DataRowMetadataOntology.bulk_upsert._batch_upsert": {
            "name": "_batch_upsert",
            "location": 299,
            "return": [
                "list[DataRowMetadataBatchResponse]"
            ],
            "arguments": {
                "upserts": []
            }
        },
        "DataRowMetadataOntology.bulk_delete._batch_delete": {
            "name": "_batch_delete",
            "location": 360,
            "return": [
                "list[DataRowMetadataBatchResponse]"
            ],
            "arguments": {
                "deletes": []
            }
        },
        "DataRowMetadataOntology.bulk_export._bulk_export": {
            "name": "_bulk_export",
            "location": 405,
            "return": [],
            "arguments": {
                "_data_row_ids": []
            }
        },
        "DataRowMetadataOntology.parse_upsert_metadata._convert_metadata_field": {
            "name": "_convert_metadata_field",
            "location": 460,
            "return": [
                "DataRowMetadataField"
            ],
            "arguments": {
                "metadata_field": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/enums.py": {},
    "labelbox-python-master/labelbox/schema/iam_integration.py": {
        "IAMIntegration.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "dict",
                    "str",
                    "Sequence[int]"
                ],
                "data": [
                    "bool",
                    "dict",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/invite.py": {
        "Invite.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "dict",
                    "Dict[str, Any]"
                ],
                "invite_response": [
                    "str",
                    "Dict[str, str]",
                    "Dict[str, Union[Any, str]]",
                    "frozenset[Union[bytes, str]]",
                    "Type[Callable[Any, Any]]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/label.py": {
        "Label.__init__": {
            "name": "__init__",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Label.bulk_delete": {
            "name": "bulk_delete",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "labels": [
                    "str",
                    "int"
                ]
            }
        },
        "Label.create_review": {
            "name": "create_review",
            "location": 56,
            "return": [
                "Mapping[str, Any]",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Label.create_benchmark": {
            "name": "create_benchmark",
            "location": 66,
            "return": [
                "Benchmark",
                "bool",
                "Optional[str]",
                "Dict[str, Any]",
                "List['ValidatorRecord']",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/labeling_frontend.py": {},
    "labelbox-python-master/labelbox/schema/media_type.py": {
        "MediaType._missing_": {
            "name": "_missing_",
            "location": 23,
            "return": [
                "Dict[str, Any]",
                "str",
                "Callable[[str], T]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "bool"
                ],
                "name": [
                    "Optional[str]",
                    "int",
                    "str",
                    "Callable[[Any], bool]"
                ]
            }
        },
        "MediaType.is_supported": {
            "name": "is_supported",
            "location": 37,
            "return": [
                "bool",
                "int",
                "set",
                "Iterable['cirq.Qid']"
            ],
            "arguments": {
                "cls": [
                    "Type",
                    "str"
                ],
                "value": [
                    "Type",
                    "str"
                ]
            }
        },
        "MediaType.get_supported_members": {
            "name": "get_supported_members",
            "location": 42,
            "return": [
                "list",
                "List[str]",
                "str",
                "Iterable[str]"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Any]",
                    "dict",
                    "bool",
                    "List[str]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/model.py": {
        "Model.create_model_run": {
            "name": "create_model_run",
            "location": 21,
            "return": [
                "ModelRun",
                "bool",
                "str"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "Model.delete": {
            "name": "delete",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/model_run.py": {
        "ModelRun.upsert_labels": {
            "name": "upsert_labels",
            "location": 27,
            "return": [
                "str",
                "Dict[str, int]"
            ],
            "arguments": {
                "self": [],
                "label_ids": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Callable[[str], int]",
                    "Optional[float]"
                ],
                "timeout_seconds": [
                    "str",
                    "int"
                ]
            }
        },
        "ModelRun.upsert_data_rows": {
            "name": "upsert_data_rows",
            "location": 60,
            "return": [
                "str",
                "bool",
                "Tuple[str, dict]",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "data_row_ids": [
                    "str",
                    "int"
                ],
                "timeout_seconds": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "ModelRun._wait_until_done": {
            "name": "_wait_until_done",
            "location": 93,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "status_fn": [
                    "int"
                ],
                "timeout_seconds": [
                    "int",
                    "str",
                    "dict",
                    "Optional[str]"
                ],
                "sleep_time": [
                    "int",
                    "float",
                    "Optional[float]"
                ]
            }
        },
        "ModelRun.add_predictions": {
            "name": "add_predictions",
            "location": 110,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "dict",
                    "Tuple[Dict[str, Any], Any]",
                    "List[str]"
                ],
                "predictions": [
                    "str",
                    "bool",
                    "bytes",
                    "Sequence[str]"
                ]
            }
        },
        "ModelRun.model_run_data_rows": {
            "name": "model_run_data_rows",
            "location": 141,
            "return": [
                "PaginatedCollection",
                "str",
                "pathlib.Path",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelRun.delete": {
            "name": "delete",
            "location": 153,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelRun.delete_model_run_data_rows": {
            "name": "delete_model_run_data_rows",
            "location": 164,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data_row_ids": [
                    "Dict[str, str]",
                    "int",
                    "dict"
                ]
            }
        },
        "ModelRun.update_status": {
            "name": "update_status",
            "location": 184,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "status": [
                    "str",
                    "bool"
                ],
                "metadata": [
                    "None",
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "Sequence[str]"
                ],
                "error_message": [
                    "None",
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "Sequence[str]"
                ]
            }
        },
        "ModelRun.export_labels": {
            "name": "export_labels",
            "location": 216,
            "return": [
                "None",
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "download": [
                    "bool",
                    "int",
                    "str",
                    "List[str]"
                ],
                "timeout_seconds": [
                    "int",
                    "float",
                    "str",
                    "Optional[int]",
                    "Optional[Set[str]]",
                    "list"
                ]
            }
        },
        "ModelRunDataRow.__init__": {
            "name": "__init__",
            "location": 269,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "client": [
                    "Dict[str, Any]",
                    "dict",
                    "float",
                    "str",
                    "bool"
                ],
                "model_id": [
                    "str",
                    "sqlalchemy.orm.session.Session",
                    "int",
                    "dict"
                ]
            }
        },
        "ModelRunDataRow.url": {
            "name": "url",
            "location": 274,
            "return": [
                "typing.Text",
                "str",
                "Callable[[str], bool]",
                "List[object]",
                "Optional[str]",
                "dict",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/ontology.py": {
        "Option.__post_init__": {
            "name": "__post_init__",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Option.from_dict": {
            "name": "from_dict",
            "location": 53,
            "return": [
                "bool",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "Type['Declared']",
                    "List[Dict]"
                ],
                "dictionary": [
                    "dict",
                    "Type['Declared']",
                    "List[Dict]"
                ]
            }
        },
        "Option.asdict": {
            "name": "asdict",
            "location": 66,
            "return": [
                "dict[typing.Text, list]",
                "bool",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "Option.add_option": {
            "name": "add_option",
            "location": 75,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "str",
                    "dict"
                ]
            }
        },
        "Classification.__post_init__": {
            "name": "__post_init__",
            "location": 141,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classification.name": {
            "name": "name",
            "location": 149,
            "return": [
                "Dict[str, Any]",
                "str",
                "int",
                "Iterator",
                "Container[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Classification.from_dict": {
            "name": "from_dict",
            "location": 153,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Any]"
                ],
                "dictionary": [
                    "Dict[str, Any]"
                ]
            }
        },
        "Classification.asdict": {
            "name": "asdict",
            "location": 162,
            "return": [
                "dict[typing.Text, list]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "is_subclass": [
                    "bool",
                    "str"
                ]
            }
        },
        "Classification.add_option": {
            "name": "add_option",
            "location": 182,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "option": [
                    "OrderedDict",
                    "str",
                    "Type",
                    "List[str]",
                    "Union[str, List[str]]",
                    "bool"
                ]
            }
        },
        "Tool.from_dict": {
            "name": "from_dict",
            "location": 239,
            "return": [
                "Dict[str, Any]",
                "str",
                "dict",
                "Optional[str]",
                "type"
            ],
            "arguments": {
                "cls": [
                    "Dict[str, Any]",
                    "dict",
                    "str"
                ],
                "dictionary": [
                    "Dict[str, Any]",
                    "dict",
                    "str"
                ]
            }
        },
        "Tool.asdict": {
            "name": "asdict",
            "location": 251,
            "return": [
                "dict[typing.Text, list]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Tool.add_classification": {
            "name": "add_classification",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "classification": [
                    "float"
                ]
            }
        },
        "Ontology.__init__": {
            "name": "__init__",
            "location": 299,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Ontology.tools": {
            "name": "tools",
            "location": 304,
            "return": [
                "list",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Ontology.classifications": {
            "name": "classifications",
            "location": 312,
            "return": [
                "list",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "OntologyBuilder.from_dict": {
            "name": "from_dict",
            "location": 351,
            "return": [
                "bool",
                "List[int]",
                "List[str]",
                "Dict[str, bool]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "List[List]",
                    "dict",
                    "Dict[int, Dict[str, Any]]",
                    "Dict[str, Type]"
                ],
                "dictionary": [
                    "List[List]",
                    "dict",
                    "Dict[int, Dict[str, Any]]",
                    "Dict[str, Type]"
                ]
            }
        },
        "OntologyBuilder.asdict": {
            "name": "asdict",
            "location": 358,
            "return": [
                "Sequence['cirq.Qid']",
                "dict[typing.Text, list]"
            ],
            "arguments": {
                "self": []
            }
        },
        "OntologyBuilder._update_colors": {
            "name": "_update_colors",
            "location": 365,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "OntologyBuilder.from_project": {
            "name": "from_project",
            "location": 376,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "Callable",
                    "List[str]"
                ],
                "project": [
                    "rflx.model.Model",
                    "List[str]",
                    "str"
                ]
            }
        },
        "OntologyBuilder.from_ontology": {
            "name": "from_ontology",
            "location": 381,
            "return": [
                "Dict[str, bool]",
                "bytes",
                "Optional[Dict[str, str]]"
            ],
            "arguments": {
                "cls": [
                    "List[Dict[str, Any]]",
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "float"
                ],
                "ontology": [
                    "List[Dict[str, Any]]",
                    "int",
                    "str",
                    "Dict[str, Any]",
                    "float"
                ]
            }
        },
        "OntologyBuilder.add_tool": {
            "name": "add_tool",
            "location": 384,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tool": [
                    "Dict[str, Any]"
                ]
            }
        },
        "OntologyBuilder.add_classification": {
            "name": "add_classification",
            "location": 390,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "classification": [
                    "src.core.model.profile.Profile"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/organization.py": {
        "Organization.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Organization.invite_user": {
            "name": "invite_user",
            "location": 49,
            "return": [
                "Invite",
                "models.User",
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "email": [
                    "str"
                ],
                "role": [
                    "str",
                    "Optional[bool]",
                    "Dict[str, float]",
                    "dict"
                ],
                "project_roles": [
                    "None",
                    "str",
                    "Dict[str, float]",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "Organization.invite_limit": {
            "name": "invite_limit",
            "location": 101,
            "return": [
                "InviteLimit",
                "str",
                "Dict[str, int]",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Organization.remove_user": {
            "name": "remove_user",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "user": [
                    "models.user.User",
                    "asgard.models.user.User",
                    "core.models.User",
                    "app.models.User",
                    "Union[server.models.User, int]",
                    "models.User",
                    "kirin.core.model.StopTimeUpdate"
                ]
            }
        },
        "Organization.create_resource_tag": {
            "name": "create_resource_tag",
            "location": 132,
            "return": [
                "ResourceTag",
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "Dict[str, str]",
                    "dict",
                    "Iterable[str]",
                    "MutableMapping"
                ]
            }
        },
        "Organization.get_resource_tags": {
            "name": "get_resource_tags",
            "location": 161,
            "return": [
                "list[ResourceTag]",
                "bool",
                "str",
                "raiden.utils.List[raiden.tests.utils.transporParsedURL]",
                "Optional[Union[int, str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Organization.get_iam_integrations": {
            "name": "get_iam_integrations",
            "location": 173,
            "return": [
                "list[IAMIntegration]",
                "Optional[str]",
                "Optional[Sequence[Any]]",
                "Optional[List[Any]]",
                "Optional[Exception]",
                "tuple",
                "Optional[bool]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Organization.get_default_iam_integration": {
            "name": "get_default_iam_integration",
            "location": 192,
            "return": [
                "None",
                "Optional[str]",
                "list",
                "Optional[bool]",
                "Optional[float]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/project.py": {
        "_check_converter_import": {
            "name": "_check_converter_import",
            "location": 968,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "Project.update": {
            "name": "update",
            "location": 95,
            "return": [
                "str",
                "dict",
                "Tuple[float, float]",
                "Set[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Project.members": {
            "name": "members",
            "location": 111,
            "return": [
                "PaginatedCollection",
                "str",
                "bytes",
                "logging.LogRecord",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Project.update_project_resource_tags": {
            "name": "update_project_resource_tags",
            "location": 127,
            "return": [
                "list[ResourceTag]",
                "bool",
                "str",
                "Optional[Union[int, str]]"
            ],
            "arguments": {
                "self": [],
                "resource_tag_ids": [
                    "str",
                    "dict"
                ]
            }
        },
        "Project.labels": {
            "name": "labels",
            "location": 154,
            "return": [
                "str",
                "PaginatedCollection"
            ],
            "arguments": {
                "self": [],
                "datasets": [
                    "None",
                    "str",
                    "Optional[str]",
                    "Optional[int]",
                    "bool"
                ],
                "order_by": [
                    "None",
                    "int",
                    "bool",
                    "Optional[str]",
                    "Optional[Dict[str, Any]]",
                    "str"
                ]
            }
        },
        "Project.export_queued_data_rows": {
            "name": "export_queued_data_rows",
            "location": 188,
            "return": [
                "dict",
                "str",
                "Mapping[str, Any]",
                "int",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "timeout_seconds": [
                    "int",
                    "str",
                    "bool",
                    "Optional[str]",
                    "float"
                ]
            }
        },
        "Project.video_label_generator": {
            "name": "video_label_generator",
            "location": 226,
            "return": [
                "str",
                "dict",
                "bool"
            ],
            "arguments": {
                "self": [],
                "timeout_seconds": [
                    "int",
                    "bytes",
                    "str"
                ]
            }
        },
        "Project.label_generator": {
            "name": "label_generator",
            "location": 258,
            "return": [
                "str",
                "dict",
                "bool"
            ],
            "arguments": {
                "self": [],
                "timeout_seconds": [
                    "int",
                    "str",
                    "bool",
                    "qutebrowser.utils.usertypes.Backend",
                    "Optional[bool]",
                    "List[str]"
                ]
            }
        },
        "Project.export_labels": {
            "name": "export_labels",
            "location": 292,
            "return": [
                "None",
                "bool",
                "axion.utils.types.AnyCallable",
                "str",
                "dict"
            ],
            "arguments": {
                "self": [],
                "download": [
                    "bool",
                    "int",
                    "str",
                    "List[str]"
                ],
                "timeout_seconds": [
                    "int",
                    "float",
                    "str",
                    "Optional[int]",
                    "Optional[Set[str]]",
                    "list"
                ]
            }
        },
        "Project.export_issues": {
            "name": "export_issues",
            "location": 376,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": [],
                "status": [
                    "None",
                    "str",
                    "int",
                    "Optional[str]",
                    "Callable[[str], int]"
                ]
            }
        },
        "Project.upsert_instructions": {
            "name": "upsert_instructions",
            "location": 410,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "instructions_file": [
                    "str",
                    "FrozenSet[str]",
                    "TextIO",
                    "pathlib.Path"
                ]
            }
        },
        "Project.labeler_performance": {
            "name": "labeler_performance",
            "location": 462,
            "return": [
                "PaginatedCollection",
                "str",
                "bytes",
                "logging.LogRecord",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Project.review_metrics": {
            "name": "review_metrics",
            "location": 489,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "net_score": [
                    "Type",
                    "dict",
                    "Optional[\"Outcome\"]"
                ]
            }
        },
        "Project.setup_editor": {
            "name": "setup_editor",
            "location": 510,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ontology": [
                    "str",
                    "bytes"
                ]
            }
        },
        "Project.setup": {
            "name": "setup",
            "location": 545,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labeling_frontend": [
                    "Optional[List[Any]]",
                    "Callable"
                ],
                "labeling_frontend_options": [
                    "str",
                    "float",
                    "Optional[str]"
                ]
            }
        },
        "Project.create_batch": {
            "name": "create_batch",
            "location": 572,
            "return": [
                "bool",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Dict[str, Any]",
                    "str",
                    "dict",
                    "Set[str]",
                    "MutableMapping[str, str]",
                    "Dict[str, 'LabwareDefinition']",
                    "Dict[str, str]"
                ],
                "data_rows": [
                    "str",
                    "bool",
                    "Optional[int]",
                    "Optional[bool]",
                    "Mapping[str, Any]"
                ],
                "priority": [
                    "int",
                    "Dict[str, Any]",
                    "str",
                    "dict",
                    "Set[str]",
                    "MutableMapping[str, str]",
                    "Dict[str, 'LabwareDefinition']",
                    "Dict[str, str]"
                ]
            }
        },
        "Project._update_queue_mode": {
            "name": "_update_queue_mode",
            "location": 628,
            "return": [
                "str",
                "Callable[[], str]",
                "hackathon.utils.utils.DataMessage",
                "int",
                "dict"
            ],
            "arguments": {
                "self": [],
                "mode": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Callable[[str], str]",
                    "Dict[str, str]"
                ]
            }
        },
        "Project.queue_mode": {
            "name": "queue_mode",
            "location": 658,
            "return": [
                "str",
                "list",
                "int",
                "dict",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "Project.validate_labeling_parameter_overrides": {
            "name": "validate_labeling_parameter_overrides",
            "location": 678,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict",
                    "T",
                    "Iterable[T]",
                    "Iterable",
                    "bytes"
                ]
            }
        },
        "Project.set_labeling_parameter_overrides": {
            "name": "set_labeling_parameter_overrides",
            "location": 701,
            "return": [
                "str",
                "set",
                "Optional[str]",
                "List[str]",
                "bool"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "int",
                    "bytes",
                    "List[int]",
                    "float",
                    "dict",
                    "Callable"
                ]
            }
        },
        "Project.unset_labeling_parameter_overrides": {
            "name": "unset_labeling_parameter_overrides",
            "location": 749,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "data_rows": [
                    "Dict[str, Any]",
                    "dict",
                    "int",
                    "str"
                ]
            }
        },
        "Project.upsert_review_queue": {
            "name": "upsert_review_queue",
            "location": 768,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "quota_factor": [
                    "str"
                ]
            }
        },
        "Project.extend_reservations": {
            "name": "extend_reservations",
            "location": 793,
            "return": [
                "List[int]",
                "Iterable[str]",
                "Iterable[T]",
                "int"
            ],
            "arguments": {
                "self": [],
                "queue_type": [
                    "Optional[int]",
                    "set",
                    "Optional[str]",
                    "type",
                    "IO"
                ]
            }
        },
        "Project.enable_model_assisted_labeling": {
            "name": "enable_model_assisted_labeling",
            "location": 811,
            "return": [
                "Tuple[int, int]",
                "float",
                "list",
                "List[str]",
                "Dict[int, dict]",
                "django.utils.timezone.timedelta"
            ],
            "arguments": {
                "self": [],
                "toggle": [
                    "bool",
                    "Dict[str, Dict[str, Any]]",
                    "Optional[str]",
                    "List[Dict[str, Any]]",
                    "List[dict]"
                ]
            }
        },
        "Project.bulk_import_requests": {
            "name": "bulk_import_requests",
            "location": 836,
            "return": [
                "PaginatedCollection",
                "str",
                "dict",
                "cmk.utils.type_defs.UserId"
            ],
            "arguments": {
                "self": []
            }
        },
        "Project.batches": {
            "name": "batches",
            "location": 857,
            "return": [
                "PaginatedCollection",
                "str",
                "bytes",
                "logging.LogRecord",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "Project.upload_annotations": {
            "name": "upload_annotations",
            "location": 875,
            "return": [
                "cmk.utils.type_defs.UserId",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "dict",
                    "Optional[Dict[str, Any]]",
                    "Optional[bytes]"
                ],
                "annotations": [
                    "str",
                    "dict"
                ],
                "validate": [
                    "bool",
                    "str",
                    "dict",
                    "Optional[Dict[str, Any]]",
                    "Optional[bytes]"
                ]
            }
        },
        "Project.export_labels._string_from_dict": {
            "name": "_string_from_dict",
            "location": 311,
            "return": [
                "str",
                "Optional[List[str]]",
                "Optional[Dict[str, str]]",
                "Optional[str]"
            ],
            "arguments": {
                "dictionary": [
                    "str",
                    "type"
                ],
                "value_with_quotes": [
                    "bool",
                    "Sequence[str]",
                    "str",
                    "Callable[[KT], VT]",
                    "List[str]"
                ]
            }
        },
        "Project.export_labels._validate_datetime": {
            "name": "_validate_datetime",
            "location": 324,
            "return": [
                "bool"
            ],
            "arguments": {
                "string_date": [
                    "str",
                    "datetime.datetime",
                    "datetime.date",
                    "Optional[str]",
                    "datetime.timezone"
                ]
            }
        },
        "Project.labeler_performance.create_labeler_performance": {
            "name": "create_labeler_performance",
            "location": 476,
            "return": [
                "LabelerPerformance",
                "bytes",
                "bool",
                "str",
                "float"
            ],
            "arguments": {
                "client": [
                    "float",
                    "object",
                    "bool"
                ],
                "result": [
                    "sqlalchemy.orm.Session",
                    "dict",
                    "bool"
                ]
            }
        },
        "Project.upload_annotations._is_url_valid": {
            "name": "_is_url_valid",
            "location": 897,
            "return": [
                "bool",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "url": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/project_resource_tag.py": {},
    "labelbox-python-master/labelbox/schema/resource_tag.py": {},
    "labelbox-python-master/labelbox/schema/review.py": {},
    "labelbox-python-master/labelbox/schema/role.py": {
        "get_roles": {
            "name": "get_roles",
            "location": 13,
            "return": [
                "dict[, Role]",
                "str",
                "bool"
            ],
            "arguments": {
                "client": [
                    "aioguardian.Client",
                    "List[str]",
                    "Client",
                    "str"
                ]
            }
        },
        "format_role": {
            "name": "format_role",
            "location": 25,
            "return": [
                "str",
                "bool",
                "list"
            ],
            "arguments": {
                "name": [
                    "str",
                    "int",
                    "Optional[str]",
                    "Optional[Iterable]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/task.py": {
        "lru_cache": {
            "name": "lru_cache",
            "location": 14,
            "return": [
                "typing.Callable[..., typing.Callable[..., typing.Dict[builtins.str, typing.Any]]]",
                "None"
            ],
            "arguments": {}
        },
        "Task.refresh": {
            "name": "refresh",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Task.wait_till_done": {
            "name": "wait_till_done",
            "location": 57,
            "return": [
                "None",
                "Union[tuple, list]",
                "List[int]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "timeout_seconds": [
                    "int",
                    "str",
                    "dict"
                ]
            }
        },
        "Task.errors": {
            "name": "errors",
            "location": 78,
            "return": [
                "None",
                "Type",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Task.result": {
            "name": "result",
            "location": 87,
            "return": [
                "list[dict[typing.Text, ]]",
                "Dict[str, Any]",
                "Exception",
                "dict",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Task._fetch_remote_json": {
            "name": "_fetch_remote_json",
            "location": 101,
            "return": [
                "bytes",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/labelbox/schema/user.py": {
        "User.update_org_role": {
            "name": "update_org_role",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "role": [
                    "Dict[str, Any]"
                ]
            }
        },
        "User.remove_from_project": {
            "name": "remove_from_project",
            "location": 66,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "project": [
                    "Project",
                    "Optional[str]",
                    "str"
                ]
            }
        },
        "User.upsert_project_role": {
            "name": "upsert_project_role",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "project": [
                    "Project",
                    "str"
                ],
                "role": [
                    "Project",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/webhook.py": {
        "Webhook.create": {
            "name": "create",
            "location": 58,
            "return": [
                "bool",
                "Webhook"
            ],
            "arguments": {
                "client": [
                    "str",
                    "List[str]"
                ],
                "topics": [
                    "str",
                    "Optional[str]",
                    "float",
                    "bool"
                ],
                "url": [
                    "str",
                    "Dict[str, Any]"
                ],
                "secret": [
                    "str",
                    "Dict[str, Any]"
                ],
                "project": [
                    "str",
                    "Optional[dict]",
                    "Optional[float]",
                    "dict",
                    "Optional[str]"
                ]
            }
        },
        "Webhook.validate_topics": {
            "name": "validate_topics",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "topics": [
                    "str",
                    "MutableMapping[str, Any]",
                    "int"
                ]
            }
        },
        "Webhook.validate_value": {
            "name": "validate_value",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "str",
                    "Dict[str, Any]",
                    "List[str]",
                    "list",
                    "Union[dict, List[Any]]",
                    "int"
                ],
                "enum": [
                    "dict",
                    "str",
                    "Tuple[str, Any]"
                ]
            }
        },
        "Webhook.delete": {
            "name": "delete",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Webhook.update": {
            "name": "update",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "topics": [
                    "None",
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Optional[Callable]",
                    "bool",
                    "Optional[bool]"
                ],
                "url": [
                    "None",
                    "str",
                    "bytes",
                    "dict",
                    "bool"
                ],
                "status": [
                    "None",
                    "Optional[str]",
                    "Optional[Dict]",
                    "int",
                    "str",
                    "Optional[int]"
                ]
            }
        }
    },
    "labelbox-python-master/labelbox/schema/__init__.py": {},
    "labelbox-python-master/tests/conftest.py": {
        "rand_gen": {
            "name": "rand_gen",
            "location": 9,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "rand_gen.gen": {
            "name": "gen",
            "location": 11,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "field_type": [
                    "str",
                    "int",
                    "Optional[str]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/test_prefetch_generator.py": {
        "test_single_thread_generator": {
            "name": "test_single_thread_generator",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_multi_thread_generator": {
            "name": "test_multi_thread_generator",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "ChildClassGenerator.__init__": {
            "name": "__init__",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "examples": [
                    "int",
                    "float",
                    "Optional[int]",
                    "bool",
                    "Dict[str, str]"
                ],
                "num_executors": [
                    "int",
                    "float",
                    "Optional[int]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        },
        "ChildClassGenerator._process": {
            "name": "_process",
            "location": 11,
            "return": [
                "str",
                "int",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "int",
                    "Tuple[str, int]",
                    "complex",
                    "list"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/__init__.py": {},
    "labelbox-python-master/tests/data/annotation_types/test_annotation.py": {
        "test_annotation": {
            "name": "test_annotation",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_video_annotations": {
            "name": "test_video_annotations",
            "location": 52,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/test_collection.py": {
        "list_of_labels": {
            "name": "list_of_labels",
            "location": 14,
            "return": [
                "list[Label]",
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "signer": {
            "name": "signer",
            "location": 19,
            "return": [
                "int",
                "str",
                "bool",
                "Optional[BaseException]",
                "Union[str, Tuple[str, ...]]"
            ],
            "arguments": {}
        },
        "test_generator": {
            "name": "test_generator",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "list_of_labels": [
                    "numpy.ndarray",
                    "Hashable"
                ]
            }
        },
        "test_conversion": {
            "name": "test_conversion",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "list_of_labels": [
                    "int"
                ]
            }
        },
        "test_adding_schema_ids": {
            "name": "test_adding_schema_ids",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_adding_urls": {
            "name": "test_adding_urls",
            "location": 91,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "signer": [
                    "Dict[str, Any]",
                    "taskiinfrastructure.data.json.repositories.task_repository.JsonTaskRepository"
                ]
            }
        },
        "test_adding_to_dataset": {
            "name": "test_adding_to_dataset",
            "location": 111,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "signer": [
                    "Exception"
                ]
            }
        },
        "test_adding_to_masks": {
            "name": "test_adding_to_masks",
            "location": 142,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "signer": []
            }
        },
        "signer.get_signer": {
            "name": "get_signer",
            "location": 21,
            "return": [
                "typing.Callable",
                "int",
                "List[int]",
                "bytes",
                "str"
            ],
            "arguments": {
                "uuid": [
                    "str",
                    "bool"
                ]
            }
        },
        "FakeDataset.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FakeDataset.create_data_row": {
            "name": "create_data_row",
            "location": 33,
            "return": [
                "List[str]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "row_data": [
                    "Dict[str, str]",
                    "int",
                    "list"
                ],
                "external_id": [
                    "None",
                    "Optional[int]",
                    "Optional[str]",
                    "int",
                    "Optional[uuid.UUID]"
                ]
            }
        },
        "FakeDataset.create_data_rows": {
            "name": "create_data_rows",
            "location": 38,
            "return": [
                "FakeDataset",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "args": []
            }
        },
        "FakeDataset.wait_till_done": {
            "name": "wait_till_done",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "FakeDataset.export_data_rows": {
            "name": "export_data_rows",
            "location": 49,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "labelbox-python-master/tests/data/annotation_types/test_label.py": {
        "test_schema_assignment_geometry": {
            "name": "test_schema_assignment_geometry",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_schema_assignment_classification": {
            "name": "test_schema_assignment_classification",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_schema_assignment_subclass": {
            "name": "test_schema_assignment_subclass",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_highly_nested": {
            "name": "test_highly_nested",
            "location": 110,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/test_metrics.py": {
        "test_legacy_scalar_metric": {
            "name": "test_legacy_scalar_metric",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_custom_scalar_metric": {
            "name": "test_custom_scalar_metric",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "feature_name": [
                    "Optional[List[str]]",
                    "str",
                    "Optional[str]",
                    "Optional[Callable[[], Any]]",
                    "Optional[Any]",
                    "list",
                    "List[str]"
                ],
                "subclass_name": [
                    "Optional[List[str]]",
                    "str",
                    "Optional[str]",
                    "Optional[Callable[[], Any]]",
                    "Optional[Any]",
                    "list",
                    "List[str]"
                ],
                "aggregation": [
                    "str",
                    "Dict[str, Any]",
                    "List[int]",
                    "IO"
                ],
                "value": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "test_custom_confusison_matrix_metric": {
            "name": "test_custom_confusison_matrix_metric",
            "location": 113,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "feature_name": [
                    "str",
                    "Optional[str]",
                    "Dict[int, Any]"
                ],
                "subclass_name": [
                    "str",
                    "Optional[str]",
                    "Dict[int, Any]"
                ],
                "aggregation": [
                    "str",
                    "Dict[str, Any]",
                    "List[int]",
                    "IO"
                ],
                "value": [
                    "str",
                    "float"
                ]
            }
        },
        "test_name_exists": {
            "name": "test_name_exists",
            "location": 157,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_invalid_aggregations": {
            "name": "test_invalid_aggregations",
            "location": 164,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_invalid_number_of_confidence_scores": {
            "name": "test_invalid_number_of_confidence_scores",
            "location": 178,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/test_ner.py": {
        "test_ner": {
            "name": "test_ner",
            "location": 4,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/test_tiled_image.py": {
        "test_epsg": {
            "name": "test_epsg",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "epsg": [
                    "str",
                    "float"
                ]
            }
        },
        "test_tiled_bounds": {
            "name": "test_tiled_bounds",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "epsg": [
                    "bool",
                    "str"
                ]
            }
        },
        "test_tiled_bounds_same": {
            "name": "test_tiled_bounds_same",
            "location": 29,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "epsg": []
            }
        },
        "test_create_tiled_image_data": {
            "name": "test_create_tiled_image_data",
            "location": 36,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_epsg_point_projections": {
            "name": "test_epsg_point_projections",
            "location": 53,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/__init__.py": {},
    "labelbox-python-master/tests/data/annotation_types/classification/test_classification.py": {
        "test_classification_answer": {
            "name": "test_classification_answer",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_classification": {
            "name": "test_classification",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_subclass": {
            "name": "test_subclass",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_radio": {
            "name": "test_radio",
            "location": 81,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_checklist": {
            "name": "test_checklist",
            "location": 118,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_dropdown": {
            "name": "test_dropdown",
            "location": 156,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/classification/__init__.py": {},
    "labelbox-python-master/tests/data/annotation_types/data/test_raster.py": {
        "test_validate_schema": {
            "name": "test_validate_schema",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_im_bytes": {
            "name": "test_im_bytes",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_im_url": {
            "name": "test_im_url",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_im_path": {
            "name": "test_im_path",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_ref": {
            "name": "test_ref",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/data/test_text.py": {
        "test_validate_schema": {
            "name": "test_validate_schema",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_text": {
            "name": "test_text",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_url": {
            "name": "test_url",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_file": {
            "name": "test_file",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmpdir": [
                    "str"
                ]
            }
        },
        "test_ref": {
            "name": "test_ref",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/data/test_video.py": {
        "test_validate_schema": {
            "name": "test_validate_schema",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_frames": {
            "name": "test_frames",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_file_path": {
            "name": "test_file_path",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_file_url": {
            "name": "test_file_url",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_ref": {
            "name": "test_ref",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/data/__init__.py": {},
    "labelbox-python-master/tests/data/annotation_types/geometry/test_line.py": {
        "test_line": {
            "name": "test_line",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/geometry/test_mask.py": {
        "test_mask": {
            "name": "test_mask",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/geometry/test_point.py": {
        "test_point": {
            "name": "test_point",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/geometry/test_polygon.py": {
        "test_polygon": {
            "name": "test_polygon",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/geometry/test_rectangle.py": {
        "test_rectangle": {
            "name": "test_rectangle",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/annotation_types/geometry/__init__.py": {},
    "labelbox-python-master/tests/data/metrics/confusion_matrix/conftest.py": {
        "get_radio": {
            "name": "get_radio",
            "location": 76,
            "return": [
                "ClassificationAnnotation",
                "str",
                "dict",
                "List[str]",
                "Optional[str]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Dict[str, 'LabwareDefinition']",
                    "Set[str]",
                    "Optional[str]",
                    "List[str]",
                    "Dict[str, Any]"
                ],
                "answer_name": [
                    "str",
                    "Dict[str, 'LabwareDefinition']",
                    "Set[str]",
                    "Optional[str]",
                    "List[str]",
                    "Dict[str, Any]"
                ]
            }
        },
        "get_text": {
            "name": "get_text",
            "location": 25,
            "return": [
                "ClassificationAnnotation",
                "str",
                "int",
                "bool"
            ],
            "arguments": {
                "name": [
                    "str",
                    "int",
                    "Dict[str, str]",
                    "List[str]",
                    "bool"
                ],
                "text_content": [
                    "str",
                    "int",
                    "Dict[str, str]",
                    "List[str]",
                    "bool"
                ]
            }
        },
        "get_checklist": {
            "name": "get_checklist",
            "location": 81,
            "return": [
                "ClassificationAnnotation",
                "str",
                "dict",
                "List[str]",
                "Optional[str]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Set[str]",
                    "Dict[str, 'LabwareDefinition']",
                    "Dict[str, Any]"
                ],
                "answer_names": [
                    "str",
                    "Set[str]",
                    "Dict[str, 'LabwareDefinition']",
                    "Dict[str, Any]"
                ]
            }
        },
        "get_polygon": {
            "name": "get_polygon",
            "location": 37,
            "return": [
                "ObjectAnnotation",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "int"
                ],
                "points": [
                    "str",
                    "int"
                ],
                "subclasses": [
                    "None",
                    "str",
                    "int"
                ]
            }
        },
        "get_rectangle": {
            "name": "get_rectangle",
            "location": 44,
            "return": [
                "ObjectAnnotation",
                "str",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "name": [
                    "Optional[int]",
                    "Optional[str]",
                    "int",
                    "float",
                    "Union[str, Tuple[str, ...]]",
                    "bool"
                ],
                "start": [
                    "Optional[int]",
                    "Optional[str]",
                    "int",
                    "float",
                    "Union[str, Tuple[str, ...]]",
                    "bool"
                ],
                "end": [
                    "Optional[int]",
                    "Optional[str]",
                    "int",
                    "float",
                    "Union[str, Tuple[str, ...]]",
                    "bool"
                ],
                "subclasses": [
                    "None",
                    "Optional[int]",
                    "Optional[str]",
                    "int",
                    "float",
                    "Union[str, Tuple[str, ...]]",
                    "bool"
                ]
            }
        },
        "get_mask": {
            "name": "get_mask",
            "location": 52,
            "return": [
                "ObjectAnnotation",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Optional[str]",
                    "Optional[Any]"
                ],
                "pixels": [
                    "str",
                    "int",
                    "Iterable[str]"
                ],
                "color": [
                    "tuple[int]",
                    "str",
                    "List[str]",
                    "Optional[List[str]]",
                    "Optional[Dict[str, str]]",
                    "List[allennlp.data.tokenizers.Token]",
                    "IO"
                ],
                "subclasses": [
                    "None",
                    "str",
                    "Optional[str]",
                    "Optional[Any]"
                ]
            }
        },
        "get_line": {
            "name": "get_line",
            "location": 62,
            "return": [
                "ObjectAnnotation",
                "str",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "int"
                ],
                "points": [
                    "str",
                    "int"
                ],
                "subclasses": [
                    "None",
                    "str",
                    "int"
                ]
            }
        },
        "get_point": {
            "name": "get_point",
            "location": 69,
            "return": [
                "ObjectAnnotation",
                "str",
                "Optional[str]",
                "dict",
                "List[str]",
                "bytes",
                "bool"
            ],
            "arguments": {
                "name": [
                    "bool",
                    "str",
                    "Union[int, float]",
                    "Optional[Any]",
                    "bytes",
                    "int"
                ],
                "x": [
                    "bool",
                    "str",
                    "Union[int, float]",
                    "Optional[Any]",
                    "bytes",
                    "int"
                ],
                "y": [
                    "bool",
                    "str",
                    "Union[int, float]",
                    "Optional[Any]",
                    "bytes",
                    "int"
                ],
                "subclasses": [
                    "None",
                    "bool",
                    "str",
                    "Union[int, float]",
                    "Optional[Any]",
                    "bytes",
                    "int"
                ]
            }
        },
        "get_ner": {
            "name": "get_ner",
            "location": 89,
            "return": [
                "ObjectAnnotation",
                "str",
                "Optional[str]",
                "dict",
                "List[str]",
                "bytes"
            ],
            "arguments": {
                "name": [
                    "str",
                    "int"
                ],
                "start": [
                    "str",
                    "int"
                ],
                "end": [
                    "str",
                    "int"
                ],
                "subclasses": [
                    "None",
                    "str",
                    "int"
                ]
            }
        },
        "get_object_pairs": {
            "name": "get_object_pairs",
            "location": 96,
            "return": [
                "str",
                "bool",
                "Awaitable"
            ],
            "arguments": {
                "tool_fn": [
                    "bool",
                    "int",
                    "Union[List[str], str]",
                    "allennlp.data.vocabulary.Vocabulary",
                    "str"
                ]
            }
        },
        "radio_pairs": {
            "name": "radio_pairs",
            "location": 191,
            "return": [
                "list[NameSpace]",
                "Dict[str, str]",
                "Union[type, Tuple[type, ...]]",
                "Dict[str, List[Callable]]"
            ],
            "arguments": {}
        },
        "checklist_pairs": {
            "name": "checklist_pairs",
            "location": 227,
            "return": [
                "list[NameSpace]",
                "Dict[str, Any]",
                "int",
                "Dict[str, Union[str, Any]]"
            ],
            "arguments": {}
        },
        "polygon_pairs": {
            "name": "polygon_pairs",
            "location": 312,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "rectangle_pairs": {
            "name": "rectangle_pairs",
            "location": 318,
            "return": [
                "Optional[str]",
                "bool",
                "str"
            ],
            "arguments": {}
        },
        "mask_pairs": {
            "name": "mask_pairs",
            "location": 323,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "line_pairs": {
            "name": "line_pairs",
            "location": 328,
            "return": [
                "bool",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "point_pairs": {
            "name": "point_pairs",
            "location": 334,
            "return": [
                "Optional[int]",
                "Optional[List[Callable]]",
                "str"
            ],
            "arguments": {}
        },
        "ner_pairs": {
            "name": "ner_pairs",
            "location": 339,
            "return": [
                "Optional[str]",
                "bool",
                "str"
            ],
            "arguments": {}
        },
        "pair_iou_thresholds": {
            "name": "pair_iou_thresholds",
            "location": 344,
            "return": [
                "list[NameSpace]",
                "Dict[str, Any]",
                "int",
                "Dict[str, Union[str, Any]]"
            ],
            "arguments": {}
        },
        "NameSpace.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "Dict[str, Any]",
                    "Type[types.C]",
                    "bool",
                    "str"
                ],
                "ground_truths": [
                    "Dict[str, Any]",
                    "Type[types.C]",
                    "bool",
                    "str"
                ],
                "expected": [
                    "Dict[str, Any]",
                    "Type[types.C]",
                    "bool",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/metrics/confusion_matrix/test_confusion_matrix_data_row.py": {
        "test_overlapping_objects": {
            "name": "test_overlapping_objects",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tool_examples": [
                    "List[str]"
                ]
            }
        },
        "test_overlapping_classifications": {
            "name": "test_overlapping_classifications",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tool_examples": [
                    "List[str]"
                ]
            }
        },
        "test_partial_overlap": {
            "name": "test_partial_overlap",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair_iou_thresholds": [
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/metrics/confusion_matrix/test_confusion_matrix_feature.py": {
        "test_overlapping_objects": {
            "name": "test_overlapping_objects",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tool_examples": [
                    "List[str]"
                ]
            }
        },
        "test_overlapping_classifications": {
            "name": "test_overlapping_classifications",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tool_examples": [
                    "List[str]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/metrics/iou/data_row/conftest.py": {
        "polygon_pair": {
            "name": "polygon_pair",
            "location": 36,
            "return": [
                "NameSpace",
                "bool",
                "apistar.types.WSGIEnviron",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "box_pair": {
            "name": "box_pair",
            "location": 82,
            "return": [
                "NameSpace",
                "bool",
                "apistar.types.WSGIEnviron",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "unmatched_prediction": {
            "name": "unmatched_prediction",
            "location": 110,
            "return": [
                "NameSpace",
                "bool",
                "apistar.types.WSGIEnviron",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "unmatched_label": {
            "name": "unmatched_label",
            "location": 177,
            "return": [
                "NameSpace",
                "Dict[str, Any]",
                "str",
                "dict",
                "Optional[int]",
                "Dict[str, float]"
            ],
            "arguments": {}
        },
        "create_mask_url": {
            "name": "create_mask_url",
            "location": 240,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "indices": [
                    "str",
                    "dict",
                    "List[dict]",
                    "bool",
                    "tuple",
                    "Type[T]"
                ],
                "h": [
                    "int",
                    "str",
                    "Optional[List]",
                    "T"
                ],
                "w": [
                    "int",
                    "str",
                    "Optional[List]",
                    "T"
                ],
                "value": [
                    "str",
                    "Dict[str, Any]",
                    "int",
                    "bool",
                    "list"
                ]
            }
        },
        "mask_pair": {
            "name": "mask_pair",
            "location": 248,
            "return": [
                "NameSpace",
                "dict",
                "Dict[str, str]",
                "str",
                "Dict[str, float]"
            ],
            "arguments": {}
        },
        "matching_radio": {
            "name": "matching_radio",
            "location": 273,
            "return": [
                "NameSpace",
                "bool",
                "Optional[Match]",
                "Union[type, Tuple[type, ...]]",
                "Dict[str, str]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {}
        },
        "empty_radio_label": {
            "name": "empty_radio_label",
            "location": 296,
            "return": [
                "NameSpace",
                "str",
                "bool",
                "Dict[str, List[str]]",
                "Mapping[str, Any]"
            ],
            "arguments": {}
        },
        "empty_radio_prediction": {
            "name": "empty_radio_prediction",
            "location": 312,
            "return": [
                "NameSpace",
                "str",
                "Dict[str, Any]",
                "apistar.types.WSGIEnviron",
                "dict",
                "bool",
                "Callable"
            ],
            "arguments": {}
        },
        "matching_checklist": {
            "name": "matching_checklist",
            "location": 326,
            "return": [
                "NameSpace",
                "bool",
                "Optional[Match]",
                "Union[type, Tuple[type, ...]]",
                "Dict[str, str]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {}
        },
        "partially_matching_checklist_1": {
            "name": "partially_matching_checklist_1",
            "location": 366,
            "return": [
                "NameSpace",
                "bool",
                "int",
                "Optional[Match]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "partially_matching_checklist_2": {
            "name": "partially_matching_checklist_2",
            "location": 413,
            "return": [
                "NameSpace",
                "bool",
                "int",
                "Optional[Match]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "partially_matching_checklist_3": {
            "name": "partially_matching_checklist_3",
            "location": 456,
            "return": [
                "NameSpace",
                "bool",
                "int",
                "Optional[Match]",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "empty_checklist_label": {
            "name": "empty_checklist_label",
            "location": 499,
            "return": [
                "NameSpace",
                "str",
                "bool",
                "Dict[str, List[str]]",
                "Mapping[str, Any]"
            ],
            "arguments": {}
        },
        "empty_checklist_prediction": {
            "name": "empty_checklist_prediction",
            "location": 516,
            "return": [
                "NameSpace",
                "str",
                "Dict[str, Any]",
                "apistar.types.WSGIEnviron",
                "dict",
                "bool",
                "Callable"
            ],
            "arguments": {}
        },
        "matching_text": {
            "name": "matching_text",
            "location": 534,
            "return": [
                "NameSpace",
                "bool",
                "Dict[str, Any]",
                "Union[type, Tuple[type, ...]]",
                "Optional[Match]",
                "Dict[str, str]"
            ],
            "arguments": {}
        },
        "not_matching_text": {
            "name": "not_matching_text",
            "location": 553,
            "return": [
                "NameSpace",
                "bool",
                "int",
                "Tuple[str]",
                "Dict[str, str]",
                "Dict[str, Any]",
                "Union[type, Tuple[type, ...]]",
                "str"
            ],
            "arguments": {}
        },
        "test_box_with_subclass": {
            "name": "test_box_with_subclass",
            "location": 572,
            "return": [
                "NameSpace"
            ],
            "arguments": {}
        },
        "test_box_with_wrong_subclass": {
            "name": "test_box_with_wrong_subclass",
            "location": 612,
            "return": [
                "NameSpace"
            ],
            "arguments": {}
        },
        "line_pair": {
            "name": "line_pair",
            "location": 652,
            "return": [
                "NameSpace",
                "Optional[str]",
                "bool",
                "List[str]",
                "Dict[str, Type[Any]]",
                "Optional[Match]",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "point_pair": {
            "name": "point_pair",
            "location": 682,
            "return": [
                "NameSpace",
                "bool",
                "apistar.types.WSGIEnviron",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "matching_ner": {
            "name": "matching_ner",
            "location": 706,
            "return": [
                "NameSpace",
                "bool",
                "Dict[str, str]",
                "Union[type, Tuple[type, ...]]",
                "Optional[Match]",
                "str"
            ],
            "arguments": {}
        },
        "no_matching_ner": {
            "name": "no_matching_ner",
            "location": 733,
            "return": [
                "NameSpace",
                "Dict[str, Any]",
                "dict",
                "apistar.types.WSGIEnviron",
                "str",
                "Dict[str, str]"
            ],
            "arguments": {}
        },
        "partial_matching_ner": {
            "name": "partial_matching_ner",
            "location": 760,
            "return": [
                "NameSpace",
                "bool",
                "apistar.types.WSGIEnviron",
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "NameSpace.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ],
                "labels": [
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ],
                "expected": [
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ],
                "data_row_expected": [
                    "None",
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ],
                "media_attributes": [
                    "None",
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ],
                "metadata": [
                    "None",
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ],
                "classifications": [
                    "None",
                    "str",
                    "Dict[str, Any]",
                    "bool",
                    "Dict[str, str]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/metrics/iou/data_row/test_data_row_iou.py": {
        "check_iou": {
            "name": "check_iou",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "bytes",
                    "bytearray"
                ],
                "mask": [
                    "None",
                    "str",
                    "bool"
                ]
            }
        },
        "check_iou_checklist": {
            "name": "check_iou_checklist",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "bytes",
                    "bytearray"
                ],
                "mask": [
                    "None",
                    "str",
                    "bool"
                ]
            }
        },
        "strings_to_fixtures": {
            "name": "strings_to_fixtures",
            "location": 61,
            "return": [
                "list",
                "str",
                "List[str]",
                "Optional[str]"
            ],
            "arguments": {
                "strings": [
                    "str",
                    "List[str]",
                    "int"
                ]
            }
        },
        "test_overlapping": {
            "name": "test_overlapping",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "polygon_pair": [
                    "str",
                    "float"
                ],
                "box_pair": [
                    "str",
                    "float"
                ],
                "mask_pair": [
                    "str"
                ]
            }
        },
        "test_unmatched": {
            "name": "test_unmatched",
            "location": 76,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "float"
                ]
            }
        },
        "test_radio": {
            "name": "test_radio",
            "location": 86,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "float"
                ]
            }
        },
        "test_checklist": {
            "name": "test_checklist",
            "location": 99,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "float"
                ]
            }
        },
        "test_text": {
            "name": "test_text",
            "location": 105,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "bool",
                    "Iterable[Any]",
                    "Dict[str, float]"
                ]
            }
        },
        "test_vector_with_subclass": {
            "name": "test_vector_with_subclass",
            "location": 112,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "float"
                ]
            }
        },
        "test_others": {
            "name": "test_others",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "float"
                ]
            }
        },
        "test_ner": {
            "name": "test_ner",
            "location": 124,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "str",
                    "float"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/metrics/iou/feature/conftest.py": {
        "different_classes": {
            "name": "different_classes",
            "location": 18,
            "return": [
                "list[NameSpace]",
                "str",
                "bool",
                "type",
                "dict"
            ],
            "arguments": {}
        },
        "one_overlap_class": {
            "name": "one_overlap_class",
            "location": 46,
            "return": [
                "list[NameSpace]",
                "str",
                "dict",
                "bool",
                "Union[str, List[str]]"
            ],
            "arguments": {}
        },
        "empty_annotations": {
            "name": "empty_annotations",
            "location": 110,
            "return": [
                "list[NameSpace]",
                "str",
                "Optional[Callable]"
            ],
            "arguments": {}
        },
        "NameSpace.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "predictions": [
                    "Dict[str, Any]",
                    "Type[types.C]",
                    "bool",
                    "str"
                ],
                "ground_truths": [
                    "Dict[str, Any]",
                    "Type[types.C]",
                    "bool",
                    "str"
                ],
                "expected": [
                    "Dict[str, Any]",
                    "Type[types.C]",
                    "bool",
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/metrics/iou/feature/test_feature_iou.py": {
        "check_iou": {
            "name": "check_iou",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pair": [
                    "float"
                ]
            }
        },
        "test_different_classes": {
            "name": "test_different_classes",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "different_classes": [
                    "List[str]"
                ]
            }
        },
        "test_empty_annotations": {
            "name": "test_empty_annotations",
            "location": 30,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "empty_annotations": [
                    "str",
                    "Mapping[str, Any]"
                ]
            }
        },
        "test_one_overlap_classes": {
            "name": "test_one_overlap_classes",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "one_overlap_class": [
                    "bool",
                    "Type",
                    "Type[Any]",
                    "Iterable[str]",
                    "Exception"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/serialization/__init__.py": {},
    "labelbox-python-master/tests/data/serialization/coco/test_coco.py": {
        "run_instances": {
            "name": "run_instances",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_rle_objects": {
            "name": "test_rle_objects",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_panoptic": {
            "name": "test_panoptic",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/labelbox_v1/test_image.py": {
        "test_image": {
            "name": "test_image",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/serialization/labelbox_v1/test_text.py": {
        "test_text": {
            "name": "test_text",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/labelbox_v1/test_tiled_image.py": {
        "test_image": {
            "name": "test_image",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "file_path": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/data/serialization/labelbox_v1/test_unknown_media.py": {
        "test_image": {
            "name": "test_image",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/labelbox_v1/test_video.py": {
        "round_dict": {
            "name": "round_dict",
            "location": 6,
            "return": [
                "str",
                "Union[Dict, Tuple]",
                "Sequence",
                "bytes",
                "int"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "Dict[str, List[str]]",
                    "List[str]",
                    "Dict[str, Any]",
                    "Dict[str, str]"
                ]
            }
        },
        "test_video": {
            "name": "test_video",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_classification.py": {
        "test_classification": {
            "name": "test_classification",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_export_video_objects.py": {
        "video_bbox_label": {
            "name": "video_bbox_label",
            "location": 7,
            "return": [
                "Label",
                "int",
                "str",
                "Mapping[str, Any]"
            ],
            "arguments": {}
        },
        "video_serialized_bbox_label": {
            "name": "video_serialized_bbox_label",
            "location": 520,
            "return": [
                "dict[typing.Text, typing.Union[typing.Text,dict[typing.Text, typing.Text],list[dict[typing.Text, list[dict[typing.Text, typing.Union[int,dict[typing.Text, float]]]]]]]]",
                "str",
                "bytes",
                "List[dict]",
                "bytearray",
                "Callable"
            ],
            "arguments": {}
        },
        "test_serialize_video_objects": {
            "name": "test_serialize_video_objects",
            "location": 586,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_image.py": {
        "round_dict": {
            "name": "round_dict",
            "location": 9,
            "return": [
                "dict",
                "str",
                "Union[Dict, Tuple]",
                "Sequence",
                "bytes",
                "int"
            ],
            "arguments": {
                "data": [
                    "dict",
                    "Union[Dict, List]",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_image": {
            "name": "test_image",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_mask": {
            "name": "test_mask",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_mask_from_arr": {
            "name": "test_mask_from_arr",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_metric.py": {
        "test_metric": {
            "name": "test_metric",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_custom_scalar_metric": {
            "name": "test_custom_scalar_metric",
            "location": 19,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_custom_confusion_matrix_metric": {
            "name": "test_custom_confusion_matrix_metric",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_nested.py": {
        "test_nested": {
            "name": "test_nested",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_text.py": {
        "test_text": {
            "name": "test_text",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/test_video.py": {
        "test_video": {
            "name": "test_video",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/data/serialization/ndjson/__init__.py": {},
    "labelbox-python-master/tests/integration/conftest.py": {
        "environ": {
            "name": "environ",
            "location": 32,
            "return": [
                "Tuple[Any, Any, Any]",
                "Environ"
            ],
            "arguments": {}
        },
        "graphql_url": {
            "name": "graphql_url",
            "location": 46,
            "return": [
                "str",
                "typing.Text",
                "float",
                "None"
            ],
            "arguments": {
                "environ": [
                    "dict",
                    "Dict[str, Any]",
                    "str"
                ]
            }
        },
        "testing_api_key": {
            "name": "testing_api_key",
            "location": 65,
            "return": [
                "int"
            ],
            "arguments": {
                "environ": [
                    "str"
                ]
            }
        },
        "cancel_invite": {
            "name": "cancel_invite",
            "location": 77,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "int",
                    "str",
                    "Optional[float]",
                    "Sequence[int]"
                ],
                "invite_id": [
                    "int",
                    "str",
                    "Optional[float]",
                    "Sequence[int]"
                ]
            }
        },
        "get_project_invites": {
            "name": "get_project_invites",
            "location": 86,
            "return": [
                "str",
                "PaginatedCollection"
            ],
            "arguments": {
                "client": [
                    "str",
                    "Optional[str]",
                    "int"
                ],
                "project_id": [
                    "str",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "get_invites": {
            "name": "get_invites",
            "location": 103,
            "return": [
                "PaginatedCollection",
                "str",
                "bool"
            ],
            "arguments": {
                "client": [
                    "List[str]",
                    "zerver.models.Client",
                    "bool"
                ]
            }
        },
        "queries": {
            "name": "queries",
            "location": 120,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "client": {
            "name": "client",
            "location": 142,
            "return": [
                "IntegrationClient",
                "str",
                "Callable",
                "Callable[..., neuromation.api.Client]"
            ],
            "arguments": {
                "environ": [
                    "str",
                    "dict",
                    "Callable",
                    "Callable[..., neuromation.api.Client]"
                ]
            }
        },
        "image_url": {
            "name": "image_url",
            "location": 147,
            "return": [
                "List[str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "client": [
                    "str",
                    "List[str]",
                    "Optional[arxiv.submission.Client]",
                    "arxiv.submission.User"
                ]
            }
        },
        "project": {
            "name": "project",
            "location": 152,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "Dict[str, Any]",
                    "zulip.Client",
                    "sqlalchemy.orm.Session",
                    "tracim.models.data.User"
                ],
                "rand_gen": [
                    "Dict[str, Any]",
                    "zulip.Client",
                    "sqlalchemy.orm.Session",
                    "tracim.models.data.User"
                ]
            }
        },
        "dataset": {
            "name": "dataset",
            "location": 159,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "Dict[str, Any]"
                ],
                "rand_gen": [
                    "Dict[str, Any]"
                ]
            }
        },
        "datarow": {
            "name": "datarow",
            "location": 166,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "dataset": [
                    "List[str]",
                    "str",
                    "bytes",
                    "Mapping[starfish.types.Coordinates, Tuple[starfish.types.Number, starfish.types.Number]]",
                    "Mapping[starfish.core.types.Coordinates, starfish.core.types.ArrayLike[starfish.core.types.Number]]",
                    "Sequence[str]"
                ],
                "image_url": [
                    "str",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "iframe_url": {
            "name": "iframe_url",
            "location": 180,
            "return": [
                "typing.Text",
                "str",
                "float"
            ],
            "arguments": {
                "environ": [
                    "Mapping[str, Any]",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        },
        "sample_video": {
            "name": "sample_video",
            "location": 188,
            "return": [
                "typing.Text",
                "str",
                "int",
                "list"
            ],
            "arguments": {}
        },
        "organization": {
            "name": "organization",
            "location": 195,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": []
            }
        },
        "project_based_user": {
            "name": "project_based_user",
            "location": 209,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "rand_gen": [
                    "str"
                ]
            }
        },
        "project_pack": {
            "name": "project_pack",
            "location": 233,
            "return": [
                "",
                "typing.Generator[list]"
            ],
            "arguments": {
                "client": [
                    "Callable",
                    "Dict[str, Any]",
                    "Optional[str]"
                ]
            }
        },
        "configured_project": {
            "name": "configured_project",
            "location": 243,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "project": [
                    "str",
                    "bool"
                ],
                "client": [
                    "str"
                ],
                "rand_gen": [
                    "str",
                    "TextIO"
                ],
                "image_url": [
                    "str",
                    "int",
                    "Tuple[int, int]",
                    "bool"
                ]
            }
        },
        "configured_project_with_label": {
            "name": "configured_project_with_label",
            "location": 257,
            "return": [
                "",
                "typing.Generator[list]"
            ],
            "arguments": {
                "client": [
                    "bool",
                    "sqlalchemy.orm.session.Session",
                    "List[str]"
                ],
                "rand_gen": [
                    "bool",
                    "sqlalchemy.orm.session.Session",
                    "List[str]"
                ],
                "image_url": [
                    "bool",
                    "sqlalchemy.orm.session.Session",
                    "List[str]"
                ],
                "project": [
                    "str",
                    "sqlalchemy.orm.session.Session"
                ],
                "dataset": [
                    "str",
                    "bool"
                ],
                "datarow": [
                    "str",
                    "bool"
                ]
            }
        },
        "configured_project_with_complex_ontology": {
            "name": "configured_project_with_complex_ontology",
            "location": 310,
            "return": [
                "",
                "typing.Generator[list]"
            ],
            "arguments": {
                "client": [
                    "dict"
                ],
                "rand_gen": [
                    "int",
                    "str"
                ],
                "image_url": [
                    "str",
                    "dict",
                    "app.utils.types.JSON"
                ]
            }
        },
        "IntegrationClient.__init__": {
            "name": "__init__",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "environ": [
                    "str",
                    "List[str]",
                    "Dict[str, str]"
                ]
            }
        },
        "IntegrationClient.execute": {
            "name": "execute",
            "location": 134,
            "return": [
                "Set[str]",
                "List[Dict[str, Any]]",
                "types.solution_T",
                "int",
                "str",
                "bytes"
            ],
            "arguments": {
                "self": [],
                "query": [
                    "None",
                    "str",
                    "Iterable[str]",
                    "daylighdb.models.User",
                    "type",
                    "Sequence[type]"
                ],
                "params": [
                    "None",
                    "str",
                    "int"
                ],
                "check_naming": [
                    "bool",
                    "Optional[str]",
                    "str",
                    "medtagger.database.models.User",
                    "sqlalchemy.orm.session.Session"
                ]
            }
        },
        "configured_project_with_label.create_label": {
            "name": "create_label",
            "location": 291,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/integration/test_batch.py": {
        "big_dataset": {
            "name": "big_dataset",
            "location": 9,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "List[str]",
                    "dict",
                    "int"
                ]
            }
        },
        "small_dataset": {
            "name": "small_dataset",
            "location": 22,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "List[str]",
                    "dict",
                    "int"
                ]
            }
        },
        "test_create_batch": {
            "name": "test_create_batch",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "float"
                ],
                "big_dataset": [
                    "int"
                ]
            }
        },
        "test_archive_batch": {
            "name": "test_archive_batch",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [],
                "small_dataset": [
                    "int"
                ]
            }
        },
        "test_batch_project": {
            "name": "test_batch_project",
            "location": 53,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [],
                "small_dataset": [
                    "int"
                ]
            }
        },
        "test_export_data_rows": {
            "name": "test_export_data_rows",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "float"
                ],
                "dataset": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_benchmark.py": {
        "test_benchmark": {
            "name": "test_benchmark",
            "location": 1,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Optional[Dict[str, Any]]",
                    "bool",
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_client_errors.py": {
        "test_missing_api_key": {
            "name": "test_missing_api_key",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_bad_key": {
            "name": "test_bad_key",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rand_gen": []
            }
        },
        "test_syntax_error": {
            "name": "test_syntax_error",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "test_semantic_error": {
            "name": "test_semantic_error",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "test_timeout_error": {
            "name": "test_timeout_error",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "project": [
                    "str",
                    "bytes"
                ]
            }
        },
        "test_query_complexity_error": {
            "name": "test_query_complexity_error",
            "location": 58,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str",
                    "List[str]"
                ]
            }
        },
        "test_resource_not_found_error": {
            "name": "test_resource_not_found_error",
            "location": 65,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": []
            }
        },
        "test_network_error": {
            "name": "test_network_error",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": []
            }
        },
        "test_invalid_attribute_error": {
            "name": "test_invalid_attribute_error",
            "location": 78,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": []
            }
        },
        "test_api_limit_error": {
            "name": "test_api_limit_error",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool"
                ]
            }
        },
        "test_api_limit_error.get": {
            "name": "get",
            "location": 116,
            "return": [
                "Exception",
                "str",
                "Callable[[], str]",
                "dict"
            ],
            "arguments": {
                "arg": [
                    "bool",
                    "str",
                    "T",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_dataset.py": {
        "test_dataset": {
            "name": "test_dataset",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": [
                    "str",
                    "dict"
                ]
            }
        },
        "test_dataset_filtering": {
            "name": "test_dataset_filtering",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "rand_gen": [
                    "int"
                ]
            }
        },
        "test_get_data_row_for_external_id": {
            "name": "test_get_data_row_for_external_id",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "bool",
                    "Tuple[str]",
                    "str"
                ],
                "rand_gen": [
                    "Dict[str, Sequence[str]]"
                ],
                "image_url": [
                    "str"
                ]
            }
        },
        "test_upload_video_file": {
            "name": "test_upload_video_file",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "Iterable[int]"
                ],
                "sample_video": [
                    "str"
                ]
            }
        },
        "test_data_row_export": {
            "name": "test_data_row_export",
            "location": 104,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [],
                "image_url": [
                    "int",
                    "Hashable",
                    "Optional[Dict]"
                ]
            }
        },
        "test_create_descriptor_file": {
            "name": "test_create_descriptor_file",
            "location": 114,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_data_rows.py": {
        "mdo": {
            "name": "mdo",
            "location": 24,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "dict"
                ]
            }
        },
        "make_metadata_fields": {
            "name": "make_metadata_fields",
            "location": 31,
            "return": [
                "list[DataRowMetadataField]",
                "str",
                "bool",
                "Iterable[str]"
            ],
            "arguments": {}
        },
        "make_metadata_fields_dict": {
            "name": "make_metadata_fields_dict",
            "location": 45,
            "return": [
                "list[dict[typing.Text, typing.Union[typing.Text,list[float]]]]",
                "str",
                "Iterable[str]",
                "bool",
                "List[str]"
            ],
            "arguments": {}
        },
        "test_get_data_row": {
            "name": "test_get_data_row",
            "location": 66,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [],
                "client": []
            }
        },
        "test_lookup_data_rows": {
            "name": "test_lookup_data_rows",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "dataset": []
            }
        },
        "test_data_row_bulk_creation": {
            "name": "test_data_row_bulk_creation",
            "location": 100,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "list",
                    "List[str]",
                    "Optional[str]"
                ],
                "rand_gen": [
                    "int",
                    "Optional[Union[float, str]]",
                    "str",
                    "Iterable[int]"
                ],
                "image_url": [
                    "str",
                    "Optional[Dict]",
                    "dict"
                ]
            }
        },
        "test_data_row_large_bulk_creation": {
            "name": "test_data_row_large_bulk_creation",
            "location": 150,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "Dict[str, Any]",
                    "Dict[str, int]"
                ],
                "image_url": [
                    "dict",
                    "Dict[str, str]",
                    "bool",
                    "int"
                ]
            }
        },
        "test_data_row_single_creation": {
            "name": "test_data_row_single_creation",
            "location": 165,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "List[str]"
                ],
                "rand_gen": [
                    "int",
                    "Optional[Union[float, str]]",
                    "str",
                    "Iterable[int]"
                ],
                "image_url": [
                    "dict",
                    "str",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_create_data_row_with_dict": {
            "name": "test_create_data_row_with_dict",
            "location": 187,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Optional[str]",
                    "List[bytes]",
                    "Iterable[str]",
                    "List[str]"
                ],
                "image_url": []
            }
        },
        "test_create_data_row_with_dict_containing_field": {
            "name": "test_create_data_row_with_dict_containing_field",
            "location": 201,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "Optional[str]",
                    "Mapping[str, Sequence[str]]",
                    "List[str]",
                    "list",
                    "Union[int, str]",
                    "str"
                ],
                "image_url": [
                    "Dict[str, str]",
                    "dict"
                ]
            }
        },
        "test_create_data_row_with_dict_unpacked": {
            "name": "test_create_data_row_with_dict_unpacked",
            "location": 215,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Optional[str]",
                    "List[bytes]",
                    "Iterable[str]",
                    "List[str]"
                ],
                "image_url": []
            }
        },
        "test_create_data_row_with_invalid_input": {
            "name": "test_create_data_row_with_invalid_input",
            "location": 229,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int"
                ],
                "image_url": [
                    "IO[bytes]",
                    "str",
                    "bool"
                ]
            }
        },
        "test_create_data_row_with_metadata": {
            "name": "test_create_data_row_with_metadata",
            "location": 238,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mdo": [
                    "str"
                ],
                "dataset": [
                    "str",
                    "Iterable[str]",
                    "List[str]",
                    "bool",
                    "int",
                    "Sequence[str]",
                    "bytes",
                    "Dict[str, Any]"
                ],
                "image_url": []
            }
        },
        "test_create_data_row_with_metadata_dict": {
            "name": "test_create_data_row_with_metadata_dict",
            "location": 262,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mdo": [
                    "str"
                ],
                "dataset": [
                    "str",
                    "Iterable[str]",
                    "List[str]",
                    "bool",
                    "int",
                    "Sequence[str]",
                    "bytes",
                    "Dict[str, Any]"
                ],
                "image_url": [
                    "Dict[str, str]"
                ]
            }
        },
        "test_create_data_row_with_invalid_metadata": {
            "name": "test_create_data_row_with_invalid_metadata",
            "location": 286,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "str"
                ],
                "image_url": [
                    "int",
                    "str"
                ]
            }
        },
        "test_create_data_rows_with_metadata": {
            "name": "test_create_data_rows_with_metadata",
            "location": 295,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mdo": [
                    "str"
                ],
                "dataset": [
                    "int"
                ],
                "image_url": [
                    "str",
                    "int"
                ]
            }
        },
        "test_create_data_rows_with_invalid_metadata": {
            "name": "test_create_data_rows_with_invalid_metadata",
            "location": 343,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "str"
                ],
                "image_url": [
                    "dict",
                    "str"
                ]
            }
        },
        "test_create_data_rows_with_metadata_missing_value": {
            "name": "test_create_data_rows_with_metadata_missing_value",
            "location": 356,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "Iterable[T]",
                    "str",
                    "bool"
                ],
                "image_url": [
                    "dict",
                    "Iterable[T]",
                    "str",
                    "bool"
                ]
            }
        },
        "test_create_data_rows_with_metadata_missing_schema_id": {
            "name": "test_create_data_rows_with_metadata_missing_schema_id",
            "location": 370,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "List[str]",
                    "bool",
                    "Iterable[T]"
                ],
                "image_url": [
                    "dict",
                    "List[str]",
                    "bool",
                    "Iterable[T]"
                ]
            }
        },
        "test_create_data_rows_with_metadata_wrong_type": {
            "name": "test_create_data_rows_with_metadata_wrong_type",
            "location": 384,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "str"
                ],
                "image_url": [
                    "dict",
                    "str"
                ]
            }
        },
        "test_data_row_update": {
            "name": "test_data_row_update",
            "location": 398,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "bytes"
                ],
                "rand_gen": [
                    "str"
                ],
                "image_url": [
                    "str",
                    "bytes"
                ]
            }
        },
        "test_data_row_filtering_sorting": {
            "name": "test_data_row_filtering_sorting",
            "location": 409,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "int",
                    "str"
                ],
                "image_url": [
                    "dict",
                    "int",
                    "str"
                ]
            }
        },
        "test_data_row_deletion": {
            "name": "test_data_row_deletion",
            "location": 443,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "str",
                    "bytes",
                    "BaseException"
                ],
                "image_url": [
                    "dict",
                    "BaseException"
                ]
            }
        },
        "test_data_row_iteration": {
            "name": "test_data_row_iteration",
            "location": 469,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "dict",
                    "Dict[str, str]"
                ],
                "image_url": [
                    "dict",
                    "Dict[str, List[int]]",
                    "Dict[str, str]",
                    "str"
                ]
            }
        },
        "test_data_row_attachments": {
            "name": "test_data_row_attachments",
            "location": 482,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "bytes",
                    "Dict[str, Any]"
                ],
                "image_url": [
                    "str",
                    "dict"
                ]
            }
        },
        "test_create_data_rows_sync_attachments": {
            "name": "test_create_data_rows_sync_attachments",
            "location": 513,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "int"
                ],
                "image_url": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "test_create_data_rows_sync_mixed_upload": {
            "name": "test_create_data_rows_sync_mixed_upload",
            "location": 533,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "dict",
                    "int",
                    "str",
                    "bool",
                    "Set[str]"
                ],
                "image_url": [
                    "str",
                    "int"
                ]
            }
        },
        "test_delete_data_row_attachment": {
            "name": "test_delete_data_row_attachment",
            "location": 545,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [
                    "list",
                    "int",
                    "Callable",
                    "Callable[[], None]",
                    "str"
                ],
                "image_url": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "test_create_data_rows_result": {
            "name": "test_create_data_rows_result",
            "location": 559,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool",
                    "Optional[Dict[str, Any]]"
                ],
                "dataset": [
                    "str"
                ],
                "image_url": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_data_row_media_attributes.py": {
        "test_export_empty_media_attributes": {
            "name": "test_export_empty_media_attributes",
            "location": 1,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Dict[str, int]",
                    "List[str]",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_data_row_metadata.py": {
        "mdo": {
            "name": "mdo",
            "location": 29,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "dict"
                ]
            }
        },
        "big_dataset": {
            "name": "big_dataset",
            "location": 38,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "dataset": [
                    "str",
                    "List[str]",
                    "datetime.datetime",
                    "Optional[str]"
                ],
                "image_url": [
                    "str",
                    "List[str]",
                    "datetime.datetime",
                    "Optional[str]"
                ]
            }
        },
        "make_metadata": {
            "name": "make_metadata",
            "location": 50,
            "return": [
                "DataRowMetadata",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "dr_id": [
                    "str",
                    "Optional[int]",
                    "int"
                ]
            }
        },
        "test_export_empty_metadata": {
            "name": "test_export_empty_metadata",
            "location": 68,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Dict[str, int]",
                    "List[str]",
                    "dict"
                ]
            }
        },
        "test_get_datarow_metadata_ontology": {
            "name": "test_get_datarow_metadata_ontology",
            "location": 75,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mdo": [
                    "Dict[str, Any]"
                ]
            }
        },
        "test_bulk_upsert_datarow_metadata": {
            "name": "test_bulk_upsert_datarow_metadata",
            "location": 95,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [],
                "mdo": []
            }
        },
        "test_large_bulk_upsert_datarow_metadata": {
            "name": "test_large_bulk_upsert_datarow_metadata",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "big_dataset": [
                    "str"
                ],
                "mdo": []
            }
        },
        "test_bulk_delete_datarow_metadata": {
            "name": "test_bulk_delete_datarow_metadata",
            "location": 126,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [
                    "Dict[str, Sequence[Any]]"
                ],
                "mdo": []
            }
        },
        "test_bulk_partial_delete_datarow_metadata": {
            "name": "test_bulk_partial_delete_datarow_metadata",
            "location": 139,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [],
                "mdo": []
            }
        },
        "test_large_bulk_delete_datarow_metadata": {
            "name": "test_large_bulk_delete_datarow_metadata",
            "location": 158,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "big_dataset": [
                    "str"
                ],
                "mdo": [
                    "Dict[str, Any]"
                ]
            }
        },
        "test_bulk_delete_datarow_enum_metadata": {
            "name": "test_bulk_delete_datarow_enum_metadata",
            "location": 194,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [
                    "Dict[str, Any]"
                ],
                "mdo": []
            }
        },
        "test_raise_enum_upsert_schema_error": {
            "name": "test_raise_enum_upsert_schema_error",
            "location": 215,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [
                    "int"
                ],
                "mdo": []
            }
        },
        "test_upsert_non_existent_schema_id": {
            "name": "test_upsert_non_existent_schema_id",
            "location": 227,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [
                    "int"
                ],
                "mdo": [
                    "dict"
                ]
            }
        },
        "test_delete_non_existent_schema_id": {
            "name": "test_delete_non_existent_schema_id",
            "location": 239,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "datarow": [],
                "mdo": []
            }
        },
        "test_parse_raw_metadata": {
            "name": "test_parse_raw_metadata",
            "location": 247,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mdo": [
                    "str",
                    "set"
                ]
            }
        },
        "test_parse_raw_metadata_fields": {
            "name": "test_parse_raw_metadata_fields",
            "location": 286,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mdo": [
                    "str",
                    "set"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_data_upload.py": {
        "test_file_upload": {
            "name": "test_file_upload",
            "location": 5,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": [],
                "dataset": [
                    "str",
                    "int",
                    "bytes"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_dates.py": {
        "test_dates": {
            "name": "test_dates",
            "location": 4,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": []
            }
        },
        "test_utc_conversion": {
            "name": "test_utc_conversion",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_delegated_access.py": {
        "test_default_integration": {
            "name": "test_default_integration",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_non_default_integration": {
            "name": "test_non_default_integration",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_no_integration": {
            "name": "test_no_integration",
            "location": 59,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str",
                    "Optional[str]"
                ],
                "image_url": [
                    "bool",
                    "List[Dict[str, Any]]",
                    "str"
                ]
            }
        },
        "test_no_default_integration": {
            "name": "test_no_default_integration",
            "location": 67,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_export.py": {
        "test_export_annotations_nested_checklist": {
            "name": "test_export_annotations_nested_checklist",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool",
                    "int"
                ],
                "configured_project_with_complex_ontology": [
                    "str"
                ]
            }
        },
        "test_export_filtered_dates": {
            "name": "test_export_filtered_dates",
            "location": 59,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool",
                    "int"
                ],
                "configured_project_with_complex_ontology": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_filtering.py": {
        "test_where": {
            "name": "test_where",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool"
                ]
            }
        },
        "test_unsupported_where": {
            "name": "test_unsupported_where",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": []
            }
        },
        "test_where._get": {
            "name": "_get",
            "location": 12,
            "return": [
                "set",
                "Optional[bool]",
                "int",
                "bool",
                "Optional[str]"
            ],
            "arguments": {
                "f": [
                    "bool",
                    "Optional[str]",
                    "Iterable[Tuple[int, int]]",
                    "str"
                ],
                "where": [
                    "None",
                    "Optional[str]",
                    "int",
                    "Optional[float]"
                ]
            }
        },
        "test_where.get": {
            "name": "get",
            "location": 33,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "where": [
                    "None",
                    "set",
                    "str",
                    "tuple"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_issues.py": {
        "test_issues_export": {
            "name": "test_issues_export",
            "location": 4,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_label.py": {
        "test_labels": {
            "name": "test_labels",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "bytes"
                ]
            }
        },
        "test_label_export": {
            "name": "test_label_export",
            "location": 26,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "int",
                    "Optional[str]",
                    "bytes",
                    "List[str]"
                ]
            }
        },
        "test_label_update": {
            "name": "test_label_update",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Optional[List[str]]"
                ]
            }
        },
        "test_label_filter_order": {
            "name": "test_label_filter_order",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Optional[List[str]]",
                    "bytes",
                    "List[str]",
                    "Optional[str]"
                ]
            }
        },
        "test_label_bulk_deletion": {
            "name": "test_label_bulk_deletion",
            "location": 60,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "IO",
                    "Dict[str, str]",
                    "int",
                    "bytes",
                    "Iterator[T]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_labeler_performance.py": {
        "test_labeler_performance": {
            "name": "test_labeler_performance",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Dict[str, int]",
                    "List[str]",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_labeling_frontend.py": {
        "test_get_labeling_frontends": {
            "name": "test_get_labeling_frontends",
            "location": 4,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "int"
                ]
            }
        },
        "test_labeling_frontend_connecting_to_project": {
            "name": "test_labeling_frontend_connecting_to_project",
            "location": 10,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_labeling_parameter_overrides.py": {
        "test_labeling_parameter_overrides": {
            "name": "test_labeling_parameter_overrides",
            "location": 5,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": [
                    "dict",
                    "str"
                ],
                "rand_gen": [
                    "str"
                ],
                "image_url": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_ontology.py": {
        "test_from_project_ontology": {
            "name": "test_from_project_ontology",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "project": [
                    "bytes",
                    "taskiinfrastructure.data.json.repositories.project_repository.JsonProjectRepository"
                ]
            }
        },
        "_get_attr_stringify_json": {
            "name": "_get_attr_stringify_json",
            "location": 18,
            "return": [
                "str",
                "Optional[str]",
                "list"
            ],
            "arguments": {
                "obj": [
                    "Dict[str, str]",
                    "str",
                    "dict"
                ],
                "attr": [
                    "str"
                ]
            }
        },
        "test_feature_schema_create_read": {
            "name": "test_feature_schema_create_read",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": [
                    "int",
                    "str"
                ]
            }
        },
        "test_ontology_create_read": {
            "name": "test_ontology_create_read",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": [
                    "bool"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_project.py": {
        "test_project": {
            "name": "test_project",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "rand_gen": [
                    "str",
                    "list"
                ]
            }
        },
        "test_update_project_resource_tags": {
            "name": "test_update_project_resource_tags",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "test_project_filtering": {
            "name": "test_project_filtering",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": []
            }
        },
        "test_upsert_review_queue": {
            "name": "test_upsert_review_queue",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": []
            }
        },
        "test_extend_reservations": {
            "name": "test_extend_reservations",
            "location": 132,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": [
                    "models.Project",
                    "bytes"
                ]
            }
        },
        "test_attach_instructions": {
            "name": "test_attach_instructions",
            "location": 141,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "project": [
                    "models.Project"
                ]
            }
        },
        "test_html_instructions": {
            "name": "test_html_instructions",
            "location": 166,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "str",
                    "Dict[str, Sequence[str]]"
                ]
            }
        },
        "test_same_ontology_after_instructions": {
            "name": "test_same_ontology_after_instructions",
            "location": 182,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_complex_ontology": [
                    "str",
                    "int",
                    "managers.models.Project",
                    "bytes",
                    "BinaryIO"
                ]
            }
        },
        "test_queued_data_row_export": {
            "name": "test_queued_data_row_export",
            "location": 195,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "str"
                ]
            }
        },
        "test_queue_mode": {
            "name": "test_queue_mode",
            "location": 200,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "str"
                ]
            }
        },
        "test_batches": {
            "name": "test_batches",
            "location": 207,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "bytes",
                    "Callable"
                ],
                "dataset": [
                    "List[str]",
                    "Set[str]"
                ],
                "image_url": [
                    "str",
                    "Callable",
                    "Optional[str]"
                ]
            }
        },
        "test_media_type": {
            "name": "test_media_type",
            "location": 226,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "configured_project": [
                    "Optional[str]",
                    "bool"
                ],
                "rand_gen": []
            }
        },
        "test_update_project_resource_tags.delete_tag": {
            "name": "delete_tag",
            "location": 49,
            "return": [
                "str",
                "dict",
                "Tuple[int]",
                "bytes"
            ],
            "arguments": {
                "tag_id": [
                    "str",
                    "Union[str, os.PathLike]",
                    "Optional[Union[int, Any]]",
                    "List[str]",
                    "Optional[str]",
                    "bool"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_project_setup.py": {
        "simple_ontology": {
            "name": "simple_ontology",
            "location": 12,
            "return": [
                "dict[typing.Text, list[dict[typing.Text, typing.Union[typing.Text,list[dict[typing.Text, typing.Text]],bool]]]]",
                "str",
                "Tuple[str]",
                "Callable[[None], None]",
                "bool",
                "List[str]",
                "int"
            ],
            "arguments": {}
        },
        "test_project_setup": {
            "name": "test_project_setup",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "project": [
                    "bool",
                    "int"
                ]
            }
        },
        "test_project_editor_setup": {
            "name": "test_project_editor_setup",
            "location": 55,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str",
                    "int"
                ],
                "project": [
                    "str",
                    "int",
                    "Iterable[Tuple[int, int]]"
                ],
                "rand_gen": [
                    "str",
                    "Dict[str, str]",
                    "Optional[str]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_relationships.py": {
        "test_project_dataset": {
            "name": "test_project_dataset",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "rand_gen": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_review.py": {
        "test_reviews": {
            "name": "test_reviews",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "test_review_metrics": {
            "name": "test_review_metrics",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project_with_label": [
                    "str",
                    "Dict[str, int]",
                    "List[str]",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_sorting.py": {
        "test_relationship_sorting": {
            "name": "test_relationship_sorting",
            "location": 8,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool"
                ]
            }
        },
        "test_top_level_sorting": {
            "name": "test_top_level_sorting",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": []
            }
        },
        "test_relationship_sorting.get": {
            "name": "get",
            "location": 18,
            "return": [
                "list",
                "List[str]",
                "str",
                "List[Dict]",
                "List[int]"
            ],
            "arguments": {
                "order_by": [
                    "str",
                    "Optional[int]",
                    "bool"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_task.py": {
        "test_task_errors": {
            "name": "test_task_errors",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Callable",
                    "Dict[str, Any]"
                ],
                "image_url": [
                    "dict",
                    "Mapping"
                ]
            }
        },
        "test_task_success_json": {
            "name": "test_task_success_json",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Optional[Exception]",
                    "dict"
                ],
                "image_url": [
                    "str",
                    "dict",
                    "List[recidiviz.persistence.database.schema.state.schema.StateIncarcerationPeriod]",
                    "OrderedDict",
                    "bool"
                ]
            }
        },
        "test_task_success_label_export": {
            "name": "test_task_success_label_export",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "configured_project_with_label": [
                    "Callable",
                    "float"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_toggle_mal.py": {
        "test_enable_model_assisted_labeling": {
            "name": "test_enable_model_assisted_labeling",
            "location": 1,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": []
            }
        }
    },
    "labelbox-python-master/tests/integration/test_user_and_org.py": {
        "test_user": {
            "name": "test_user",
            "location": 1,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ]
            }
        },
        "test_organization": {
            "name": "test_organization",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": []
            }
        },
        "test_user_and_org_projects": {
            "name": "test_user_and_org_projects",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": [
                    "str"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_user_management.py": {
        "test_org_invite": {
            "name": "test_org_invite",
            "location": 5,
            "return": [
                "str",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "organization": [
                    "float"
                ],
                "environ": [
                    "Mapping",
                    "str",
                    "bool",
                    "Optional[Dict[str, Any]]"
                ],
                "queries": [
                    "dict"
                ]
            }
        },
        "test_project_invite": {
            "name": "test_project_invite",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str",
                    "dict"
                ],
                "organization": [
                    "str",
                    "Callable"
                ],
                "project_pack": [
                    "Callable",
                    "List[str]"
                ],
                "queries": [
                    "str",
                    "Union[str, List[str]]"
                ]
            }
        },
        "test_member_management": {
            "name": "test_member_management",
            "location": 78,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "organization": [
                    "Callable[[List, bool], None]"
                ],
                "project": [],
                "project_based_user": [
                    "Callable"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/test_webhook.py": {
        "test_webhook_create_update": {
            "name": "test_webhook_create_update",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "project": [
                    "str"
                ],
                "rand_gen": [
                    "List[Dict[str, Any]]",
                    "int"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/conftest.py": {
        "ontology": {
            "name": "ontology",
            "location": 14,
            "return": [
                "dict[typing.Text, list[dict[typing.Text, typing.Union[bool,typing.Text,list[dict[typing.Text, typing.Union[bool,typing.Text,list[dict[typing.Text, typing.Text]]]]]]]]]",
                "str",
                "List[str]",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "configured_project": {
            "name": "configured_project",
            "location": 107,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "ontology": [
                    "bool",
                    "List[str]",
                    "str",
                    "T"
                ],
                "rand_gen": [
                    "int",
                    "str"
                ],
                "image_url": [
                    "str",
                    "dict",
                    "bytes",
                    "bool"
                ]
            }
        },
        "prediction_id_mapping": {
            "name": "prediction_id_mapping",
            "location": 125,
            "return": [
                "dict[, dict[typing.Text, typing.Union[str,dict[typing.Text, ]]]]",
                "str",
                "set",
                "dict"
            ],
            "arguments": {
                "configured_project": [
                    "Dict[str, Any]"
                ]
            }
        },
        "polygon_inference": {
            "name": "polygon_inference",
            "location": 147,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "rectangle_inference": {
            "name": "rectangle_inference",
            "location": 169,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "line_inference": {
            "name": "line_inference",
            "location": 193,
            "return": [
                "str",
                "Sequence[str]",
                "Set[str]",
                "list"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "MutableMapping",
                    "Optional[dict]",
                    "dict",
                    "Optional[\"TrackingData\"]",
                    "str",
                    "bytes",
                    "Dict[str, Any]"
                ]
            }
        },
        "point_inference": {
            "name": "point_inference",
            "location": 208,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "entity_inference": {
            "name": "entity_inference",
            "location": 216,
            "return": [
                "bool",
                "float",
                "Optional[Any]",
                "Optional[Union[str, Any]]"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "Union['KspNativeControl', int]",
                    "Optional[Dict]"
                ]
            }
        },
        "segmentation_inference": {
            "name": "segmentation_inference",
            "location": 224,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "segmentation_inference_rle": {
            "name": "segmentation_inference_rle",
            "location": 236,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "segmentation_inference_png": {
            "name": "segmentation_inference_png",
            "location": 250,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "checklist_inference": {
            "name": "checklist_inference",
            "location": 263,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "text_inference": {
            "name": "text_inference",
            "location": 275,
            "return": [
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "video_checklist_inference": {
            "name": "video_checklist_inference",
            "location": 283,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "prediction_id_mapping": [
                    "str",
                    "int",
                    "dict"
                ]
            }
        },
        "model_run_predictions": {
            "name": "model_run_predictions",
            "location": 304,
            "return": [
                "list",
                "Callable",
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "polygon_inference": [
                    "bool",
                    "Optional[str]",
                    "List[str]",
                    "int"
                ],
                "rectangle_inference": [
                    "bool",
                    "Optional[str]",
                    "List[str]",
                    "int"
                ],
                "line_inference": [
                    "bool",
                    "Optional[str]",
                    "List[str]",
                    "int"
                ]
            }
        },
        "object_predictions": {
            "name": "object_predictions",
            "location": 312,
            "return": [
                "list",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "polygon_inference": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ],
                "rectangle_inference": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ],
                "line_inference": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ],
                "entity_inference": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ],
                "segmentation_inference": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ],
                "segmentation_inference_rle": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ],
                "segmentation_inference_png": [
                    "bool",
                    "Callable[..., None]",
                    "int",
                    "Callable",
                    "List['cirq.Circuit']"
                ]
            }
        },
        "classification_predictions": {
            "name": "classification_predictions",
            "location": 323,
            "return": [
                "str",
                "list"
            ],
            "arguments": {
                "checklist_inference": [
                    "str",
                    "int",
                    "Dict[str, Sequence[str]]"
                ],
                "text_inference": [
                    "str",
                    "int",
                    "Dict[str, Sequence[str]]"
                ]
            }
        },
        "predictions": {
            "name": "predictions",
            "location": 328,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "object_predictions": [
                    "int",
                    "Callable",
                    "str"
                ],
                "classification_predictions": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "model": {
            "name": "model",
            "location": 333,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "str",
                    "int"
                ],
                "rand_gen": [
                    "str",
                    "int"
                ],
                "configured_project": [
                    "str",
                    "float"
                ]
            }
        },
        "model_run": {
            "name": "model_run",
            "location": 346,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "rand_gen": [
                    "str",
                    "dict",
                    "Type"
                ],
                "model": []
            }
        },
        "model_run_with_model_run_data_rows": {
            "name": "model_run_with_model_run_data_rows",
            "location": 358,
            "return": [
                "",
                "typing.Generator"
            ],
            "arguments": {
                "client": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "configured_project": [
                    "bool",
                    "str",
                    "Callable[[], Any]"
                ],
                "model_run_predictions": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "model_run": [
                    "int",
                    "bool",
                    "str"
                ]
            }
        },
        "annotation_import_test_helpers": {
            "name": "annotation_import_test_helpers",
            "location": 391,
            "return": [
                "AnnotationImportTestHelpers",
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "AnnotationImportTestHelpers.assert_file_content": {
            "name": "assert_file_content",
            "location": 376,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "url": [
                    "str"
                ],
                "predictions": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "AnnotationImportTestHelpers.check_running_state": {
            "name": "check_running_state",
            "location": 381,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "req": [
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "str"
                ],
                "url": [
                    "None",
                    "str",
                    "Optional[str]"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/test_bulk_import_request.py": {
        "test_create_from_url": {
            "name": "test_create_from_url",
            "location": 15,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": []
            }
        },
        "test_validate_file": {
            "name": "test_validate_file",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "str",
                    "dict"
                ]
            }
        },
        "test_create_from_objects": {
            "name": "test_create_from_objects",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [],
                "predictions": [],
                "annotation_import_test_helpers": [
                    "List[str]",
                    "str"
                ]
            }
        },
        "test_create_from_local_file": {
            "name": "test_create_from_local_file",
            "location": 57,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmp_path": [
                    "str"
                ],
                "predictions": [],
                "configured_project": [
                    "str"
                ],
                "annotation_import_test_helpers": [
                    "str"
                ]
            }
        },
        "test_get": {
            "name": "test_get",
            "location": 77,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "configured_project": [
                    "dict"
                ]
            }
        },
        "test_validate_ndjson": {
            "name": "test_validate_ndjson",
            "location": 95,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmp_path": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "configured_project": []
            }
        },
        "test_validate_ndjson_uuid": {
            "name": "test_validate_ndjson_uuid",
            "location": 107,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmp_path": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "configured_project": [
                    "Optional[str]"
                ],
                "predictions": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_wait_till_done": {
            "name": "test_wait_till_done",
            "location": 130,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rectangle_inference": [],
                "configured_project": [
                    "str"
                ]
            }
        },
        "test_project_bulk_import_requests": {
            "name": "test_project_bulk_import_requests",
            "location": 153,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [],
                "predictions": []
            }
        },
        "test_delete": {
            "name": "test_delete",
            "location": 176,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [],
                "predictions": []
            }
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/test_label_import.py": {
        "test_create_from_url": {
            "name": "test_create_from_url",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "project": [],
                "annotation_import_test_helpers": [
                    "str"
                ]
            }
        },
        "test_create_from_objects": {
            "name": "test_create_from_objects",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "configured_project": [
                    "str"
                ],
                "object_predictions": [
                    "str"
                ],
                "annotation_import_test_helpers": [
                    "Callable"
                ]
            }
        },
        "test_get": {
            "name": "test_get",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "bool",
                    "int"
                ],
                "project": [],
                "annotation_import_test_helpers": [
                    "str"
                ]
            }
        },
        "test_wait_till_done": {
            "name": "test_wait_till_done",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "project": [],
                "predictions": []
            }
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/test_mea_prediction_import.py": {
        "test_create_from_url": {
            "name": "test_create_from_url",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model_run_with_model_run_data_rows": [
                    "str",
                    "dict"
                ],
                "annotation_import_test_helpers": [
                    "bool",
                    "Optional[str]",
                    "str",
                    "Dict[str, Any]",
                    "float"
                ]
            }
        },
        "test_create_from_objects": {
            "name": "test_create_from_objects",
            "location": 25,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model_run_with_model_run_data_rows": [
                    "str",
                    "dict",
                    "Mapping[str, Any]"
                ],
                "object_predictions": [
                    "str",
                    "dict",
                    "bool"
                ],
                "annotation_import_test_helpers": [
                    "str",
                    "Iterable[str]"
                ]
            }
        },
        "test_create_from_local_file": {
            "name": "test_create_from_local_file",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmp_path": [
                    "str"
                ],
                "model_run_with_model_run_data_rows": [
                    "str",
                    "Callable"
                ],
                "object_predictions": [
                    "dict",
                    "str",
                    "Dict[str, Any]",
                    "Dict[str, str]"
                ],
                "annotation_import_test_helpers": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_get": {
            "name": "test_get",
            "location": 59,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "model_run_with_model_run_data_rows": [
                    "str"
                ],
                "annotation_import_test_helpers": [
                    "Optional[str]",
                    "Dict[str, Any]",
                    "dict"
                ]
            }
        },
        "test_wait_till_done": {
            "name": "test_wait_till_done",
            "location": 76,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model_run_predictions": [
                    "str",
                    "Callable",
                    "Set[str]",
                    "Optional[str]"
                ],
                "model_run_with_model_run_data_rows": [
                    "str",
                    "dict"
                ]
            }
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/test_model.py": {
        "test_model": {
            "name": "test_model",
            "location": 4,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "str"
                ],
                "configured_project": [],
                "rand_gen": [
                    "bytes",
                    "Callable",
                    "str"
                ]
            }
        },
        "test_model_delete": {
            "name": "test_model_delete",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "model": []
            }
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/test_model_run.py": {
        "test_model_run": {
            "name": "test_model_run",
            "location": 6,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [],
                "configured_project_with_label": [
                    "str",
                    "Callable",
                    "bool"
                ],
                "rand_gen": [
                    "bytes"
                ]
            }
        },
        "test_model_run_delete": {
            "name": "test_model_run_delete",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "Callable",
                    "str"
                ],
                "model_run": [
                    "int",
                    "bool"
                ]
            }
        },
        "test_model_run_data_rows_delete": {
            "name": "test_model_run_data_rows_delete",
            "location": 47,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "client": [
                    "Callable"
                ],
                "model_run_with_model_run_data_rows": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_model_run_upsert_data_rows": {
            "name": "test_model_run_upsert_data_rows",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dataset": [
                    "bytes",
                    "str",
                    "dict",
                    "bool"
                ],
                "model_run": [
                    "bool",
                    "Sequence[str]",
                    "str",
                    "Dict[str, str]",
                    "List[str]",
                    "Callable",
                    "Iterable[str]"
                ]
            }
        },
        "test_model_run_upsert_data_rows_with_existing_labels": {
            "name": "test_model_run_upsert_data_rows_with_existing_labels",
            "location": 71,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model_run_with_model_run_data_rows": [
                    "Sequence[str]",
                    "str"
                ]
            }
        },
        "test_model_run_export_labels": {
            "name": "test_model_run_export_labels",
            "location": 84,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model_run_with_model_run_data_rows": [
                    "dict"
                ]
            }
        },
        "test_model_run_status": {
            "name": "test_model_run_status",
            "location": 91,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "model_run_with_model_run_data_rows": [
                    "str",
                    "Optional[dict]",
                    "Optional[str]",
                    "List[str]"
                ]
            }
        },
        "test_model_run_status.get_model_run_status": {
            "name": "get_model_run_status",
            "location": 93,
            "return": [
                "Dict[str, Union[int, bool]]",
                "bytearray",
                "Optional[Exception]"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/integration/annotation_import/test_ndjson_validation.py": {
        "test_classification_construction": {
            "name": "test_classification_construction",
            "location": 13,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "checklist_inference": [
                    "str"
                ],
                "text_inference": []
            }
        },
        "test_subclassification_construction": {
            "name": "test_subclassification_construction",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rectangle_inference": []
            }
        },
        "test_tool_construction": {
            "name": "test_tool_construction",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "inference": [
                    "str"
                ],
                "expected_type": [
                    "str"
                ]
            }
        },
        "test_incorrect_feature_schema": {
            "name": "test_incorrect_feature_schema",
            "location": 38,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rectangle_inference": [],
                "polygon_inference": [],
                "configured_project": []
            }
        },
        "no_tool": {
            "name": "no_tool",
            "location": 48,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "text_inference": [
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "configured_project": [
                    "bool",
                    "str",
                    "Sequence[Dict[str, str]]"
                ]
            }
        },
        "test_invalid_text": {
            "name": "test_invalid_text",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "text_inference": [
                    "str",
                    "Dict[str, str]"
                ],
                "configured_project": [
                    "str"
                ]
            }
        },
        "test_invalid_checklist_item": {
            "name": "test_invalid_checklist_item",
            "location": 77,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "checklist_inference": [],
                "configured_project": []
            }
        },
        "test_invalid_polygon": {
            "name": "test_invalid_polygon",
            "location": 102,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "polygon_inference": [],
                "configured_project": []
            }
        },
        "test_incorrect_entity": {
            "name": "test_incorrect_entity",
            "location": 110,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "entity_inference": [
                    "str",
                    "bool",
                    "Sequence[str]"
                ],
                "configured_project": [
                    "Callable[[List, bool], None]",
                    "str"
                ]
            }
        },
        "test_incorrect_mask": {
            "name": "test_incorrect_mask",
            "location": 126,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "segmentation_inference": [],
                "configured_project": [
                    "bool"
                ]
            }
        },
        "test_all_validate_json": {
            "name": "test_all_validate_json",
            "location": 145,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [],
                "predictions": []
            }
        },
        "test_incorrect_line": {
            "name": "test_incorrect_line",
            "location": 151,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "line_inference": [
                    "str",
                    "Dict[str, Any]",
                    "bytes"
                ],
                "configured_project": [
                    "str"
                ]
            }
        },
        "test_incorrect_rectangle": {
            "name": "test_incorrect_rectangle",
            "location": 158,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rectangle_inference": [],
                "configured_project": []
            }
        },
        "test_duplicate_tools": {
            "name": "test_duplicate_tools",
            "location": 164,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rectangle_inference": [],
                "configured_project": []
            }
        },
        "test_invalid_feature_schema": {
            "name": "test_invalid_feature_schema",
            "location": 172,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "Callable"
                ],
                "rectangle_inference": [
                    "Callable"
                ]
            }
        },
        "test_missing_feature_schema": {
            "name": "test_missing_feature_schema",
            "location": 180,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "configured_project": [
                    "Callable"
                ],
                "rectangle_inference": [
                    "Callable"
                ]
            }
        },
        "test_validate_ndjson": {
            "name": "test_validate_ndjson",
            "location": 188,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmp_path": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "configured_project": [
                    "Callable",
                    "str",
                    "bool"
                ]
            }
        },
        "test_validate_ndjson_uuid": {
            "name": "test_validate_ndjson_uuid",
            "location": 200,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "tmp_path": [
                    "str",
                    "bool",
                    "Optional[str]"
                ],
                "configured_project": [
                    "Optional[str]"
                ],
                "predictions": [
                    "str",
                    "Dict[str, Any]"
                ]
            }
        },
        "test_video_upload": {
            "name": "test_video_upload",
            "location": 221,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "video_checklist_inference": [],
                "configured_project": []
            }
        }
    },
    "labelbox-python-master/tests/unit/test_unit_case_change.py": {
        "test_camel": {
            "name": "test_camel",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_snake": {
            "name": "test_snake",
            "location": 16,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_title": {
            "name": "test_title",
            "location": 23,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/unit/test_unit_entity_meta.py": {
        "test_illegal_cache_cond1": {
            "name": "test_illegal_cache_cond1",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_illegal_cache_cond2": {
            "name": "test_illegal_cache_cond2",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/unit/test_unit_filter.py": {
        "test_comparison_creation": {
            "name": "test_comparison_creation",
            "location": 7,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_comparison_equality": {
            "name": "test_comparison_equality",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_rich_comparison": {
            "name": "test_rich_comparison",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_logical_expr_creation": {
            "name": "test_logical_expr_creation",
            "location": 40,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_logical_expr_ops": {
            "name": "test_logical_expr_ops",
            "location": 50,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/unit/test_unit_ontology.py": {
        "test_create_tool": {
            "name": "test_create_tool",
            "location": 141,
            "return": [
                "None"
            ],
            "arguments": {
                "tool_type": []
            }
        },
        "test_create_classification": {
            "name": "test_create_classification",
            "location": 147,
            "return": [
                "None"
            ],
            "arguments": {
                "class_type": [
                    "str",
                    "Type[Any]",
                    "Type",
                    "Callable"
                ]
            }
        },
        "test_create_option_with_value": {
            "name": "test_create_option_with_value",
            "location": 154,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "str",
                    "Type[Any]"
                ],
                "expected_value": [
                    "str",
                    "bool",
                    "T"
                ],
                "typing": [
                    "str",
                    "dict",
                    "bool"
                ]
            }
        },
        "test_create_option_with_value_and_label": {
            "name": "test_create_option_with_value_and_label",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "value": [
                    "str",
                    "Sequence[str]",
                    "Sequence[List[Any]]"
                ],
                "label": [
                    "dict",
                    "Optional[str]"
                ],
                "expected_value": [
                    "type",
                    "Callable",
                    "str",
                    "bool"
                ],
                "typing": [
                    "Callable",
                    "Union[str, int]",
                    "T",
                    "str",
                    "Type"
                ]
            }
        },
        "test_create_empty_ontology": {
            "name": "test_create_empty_ontology",
            "location": 171,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_add_ontology_tool": {
            "name": "test_add_ontology_tool",
            "location": 177,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_add_ontology_classification": {
            "name": "test_add_ontology_classification",
            "location": 193,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_tool_add_classification": {
            "name": "test_tool_add_classification",
            "location": 214,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_classification_add_option": {
            "name": "test_classification_add_option",
            "location": 225,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_option_add_option": {
            "name": "test_option_add_option",
            "location": 237,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_ontology_asdict": {
            "name": "test_ontology_asdict",
            "location": 248,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/unit/test_unit_query.py": {
        "format": {
            "name": "format",
            "location": 8,
            "return": [
                "str",
                "Type[Any]"
            ],
            "arguments": {}
        },
        "test_query_what": {
            "name": "test_query_what",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_query_subquery": {
            "name": "test_query_subquery",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_query_where": {
            "name": "test_query_where",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_query_param_declaration": {
            "name": "test_query_param_declaration",
            "location": 37,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_query_order_by": {
            "name": "test_query_order_by",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_logical_ops": {
            "name": "test_logical_ops",
            "location": 54,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "labelbox-python-master/tests/unit/test_unit_rand_gen.py": {
        "test_gen_str": {
            "name": "test_gen_str",
            "location": 1,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "rand_gen": [
                    "str",
                    "bytes"
                ]
            }
        }
    }
}
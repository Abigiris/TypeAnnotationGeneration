{
    "minichain-master/chain/block.py": {
        "Block.__hash__": {
            "name": "__hash__",
            "location": 15,
            "return": [
                "int",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.calculate_hash": {
            "name": "calculate_hash",
            "location": 19,
            "return": [
                "dict",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "index": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "typing.IO"
                ],
                "prev_hash": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "typing.IO"
                ],
                "timestamp": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "typing.IO"
                ],
                "data": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "typing.IO"
                ],
                "nonce": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "typing.IO"
                ],
                "target": [
                    "str",
                    "int",
                    "IO[bytes]",
                    "typing.IO"
                ]
            }
        },
        "Block.validate_difficulty": {
            "name": "validate_difficulty",
            "location": 26,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "hash": [
                    "str",
                    "tuple",
                    "int",
                    "bytes"
                ],
                "target": [
                    "str",
                    "tuple",
                    "int",
                    "bytes"
                ]
            }
        },
        "Block.deserialize": {
            "name": "deserialize",
            "location": 30,
            "return": [
                "str"
            ],
            "arguments": {
                "cls": [
                    "dict",
                    "int",
                    "dict[, ]",
                    "str",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ],
                "other": [
                    "dict",
                    "int",
                    "dict[, ]",
                    "str",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "Block.serialize": {
            "name": "serialize",
            "location": 33,
            "return": [
                "dict",
                "Dict[str, Any]",
                "Dict[str, Dict[str, str]]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.is_valid": {
            "name": "is_valid",
            "location": 44,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.is_valid_hash": {
            "name": "is_valid_hash",
            "location": 47,
            "return": [
                "bool",
                "Dict[str, Union[str, Set]]",
                "List['Product']",
                "Dict[str, Dict[str, Any]]",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.is_valid_difficulty": {
            "name": "is_valid_difficulty",
            "location": 50,
            "return": [
                "str",
                "dict",
                "Iterable[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Block.recalculate_hash": {
            "name": "recalculate_hash",
            "location": 53,
            "return": [
                "str",
                "Optional[Dict]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "minichain-master/chain/blockchain.py": {
        "BlockChain.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "blocks": [
                    "list[]",
                    "int",
                    "Optional[int]",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "BlockChain.__len__": {
            "name": "__len__",
            "location": 14,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.__repr__": {
            "name": "__repr__",
            "location": 17,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.__getitem__": {
            "name": "__getitem__",
            "location": 20,
            "return": [
                "set"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "int"
                ]
            }
        },
        "BlockChain.__eq__": {
            "name": "__eq__",
            "location": 26,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[int, \"BitVec\"]",
                    "int"
                ]
            }
        },
        "BlockChain.__hash__": {
            "name": "__hash__",
            "location": 34,
            "return": [
                "int",
                "Tuple[int, int]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.are_blocks_adjacent": {
            "name": "are_blocks_adjacent",
            "location": 38,
            "return": [
                "bool"
            ],
            "arguments": {
                "block": [
                    "Block",
                    "str"
                ],
                "prev_block": [
                    "None",
                    "Optional[mypy.nodes.Block]",
                    "block.Block",
                    "Block"
                ]
            }
        },
        "BlockChain.genesis": {
            "name": "genesis",
            "location": 46,
            "return": [
                "Block",
                "Dict[str, int]",
                "str",
                "int"
            ],
            "arguments": {}
        },
        "BlockChain.deserialize": {
            "name": "deserialize",
            "location": 60,
            "return": [
                "str",
                "Dict[str, Any]",
                "bytes"
            ],
            "arguments": {
                "cls": [
                    "typing.Callable[, ]",
                    "float",
                    "Callable",
                    "str",
                    "dict[, ]",
                    "dict",
                    "raiden.utils.Any",
                    "typing.Type",
                    "dict[str, typing.Any]",
                    "type",
                    "Dict[str, Any]"
                ],
                "other": [
                    "type",
                    "Callable",
                    "Sequence[Any]"
                ]
            }
        },
        "BlockChain.interval": {
            "name": "interval",
            "location": 65,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.latest_block": {
            "name": "latest_block",
            "location": 69,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.length": {
            "name": "length",
            "location": 73,
            "return": [
                "int",
                "Sequence['cirq.Qid']",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.serialize": {
            "name": "serialize",
            "location": 76,
            "return": [
                "str",
                "list",
                "dict",
                "int",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.replace": {
            "name": "replace",
            "location": 79,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "raiden.utils.Any"
                ]
            }
        },
        "BlockChain.retarget": {
            "name": "retarget",
            "location": 90,
            "return": [
                "str",
                "utils.Node",
                "int",
                "List[int]",
                "raiden.utils.Tuple[int, int]",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.validate_blocks": {
            "name": "validate_blocks",
            "location": 110,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "left": [
                    "int",
                    "str",
                    "set",
                    "set[]",
                    "Dict[int, Any]",
                    "dict[int, typing.Any]"
                ],
                "right": [
                    "int",
                    "set",
                    "str",
                    "Dict[int, Any]"
                ]
            }
        },
        "BlockChain.is_valid_chain": {
            "name": "is_valid_chain",
            "location": 122,
            "return": [
                "Dict[str, Any]",
                "str",
                "raiden.utils.BlockNumber",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BlockChain.generate_next": {
            "name": "generate_next",
            "location": 125,
            "return": [
                "Block",
                "Dict[str, int]",
                "str",
                "int"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "Dict[str, Any]",
                    "int",
                    "dict[str, typing.Any]",
                    "Optional[dict]",
                    "dict[, ]",
                    "Iterable",
                    "None"
                ]
            }
        },
        "BlockChain.is_next_block": {
            "name": "is_next_block",
            "location": 138,
            "return": [
                "List[str]",
                "raiden.utils.TokenAmount",
                "Dict[str, Any]",
                "Sequence[str]",
                "raiden.utils.BlockNumber"
            ],
            "arguments": {
                "self": [],
                "block": [
                    "str",
                    "mypy.nodes.Block",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ]
            }
        },
        "BlockChain.add_block": {
            "name": "add_block",
            "location": 141,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "block": [
                    "mypy.nodes.Block",
                    "dict",
                    "str"
                ]
            }
        },
        "BlockChain.mine": {
            "name": "mine",
            "location": 148,
            "return": [
                "bool",
                "Optional[str]",
                "int",
                "Callable[..., None]",
                "str"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "dict",
                    "bytes",
                    "dict[, ]",
                    "Union[str, bytes, None]",
                    "str",
                    "None"
                ]
            }
        }
    },
    "minichain-master/chain/mempool.py": {
        "get_mempool": {
            "name": "get_mempool",
            "location": 51,
            "return": [
                "Mempool",
                "str",
                "bool"
            ],
            "arguments": {}
        },
        "Mempool.__init__": {
            "name": "__init__",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transactions": [
                    "set[]",
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "Mempool.__repr__": {
            "name": "__repr__",
            "location": 12,
            "return": [
                "typing.Text",
                "str",
                "Optional[str]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Mempool.__eq__": {
            "name": "__eq__",
            "location": 15,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[str, \"Date\"]",
                    "str",
                    "Union[int, float]",
                    "int",
                    "float"
                ]
            }
        },
        "Mempool.trim_txs": {
            "name": "trim_txs",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "block_txs": [
                    "int",
                    "str"
                ]
            }
        },
        "Mempool.is_double_spent": {
            "name": "is_double_spent",
            "location": 23,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "transaction": [
                    "int",
                    "str",
                    "typing.Callable[, ]",
                    "T",
                    "Callable"
                ]
            }
        },
        "Mempool.add": {
            "name": "add",
            "location": 29,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "transaction": [
                    "dict[, ]",
                    "str",
                    "dict",
                    "None",
                    "Optional[str]",
                    "list[str]",
                    "List[str]",
                    "dict[str, dict[str, typing.Any]]",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, Any]"
                ]
            }
        },
        "Mempool.remove": {
            "name": "remove",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transaction": [
                    "int",
                    "List[int]",
                    "list[int]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "Mempool.serialize": {
            "name": "serialize",
            "location": 40,
            "return": [
                "bytes",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Mempool.deserialize": {
            "name": "deserialize",
            "location": 44,
            "return": [
                "Mempool",
                "str",
                "Callable",
                "dict"
            ],
            "arguments": {
                "other": [
                    "list[int]",
                    "str",
                    "bool",
                    "Union[Set[int], List[int], Dict[int, Any]]"
                ]
            }
        }
    },
    "minichain-master/chain/p2p.py": {
        "Message.get_latest_block": {
            "name": "get_latest_block",
            "location": 29,
            "return": [
                "str",
                "Optional[Dict]",
                "List[str]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "dict",
                    "dict[, ]",
                    "List[str]",
                    "list[str]",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Union[Callable[[Dict], Hashable], str]",
                    "typing.Callable[dict[, ], typing.Hashable]"
                ]
            }
        },
        "Message.send_latest_block": {
            "name": "send_latest_block",
            "location": 33,
            "return": [
                "Set[str]",
                "Dict[str, Any]",
                "Dict[str, str]",
                "Dict[str, List[Callable]]"
            ],
            "arguments": {
                "cls": [
                    "dict[, ]",
                    "mypy.nodes.Block",
                    "Block",
                    "dict"
                ],
                "block": [
                    "mypy.nodes.Block",
                    "Block",
                    "dict"
                ]
            }
        },
        "Message.get_blocks": {
            "name": "get_blocks",
            "location": 37,
            "return": [
                "str",
                "dict",
                "Mapping[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "int"
                ],
                "start_index": [
                    "int"
                ],
                "end_index": [
                    "int"
                ]
            }
        },
        "Message.send_blocks": {
            "name": "send_blocks",
            "location": 43,
            "return": [
                "Optional[str]",
                "bool"
            ],
            "arguments": {
                "cls": [
                    "int",
                    "Sequence[int]",
                    "typing.Sequence[int]"
                ],
                "start_index": [
                    "int",
                    "Sequence[int]",
                    "typing.Sequence[int]"
                ],
                "end_index": [
                    "int",
                    "Sequence[int]",
                    "typing.Sequence[int]"
                ],
                "blocks": [
                    "int",
                    "Sequence[int]"
                ]
            }
        },
        "Message.get_blockchain": {
            "name": "get_blockchain",
            "location": 52,
            "return": [
                "str",
                "Dict[str, Any]",
                "dict",
                "Dict[str, str]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, str]",
                    "conflow.node.AbstractNode",
                    "str",
                    "dict[, ]",
                    "Dict[str, str]",
                    "dict",
                    "list[dict[str, typing.Any]]",
                    "list[str]",
                    "List[Dict[str, Any]]",
                    "List[str]"
                ]
            }
        },
        "Message.send_blockchain": {
            "name": "send_blockchain",
            "location": 56,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Optional[int]",
                    "int",
                    "type",
                    "None",
                    "bool",
                    "typing.Type"
                ],
                "blockchain": [
                    "str",
                    "Optional[int]",
                    "type",
                    "bool"
                ]
            }
        },
        "Message.get_transactions": {
            "name": "get_transactions",
            "location": 62,
            "return": [
                "Dict[str, str]",
                "str",
                "Iterable[Tuple[int, int]]",
                "List[str]",
                "Dict[str, Any]",
                "cmk.utils.type_defs.CheckPluginName.Str"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "Message.send_transactions": {
            "name": "send_transactions",
            "location": 66,
            "return": [
                "Set[str]",
                "Dict[str, str]",
                "Dict[str, List[Callable]]",
                "str",
                "dict"
            ],
            "arguments": {
                "cls": [
                    "None",
                    "Optional[mypy.nodes.Node]",
                    "tuple[object]",
                    "Tuple[object]",
                    "typing.Callable[str, str]",
                    "raiden.utils.BlockIdentifier",
                    "Callable[[str], str]"
                ],
                "transactions": [
                    "tuple[object]",
                    "Optional[mypy.nodes.Node]",
                    "Tuple[object]",
                    "raiden.utils.BlockIdentifier",
                    "Callable[[str], str]"
                ]
            }
        },
        "UDPProtocal.get_refresh_ids": {
            "name": "get_refresh_ids",
            "location": 74,
            "return": [
                "list[typing.Union[int,list[tuple[typing.Union[typing.Any,typing.Any,typing.Any,float]]],dict[str, list[]]]]",
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "TCPProtocol.__init__": {
            "name": "__init__",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "server": [
                    "bool",
                    "str",
                    "int",
                    "tuple[typing.Union[float,float,float,float]]",
                    "Tuple[float, float, float, float]"
                ]
            }
        },
        "TCPProtocol.reply": {
            "name": "reply",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "str",
                    "Union[str, bytes]"
                ]
            }
        },
        "TCPProtocol.handle_request_latest_block": {
            "name": "handle_request_latest_block",
            "location": 97,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TCPProtocol.handle_receive_latest_block": {
            "name": "handle_receive_latest_block",
            "location": 101,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "block": [
                    "dict[, ]",
                    "str",
                    "mypy.nodes.Block",
                    "dict"
                ]
            }
        },
        "TCPProtocol.handle_request_blockchain": {
            "name": "handle_request_blockchain",
            "location": 117,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TCPProtocol.handle_receive_blockchain": {
            "name": "handle_receive_blockchain",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "blockchain": [
                    "bool",
                    "dict[, ]",
                    "int",
                    "dict",
                    "random.Random"
                ]
            }
        },
        "TCPProtocol.handle_message": {
            "name": "handle_message",
            "location": 128,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "msg": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "List[dict]",
                    "list[dict[, ]]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "TCPProtocol.connection_made": {
            "name": "connection_made",
            "location": 144,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "transport": [
                    "str",
                    "int"
                ]
            }
        },
        "TCPProtocol.data_received": {
            "name": "data_received",
            "location": 149,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[]",
                    "str",
                    "memoryview",
                    "list",
                    "raiden.utils.Address",
                    "Union[Iterable, str]",
                    "Union[int, str]",
                    "bool"
                ]
            }
        },
        "TCPProtocol.connection_lost": {
            "name": "connection_lost",
            "location": 153,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "exc": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TCPClientProtocol.__init__": {
            "name": "__init__",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "server": [
                    "bool",
                    "AsyncContextManager[None]",
                    "int"
                ],
                "data": [
                    "str",
                    "dict[str, typing.Any]",
                    "cmk.utils.type_defs.AgentRawData",
                    "dict[, ]",
                    "bytes",
                    "Dict[str, Any]",
                    "typing.Mapping",
                    "dict",
                    "list[]",
                    "Mapping",
                    "raiden.utils.List[raiden.utils.Tuple[str, int]]",
                    "list"
                ]
            }
        },
        "TCPClientProtocol.connection_made": {
            "name": "connection_made",
            "location": 162,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "transport": [
                    "str",
                    "int"
                ]
            }
        },
        "TCPClientProtocol.data_received": {
            "name": "data_received",
            "location": 168,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "data": [
                    "bytes",
                    "list[]",
                    "str",
                    "memoryview",
                    "list",
                    "raiden.utils.Address",
                    "Union[Iterable, str]",
                    "Union[int, str]",
                    "bool"
                ]
            }
        },
        "TCPClientProtocol.connection_lost": {
            "name": "connection_lost",
            "location": 172,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "exc": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "P2PServer.__init__": {
            "name": "__init__",
            "location": 179,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "ksize": [
                    "int",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.ChannelID",
                    "raiden.utils.ChainID",
                    "raiden.utils.PaymentID",
                    "raiden.utils.PaymentHashInvoice",
                    "raiden.utils.Locksroot",
                    "raiden.utils.Nonce",
                    "raiden.utils.TokenNetworkAddress"
                ],
                "alpha": [
                    "int",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.ChannelID",
                    "raiden.utils.ChainID",
                    "raiden.utils.PaymentID",
                    "raiden.utils.PaymentHashInvoice",
                    "raiden.utils.Locksroot",
                    "raiden.utils.Nonce",
                    "raiden.utils.TokenNetworkAddress"
                ],
                "node_id": [
                    "None",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.ChannelID",
                    "raiden.utils.ChainID",
                    "raiden.utils.PaymentID",
                    "raiden.utils.PaymentHashInvoice",
                    "raiden.utils.Locksroot",
                    "raiden.utils.Nonce",
                    "raiden.utils.TokenNetworkAddress"
                ],
                "storage": [
                    "None",
                    "raiden.utils.TokenAmount",
                    "raiden.utils.ChannelID",
                    "raiden.utils.ChainID",
                    "raiden.utils.PaymentID",
                    "raiden.utils.PaymentHashInvoice",
                    "raiden.utils.Locksroot",
                    "raiden.utils.Nonce",
                    "raiden.utils.TokenNetworkAddress"
                ],
                "mining": [
                    "bool",
                    "int",
                    "str",
                    "Tuple[str, str, str]"
                ]
            }
        },
        "P2PServer.listen": {
            "name": "listen",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "port": [
                    "int"
                ],
                "interface": [
                    "int",
                    "typing.Text"
                ]
            }
        },
        "P2PServer.stop": {
            "name": "stop",
            "location": 201,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "P2PServer.refresh_table": {
            "name": "refresh_table",
            "location": 214,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "P2PServer.get_mempool": {
            "name": "get_mempool",
            "location": 220,
            "return": [
                "typing.Text",
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "P2PServer.read_blockchain": {
            "name": "read_blockchain",
            "location": 223,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "P2PServer.sync_blockchain": {
            "name": "sync_blockchain",
            "location": 253,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "P2PServer.broadcast_message": {
            "name": "broadcast_message",
            "location": 259,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "Iterable[T]",
                    "int",
                    "typing.Iterable[T]"
                ]
            }
        },
        "P2PServer.get_peers": {
            "name": "get_peers",
            "location": 262,
            "return": [
                "int",
                "Optional[List[str]]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "minichain-master/chain/transaction.py": {
        "TxIn.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tx_index": [
                    "bool",
                    "list[str]",
                    "typing.Callable[, ]",
                    "List[str]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "int",
                    "Callable"
                ],
                "tx_hash": [
                    "bool",
                    "list[str]",
                    "typing.Callable[, ]",
                    "List[str]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "int",
                    "Callable"
                ],
                "amount": [
                    "bool",
                    "list[str]",
                    "typing.Callable[, ]",
                    "List[str]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "int",
                    "Callable"
                ],
                "pubkey": [
                    "bool",
                    "list[str]",
                    "typing.Callable[, ]",
                    "List[str]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "int",
                    "Callable"
                ],
                "signature": [
                    "typing.Text",
                    "bool",
                    "List[str]",
                    "Iterable[str]",
                    "Iterable[Union[int, str]]",
                    "int",
                    "Callable"
                ]
            }
        },
        "TxIn.__eq__": {
            "name": "__eq__",
            "location": 26,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Union[int, \"BitVec\"]",
                    "int"
                ]
            }
        },
        "TxIn.__repr__": {
            "name": "__repr__",
            "location": 31,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.__hash__": {
            "name": "__hash__",
            "location": 40,
            "return": [
                "int",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.signature": {
            "name": "signature",
            "location": 44,
            "return": [
                "int",
                "Set[str]",
                "str",
                "set"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.hash": {
            "name": "hash",
            "location": 48,
            "return": [
                "int",
                "Tuple[int, int]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.valid": {
            "name": "valid",
            "location": 52,
            "return": [
                "bool",
                "Optional[int]",
                "int",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.serialize": {
            "name": "serialize",
            "location": 55,
            "return": [
                "str",
                "Dict[str, Any]",
                "int",
                "Dict[str, Dict[str, str]]",
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.calculate_hash": {
            "name": "calculate_hash",
            "location": 64,
            "return": [
                "cmk.utils.type_defs.EventRule",
                "dict",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxIn.sign": {
            "name": "sign",
            "location": 68,
            "return": [
                "int",
                "decimal.Decimal",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "int",
                    "str",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "TxIn.verify": {
            "name": "verify",
            "location": 72,
            "return": [
                "bool",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "quiet": [
                    "bool",
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict"
                ]
            }
        },
        "TxIn.deserialize": {
            "name": "deserialize",
            "location": 86,
            "return": [
                "bool",
                "TxIn"
            ],
            "arguments": {
                "other": [
                    "Iterable[T]",
                    "raiden.utils.Any"
                ]
            }
        },
        "TxOut.__init__": {
            "name": "__init__",
            "location": 92,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "amount": [
                    "int",
                    "bytes",
                    "decimal.Decimal"
                ],
                "address": [
                    "int",
                    "bytes",
                    "decimal.Decimal"
                ]
            }
        },
        "TxOut.__eq__": {
            "name": "__eq__",
            "location": 96,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "int",
                    "str",
                    "raiden.utils.Any",
                    "bool"
                ]
            }
        },
        "TxOut.__repr__": {
            "name": "__repr__",
            "location": 101,
            "return": [
                "typing.Text",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxOut.__hash__": {
            "name": "__hash__",
            "location": 104,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxOut.amount": {
            "name": "amount",
            "location": 108,
            "return": [
                "Sequence[int]",
                "int",
                "bytes",
                "dict",
                "List[List[int]]",
                "Union[int, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxOut.address": {
            "name": "address",
            "location": 112,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxOut.serialize": {
            "name": "serialize",
            "location": 115,
            "return": [
                "bool",
                "Dict[str, bool]",
                "Dict[str, Set[str]]",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TxOut.deserialize": {
            "name": "deserialize",
            "location": 119,
            "return": [
                "TxOut",
                "str",
                "bool",
                "bytes",
                "int"
            ],
            "arguments": {
                "other": [
                    "Iterable[T]",
                    "raiden.utils.Any"
                ]
            }
        },
        "Transaction.__init__": {
            "name": "__init__",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "type": [
                    "str",
                    "bool",
                    "typing.TextIO",
                    "TextIO",
                    "dict[int, bool]",
                    "Dict[int, bool]",
                    "int"
                ],
                "inputs": [
                    "list[]",
                    "str",
                    "bool",
                    "TextIO",
                    "Dict[int, bool]",
                    "int"
                ],
                "outputs": [
                    "list[]",
                    "str",
                    "bool",
                    "TextIO",
                    "Dict[int, bool]",
                    "int"
                ]
            }
        },
        "Transaction.__eq__": {
            "name": "__eq__",
            "location": 143,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "tuple[typing.Union[float,float]]",
                    "float",
                    "raiden.utils.Any",
                    "Tuple[float, float]"
                ]
            }
        },
        "Transaction.__repr__": {
            "name": "__repr__",
            "location": 148,
            "return": [
                "str",
                "typing.Text"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.__hash__": {
            "name": "__hash__",
            "location": 153,
            "return": [
                "int",
                "dict",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.reward": {
            "name": "reward",
            "location": 157,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.type": {
            "name": "type",
            "location": 161,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Transaction.inputs": {
            "name": "inputs",
            "location": 165,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.outputs": {
            "name": "outputs",
            "location": 169,
            "return": [
                "int",
                "bytes",
                "IO[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.hash": {
            "name": "hash",
            "location": 173,
            "return": [
                "int",
                "Tuple[int, int]",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.total_input": {
            "name": "total_input",
            "location": 177,
            "return": [
                "bool",
                "int",
                "List[str]",
                "Optional[dict]",
                "Tuple[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.total_output": {
            "name": "total_output",
            "location": 181,
            "return": [
                "bool",
                "int",
                "Tuple[int, int]",
                "Iterable[dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.has_enough_balance": {
            "name": "has_enough_balance",
            "location": 185,
            "return": [
                "bool",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.fee": {
            "name": "fee",
            "location": 189,
            "return": [
                "int",
                "List[int]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.valid": {
            "name": "valid",
            "location": 194,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.has_same_inputs": {
            "name": "has_same_inputs",
            "location": 200,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Optional[\"Cell\"]",
                    "None"
                ]
            }
        },
        "Transaction.serialize": {
            "name": "serialize",
            "location": 207,
            "return": [
                "bool",
                "Optional[Any]",
                "Optional[Dict[str, str]]",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.calculate_hash": {
            "name": "calculate_hash",
            "location": 214,
            "return": [
                "cmk.utils.type_defs.EventRule",
                "dict",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Transaction.deserialize": {
            "name": "deserialize",
            "location": 219,
            "return": [
                "Transaction",
                "str",
                "int",
                "Tuple[str, str]"
            ],
            "arguments": {
                "other": [
                    "raiden.utils.Any"
                ]
            }
        }
    },
    "minichain-master/chain/wallet.py": {
        "Wallet.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "password": [
                    "str",
                    "int",
                    "None"
                ]
            }
        },
        "Wallet.get_public_key": {
            "name": "get_public_key",
            "location": 9,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Wallet.get_private_key": {
            "name": "get_private_key",
            "location": 12,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "password": [
                    "int",
                    "str",
                    "None"
                ]
            }
        }
    },
    "minichain-master/chain/__init__.py": {},
    "minichain-master/chain/__main__.py": {},
    "minichain-master/chain/utils/elliptic.py": {
        "remove_0x": {
            "name": "remove_0x",
            "location": 10,
            "return": [
                "str"
            ],
            "arguments": {
                "s": [
                    "str"
                ]
            }
        },
        "decode_hex": {
            "name": "decode_hex",
            "location": 16,
            "return": [
                "bytes"
            ],
            "arguments": {
                "s": [
                    "str"
                ]
            }
        },
        "generate_keypair": {
            "name": "generate_keypair",
            "location": 20,
            "return": [
                "Tuple[(str, str)]"
            ],
            "arguments": {}
        },
        "sign": {
            "name": "sign",
            "location": 25,
            "return": [
                "str"
            ],
            "arguments": {
                "priv_key": [
                    "str"
                ],
                "msg": [
                    "str"
                ]
            }
        },
        "verify": {
            "name": "verify",
            "location": 30,
            "return": [
                "bool"
            ],
            "arguments": {
                "pub_key": [
                    "str"
                ],
                "sig": [
                    "str"
                ],
                "msg": [
                    "str"
                ]
            }
        }
    },
    "minichain-master/chain/utils/log.py": {
        "_stderr_supports_color": {
            "name": "_stderr_supports_color",
            "location": 9,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "LogFormatter.__init__": {
            "name": "__init__",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fmt": [
                    "str",
                    "bool",
                    "Sequence"
                ],
                "datefmt": [
                    "str",
                    "dict"
                ],
                "style": [
                    "typing.Text",
                    "List[Dict[str, Any]]",
                    "bool",
                    "str",
                    "Callable[[List], List[str]]"
                ],
                "color": [
                    "bool",
                    "str",
                    "Sequence"
                ],
                "colors": [
                    "List[str]",
                    "dict"
                ]
            }
        },
        "LogFormatter.format": {
            "name": "format",
            "location": 69,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "record": [
                    "str",
                    "logging.LogRecord",
                    "dict"
                ]
            }
        }
    },
    "minichain-master/chain/utils/__init__.py": {},
    "minichain-master/tests/test_blockchain.py": {
        "TestBlockChain.test_block": {
            "name": "test_block",
            "location": 9,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBlockChain.test_blockchain": {
            "name": "test_blockchain",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "minichain-master/tests/test_tx.py": {
        "TestTx.test_txin": {
            "name": "test_txin",
            "location": 12,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTx.test_txout": {
            "name": "test_txout",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTx.test_transaction": {
            "name": "test_transaction",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "minichain-master/tests/test_utils.py": {
        "TestUtils.test_elliptic": {
            "name": "test_elliptic",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestUtils.test_log": {
            "name": "test_log",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "minichain-master/tests/__init__.py": {
        "TestCase.assertSerializable": {
            "name": "assertSerializable",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cls": [
                    "dict",
                    "bytes",
                    "Dict[str, Any]"
                ],
                "obj": [
                    "int",
                    "List[str]",
                    "list",
                    "dict",
                    "str"
                ],
                "env": [
                    "str",
                    "List[str]",
                    "float"
                ]
            }
        }
    }
}
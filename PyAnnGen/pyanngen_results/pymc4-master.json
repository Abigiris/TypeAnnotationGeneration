{
    "pymc4-master/nbconfig.py": {},
    "pymc4-master/setup.py": {
        "get_requirements": {
            "name": "get_requirements",
            "location": 34,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        },
        "get_long_description": {
            "name": "get_long_description",
            "location": 39,
            "return": [
                "str",
                "list"
            ],
            "arguments": {}
        },
        "get_version": {
            "name": "get_version",
            "location": 44,
            "return": [
                "str"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/notebooks/utils.py": {
        "plot_samples": {
            "name": "plot_samples",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "x": [
                    "bool",
                    "numpy.ndarray"
                ],
                "batched_samples": [
                    "str",
                    "float",
                    "Tuple"
                ],
                "labels": [
                    "List[dict[str,Any]]",
                    "List[Dict[str,Any]]",
                    "str",
                    "List[Union[str,int]]",
                    "Union[str,Iterable[str]]",
                    "Iterable",
                    "Optional[List[Any]]",
                    "Iterable[Callable]"
                ],
                "names": [
                    "str",
                    "List",
                    "List[str]",
                    "Optional[bool]",
                    "Tuple[Union[str,...]]",
                    "Union[str,List[str],Tuple[str,...]]",
                    "Optional[Callable[,Any]]",
                    "Optional[Any]",
                    "Optional[Dict]",
                    "Optional[str]"
                ],
                "ylim": [
                    "None",
                    "Optional[str]",
                    "str",
                    "bool",
                    "Optional[bool]",
                    "Optional[Dict[str,int]]",
                    "Dict[str,int]"
                ]
            }
        },
        "plot_cov_matrix": {
            "name": "plot_cov_matrix",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "k": [
                    "str",
                    "Type[T]",
                    "Type",
                    "Optional[str]",
                    "None"
                ],
                "X": [
                    "str",
                    "Type[T]",
                    "Type",
                    "Optional[str]",
                    "None"
                ],
                "labels": [
                    "str",
                    "List[str]",
                    "int"
                ],
                "names": [
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "Optional[List[str]]"
                ],
                "vlim": [
                    "Optional[str]",
                    "None",
                    "bool",
                    "str",
                    "Optional[bool]",
                    "Optional[IO[bytes]]",
                    "IO",
                    "Optional[bytes]",
                    "bytes"
                ],
                "cmap": [
                    "Text",
                    "bool",
                    "str",
                    "Callable"
                ],
                "interpolation": [
                    "Text",
                    "bool",
                    "str",
                    "Callable"
                ]
            }
        }
    },
    "pymc4-master/notebooks/__init__.py": {},
    "pymc4-master/pymc4/coroutine_model.py": {
        "model": {
            "name": "model",
            "location": 15,
            "return": [
                "ModelTemplate",
                "str",
                "Type[Any]"
            ],
            "arguments": {
                "genfn": [
                    "bool",
                    "str",
                    "Optional[Type]",
                    "Type",
                    "int",
                    "None"
                ]
            }
        },
        "get_name": {
            "name": "get_name",
            "location": 35,
            "return": [
                "str",
                "Type",
                "Set[str]",
                "Tuple[str]",
                "List[str]",
                "_no_name_provided"
            ],
            "arguments": {
                "default": [
                    "str"
                ],
                "base_fn": [
                    "str",
                    "List[str]"
                ],
                "name": [
                    "str",
                    "Type",
                    "cmk.utils.type_defs.SectionName",
                    "mypy.types.Type"
                ]
            }
        },
        "unpack": {
            "name": "unpack",
            "location": 175,
            "return": [
                "Generator[(_T0, Any, Any)]"
            ],
            "arguments": {
                "arg": [
                    "Dict",
                    "Type"
                ]
            }
        },
        "ModelTemplate.__init__": {
            "name": "__init__",
            "location": 80,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "template": [
                    "Mapping",
                    "Optional[Mapping]",
                    "bool",
                    "str",
                    "None",
                    "Optional[str]",
                    "Mapping[str,Any]"
                ]
            }
        },
        "ModelTemplate.__call__": {
            "name": "__call__",
            "location": 86,
            "return": [
                "Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "Model.validate_name": {
            "name": "validate_name",
            "location": 196,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Optional[str]",
                    "None",
                    "Optional[Iterable[str]]",
                    "Iterable[str]"
                ]
            }
        },
        "Model.__init__": {
            "name": "__init__",
            "location": 205,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "genfn": [
                    "str",
                    "Optional[Mapping]",
                    "Mapping",
                    "Optional[int]",
                    "None",
                    "Type[T]",
                    "int",
                    "bool",
                    "Type"
                ]
            }
        },
        "Model.control_flow": {
            "name": "control_flow",
            "location": 215,
            "return": [
                "Generator[(nothing, Any, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "model.wrapped": {
            "name": "wrapped",
            "location": 24,
            "return": [
                "str",
                "dict",
                "Iterable",
                "T",
                "starfish.types.Axes"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/pymc4/forward_sampling.py": {
        "sample_prior_predictive": {
            "name": "sample_prior_predictive",
            "location": 26,
            "return": [
                "Dict[str, Any]",
                "bool",
                "List[str]",
                "hackathon.utils.utils.DataMessage"
            ],
            "arguments": {
                "model": [
                    "bool",
                    "Tuple[str]",
                    "Optional[str]",
                    "str",
                    "Optional[int]",
                    "None"
                ],
                "sample_shape": [
                    "int",
                    "bool"
                ],
                "sample_from_observed": [
                    "bool",
                    "Tuple[str]",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "var_names": [
                    "str",
                    "None",
                    "bool",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "state": [
                    "bool",
                    "None",
                    "Tuple[str]",
                    "Optional[str]",
                    "Optional[int]",
                    "str"
                ],
                "use_auto_batching": [
                    "bool",
                    "Tuple[str]",
                    "Optional[str]",
                    "Optional[int]"
                ]
            }
        },
        "sample_posterior_predictive": {
            "name": "sample_posterior_predictive",
            "location": 237,
            "return": [
                "Any"
            ],
            "arguments": {
                "model": [
                    "int",
                    "str",
                    "Optional[Type[Warning]]",
                    "Type",
                    "bool",
                    "None"
                ],
                "trace": [
                    "bool",
                    "Optional[float]",
                    "float",
                    "int",
                    "None"
                ],
                "var_names": [
                    "str",
                    "bool",
                    "cmk.utils.type_defs.LabelSources",
                    "cmk.utils.type_defs.Labels"
                ],
                "observed": [
                    "int",
                    "None",
                    "str",
                    "Optional[Type[Warning]]",
                    "bool",
                    "Type"
                ],
                "use_auto_batching": [
                    "bool",
                    "int",
                    "str",
                    "Optional[Type[Warning]]"
                ],
                "inplace": [
                    "bool",
                    "Optional[float]",
                    "int"
                ]
            }
        },
        "sample_prior_predictive.single_draw": {
            "name": "single_draw",
            "location": 212,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "index": []
            }
        },
        "sample_posterior_predictive.single_draw": {
            "name": "single_draw",
            "location": 401,
            "return": [
                "Tuple",
                "bool",
                "str",
                "Optional[bool]",
                "Optional[str]",
                "List[str]",
                "Optional[float]"
            ],
            "arguments": {
                "elems": [
                    "dict",
                    "str",
                    "Dict[str, numpy.ndarray]",
                    "int"
                ]
            }
        }
    },
    "pymc4-master/pymc4/scopes.py": {
        "name_scope": {
            "name": "name_scope",
            "location": 225,
            "return": [
                "Scope"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Union[str,None]",
                    "None"
                ]
            }
        },
        "Scope.__init__": {
            "name": "__init__",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Scope.__enter__": {
            "name": "__enter__",
            "location": 32,
            "return": [
                "Scope"
            ],
            "arguments": {
                "self": [
                    "_TScope@@Scope@@"
                ]
            }
        },
        "Scope.__exit__": {
            "name": "__exit__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "typ": [
                    "Optional[Type[BaseException]]"
                ],
                "value": [
                    "Optional[BaseException]"
                ],
                "traceback": [
                    "Optional[BaseException]",
                    "BaseException",
                    "Iterable[float]",
                    "Callable[[str,object],None]",
                    "bool",
                    "None",
                    "Callable[str,object,None]"
                ]
            }
        },
        "Scope.__getattr__": {
            "name": "__getattr__",
            "location": 41,
            "return": [
                "int",
                "Dict[str, Any]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "str",
                    "Dict",
                    "Dict[str,Any]",
                    "Type"
                ]
            }
        },
        "Scope.get_contexts": {
            "name": "get_contexts",
            "location": 46,
            "return": [
                "List",
                "str",
                "int"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Type",
                    "Exception",
                    "Type[object]",
                    "T"
                ]
            }
        },
        "Scope.chain": {
            "name": "chain",
            "location": 64,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "cls": [
                    "Optional[List[Any]]",
                    "Optional[List]",
                    "float"
                ],
                "attr": [
                    "bytes",
                    "Callable"
                ]
            }
        },
        "Scope.variable_name": {
            "name": "variable_name",
            "location": 144,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Dict[str, str]",
                    "List[str]",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "Dict[str,str]",
                    "List[str]",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "Scope.transformed_variable_name": {
            "name": "transformed_variable_name",
            "location": 181,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "cls": [
                    "str"
                ],
                "transform_name": [
                    "str"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "Scope.__repr__": {
            "name": "__repr__",
            "location": 214,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/pymc4/utils.py": {
        "biwrap": {
            "name": "biwrap",
            "location": 10,
            "return": [
                "Callable"
            ],
            "arguments": {
                "wrapper": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "get_data": {
            "name": "get_data",
            "location": 215,
            "return": [
                "io.BytesIO"
            ],
            "arguments": {
                "filename": [
                    "str",
                    "bytes",
                    "Dict",
                    "List[dict]"
                ]
            }
        },
        "biwrap.enhanced": {
            "name": "enhanced",
            "location": 21,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "NameParts.is_valid_untransformed_name": {
            "name": "is_valid_untransformed_name",
            "location": 70,
            "return": [
                "bool"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Pattern[str]",
                    "Pattern"
                ],
                "name": [
                    "str",
                    "Pattern[str]",
                    "Pattern"
                ]
            }
        },
        "NameParts.is_valid_name": {
            "name": "is_valid_name",
            "location": 93,
            "return": [
                "bool"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Pattern[str]",
                    "Pattern"
                ],
                "name": [
                    "str",
                    "Pattern[str]",
                    "Pattern"
                ]
            }
        },
        "NameParts.__init__": {
            "name": "__init__",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str",
                    "List[str]",
                    "Dict[str,str]",
                    "Optional[List[str]]",
                    "Iterable[str]"
                ],
                "transform_name": [
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "bool",
                    "None"
                ],
                "untransformed_name": [
                    "str",
                    "Optional[str]",
                    "List[str]",
                    "bool",
                    "None"
                ]
            }
        },
        "NameParts.from_name": {
            "name": "from_name",
            "location": 136,
            "return": [
                "NameParts"
            ],
            "arguments": {
                "cls": [
                    "Type[_TNameParts]"
                ],
                "name": [
                    "str"
                ]
            }
        },
        "NameParts.original_name": {
            "name": "original_name",
            "location": 164,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "NameParts.full_original_name": {
            "name": "full_original_name",
            "location": 179,
            "return": [
                "str",
                "List[Tuple[int]]",
                "Tuple[List[int],int]",
                "List[T]",
                "List[int]",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NameParts.full_untransformed_name": {
            "name": "full_untransformed_name",
            "location": 191,
            "return": [
                "str",
                "List[Tuple[int]]",
                "Tuple[List[int],int]",
                "List[T]",
                "List[int]",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "NameParts.is_transformed": {
            "name": "is_transformed",
            "location": 202,
            "return": [
                "bool",
                "Dict[int, int]",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "NameParts.__repr__": {
            "name": "__repr__",
            "location": 206,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "NameParts.replace_transform": {
            "name": "replace_transform",
            "location": 210,
            "return": [
                "NameParts"
            ],
            "arguments": {
                "self": [
                    "_TNameParts@@NameParts@@"
                ],
                "transform_name": [
                    "str"
                ]
            }
        }
    },
    "pymc4-master/pymc4/__init__.py": {},
    "pymc4-master/pymc4/distributions/batchstack.py": {
        "_make_summary_statistic": {
            "name": "_make_summary_statistic",
            "location": 24,
            "return": [
                "Callable"
            ],
            "arguments": {
                "attr": [
                    "str",
                    "Callable",
                    "List[str]",
                    "list"
                ]
            }
        },
        "_kl_sample": {
            "name": "_kl_sample",
            "location": 212,
            "return": [
                "Callable",
                "Tuple[Any, Any, Any]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "a": [
                    "str",
                    "Optional[str]"
                ],
                "b": [
                    "str",
                    "dict",
                    "Union[int, str, bool]"
                ],
                "name": [
                    "str",
                    "Tuple[str]"
                ]
            }
        },
        "_make_summary_statistic._fn": {
            "name": "_fn",
            "location": 27,
            "return": [
                "List[str]",
                "str",
                "Optional[Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "distribution": [
                    "Callable[[Any], bool]",
                    "str",
                    "Set[str]",
                    "dict",
                    "Callable[[List], bool]",
                    "List[\"Taxon\"]"
                ],
                "batch_stack": [
                    "str",
                    "bool",
                    "int"
                ],
                "validate_args": [
                    "str",
                    "Optional[bool]",
                    "bool",
                    "List[str]",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "Union[str, int]"
                ]
            }
        },
        "BatchStacker.distribution": {
            "name": "distribution",
            "location": 142,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker.batch_stack": {
            "name": "batch_stack",
            "location": 147,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 151,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker._batch_shape": {
            "name": "_batch_shape",
            "location": 160,
            "return": [
                "str",
                "list",
                "Optional[BaseException]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker._event_shape_tensor": {
            "name": "_event_shape_tensor",
            "location": 169,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker._event_shape": {
            "name": "_event_shape",
            "location": 172,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchStacker._sample_n": {
            "name": "_sample_n",
            "location": 175,
            "return": [
                "str",
                "List[str]",
                "float",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "str",
                    "int",
                    "Union[int, str]",
                    "Optional[str]"
                ],
                "seed": [
                    "str",
                    "int",
                    "Union[int, str]",
                    "Optional[str]"
                ]
            }
        },
        "BatchStacker._log_prob": {
            "name": "_log_prob",
            "location": 180,
            "return": [
                "Tuple[float, float]",
                "float",
                "int",
                "dict",
                "str",
                "Union[int, float]"
            ],
            "arguments": {
                "self": [],
                "x": []
            }
        },
        "BatchStacker._entropy": {
            "name": "_entropy",
            "location": 202,
            "return": [
                "float",
                "str",
                "numpy.ndarray"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/pymc4/distributions/continuous.py": {
        "Normal.__init__": {
            "name": "__init__",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Normal._init_distribution": {
            "name": "_init_distribution",
            "location": 110,
            "return": [
                "Normal",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "GeneralizedNormal.__init__": {
            "name": "__init__",
            "location": 167,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ],
                "power": [
                    "str",
                    "float"
                ]
            }
        },
        "GeneralizedNormal._init_distribution": {
            "name": "_init_distribution",
            "location": 171,
            "return": [
                "GeneralizedNormal",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "HalfNormal.__init__": {
            "name": "__init__",
            "location": 232,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "HalfNormal._init_distribution": {
            "name": "_init_distribution",
            "location": 236,
            "return": [
                "HalfNormal",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "HalfStudentT.__init__": {
            "name": "__init__",
            "location": 292,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "df": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "HalfStudentT._init_distribution": {
            "name": "_init_distribution",
            "location": 296,
            "return": [
                "HalfStudentT",
                "Iterable[int]",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Beta.__init__": {
            "name": "__init__",
            "location": 349,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration0": [
                    "str",
                    "float"
                ],
                "concentration1": [
                    "str",
                    "float"
                ]
            }
        },
        "Beta._init_distribution": {
            "name": "_init_distribution",
            "location": 355,
            "return": [
                "Beta",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Cauchy.__init__": {
            "name": "__init__",
            "location": 407,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Cauchy._init_distribution": {
            "name": "_init_distribution",
            "location": 411,
            "return": [
                "Cauchy",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Chi2.__init__": {
            "name": "__init__",
            "location": 453,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "df": [
                    "str",
                    "float"
                ]
            }
        },
        "Chi2._init_distribution": {
            "name": "_init_distribution",
            "location": 457,
            "return": [
                "Chi2",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Exponential.__init__": {
            "name": "__init__",
            "location": 498,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "rate": [
                    "str",
                    "float"
                ]
            }
        },
        "Exponential._init_distribution": {
            "name": "_init_distribution",
            "location": 502,
            "return": [
                "Exponential",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Gamma.__init__": {
            "name": "__init__",
            "location": 551,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ],
                "rate": [
                    "str",
                    "float"
                ]
            }
        },
        "Gamma._init_distribution": {
            "name": "_init_distribution",
            "location": 555,
            "return": [
                "Gamma",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Gumbel.__init__": {
            "name": "__init__",
            "location": 607,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Gumbel._init_distribution": {
            "name": "_init_distribution",
            "location": 611,
            "return": [
                "Gumbel",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Gumbel.validate_args": {
            "name": "validate_args",
            "location": 616,
            "return": [
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "HalfCauchy.__init__": {
            "name": "__init__",
            "location": 657,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "HalfCauchy._init_distribution": {
            "name": "_init_distribution",
            "location": 661,
            "return": [
                "HalfCauchy",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "InverseGamma.__init__": {
            "name": "__init__",
            "location": 709,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "InverseGamma._init_distribution": {
            "name": "_init_distribution",
            "location": 713,
            "return": [
                "InverseGamma",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "InverseGaussian.__init__": {
            "name": "__init__",
            "location": 727,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ]
            }
        },
        "InverseGaussian._init_distribution": {
            "name": "_init_distribution",
            "location": 731,
            "return": [
                "InverseGaussian",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Kumaraswamy.__init__": {
            "name": "__init__",
            "location": 777,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration0": [
                    "str",
                    "float"
                ],
                "concentration1": [
                    "str",
                    "float"
                ]
            }
        },
        "Kumaraswamy._init_distribution": {
            "name": "_init_distribution",
            "location": 783,
            "return": [
                "Kumaraswamy",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Kumaraswamy.validate_args": {
            "name": "validate_args",
            "location": 793,
            "return": [
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Laplace.__init__": {
            "name": "__init__",
            "location": 838,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Laplace._init_distribution": {
            "name": "_init_distribution",
            "location": 842,
            "return": [
                "Laplace",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Logistic.__init__": {
            "name": "__init__",
            "location": 889,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Logistic._init_distribution": {
            "name": "_init_distribution",
            "location": 893,
            "return": [
                "Logistic",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LogitNormal.__init__": {
            "name": "__init__",
            "location": 916,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "LogitNormal._init_distribution": {
            "name": "_init_distribution",
            "location": 920,
            "return": [
                "LogitNormal",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LogNormal.__init__": {
            "name": "__init__",
            "location": 979,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "LogNormal._init_distribution": {
            "name": "_init_distribution",
            "location": 983,
            "return": [
                "LogNormal",
                "str",
                "int",
                "Iterable[int]",
                "bool"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Moyal.__init__": {
            "name": "__init__",
            "location": 1037,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Moyal._init_distribution": {
            "name": "_init_distribution",
            "location": 1041,
            "return": [
                "Moyal",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Moyal.validate_args": {
            "name": "validate_args",
            "location": 1046,
            "return": [
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Pareto._init_transform": {
            "name": "_init_transform",
            "location": 1094,
            "return": [
                "Union[(transforms.LowerBound, _T0)]"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "List",
                    "str",
                    "None",
                    "Sequence[Any]",
                    "Optional[str]",
                    "Iterable[T]",
                    "T",
                    "Optional[Sequence[Any]]"
                ]
            }
        },
        "Pareto.__init__": {
            "name": "__init__",
            "location": 1100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Pareto._init_distribution": {
            "name": "_init_distribution",
            "location": 1104,
            "return": [
                "Pareto",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Pareto.upper_limit": {
            "name": "upper_limit",
            "location": 1108,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Pareto.lower_limit": {
            "name": "lower_limit",
            "location": 1111,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Pareto.test_value": {
            "name": "test_value",
            "location": 1115,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "StudentT.__init__": {
            "name": "__init__",
            "location": 1179,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ],
                "df": [
                    "str",
                    "float"
                ]
            }
        },
        "StudentT._init_distribution": {
            "name": "_init_distribution",
            "location": 1183,
            "return": [
                "StudentT",
                "int",
                "List[int]",
                "Iterable[int]"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Triangular.__init__": {
            "name": "__init__",
            "location": 1241,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "low": [
                    "str"
                ],
                "peak": [
                    "str"
                ],
                "high": [
                    "str"
                ]
            }
        },
        "Triangular._init_distribution": {
            "name": "_init_distribution",
            "location": 1245,
            "return": [
                "Triangular",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Triangular.lower_limit": {
            "name": "lower_limit",
            "location": 1249,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Triangular.upper_limit": {
            "name": "upper_limit",
            "location": 1252,
            "return": [
                "int",
                "bool",
                "IO",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Uniform.__init__": {
            "name": "__init__",
            "location": 1297,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "low": [
                    "str"
                ],
                "high": [
                    "str"
                ]
            }
        },
        "Uniform._init_distribution": {
            "name": "_init_distribution",
            "location": 1301,
            "return": [
                "Uniform",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Uniform.lower_limit": {
            "name": "lower_limit",
            "location": 1306,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Uniform.upper_limit": {
            "name": "upper_limit",
            "location": 1309,
            "return": [
                "int",
                "bool",
                "IO",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Flat.__init__": {
            "name": "__init__",
            "location": 1321,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ]
            }
        },
        "Flat._init_distribution": {
            "name": "_init_distribution",
            "location": 1325,
            "return": [
                "Uniform",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "Dict[str,Any]",
                    "str",
                    "Union[str,int]",
                    "bool"
                ]
            }
        },
        "Flat.log_prob": {
            "name": "log_prob",
            "location": 1328,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "Dict",
                    "bytes",
                    "numpy.ndarray"
                ]
            }
        },
        "Flat.sample": {
            "name": "sample",
            "location": 1354,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "seed": [
                    "int",
                    "None",
                    "str",
                    "Iterable[Context]",
                    "Iterable[C]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "HalfFlat.__init__": {
            "name": "__init__",
            "location": 1362,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ]
            }
        },
        "HalfFlat._init_distribution": {
            "name": "_init_distribution",
            "location": 1366,
            "return": [
                "Uniform",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "Dict[str,Any]",
                    "str",
                    "Union[str,int]",
                    "bool"
                ]
            }
        },
        "HalfFlat.log_prob": {
            "name": "log_prob",
            "location": 1369,
            "return": [
                "str",
                "float",
                "int"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "HalfFlat.sample": {
            "name": "sample",
            "location": 1397,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "shape": [
                    "Tuple",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "seed": [
                    "int",
                    "None",
                    "str",
                    "Iterable[Context]",
                    "Iterable[C]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "VonMises.__init__": {
            "name": "__init__",
            "location": 1445,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ]
            }
        },
        "VonMises._init_distribution": {
            "name": "_init_distribution",
            "location": 1449,
            "return": [
                "VonMises",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "VonMises.lower_limit": {
            "name": "lower_limit",
            "location": 1453,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "VonMises.upper_limit": {
            "name": "upper_limit",
            "location": 1456,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Weibull.__init__": {
            "name": "__init__",
            "location": 1510,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Weibull._init_distribution": {
            "name": "_init_distribution",
            "location": 1514,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "pymc4-master/pymc4/distributions/discrete.py": {
        "Bernoulli.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "probs": [
                    "str",
                    "float"
                ]
            }
        },
        "Bernoulli._init_distribution": {
            "name": "_init_distribution",
            "location": 76,
            "return": [
                "Bernoulli",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Bernoulli.lower_limit": {
            "name": "lower_limit",
            "location": 80,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Bernoulli.upper_limit": {
            "name": "upper_limit",
            "location": 83,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Binomial.__init__": {
            "name": "__init__",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "total_count": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "probs": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ]
            }
        },
        "Binomial._init_distribution": {
            "name": "_init_distribution",
            "location": 133,
            "return": [
                "Binomial",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int"
                ]
            }
        },
        "Binomial.lower_limit": {
            "name": "lower_limit",
            "location": 137,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Binomial.upper_limit": {
            "name": "upper_limit",
            "location": 140,
            "return": [
                "int",
                "bool",
                "IO",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BetaBinomial.__init__": {
            "name": "__init__",
            "location": 190,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "total_count": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "concentration0": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "concentration1": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ]
            }
        },
        "BetaBinomial._init_distribution": {
            "name": "_init_distribution",
            "location": 200,
            "return": [
                "BetaBinomial",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int"
                ]
            }
        },
        "BetaBinomial.lower_limit": {
            "name": "lower_limit",
            "location": 213,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "BetaBinomial.upper_limit": {
            "name": "upper_limit",
            "location": 216,
            "return": [
                "int",
                "bool",
                "IO",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "DiscreteUniform.__init__": {
            "name": "__init__",
            "location": 260,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "low": [
                    "str"
                ],
                "high": [
                    "str"
                ]
            }
        },
        "DiscreteUniform._init_distribution": {
            "name": "_init_distribution",
            "location": 264,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "DiscreteUniform.lower_limit": {
            "name": "lower_limit",
            "location": 271,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "DiscreteUniform.upper_limit": {
            "name": "upper_limit",
            "location": 274,
            "return": [
                "int",
                "bool",
                "IO",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Categorical.__init__": {
            "name": "__init__",
            "location": 312,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "probs": [
                    "str",
                    "float"
                ]
            }
        },
        "Categorical._init_distribution": {
            "name": "_init_distribution",
            "location": 318,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Categorical.lower_limit": {
            "name": "lower_limit",
            "location": 323,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Categorical.upper_limit": {
            "name": "upper_limit",
            "location": 326,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Geometric.__init__": {
            "name": "__init__",
            "location": 371,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "probs": [
                    "str",
                    "float"
                ]
            }
        },
        "Geometric._init_distribution": {
            "name": "_init_distribution",
            "location": 375,
            "return": [
                "Geometric",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Geometric.lower_limit": {
            "name": "lower_limit",
            "location": 379,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "Geometric.upper_limit": {
            "name": "upper_limit",
            "location": 382,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "NegativeBinomial.__init__": {
            "name": "__init__",
            "location": 443,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "total_count": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "probs": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ]
            }
        },
        "NegativeBinomial._init_distribution": {
            "name": "_init_distribution",
            "location": 447,
            "return": [
                "NegativeBinomial",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int"
                ]
            }
        },
        "Poisson.__init__": {
            "name": "__init__",
            "location": 497,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "rate": [
                    "str",
                    "float"
                ]
            }
        },
        "Poisson._init_distribution": {
            "name": "_init_distribution",
            "location": 501,
            "return": [
                "Poisson",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "ZeroInflatedBinomial.__init__": {
            "name": "__init__",
            "location": 555,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "int",
                    "None",
                    "Optional[int]",
                    "Optional[bool]",
                    "bool"
                ],
                "psi": [
                    "str",
                    "int",
                    "None",
                    "Optional[int]",
                    "Optional[bool]",
                    "bool"
                ],
                "n": [
                    "str",
                    "int",
                    "None",
                    "Optional[int]",
                    "Optional[bool]",
                    "bool"
                ],
                "p": [
                    "str",
                    "int",
                    "None",
                    "Optional[int]",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "ZeroInflatedBinomial._init_distribution": {
            "name": "_init_distribution",
            "location": 559,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "bytes",
                    "float",
                    "bool"
                ]
            }
        },
        "ZeroInflatedNegativeBinomial.__init__": {
            "name": "__init__",
            "location": 636,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "psi": [
                    "str",
                    "float"
                ],
                "mu": [
                    "str",
                    "float"
                ],
                "alpha": [
                    "str",
                    "float"
                ]
            }
        },
        "ZeroInflatedNegativeBinomial._init_distribution": {
            "name": "_init_distribution",
            "location": 640,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "bytes",
                    "float",
                    "List[str]",
                    "Tuple[Union[int,int]]",
                    "str",
                    "Tuple[int,int]"
                ]
            }
        },
        "ZeroInflatedPoisson.__init__": {
            "name": "__init__",
            "location": 705,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "psi": [
                    "str",
                    "float"
                ],
                "theta": [
                    "str",
                    "float"
                ]
            }
        },
        "ZeroInflatedPoisson._init_distribution": {
            "name": "_init_distribution",
            "location": 709,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Zipf.__init__": {
            "name": "__init__",
            "location": 755,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "power": [
                    "str",
                    "float"
                ]
            }
        },
        "Zipf._init_distribution": {
            "name": "_init_distribution",
            "location": 759,
            "return": [
                "Zipf",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "OrderedLogistic.__init__": {
            "name": "__init__",
            "location": 791,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "cutpoints": [
                    "str",
                    "float"
                ]
            }
        },
        "OrderedLogistic._init_distribution": {
            "name": "_init_distribution",
            "location": 795,
            "return": [
                "OrderedLogistic",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "OrderedLogistic.lower_limit": {
            "name": "lower_limit",
            "location": 800,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "OrderedLogistic.upper_limit": {
            "name": "upper_limit",
            "location": 803,
            "return": [
                "int",
                "bool",
                "IO",
                "bytes",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/pymc4/distributions/distribution.py": {
        "Distribution.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "Optional[List[Any]]",
                    "List[Any]",
                    "str",
                    "Optional[str]",
                    "None",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "Distribution.dtype": {
            "name": "dtype",
            "location": 82,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution._init_distribution": {
            "name": "_init_distribution",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "Dict[str,Any]",
                    "str",
                    "Union[str,int]",
                    "bool"
                ]
            }
        },
        "Distribution._init_transform": {
            "name": "_init_transform",
            "location": 89,
            "return": [
                "int",
                "bool",
                "Dict[str,Any]",
                "float",
                "str"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "int",
                    "Dict[str,Any]",
                    "str",
                    "Union[str,int]",
                    "bool"
                ]
            }
        },
        "Distribution.unpack_distribution": {
            "name": "unpack_distribution",
            "location": 92,
            "return": [
                "Generator[(Distribution, Any, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.unpack_conditions": {
            "name": "unpack_conditions",
            "location": 96,
            "return": [
                "Tuple[(Dict[(str, Any)], Dict[(str, Any)])]"
            ],
            "arguments": {
                "cls": [
                    "Dict"
                ]
            }
        },
        "Distribution.test_value": {
            "name": "test_value",
            "location": 110,
            "return": [
                "Callable",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.sample": {
            "name": "sample",
            "location": 116,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "sample_shape": [
                    "Tuple",
                    "int",
                    "Callable",
                    "str"
                ],
                "seed": [
                    "int",
                    "Callable",
                    "None",
                    "str"
                ]
            }
        },
        "Distribution.sample_numpy": {
            "name": "sample_numpy",
            "location": 129,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "sample_shape": [
                    "Tuple",
                    "int",
                    "Callable",
                    "str"
                ],
                "seed": [
                    "int",
                    "Callable",
                    "None",
                    "str"
                ]
            }
        },
        "Distribution.get_test_sample": {
            "name": "get_test_sample",
            "location": 145,
            "return": [
                "int",
                "Dict[str, Any]",
                "str"
            ],
            "arguments": {
                "self": [],
                "sample_shape": [
                    "Tuple",
                    "int",
                    "List[int]"
                ],
                "seed": [
                    "bool",
                    "str",
                    "None"
                ]
            }
        },
        "Distribution.log_prob": {
            "name": "log_prob",
            "location": 164,
            "return": [
                "str",
                "int",
                "bool",
                "Set[str]"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "float",
                    "int",
                    "str",
                    "Sequence",
                    "Union[int,bool]",
                    "bool",
                    "T"
                ]
            }
        },
        "Distribution.log_prob_numpy": {
            "name": "log_prob_numpy",
            "location": 168,
            "return": [
                "bool",
                "str",
                "Dict[str, Any]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "int",
                    "float",
                    "eth.abc.ComputationAPI"
                ]
            }
        },
        "Distribution.dist": {
            "name": "dist",
            "location": 173,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "cls": [
                    "Type[_TDistribution]"
                ]
            }
        },
        "Distribution.prior": {
            "name": "prior",
            "location": 177,
            "return": [
                "Distribution"
            ],
            "arguments": {
                "self": [
                    "_TDistribution@@Distribution@@"
                ],
                "name": [
                    "str",
                    "Optional[str]",
                    "Dict[str,str]",
                    "None"
                ]
            }
        },
        "Distribution.is_anonymous": {
            "name": "is_anonymous",
            "location": 199,
            "return": [
                "bool",
                "str",
                "Dict[str,Any]",
                "Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.is_observed": {
            "name": "is_observed",
            "location": 203,
            "return": [
                "str",
                "bool",
                "float",
                "Callable[..., None]",
                "Type[abilian.core.models.Model]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.is_root": {
            "name": "is_root",
            "location": 207,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.batch_shape": {
            "name": "batch_shape",
            "location": 211,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.event_shape": {
            "name": "event_shape",
            "location": 215,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Distribution.validate_args": {
            "name": "validate_args",
            "location": 219,
            "return": [
                "int",
                "List[Tuple[str, str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Distribution.allow_nan_stats": {
            "name": "allow_nan_stats",
            "location": 223,
            "return": [
                "bool",
                "int",
                "list"
            ],
            "arguments": {
                "self": []
            }
        },
        "Potential.__init__": {
            "name": "__init__",
            "location": 230,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "float",
                    "str",
                    "int",
                    "T"
                ],
                "coef": [
                    "float",
                    "int",
                    "List[Tuple[int,float]]",
                    "Tuple[str]",
                    "str"
                ]
            }
        },
        "Potential.value": {
            "name": "value",
            "location": 235,
            "return": [
                "int",
                "str",
                "bool",
                "Optional[str]",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "Potential.value_numpy": {
            "name": "value_numpy",
            "location": 242,
            "return": [
                "str",
                "int",
                "Type[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Deterministic.__init__": {
            "name": "__init__",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "bool",
                    "Optional[bool]",
                    "None",
                    "Mapping[str,str]",
                    "Mapping"
                ],
                "value": [
                    "str"
                ]
            }
        },
        "Deterministic.get_value": {
            "name": "get_value",
            "location": 255,
            "return": [
                "str",
                "List[str]",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Deterministic.value_numpy": {
            "name": "value_numpy",
            "location": 259,
            "return": [
                "str",
                "int",
                "Type[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Deterministic.is_anonymous": {
            "name": "is_anonymous",
            "location": 263,
            "return": [
                "bool",
                "str",
                "Dict[str,Any]",
                "Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "ContinuousDistribution.unpack_conditions": {
            "name": "unpack_conditions",
            "location": 271,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ]
            }
        },
        "BoundedDistribution.lower_limit": {
            "name": "lower_limit",
            "location": 289,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "BoundedDistribution.upper_limit": {
            "name": "upper_limit",
            "location": 293,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "BoundedDiscreteDistribution._test_value": {
            "name": "_test_value",
            "location": 299,
            "return": [
                "int",
                "Sequence[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BoundedContinuousDistribution._init_transform": {
            "name": "_init_transform",
            "location": 304,
            "return": [
                "Union[(transforms.Interval, _T0)]"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "List",
                    "str",
                    "None",
                    "Sequence[Any]",
                    "Optional[str]",
                    "Iterable[T]",
                    "T",
                    "Optional[Sequence[Any]]"
                ]
            }
        },
        "BoundedContinuousDistribution._test_value": {
            "name": "_test_value",
            "location": 311,
            "return": [
                "float",
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "UnitContinuousDistribution._init_transform": {
            "name": "_init_transform",
            "location": 316,
            "return": [
                "Union[(transforms.Sigmoid, _T0)]"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "List",
                    "str",
                    "None",
                    "Sequence[Any]",
                    "Optional[str]",
                    "Iterable[T]",
                    "T",
                    "Optional[Sequence[Any]]"
                ]
            }
        },
        "UnitContinuousDistribution.lower_limit": {
            "name": "lower_limit",
            "location": 322,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "UnitContinuousDistribution.upper_limit": {
            "name": "upper_limit",
            "location": 325,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PositiveContinuousDistribution._init_transform": {
            "name": "_init_transform",
            "location": 332,
            "return": [
                "Union[(transforms.Log, _T0)]"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "List",
                    "str",
                    "None",
                    "Sequence[Any]",
                    "Optional[str]",
                    "Iterable[T]",
                    "T",
                    "Optional[Sequence[Any]]"
                ]
            }
        },
        "PositiveContinuousDistribution.lower_limit": {
            "name": "lower_limit",
            "location": 338,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PositiveContinuousDistribution.upper_limit": {
            "name": "upper_limit",
            "location": 341,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "PositiveDiscreteDistribution.lower_limit": {
            "name": "lower_limit",
            "location": 348,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PositiveDiscreteDistribution.upper_limit": {
            "name": "upper_limit",
            "location": 351,
            "return": [
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimplexContinuousDistribution.test_value": {
            "name": "test_value",
            "location": 357,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/pymc4/distributions/mixture.py": {
        "Mixture.__init__": {
            "name": "__init__",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "p": [
                    "str",
                    "float"
                ],
                "distributions": [
                    "str",
                    "float"
                ]
            }
        },
        "Mixture._init_distribution": {
            "name": "_init_distribution",
            "location": 86,
            "return": [
                "Mixture",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "pymc4-master/pymc4/distributions/multivariate.py": {
        "Dirichlet.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ]
            }
        },
        "Dirichlet._init_distribution": {
            "name": "_init_distribution",
            "location": 67,
            "return": [
                "Dirichlet",
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LKJ.__init__": {
            "name": "__init__",
            "location": 102,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "dimension": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ]
            }
        },
        "LKJ._init_distribution": {
            "name": "_init_distribution",
            "location": 106,
            "return": [
                "LKJ",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LKJ.test_value": {
            "name": "test_value",
            "location": 111,
            "return": [
                "bool",
                "str",
                "Iterable[Any]",
                "Dict[str, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Multinomial.__init__": {
            "name": "__init__",
            "location": 150,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "total_count": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ],
                "probs": [
                    "int",
                    "float",
                    "str",
                    "bool",
                    "Union[float,int]"
                ]
            }
        },
        "Multinomial._init_distribution": {
            "name": "_init_distribution",
            "location": 154,
            "return": [
                "Multinomial",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int"
                ]
            }
        },
        "MvNormal.__init__": {
            "name": "__init__",
            "location": 191,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "covariance_matrix": [
                    "str",
                    "float"
                ]
            }
        },
        "MvNormal._init_distribution": {
            "name": "_init_distribution",
            "location": 195,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "VonMisesFisher.__init__": {
            "name": "__init__",
            "location": 231,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "mean_direction": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ]
            }
        },
        "VonMisesFisher._init_distribution": {
            "name": "_init_distribution",
            "location": 235,
            "return": [
                "VonMisesFisher",
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Wishart.__init__": {
            "name": "__init__",
            "location": 277,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "df": [
                    "str",
                    "float"
                ],
                "scale": [
                    "str",
                    "float"
                ]
            }
        },
        "Wishart._init_distribution": {
            "name": "_init_distribution",
            "location": 281,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Wishart.test_value": {
            "name": "test_value",
            "location": 286,
            "return": [
                "bool",
                "str",
                "Iterable[Any]",
                "Dict[str, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "LKJCholesky.__init__": {
            "name": "__init__",
            "location": 318,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "dimension": [
                    "str",
                    "float"
                ],
                "concentration": [
                    "str",
                    "float"
                ]
            }
        },
        "LKJCholesky._init_distribution": {
            "name": "_init_distribution",
            "location": 322,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "LKJCholesky.test_value": {
            "name": "test_value",
            "location": 327,
            "return": [
                "bool",
                "str",
                "Iterable[Any]",
                "Dict[str, float]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MvNormalCholesky.__init__": {
            "name": "__init__",
            "location": 369,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "float"
                ],
                "loc": [
                    "str",
                    "float"
                ],
                "scale_tril": [
                    "str",
                    "float"
                ]
            }
        },
        "MvNormalCholesky._init_distribution": {
            "name": "_init_distribution",
            "location": 373,
            "return": [
                "str",
                "int",
                "float"
            ],
            "arguments": {
                "conditions": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "pymc4-master/pymc4/distributions/state_functions.py": {
        "Proposal.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "None",
                    "Dict[str,Any]",
                    "List[str]",
                    "Dict"
                ]
            }
        },
        "Proposal._fn": {
            "name": "_fn",
            "location": 25,
            "return": [
                "List[tensorflow.Tensor]",
                "None"
            ],
            "arguments": {
                "self": [],
                "state_parts": [
                    "Optional[int]",
                    "int",
                    "List[tensorflow.Tensor]",
                    "str",
                    "None",
                    "Iterator[str]",
                    "Iterator"
                ],
                "seed": [
                    "Optional[int]",
                    "int",
                    "List[tensorflow.Tensor]",
                    "str",
                    "None",
                    "Iterator[str]",
                    "Iterator"
                ]
            }
        },
        "Proposal.__eq__": {
            "name": "__eq__",
            "location": 53,
            "return": [
                "bool",
                "None"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "List[str]",
                    "SupportsFloat",
                    "int",
                    "Union[int,float]",
                    "float",
                    "AbstractSet[T]",
                    "AbstractSet"
                ]
            }
        },
        "Proposal.__call__": {
            "name": "__call__",
            "location": 71,
            "return": [
                "Callable[([Any, Any], Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "CategoricalUniformFn.__init__": {
            "name": "__init__",
            "location": 91,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "classes": [
                    "bool",
                    "str",
                    "int",
                    "None",
                    "Optional[str]"
                ],
                "name": [
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        },
        "CategoricalUniformFn._fn": {
            "name": "_fn",
            "location": 95,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "state_parts": [
                    "List[tensorflow.Tensor]",
                    "Optional[int]",
                    "bytes",
                    "List[int]"
                ],
                "seed": [
                    "List[tensorflow.Tensor]",
                    "bytes",
                    "Optional[int]",
                    "List[int]",
                    "int",
                    "None"
                ]
            }
        },
        "CategoricalUniformFn.__eq__": {
            "name": "__eq__",
            "location": 107,
            "return": [
                "bool",
                "str",
                "Optional[Any]",
                "Type"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Mapping[str,str]",
                    "str",
                    "Mapping",
                    "List[str]"
                ]
            }
        },
        "BernoulliFn.__init__": {
            "name": "__init__",
            "location": 125,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "None",
                    "Optional[str]"
                ]
            }
        },
        "BernoulliFn._fn": {
            "name": "_fn",
            "location": 128,
            "return": [
                "bool",
                "Dict[str,Any]",
                "Type",
                "Tuple[Union[str,str,str,str,str,str,str,str,str,str,str,str,str]]",
                "List[tuple[Union[Any,str]]]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "state_parts": [
                    "List[tensorflow.Tensor]",
                    "T",
                    "str"
                ],
                "seed": [
                    "Optional[int]",
                    "int",
                    "List[tensorflow.Tensor]",
                    "str",
                    "None",
                    "Iterator[str]",
                    "Iterator"
                ]
            }
        },
        "BernoulliFn.__eq__": {
            "name": "__eq__",
            "location": 142,
            "return": [
                "bool",
                "str",
                "List"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "str",
                    "T"
                ]
            }
        },
        "GaussianRoundFn.__init__": {
            "name": "__init__",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "scale": [
                    "float",
                    "bool",
                    "str",
                    "Optional[str]"
                ],
                "name": [
                    "str",
                    "None",
                    "Optional[str]"
                ]
            }
        },
        "GaussianRoundFn._fn": {
            "name": "_fn",
            "location": 167,
            "return": [
                "bool",
                "Dict[str,Any]",
                "Type",
                "Tuple[Union[str,str,str,str,str,str,str,str,str,str,str,str,str]]",
                "List[tuple[Union[Any,str]]]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "state_parts": [
                    "List[tensorflow.Tensor]",
                    "T",
                    "str"
                ],
                "seed": [
                    "Optional[int]",
                    "int",
                    "List[tensorflow.Tensor]",
                    "str",
                    "None",
                    "Iterator[str]",
                    "Iterator"
                ]
            }
        },
        "GaussianRoundFn.__eq__": {
            "name": "__eq__",
            "location": 188,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "other": [
                    "Mapping[str,str]",
                    "str",
                    "Mapping",
                    "List[str]"
                ]
            }
        },
        "BernoulliFn._fn.generate_bernoulli": {
            "name": "generate_bernoulli",
            "location": 132,
            "return": [
                "bool",
                "str",
                "int",
                "List[str]",
                "allennlp.common.util.JsonDict",
                "dict"
            ],
            "arguments": {
                "state_part": [],
                "part_seed": []
            }
        },
        "GaussianRoundFn._fn.generate_rounded_normal": {
            "name": "generate_rounded_normal",
            "location": 178,
            "return": [
                "bool"
            ],
            "arguments": {
                "state_part": [
                    "int",
                    "Sequence[str]"
                ],
                "scale_part": [
                    "Optional[int]",
                    "bool",
                    "List[tensorflow.Tensor]",
                    "str",
                    "Iterator[str]"
                ],
                "part_seed": [
                    "int",
                    "Sequence[str]"
                ]
            }
        }
    },
    "pymc4-master/pymc4/distributions/timeseries.py": {
        "AR.__init__": {
            "name": "__init__",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "num_timesteps": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "coefficients": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "level_scale": [
                    "int",
                    "str",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "initial_state": [
                    "int",
                    "None",
                    "str",
                    "Optional[int]",
                    "bool"
                ],
                "initial_step": [
                    "int",
                    "str",
                    "Optional[int]",
                    "bool"
                ]
            }
        },
        "AR.unpack_conditions": {
            "name": "unpack_conditions",
            "location": 57,
            "return": [
                "Tuple[(Any, Dict[(nothing, nothing)])]"
            ],
            "arguments": {
                "cls": [
                    "memoryview",
                    "bool",
                    "str"
                ]
            }
        },
        "AR._init_distribution": {
            "name": "_init_distribution",
            "location": 67,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "conditions": []
            }
        }
    },
    "pymc4-master/pymc4/distributions/transforms.py": {
        "Transform.forward": {
            "name": "forward",
            "location": 18,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "bool",
                    "float",
                    "Iterable[Iterable[float]]",
                    "str",
                    "bytes",
                    "List",
                    "T"
                ]
            }
        },
        "Transform.inverse": {
            "name": "inverse",
            "location": 38,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "Transform.forward_log_det_jacobian": {
            "name": "forward_log_det_jacobian",
            "location": 58,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "List[str]",
                    "bool",
                    "T"
                ]
            }
        },
        "Transform.inverse_log_det_jacobian": {
            "name": "inverse_log_det_jacobian",
            "location": 74,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "str",
                    "Tuple",
                    "List[Dict[str,Any]]",
                    "float",
                    "List[dict[str,Any]]",
                    "List",
                    "int"
                ]
            }
        },
        "Invert.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "Invert.forward": {
            "name": "forward",
            "location": 103,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "Invert.inverse": {
            "name": "inverse",
            "location": 106,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Invert.forward_log_det_jacobian": {
            "name": "forward_log_det_jacobian",
            "location": 109,
            "return": [
                "Dict[str, Any]",
                "int",
                "str",
                "Callable[[], Iterable[Any]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "Dict[str,Any]",
                    "str",
                    "Dict[str,str]",
                    "Dict[str,int]",
                    "Exception"
                ]
            }
        },
        "Invert.inverse_log_det_jacobian": {
            "name": "inverse_log_det_jacobian",
            "location": 112,
            "return": [
                "str",
                "dict",
                "Dict[str, Any]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "str",
                    "Dict",
                    "Dict[str,Any]",
                    "Dict[str,str]"
                ]
            }
        },
        "BackwardTransform.__init__": {
            "name": "__init__",
            "location": 121,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transform": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "BackwardTransform.forward": {
            "name": "forward",
            "location": 124,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float",
                    "str",
                    "T"
                ]
            }
        },
        "BackwardTransform.inverse": {
            "name": "inverse",
            "location": 127,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "BackwardTransform.forward_log_det_jacobian": {
            "name": "forward_log_det_jacobian",
            "location": 130,
            "return": [
                "Dict[str, Any]",
                "int",
                "str",
                "Callable[[], Iterable[Any]]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "str",
                    "int"
                ]
            }
        },
        "BackwardTransform.inverse_log_det_jacobian": {
            "name": "inverse_log_det_jacobian",
            "location": 133,
            "return": [
                "str",
                "dict",
                "Dict[str, Any]",
                "Dict[str, str]"
            ],
            "arguments": {
                "self": [],
                "z": [
                    "str",
                    "Dict[str,Any]",
                    "Dict"
                ]
            }
        },
        "Log.__init__": {
            "name": "__init__",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Sigmoid.__init__": {
            "name": "__init__",
            "location": 149,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowerBound.__init__": {
            "name": "__init__",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lower_limit": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "UpperBound.__init__": {
            "name": "__init__",
            "location": 169,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "upper_limit": [
                    "int",
                    "bool",
                    "str",
                    "Optional[str]",
                    "None",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "Interval.__init__": {
            "name": "__init__",
            "location": 179,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lower_limit": [
                    "bool",
                    "str",
                    "List[List[int]]",
                    "List[list[int]]",
                    "int",
                    "float",
                    "Optional[float]",
                    "None"
                ],
                "upper_limit": [
                    "bool",
                    "str",
                    "List[List[int]]",
                    "List[list[int]]",
                    "int",
                    "float",
                    "Optional[float]",
                    "None"
                ]
            }
        }
    },
    "pymc4-master/pymc4/distributions/__init__.py": {},
    "pymc4-master/pymc4/flow/executor.py": {
        "_chain_map_iter": {
            "name": "_chain_map_iter",
            "location": 24,
            "return": [
                "Iterator"
            ],
            "arguments": {
                "self": []
            }
        },
        "observed_value_in_evaluation": {
            "name": "observed_value_in_evaluation",
            "location": 720,
            "return": [
                "Optional[str]",
                "str",
                "int",
                "Optional[cmk.utils.diagnostics.DiagnosticsOptionalParameters]",
                "list"
            ],
            "arguments": {
                "scoped_name": [
                    "str",
                    "pymc4.distributions.distribution.Distribution",
                    "Dict[str, str]"
                ],
                "dist": [
                    "str",
                    "pymc4.distributions.distribution.Distribution",
                    "Dict[str, str]"
                ],
                "state": [
                    "str",
                    "pymc4.distributions.distribution.Distribution",
                    "Dict[str, str]"
                ]
            }
        },
        "assert_values_compatible_with_distribution": {
            "name": "assert_values_compatible_with_distribution",
            "location": 726,
            "return": [
                "None"
            ],
            "arguments": {
                "scoped_name": [
                    "str",
                    "dict",
                    "Dict[str, Any]"
                ],
                "values": [
                    "str",
                    "dict",
                    "Dict[str, Any]"
                ],
                "dist": [
                    "pymc4.distributions.distribution.Distribution",
                    "str",
                    "list"
                ]
            }
        },
        "assert_values_compatible_with_distribution_shape": {
            "name": "assert_values_compatible_with_distribution_shape",
            "location": 762,
            "return": [
                "None"
            ],
            "arguments": {
                "scoped_name": [
                    "str"
                ],
                "values": [
                    "Optional[List[Any]]",
                    "int",
                    "Optional[bool]"
                ],
                "batch_shape": [
                    "str",
                    "dict",
                    "pymc4.distributions.distribution.Distribution",
                    "int"
                ],
                "event_shape": [
                    "str",
                    "bool",
                    "Callable"
                ]
            }
        },
        "get_observed_tensor_shape": {
            "name": "get_observed_tensor_shape",
            "location": 822,
            "return": [
                "int",
                "dict",
                "str",
                "raiden.utils.List[raiden.utils.Tuple[str, raiden.utils.Any]]",
                "bool"
            ],
            "arguments": {
                "arr": [
                    "str",
                    "bool"
                ]
            }
        },
        "SamplingState.__init__": {
            "name": "__init__",
            "location": 108,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transformed_values": [
                    "Optional[Sequence[Any]]",
                    "Union[int, None]",
                    "dict",
                    "starfish.types.Number",
                    "list",
                    "int",
                    "Optional[List[str]]"
                ],
                "untransformed_values": [
                    "Optional[Sequence[Any]]",
                    "Union[int, None]",
                    "dict",
                    "starfish.types.Number",
                    "list",
                    "int",
                    "Optional[List[str]]"
                ],
                "observed_values": [
                    "Optional[Sequence[Any]]",
                    "Union[int, None]",
                    "dict",
                    "starfish.types.Number",
                    "list",
                    "int",
                    "Optional[List[str]]"
                ],
                "discrete_distributions": [
                    "bool",
                    "int",
                    "list",
                    "Optional[Callable[[Any], Any]]"
                ],
                "continuous_distributions": [
                    "bool",
                    "int",
                    "list",
                    "Optional[Callable[[Any], Any]]"
                ],
                "potentials": [
                    "Optional[Sequence[Any]]",
                    "Optional[Union[float, str]]"
                ],
                "deterministics": [
                    "bool",
                    "Callable",
                    "Optional[float]",
                    "Optional[Union[str, Any]]"
                ],
                "posterior_predictives": [
                    "bool",
                    "Callable",
                    "str"
                ],
                "deterministics_values": [
                    "Optional[Sequence[Any]]",
                    "dict",
                    "Optional[List[str]]",
                    "Union[int, None]",
                    "list",
                    "starfish.types.Number",
                    "int"
                ]
            }
        },
        "SamplingState.collect_log_prob_elemwise": {
            "name": "collect_log_prob_elemwise",
            "location": 171,
            "return": [
                "itertools.chain"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingState.collect_log_prob": {
            "name": "collect_log_prob",
            "location": 183,
            "return": [
                "str",
                "int",
                "tensorflow.Tensor",
                "List[str]",
                "Iterable[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingState.collect_unreduced_log_prob": {
            "name": "collect_unreduced_log_prob",
            "location": 186,
            "return": [
                "dict",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingState.__repr__": {
            "name": "__repr__",
            "location": 189,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingState.from_values": {
            "name": "from_values",
            "location": 243,
            "return": [
                "SamplingState"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSamplingState]"
                ],
                "values": [
                    "Dict[str, Any]",
                    "Optional[float]",
                    "Optional[str]",
                    "str",
                    "Union[str, None]",
                    "bytes"
                ],
                "observed_values": [
                    "Dict[str, Any]",
                    "float",
                    "Tuple[str, str]",
                    "Optional[bool]",
                    "int"
                ]
            }
        },
        "SamplingState.clone": {
            "name": "clone",
            "location": 259,
            "return": [
                "SamplingState"
            ],
            "arguments": {
                "self": [
                    "_TSamplingState@@SamplingState@@"
                ]
            }
        },
        "SamplingState.as_sampling_state": {
            "name": "as_sampling_state",
            "location": 272,
            "return": [
                "Tuple[(SamplingState, List[str])]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingExecutor.validate_return_object": {
            "name": "validate_return_object",
            "location": 340,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "return_object": [
                    "str",
                    "Optional[str]",
                    "Callable[..., Awaitable[Any]]"
                ]
            }
        },
        "SamplingExecutor.validate_return_value": {
            "name": "validate_return_value",
            "location": 352,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "return_value": [
                    "int",
                    "str",
                    "Union[str, int]",
                    "bool"
                ]
            }
        },
        "SamplingExecutor.evaluate_model": {
            "name": "evaluate_model",
            "location": 355,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "model": []
            }
        },
        "SamplingExecutor.new_state": {
            "name": "new_state",
            "location": 564,
            "return": [
                "SamplingState"
            ],
            "arguments": {
                "self": [],
                "values": [
                    "Dict[str, Any]",
                    "types.streams.T",
                    "dict"
                ],
                "observed": [
                    "Dict[str, Any]",
                    "types.streams.T",
                    "dict"
                ]
            }
        },
        "SamplingExecutor.validate_state": {
            "name": "validate_state",
            "location": 569,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "List[str]",
                    "str",
                    "Tuple[int, int, str]"
                ]
            }
        },
        "SamplingExecutor.modify_distribution": {
            "name": "modify_distribution",
            "location": 576,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "dist": [
                    "Mapping[str, Any]",
                    "bool",
                    "Dict[str, Any]"
                ],
                "model_info": [
                    "Mapping[str, Any]",
                    "bool",
                    "Dict[str, Any]"
                ],
                "state": [
                    "Mapping[str, Any]",
                    "bool",
                    "Dict[str, Any]"
                ]
            }
        },
        "SamplingExecutor.proceed_distribution": {
            "name": "proceed_distribution",
            "location": 581,
            "return": [
                "Tuple[(Any, _T1)]"
            ],
            "arguments": {
                "self": [],
                "dist": [
                    "pymc4.flow.executor.SamplingState",
                    "int"
                ],
                "state": [
                    "pymc4.flow.executor.SamplingState",
                    "Dict[str, Any]",
                    "int"
                ],
                "sample_shape": [
                    "Optional[str]",
                    "float"
                ]
            }
        },
        "SamplingExecutor.proceed_deterministic": {
            "name": "proceed_deterministic",
            "location": 652,
            "return": [
                "Tuple[(Any, _T1)]"
            ],
            "arguments": {
                "self": [],
                "deterministic": [
                    "pymc4.flow.executor.SamplingState",
                    "Dict[str, Any]",
                    "int"
                ],
                "state": [
                    "pymc4.flow.executor.SamplingState",
                    "T"
                ]
            }
        },
        "SamplingExecutor.prepare_model_control_flow": {
            "name": "prepare_model_control_flow",
            "location": 679,
            "return": [
                "List[str]",
                "str",
                "int",
                "tensorflow.Tensor"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Callable[..., None]",
                    "Dict[str, Any]",
                    "Type[BaseException]"
                ],
                "model_info": [
                    "Dict[str, Set[str]]",
                    "Dict[str, Any]",
                    "Type['BaseModel']"
                ],
                "state": [
                    "str",
                    "Optional[Dict[str, Any]]",
                    "Type['BaseModel']",
                    "bool",
                    "bytes"
                ]
            }
        },
        "SamplingExecutor.finalize_control_flow": {
            "name": "finalize_control_flow",
            "location": 699,
            "return": [
                "Tuple[(Any, _T2)]"
            ],
            "arguments": {
                "self": [],
                "stop_iteration": [
                    "bool",
                    "int",
                    "Optional[bool]",
                    "Dict[str, Any]"
                ],
                "model_info": [
                    "dict",
                    "Optional[str]",
                    "str"
                ],
                "state": [
                    "Dict[str, Any]",
                    "int",
                    "telethon.tl.types.Channel"
                ]
            }
        }
    },
    "pymc4-master/pymc4/flow/meta_executor.py": {
        "MetaSamplingExecutor.proceed_distribution": {
            "name": "proceed_distribution",
            "location": 27,
            "return": [
                "Tuple[(Any, _T1)]"
            ],
            "arguments": {
                "self": [],
                "dist": [
                    "SamplingState",
                    "pymc4.flow.executor.SamplingState",
                    "int"
                ],
                "state": [
                    "Dict[str,Any]",
                    "int",
                    "SamplingState",
                    "pymc4.flow.executor.SamplingState"
                ],
                "sample_shape": [
                    "float",
                    "str",
                    "None",
                    "Dict[str,Any]"
                ]
            }
        }
    },
    "pymc4-master/pymc4/flow/posterior_predictive_executor.py": {
        "PosteriorPredictiveSamplingExecutor.validate_state": {
            "name": "validate_state",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str,str]",
                    "int",
                    "pymc4.flow.executor.SamplingState"
                ]
            }
        },
        "PosteriorPredictiveSamplingExecutor.modify_distribution": {
            "name": "modify_distribution",
            "location": 43,
            "return": [
                "int",
                "str",
                "Dict[str,dict]",
                "List[str]",
                "OrderedDict",
                "Dict"
            ],
            "arguments": {
                "self": [],
                "dist": [
                    "Mapping[str,Any]",
                    "float",
                    "Mapping",
                    "bool"
                ],
                "model_info": [
                    "Mapping[str,Any]",
                    "List",
                    "Mapping",
                    "bool",
                    "str",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "state": [
                    "bool",
                    "Dict[str,str]",
                    "List[List[str]]",
                    "List[list[str]]"
                ]
            }
        }
    },
    "pymc4-master/pymc4/flow/transformed_executor.py": {
        "make_untransformed_model": {
            "name": "make_untransformed_model",
            "location": 40,
            "return": [
                "Generator[(Union[(distribution.Potential, _T0)], Any, Any)]"
            ],
            "arguments": {
                "dist": [
                    "SamplingState"
                ],
                "transform": [
                    "Dict[str, Dict[str, Any]]",
                    "bool",
                    "Dict[str, Any]"
                ],
                "state": [
                    "str",
                    "Sequence[object]",
                    "int",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        },
        "make_transformed_model": {
            "name": "make_transformed_model",
            "location": 69,
            "return": [
                "Generator[(Union[(distribution.Potential, _T0)], Any, Any)]"
            ],
            "arguments": {
                "dist": [
                    "Dict[str,Any]",
                    "int",
                    "Type",
                    "float",
                    "object"
                ],
                "transform": [
                    "Dict",
                    "Sequence[str]",
                    "bool",
                    "SamplingState"
                ],
                "state": [
                    "bool",
                    "Dict",
                    "Dict[str,Any]"
                ]
            }
        },
        "transform_dist_if_necessary": {
            "name": "transform_dist_if_necessary",
            "location": 108,
            "return": [
                "Union[(Generator[(Union[(distribution.Potential, _T0)], Any, Any)], _T0)]"
            ],
            "arguments": {
                "dist": [
                    "str",
                    "Dict[str,Any]",
                    "Type[Any]",
                    "Type",
                    "Optional[Dict[str,Any]]",
                    "None"
                ],
                "state": [
                    "Optional[int]",
                    "int",
                    "Callable",
                    "None",
                    "Optional[str]",
                    "Optional[T]",
                    "str"
                ]
            }
        },
        "TransformedSamplingExecutor.validate_state": {
            "name": "validate_state",
            "location": 25,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "Dict[str,str]",
                    "int",
                    "pymc4.flow.executor.SamplingState"
                ]
            }
        },
        "TransformedSamplingExecutor.modify_distribution": {
            "name": "modify_distribution",
            "location": 29,
            "return": [
                "str",
                "int",
                "bytearray",
                "List",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "dist": [
                    "bool",
                    "float",
                    "Mapping[str,Any]",
                    "Mapping"
                ],
                "model_info": [
                    "Mapping[str,Any]",
                    "List",
                    "Mapping",
                    "bool",
                    "str",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "state": [
                    "Mapping[str,Any]",
                    "float",
                    "Mapping",
                    "bool"
                ]
            }
        }
    },
    "pymc4-master/pymc4/flow/__init__.py": {},
    "pymc4-master/pymc4/gp/cov.py": {
        "Covariance.__init__": {
            "name": "__init__",
            "location": 102,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Covariance._init_kernel": {
            "name": "_init_kernel",
            "location": 161,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Covariance._slice": {
            "name": "_slice",
            "location": 164,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "X1": [
                    "_T0@@"
                ],
                "X2": [
                    "_T1@@"
                ]
            }
        },
        "Covariance._diag": {
            "name": "_diag",
            "location": 182,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X1": [],
                "X2": [],
                "to_dense": []
            }
        },
        "Covariance.evaluate_kernel": {
            "name": "evaluate_kernel",
            "location": 189,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X1": [],
                "X2": []
            }
        },
        "Covariance.feature_ndims": {
            "name": "feature_ndims",
            "location": 208,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Covariance.active_dims": {
            "name": "active_dims",
            "location": 213,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Covariance.scale_diag": {
            "name": "scale_diag",
            "location": 218,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Covariance.ard": {
            "name": "ard",
            "location": 223,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Covariance.__call__": {
            "name": "__call__",
            "location": 227,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X1": [],
                "X2": [],
                "diag": [],
                "to_dense": []
            }
        },
        "Covariance.__add__": {
            "name": "__add__",
            "location": 274,
            "return": [
                "_Add"
            ],
            "arguments": {
                "self": [],
                "cov2": []
            }
        },
        "Covariance.__mul__": {
            "name": "__mul__",
            "location": 277,
            "return": [
                "_Prod"
            ],
            "arguments": {
                "self": [],
                "cov2": []
            }
        },
        "Covariance.__array_wrap__": {
            "name": "__array_wrap__",
            "location": 284,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "result": []
            }
        },
        "Combination.__init__": {
            "name": "__init__",
            "location": 311,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Combination._eval_factor": {
            "name": "_eval_factor",
            "location": 325,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "factor": [],
                "X1": [],
                "X2": [],
                "diag": [],
                "to_dense": []
            }
        },
        "Combination.merge_factors": {
            "name": "merge_factors",
            "location": 333,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X1": [],
                "X2": [],
                "diag": [],
                "to_dense": []
            }
        },
        "_Add.__call__": {
            "name": "__call__",
            "location": 352,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X1": [],
                "X2": [],
                "diag": [],
                "to_dense": []
            }
        },
        "_Prod.__call__": {
            "name": "__call__",
            "location": 370,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "X1": [],
                "X2": [],
                "diag": [],
                "to_dense": []
            }
        },
        "Stationary.length_scale": {
            "name": "length_scale",
            "location": 380,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ExpQuad.__init__": {
            "name": "__init__",
            "location": 445,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "ExpQuad._init_kernel": {
            "name": "_init_kernel",
            "location": 463,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "ExpQuad.amplitude": {
            "name": "amplitude",
            "location": 472,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Constant.__init__": {
            "name": "__init__",
            "location": 524,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "coef": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Constant._init_kernel": {
            "name": "_init_kernel",
            "location": 540,
            "return": [
                "pymc4.gp._kernel._Constant"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Constant.coef": {
            "name": "coef",
            "location": 544,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "WhiteNoise.__init__": {
            "name": "__init__",
            "location": 596,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "noise": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "WhiteNoise._init_kernel": {
            "name": "_init_kernel",
            "location": 612,
            "return": [
                "pymc4.gp._kernel._WhiteNoise"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "WhiteNoise.noise": {
            "name": "noise",
            "location": 616,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RatQuad.__init__": {
            "name": "__init__",
            "location": 662,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "scale_mixture_rate": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "RatQuad._init_kernel": {
            "name": "_init_kernel",
            "location": 682,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "RatQuad.amplitude": {
            "name": "amplitude",
            "location": 692,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "RatQuad.scale_mixture_rate": {
            "name": "scale_mixture_rate",
            "location": 697,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Matern12.__init__": {
            "name": "__init__",
            "location": 745,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Matern12._init_kernel": {
            "name": "_init_kernel",
            "location": 763,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Matern12.amplitude": {
            "name": "amplitude",
            "location": 772,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Matern32.__init__": {
            "name": "__init__",
            "location": 814,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Matern32._init_kernel": {
            "name": "_init_kernel",
            "location": 832,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Matern32.amplitude": {
            "name": "amplitude",
            "location": 841,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Matern52.__init__": {
            "name": "__init__",
            "location": 884,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Matern52._init_kernel": {
            "name": "_init_kernel",
            "location": 902,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Matern52.amplitude": {
            "name": "amplitude",
            "location": 911,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Linear.__init__": {
            "name": "__init__",
            "location": 963,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "bias_variance": [],
                "slope_variance": [],
                "shift": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Linear._init_kernel": {
            "name": "_init_kernel",
            "location": 983,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Linear.slope_variance": {
            "name": "slope_variance",
            "location": 993,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Linear.bias_variance": {
            "name": "bias_variance",
            "location": 998,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Linear.shift": {
            "name": "shift",
            "location": 1003,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Polynomial.__init__": {
            "name": "__init__",
            "location": 1051,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "bias_variance": [],
                "slope_variance": [],
                "shift": [],
                "exponent": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Polynomial._init_kernel": {
            "name": "_init_kernel",
            "location": 1073,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Polynomial.slope_variance": {
            "name": "slope_variance",
            "location": 1084,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Polynomial.bias_variance": {
            "name": "bias_variance",
            "location": 1089,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Polynomial.shift": {
            "name": "shift",
            "location": 1094,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Polynomial.exponent": {
            "name": "exponent",
            "location": 1099,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Periodic.__init__": {
            "name": "__init__",
            "location": 1149,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "period": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Periodic._init_kernel": {
            "name": "_init_kernel",
            "location": 1169,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Periodic.amplitude": {
            "name": "amplitude",
            "location": 1179,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Periodic.period": {
            "name": "period",
            "location": 1184,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Exponential.__init__": {
            "name": "__init__",
            "location": 1216,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Exponential._init_kernel": {
            "name": "_init_kernel",
            "location": 1234,
            "return": [
                "pymc4.gp._kernel._Exponential"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Exponential.amplitude": {
            "name": "amplitude",
            "location": 1243,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Gibbs.__init__": {
            "name": "__init__",
            "location": 1292,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale_fn": [],
                "fn_args": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Gibbs._init_kernel": {
            "name": "_init_kernel",
            "location": 1312,
            "return": [
                "pymc4.gp._kernel._Gibbs"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Cosine.__init__": {
            "name": "__init__",
            "location": 1356,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [],
                "amplitude": [],
                "feature_ndims": [],
                "active_dims": [],
                "scale_diag": []
            }
        },
        "Cosine._init_kernel": {
            "name": "_init_kernel",
            "location": 1374,
            "return": [
                "pymc4.gp._kernel._Cosine"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "Cosine.amplitude": {
            "name": "amplitude",
            "location": 1383,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ScaledCov.__init__": {
            "name": "__init__",
            "location": 1423,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernel": [],
                "scaling_fn": [],
                "fn_args": []
            }
        },
        "ScaledCov._init_kernel": {
            "name": "_init_kernel",
            "location": 1440,
            "return": [
                "pymc4.gp._kernel._ScaledCov"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "ScaledCov.kernel": {
            "name": "kernel",
            "location": 1450,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ScaledCov.scaling_fn": {
            "name": "scaling_fn",
            "location": 1454,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "ScaledCov.fn_args": {
            "name": "fn_args",
            "location": 1458,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "WarpedInput.__init__": {
            "name": "__init__",
            "location": 1490,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernel": [],
                "warp_fn": [],
                "fn_args": []
            }
        },
        "WarpedInput._init_kernel": {
            "name": "_init_kernel",
            "location": 1509,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": []
            }
        },
        "WarpedInput.kernel": {
            "name": "kernel",
            "location": 1514,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "WarpedInput.warp_fn": {
            "name": "warp_fn",
            "location": 1518,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "WarpedInput.fn_args": {
            "name": "fn_args",
            "location": 1522,
            "return": [],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/pymc4/gp/gp.py": {
        "BaseGP.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "cov_fn": [
                    "int",
                    "bool",
                    "float"
                ],
                "mean_fn": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "BaseGP.prior": {
            "name": "prior",
            "location": 25,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "str",
                    "bool"
                ],
                "X": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "BaseGP.conditional": {
            "name": "conditional",
            "location": 36,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Iterable[str]",
                    "bool"
                ],
                "Xnew": [
                    "str",
                    "Iterable[str]",
                    "bool"
                ],
                "given": [
                    "str",
                    "Iterable[str]",
                    "bool"
                ]
            }
        },
        "BaseGP.predict": {
            "name": "predict",
            "location": 48,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "Xnew": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "BaseGP.marginal_likelihood": {
            "name": "marginal_likelihood",
            "location": 51,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "int",
                    "str",
                    "bool"
                ],
                "X": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "LatentGP._is_univariate": {
            "name": "_is_univariate",
            "location": 110,
            "return": [
                "str",
                "Union[int, float]",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "LatentGP._build_prior": {
            "name": "_build_prior",
            "location": 114,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "bool",
                    "Optional[str]",
                    "Iterable[Sequence[str]]",
                    "str"
                ],
                "X": [
                    "str",
                    "float",
                    "int",
                    "bool",
                    "Sequence[float]"
                ],
                "jitter": [
                    "str",
                    "int",
                    "Iterable[int]",
                    "Sequence[float]",
                    "bool"
                ]
            }
        },
        "LatentGP._get_given_vals": {
            "name": "_get_given_vals",
            "location": 119,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "given": [
                    "float",
                    "str"
                ]
            }
        },
        "LatentGP._build_conditional": {
            "name": "_build_conditional",
            "location": 139,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "Xnew": [
                    "Iterable[List[T]]",
                    "int",
                    "T"
                ],
                "X": [
                    "int",
                    "str"
                ],
                "f": [
                    "int",
                    "Dict[str, Any]",
                    "bool"
                ],
                "cov_total": [
                    "float",
                    "Union[bytes, bytearray, memoryview]",
                    "int"
                ],
                "mean_total": [
                    "int",
                    "float",
                    "Iterable[str]"
                ],
                "jitter": [
                    "int"
                ]
            }
        },
        "LatentGP.prior": {
            "name": "prior",
            "location": 168,
            "return": [
                "Union[(pymc4.distributions.continuous.Normal, pymc4.distributions.multivariate.MvNormal, pymc4.distributions.multivariate.MvNormalCholesky)]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str",
                    "Optional[str]",
                    "tuple"
                ],
                "X": [
                    "str",
                    "int",
                    "float",
                    "complex"
                ]
            }
        },
        "LatentGP.conditional": {
            "name": "conditional",
            "location": 237,
            "return": [
                "Union[(pymc4.distributions.continuous.Normal, pymc4.distributions.multivariate.MvNormal, pymc4.distributions.multivariate.MvNormalCholesky)]"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ],
                "Xnew": [
                    "float",
                    "Tuple[int, int]",
                    "Set[int]",
                    "KT",
                    "T",
                    "str"
                ],
                "given": [
                    "str",
                    "float"
                ]
            }
        }
    },
    "pymc4-master/pymc4/gp/mean.py": {
        "Mean.__init__": {
            "name": "__init__",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "feature_ndims": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Mean.__call__": {
            "name": "__call__",
            "location": 27,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "bool",
                    "T"
                ]
            }
        },
        "Mean.__add__": {
            "name": "__add__",
            "location": 44,
            "return": [
                "MeanAdd"
            ],
            "arguments": {
                "self": [],
                "mean2": [
                    "int",
                    "Optional[str]",
                    "str",
                    "None"
                ]
            }
        },
        "Mean.__mul__": {
            "name": "__mul__",
            "location": 47,
            "return": [
                "MeanProd"
            ],
            "arguments": {
                "self": [],
                "mean2": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "MeanAdd.__init__": {
            "name": "__init__",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mean1": [
                    "int",
                    "float",
                    "bool"
                ],
                "mean2": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MeanAdd.__call__": {
            "name": "__call__",
            "location": 70,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "util.ArrayLike",
                    "int"
                ]
            }
        },
        "MeanProd.__init__": {
            "name": "__init__",
            "location": 86,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mean1": [
                    "int",
                    "float",
                    "bool"
                ],
                "mean2": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MeanProd.__call__": {
            "name": "__call__",
            "location": 93,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "bool",
                    "util.ArrayLike",
                    "int"
                ]
            }
        },
        "Zero.__call__": {
            "name": "__call__",
            "location": 108,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float"
                ]
            }
        },
        "Constant.__init__": {
            "name": "__init__",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "coef": [
                    "int",
                    "bool",
                    "float"
                ],
                "feature_ndims": [
                    "int",
                    "denite.util.Nvim",
                    "bool",
                    "deoplete.util.Nvim",
                    "Dict[str,Any]",
                    "Callable[[Any,Any],bool]"
                ]
            }
        },
        "Constant.__call__": {
            "name": "__call__",
            "location": 131,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float"
                ]
            }
        }
    },
    "pymc4-master/pymc4/gp/util.py": {
        "stabilize": {
            "name": "stabilize",
            "location": 15,
            "return": [
                "str",
                "bytes",
                "bool"
            ],
            "arguments": {
                "K": [
                    "float",
                    "bool",
                    "List"
                ],
                "shift": [
                    "None",
                    "Optional[int]",
                    "int",
                    "Optional[Union[bool,int]]",
                    "Dict",
                    "float",
                    "Optional[dict]",
                    "bool",
                    "Optional[numpy.ndarray]",
                    "Optional[float]"
                ]
            }
        },
        "_inherit_docs": {
            "name": "_inherit_docs",
            "location": 24,
            "return": [
                "Callable[([Any], Any)]"
            ],
            "arguments": {
                "frommeth": [
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "_build_docs": {
            "name": "_build_docs",
            "location": 37,
            "return": [
                "str",
                "bool",
                "float"
            ],
            "arguments": {
                "meth_or_cls": [
                    "str",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "_inherit_docs.inherit": {
            "name": "inherit",
            "location": 27,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tometh": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "pymc4-master/pymc4/gp/_kernel.py": {
        "_Constant.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "coef": [
                    "bool",
                    "None",
                    "Optional[bool]",
                    "float",
                    "Optional[int]",
                    "List[Any]",
                    "Optional[float]",
                    "Optional[List[Any]]"
                ],
                "feature_ndims": [
                    "int",
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "validate_args": [
                    "bool",
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "name": [
                    "Text",
                    "str",
                    "Optional[bytes]"
                ]
            }
        },
        "_Constant._apply": {
            "name": "_apply",
            "location": 33,
            "return": [
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "int",
                    "tensorflow.Tensor"
                ],
                "x2": [
                    "float",
                    "int",
                    "tensorflow.Tensor"
                ],
                "example_ndims": [
                    "int",
                    "str",
                    "float",
                    "Container",
                    "List[str]"
                ]
            }
        },
        "_Constant.coef": {
            "name": "coef",
            "location": 46,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Constant._batch_shape": {
            "name": "_batch_shape",
            "location": 49,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Constant._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 53,
            "return": [
                "str",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Constant._parameter_control_dependencies": {
            "name": "_parameter_control_dependencies",
            "location": 56,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "is_init": [
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]",
                    "None",
                    "Optional[T]",
                    "Dict[str,Any]",
                    "Optional[int]",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "Optional[str]"
                ]
            }
        },
        "_WhiteNoise.__init__": {
            "name": "__init__",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "noise": [
                    "bool",
                    "None",
                    "Optional[bool]",
                    "float",
                    "Optional[int]",
                    "List[Any]",
                    "Optional[float]",
                    "Optional[List[Any]]"
                ],
                "feature_ndims": [
                    "int",
                    "str",
                    "Type[Any]",
                    "Optional[Type[Any]]",
                    "bool"
                ],
                "validate_args": [
                    "bool",
                    "str",
                    "Type[Any]",
                    "Optional[Type[Any]]"
                ],
                "name": [
                    "Text",
                    "str",
                    "Optional[bytes]"
                ]
            }
        },
        "_WhiteNoise._apply": {
            "name": "_apply",
            "location": 84,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "bool",
                    "Exception",
                    "T"
                ],
                "x2": [
                    "bool",
                    "Exception",
                    "T"
                ],
                "example_ndims": [
                    "int",
                    "bool",
                    "T",
                    "Exception"
                ]
            }
        },
        "_WhiteNoise._matrix": {
            "name": "_matrix",
            "location": 87,
            "return": [
                "str",
                "List[int]",
                "float",
                "List",
                "List[list[float]]",
                "Dict[str,int]"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "int"
                ],
                "x2": [
                    "float",
                    "int"
                ]
            }
        },
        "_WhiteNoise.noise": {
            "name": "noise",
            "location": 105,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_WhiteNoise._batch_shape": {
            "name": "_batch_shape",
            "location": 108,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_WhiteNoise._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 112,
            "return": [
                "List",
                "bool",
                "Callable"
            ],
            "arguments": {
                "self": []
            }
        },
        "_WhiteNoise._parameter_control_dependencies": {
            "name": "_parameter_control_dependencies",
            "location": 115,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "is_init": [
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]",
                    "None",
                    "Optional[T]",
                    "Dict[str,Any]",
                    "Optional[int]",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "Optional[str]"
                ]
            }
        },
        "_Exponential.__init__": {
            "name": "__init__",
            "location": 130,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "amplitude": [
                    "bool",
                    "None",
                    "Callable",
                    "List[int]",
                    "Optional[List[int]]",
                    "str",
                    "Optional[int]"
                ],
                "length_scale": [
                    "int",
                    "List[int]",
                    "None",
                    "str"
                ],
                "feature_ndims": [
                    "int",
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "validate_args": [
                    "bool",
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "name": [
                    "Text",
                    "Dict[str,Any]",
                    "Optional[str]",
                    "Optional[Dict[str,Any]]",
                    "bool",
                    "int",
                    "Optional[bool]"
                ]
            }
        },
        "_Exponential.length_scale": {
            "name": "length_scale",
            "location": 152,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Exponential.amplitude": {
            "name": "amplitude",
            "location": 156,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Exponential._apply": {
            "name": "_apply",
            "location": 159,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "int"
                ],
                "x2": [
                    "float",
                    "int"
                ],
                "example_ndims": [
                    "int",
                    "Dict",
                    "str",
                    "float"
                ]
            }
        },
        "_Exponential._batch_shape": {
            "name": "_batch_shape",
            "location": 176,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Exponential._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 183,
            "return": [
                "str",
                "bool",
                "bytearray"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Exponential._parameter_control_dependencies": {
            "name": "_parameter_control_dependencies",
            "location": 189,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "is_init": [
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]",
                    "None",
                    "Optional[T]",
                    "Dict[str,Any]",
                    "Optional[int]",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "Optional[str]"
                ]
            }
        },
        "_Gibbs.__init__": {
            "name": "__init__",
            "location": 204,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale_fn": [
                    "int",
                    "float",
                    "None"
                ],
                "fn_args": [
                    "None",
                    "Callable[[Optional,Optional,str],None]",
                    "List[str]",
                    "Callable[_,None]",
                    "Optional[tuple]",
                    "bool",
                    "Tuple",
                    "Sequence",
                    "Alternate"
                ],
                "feature_ndims": [
                    "int",
                    "str",
                    "bool",
                    "Optional[int]",
                    "Optional[Sequence[str]]",
                    "Optional[str]"
                ],
                "dtype": [
                    "str",
                    "bool",
                    "int",
                    "Optional[int]",
                    "Optional[Sequence[str]]",
                    "Optional[str]"
                ],
                "validate_args": [
                    "bool",
                    "str",
                    "int",
                    "Optional[int]",
                    "Optional[Sequence[str]]",
                    "Optional[str]"
                ],
                "name": [
                    "Text",
                    "str",
                    "Optional[str]",
                    "Tuple",
                    "bool",
                    "float"
                ]
            }
        },
        "_Gibbs._log_apply": {
            "name": "_log_apply",
            "location": 225,
            "return": [
                "str",
                "List[bytes]",
                "Iterable[float]",
                "int",
                "float"
            ],
            "arguments": {
                "self": [],
                "lx1": [
                    "str",
                    "float"
                ],
                "lx2": [
                    "str",
                    "float"
                ]
            }
        },
        "_Gibbs._fast_apply": {
            "name": "_fast_apply",
            "location": 236,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [],
                "x2": []
            }
        },
        "_Gibbs._apply": {
            "name": "_apply",
            "location": 248,
            "return": [
                "bool",
                "List[str]",
                "int"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "int",
                    "Iterable[T]"
                ],
                "x2": [
                    "float"
                ],
                "example_ndims": [
                    "int",
                    "bool",
                    "T",
                    "Exception"
                ]
            }
        },
        "_Gibbs._batch_shape": {
            "name": "_batch_shape",
            "location": 264,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Gibbs._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 267,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Gibbs._parameter_control_dependencies": {
            "name": "_parameter_control_dependencies",
            "location": 270,
            "return": [
                "List[nothing]"
            ],
            "arguments": {
                "self": [],
                "is_init": [
                    "bool"
                ]
            }
        },
        "_Cosine.__init__": {
            "name": "__init__",
            "location": 275,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "length_scale": [
                    "bool",
                    "None",
                    "Callable",
                    "List[float]",
                    "str",
                    "int"
                ],
                "amplitude": [
                    "bool",
                    "str",
                    "None"
                ],
                "feature_ndims": [
                    "int",
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "validate_args": [
                    "bool",
                    "Optional[bool]",
                    "str",
                    "Optional[str]",
                    "List[str]"
                ],
                "name": [
                    "Text",
                    "Dict[str,Any]",
                    "Optional[str]",
                    "Optional[Dict[str,Any]]",
                    "bool",
                    "int",
                    "Optional[bool]"
                ]
            }
        },
        "_Cosine.length_scale": {
            "name": "length_scale",
            "location": 297,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Cosine.amplitude": {
            "name": "amplitude",
            "location": 301,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Cosine._apply": {
            "name": "_apply",
            "location": 304,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float",
                    "int"
                ],
                "x2": [
                    "float",
                    "int"
                ],
                "example_ndims": [
                    "int",
                    "Dict",
                    "str",
                    "float"
                ]
            }
        },
        "_Cosine._batch_shape": {
            "name": "_batch_shape",
            "location": 324,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Cosine._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 334,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_Cosine._parameter_control_dependencies": {
            "name": "_parameter_control_dependencies",
            "location": 343,
            "return": [
                "list"
            ],
            "arguments": {
                "self": [],
                "is_init": [
                    "bool",
                    "Optional[bool]",
                    "Sequence[str]",
                    "None",
                    "Optional[T]",
                    "Dict[str,Any]",
                    "Optional[int]",
                    "str",
                    "Optional[Dict[str,Any]]",
                    "Optional[str]"
                ]
            }
        },
        "_ScaledCov.__init__": {
            "name": "__init__",
            "location": 406,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kernel": [
                    "str",
                    "None",
                    "Callable",
                    "Optional[Callable]",
                    "Optional[int]",
                    "int",
                    "Optional[Sequence[str]]",
                    "Sequence[str]",
                    "Optional[str]"
                ],
                "scaling_fn": [
                    "float",
                    "None",
                    "bool",
                    "Callable",
                    "bytes",
                    "Dict[str,Tuple[str,int,int]]",
                    "Dict[str,Tuple[str,str,Any]]",
                    "Dict[str,tuple[Union[str,int,int]]]",
                    "Dict[str,tuple[Union[str,str,Any]]]"
                ],
                "fn_args": [
                    "Optional[str]",
                    "None",
                    "Sequence[str]",
                    "str",
                    "Optional[static_frame.core.util.DepthLevelSpecifier]",
                    "Optional[int]",
                    "int",
                    "Optional[float]",
                    "float"
                ],
                "feature_ndims": [
                    "int",
                    "str",
                    "bool",
                    "Type[Any]",
                    "Optional[Type[Any]]"
                ],
                "validate_args": [
                    "bool",
                    "str",
                    "Type[Any]",
                    "Optional[Type[Any]]",
                    "int"
                ],
                "name": [
                    "Text",
                    "bool",
                    "int",
                    "Optional[str]",
                    "Optional[Dict[str,Any]]",
                    "Optional[Any]",
                    "Dict",
                    "Dict[str,Any]",
                    "str"
                ]
            }
        },
        "_ScaledCov.kernel": {
            "name": "kernel",
            "location": 431,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ScaledCov.scaling_fn": {
            "name": "scaling_fn",
            "location": 435,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ScaledCov.fn_Args": {
            "name": "fn_Args",
            "location": 439,
            "return": [
                "str",
                "bool",
                "List[Tuple[str, str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ScaledCov._apply": {
            "name": "_apply",
            "location": 442,
            "return": [
                "float",
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float"
                ],
                "x2": [
                    "float"
                ],
                "example_ndims": [
                    "float",
                    "int"
                ]
            }
        },
        "_ScaledCov._matrix": {
            "name": "_matrix",
            "location": 451,
            "return": [
                "float",
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "x1": [
                    "float"
                ],
                "x2": [
                    "float"
                ]
            }
        },
        "_ScaledCov._batch_shape": {
            "name": "_batch_shape",
            "location": 470,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ScaledCov._batch_shape_tensor": {
            "name": "_batch_shape_tensor",
            "location": 473,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "_ScaledCov._parameter_control_dependencies": {
            "name": "_parameter_control_dependencies",
            "location": 476,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "is_init": [
                    "int",
                    "Dict[int,int]"
                ]
            }
        }
    },
    "pymc4-master/pymc4/gp/__init__.py": {},
    "pymc4-master/pymc4/inference/sampling.py": {
        "check_proposal_functions": {
            "name": "check_proposal_functions",
            "location": 14,
            "return": [
                "bool"
            ],
            "arguments": {
                "model": [
                    "str",
                    "Optional[dict]",
                    "Dict",
                    "None"
                ],
                "state": [
                    "tensorflow.keras.Model",
                    "None",
                    "str",
                    "Optional[dict]",
                    "Dict"
                ],
                "observed": [
                    "str",
                    "None",
                    "Optional[dict]",
                    "Dict"
                ]
            }
        },
        "sample": {
            "name": "sample",
            "location": 52,
            "return": [
                "bool"
            ],
            "arguments": {
                "model": [
                    "str",
                    "bool"
                ],
                "sampler_type": [
                    "str",
                    "bool",
                    "None",
                    "Optional[list]",
                    "List"
                ],
                "num_samples": [
                    "int",
                    "Optional[int]",
                    "float",
                    "str"
                ],
                "num_chains": [
                    "int",
                    "Optional[int]",
                    "float",
                    "str"
                ],
                "burn_in": [
                    "int",
                    "Optional[int]",
                    "Optional[str]",
                    "Optional[bool]",
                    "bool",
                    "float"
                ],
                "observed": [
                    "None",
                    "Optional[int]",
                    "int",
                    "str",
                    "bool",
                    "Optional[str]",
                    "tensorflow.keras.Model",
                    "Optional[bool]"
                ],
                "state": [
                    "None",
                    "Optional[int]",
                    "int",
                    "str",
                    "bool",
                    "Optional[str]",
                    "tensorflow.keras.Model",
                    "Optional[bool]"
                ],
                "xla": [
                    "bool",
                    "int",
                    "Optional[int]",
                    "float",
                    "str"
                ],
                "use_auto_batching": [
                    "bool",
                    "int",
                    "Optional[int]",
                    "float",
                    "str"
                ],
                "sampler_methods": [
                    "str",
                    "bool",
                    "None"
                ],
                "trace_discrete": [
                    "int",
                    "None",
                    "float",
                    "Optional[int]",
                    "str"
                ],
                "seed": [
                    "int",
                    "None",
                    "float",
                    "Optional[int]",
                    "str"
                ],
                "include_log_likelihood": [
                    "bool",
                    "int",
                    "Optional[int]",
                    "float",
                    "str"
                ]
            }
        },
        "auto_assign_sampler": {
            "name": "auto_assign_sampler",
            "location": 187,
            "return": [
                "Union[(str, _T1)]"
            ],
            "arguments": {
                "model": [
                    "int",
                    "Optional[int]",
                    "None",
                    "Optional[str]",
                    "List[str]",
                    "str",
                    "Optional[bool]",
                    "Dict[str,Any]",
                    "Optional[Dict[str,Any]]",
                    "bool"
                ],
                "sampler_type": [
                    "str",
                    "None",
                    "bool",
                    "Dict",
                    "logging.Logger"
                ]
            }
        }
    },
    "pymc4-master/pymc4/inference/__init__.py": {},
    "pymc4-master/pymc4/mcmc/samplers.py": {
        "register_sampler": {
            "name": "register_sampler",
            "location": 37,
            "return": [
                "bool",
                "Dict[str,Any]",
                "str",
                "Callable[[str],T]"
            ],
            "arguments": {
                "cls": [
                    "bool",
                    "T",
                    "int"
                ]
            }
        },
        "build_logp_and_deterministic_functions": {
            "name": "build_logp_and_deterministic_functions",
            "location": 729,
            "return": [
                "Tuple[(Any, dict, Any, list, Any)]"
            ],
            "arguments": {
                "model": [
                    "bool",
                    "Optional[int]",
                    "None",
                    "Optional[dict]",
                    "Dict",
                    "Optional[List]",
                    "List"
                ],
                "num_chains": [
                    "bool",
                    "None",
                    "Optional[int]",
                    "Optional[dict]",
                    "Dict",
                    "Optional[List]",
                    "List"
                ],
                "observed": [
                    "bool",
                    "None",
                    "Optional[int]",
                    "Optional[dict]",
                    "Dict",
                    "Optional[List]",
                    "List"
                ],
                "state": [
                    "None",
                    "Dict",
                    "Optional[pymc4.flow.SamplingState]",
                    "str",
                    "bool",
                    "Optional[Literal[only_clustered,include_clustered]]"
                ],
                "collect_reduced_log_prob": [
                    "bool",
                    "Optional[int]",
                    "Optional[dict]",
                    "Optional[List]"
                ],
                "parent_inds": [
                    "Dict",
                    "bool",
                    "List",
                    "Optional[int]",
                    "Optional[dict]",
                    "Optional[List]"
                ]
            }
        },
        "vectorize_logp_function": {
            "name": "vectorize_logp_function",
            "location": 820,
            "return": [
                "Callable"
            ],
            "arguments": {
                "logpfn": [
                    "str",
                    "Iterable",
                    "bool"
                ]
            }
        },
        "tile_init": {
            "name": "tile_init",
            "location": 828,
            "return": [
                "list"
            ],
            "arguments": {
                "init": [
                    "int"
                ],
                "num_repeats": [
                    "int"
                ]
            }
        },
        "calculate_log_likelihood": {
            "name": "calculate_log_likelihood",
            "location": 832,
            "return": [
                "dict"
            ],
            "arguments": {
                "model": [
                    "List[dict[str,Any]]",
                    "List[Dict[str,Any]]",
                    "pystork.model.Model"
                ],
                "posterior": [
                    "Dict[str,Any]",
                    "int",
                    "Dict[str,Dict[str,Any]]",
                    "Dict[str,dict[str,Any]]"
                ],
                "sampling_state": [
                    "float",
                    "Dict[str,tensorflow.Tensor]"
                ]
            }
        },
        "_BaseSampler.__init__": {
            "name": "__init__",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "int",
                    "str",
                    "Dict",
                    "allennlp.models.Model"
                ]
            }
        },
        "_BaseSampler._sample": {
            "name": "_sample",
            "location": 78,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": []
            }
        },
        "_BaseSampler._run_chains": {
            "name": "_run_chains",
            "location": 173,
            "return": [
                "Tuple",
                "str",
                "int",
                "Set[str]",
                "Mapping[str,int]",
                "bool",
                "Parameter"
            ],
            "arguments": {
                "self": [],
                "init": [
                    "int",
                    "float"
                ],
                "burn_in": [
                    "int",
                    "float"
                ]
            }
        },
        "_BaseSampler._assign_arguments": {
            "name": "_assign_arguments",
            "location": 191,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "kwargs": []
            }
        },
        "_BaseSampler._check_arguments": {
            "name": "_check_arguments",
            "location": 209,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_BaseSampler._bound_kwargs": {
            "name": "_bound_kwargs",
            "location": 222,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_BaseSampler.__call__": {
            "name": "__call__",
            "location": 231,
            "return": [
                "Sequence['cirq.Qid']",
                "bool",
                "Iterable[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_BaseSampler._default_kernel_maker": {
            "name": "_default_kernel_maker",
            "location": 236,
            "return": [
                "pymc4.mcmc.utils.KERNEL_KWARGS_SET"
            ],
            "arguments": {
                "cls": [
                    "Dict",
                    "bool"
                ]
            }
        },
        "_BaseSampler.trace_fn": {
            "name": "trace_fn",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "current_state": [
                    "Dict"
                ],
                "pkr": [
                    "Dict"
                ]
            }
        },
        "HMC.__init__": {
            "name": "__init__",
            "location": 308,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "HMC.trace_fn": {
            "name": "trace_fn",
            "location": 312,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "current_state": [
                    "int",
                    "Dict",
                    "List",
                    "Dict[str,Any]"
                ],
                "pkr": [
                    "int",
                    "Dict",
                    "List",
                    "Dict[str,Any]"
                ]
            }
        },
        "NUTS.__init__": {
            "name": "__init__",
            "location": 408,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "NUTS.trace_fn": {
            "name": "trace_fn",
            "location": 412,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "current_state": [
                    "Any",
                    "pymc4.flow.SamplingState",
                    "Union[tensorflow.Tensor,Any]"
                ],
                "pkr": [
                    "Any",
                    "pymc4.flow.SamplingState",
                    "Union[tensorflow.Tensor,Any]"
                ]
            }
        },
        "RandomWalkM.__init__": {
            "name": "__init__",
            "location": 482,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RandomWalkM.trace_fn": {
            "name": "trace_fn",
            "location": 486,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "current_state": [
                    "str",
                    "Optional[Tuple[int,...]]",
                    "Tuple[Union[int,_]]",
                    "None"
                ],
                "pkr": [
                    "str",
                    "Optional[Tuple[int,...]]",
                    "Tuple[Union[int,...]]",
                    "None"
                ]
            }
        },
        "CompoundStep.__init__": {
            "name": "__init__",
            "location": 513,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompoundStep.trace_fn": {
            "name": "trace_fn",
            "location": 517,
            "return": [
                "tuple"
            ],
            "arguments": {
                "self": [],
                "current_state": [
                    "Sequence[str]",
                    "List[str]",
                    "str",
                    "Sequence[Sequence[str]]",
                    "Any",
                    "pymc4.flow.SamplingState",
                    "None",
                    "Union[tensorflow.Tensor,Any]",
                    "raiden.utils.Optional[str]"
                ],
                "pkr": [
                    "Sequence[str]",
                    "List[str]",
                    "str",
                    "Sequence[Sequence[str]]",
                    "Any",
                    "pymc4.flow.SamplingState",
                    "None",
                    "Union[tensorflow.Tensor,Any]",
                    "raiden.utils.Optional[str]"
                ]
            }
        },
        "CompoundStep._convert_sampler_methods": {
            "name": "_convert_sampler_methods",
            "location": 523,
            "return": [
                "Dict[(Any, Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "sampler_methods": [
                    "Dict",
                    "str"
                ]
            }
        },
        "CompoundStep._merge_samplers": {
            "name": "_merge_samplers",
            "location": 548,
            "return": [
                "Tuple[(List[Tuple[(Any, Any)]], list)]"
            ],
            "arguments": {
                "self": [],
                "make_kernel_fn": [
                    "Sequence['cirq.Qid']",
                    "Optional[List[str]]",
                    "Optional[int]",
                    "str",
                    "Dict[str, Any]"
                ],
                "part_kernel_kwargs": [
                    "Sequence[cirq.Qid]",
                    "Sequence[_]",
                    "Optional[List[str]]",
                    "str",
                    "List[str]",
                    "Dict[str,Any]",
                    "Optional[int]",
                    "None",
                    "int"
                ]
            }
        },
        "CompoundStep._assign_default_methods": {
            "name": "_assign_default_methods",
            "location": 612,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompoundStep.__call__": {
            "name": "__call__",
            "location": 708,
            "return": [
                "bool",
                "Mapping",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "CompoundStep._log_variables": {
            "name": "_log_variables",
            "location": 712,
            "return": [
                "None"
            ],
            "arguments": {
                "var_keys": [
                    "int",
                    "str",
                    "bool"
                ],
                "kernel_kwargs": [
                    "bool",
                    "int",
                    "raiden.utils.SecreHash"
                ],
                "set_lengths": [
                    "bool",
                    "int",
                    "raiden.utils.SecreHash"
                ],
                "parent_inds": [
                    "bytes",
                    "bool",
                    "Optional[Callable]"
                ],
                "func_names": [
                    "bool",
                    "str",
                    "List[str]"
                ]
            }
        },
        "build_logp_and_deterministic_functions.deterministics_callback": {
            "name": "deterministics_callback",
            "location": 797,
            "return": [
                "str",
                "bool",
                "Optional[Union[str, Any]]",
                "MutableSequence[utils.CWLObjectType]"
            ],
            "arguments": {}
        },
        "vectorize_logp_function.vectorized_logpfn": {
            "name": "vectorized_logpfn",
            "location": 822,
            "return": [
                "str",
                "dict",
                "trezor.utils.Writer"
            ],
            "arguments": {}
        },
        "calculate_log_likelihood.extract_log_likelihood": {
            "name": "extract_log_likelihood",
            "location": 837,
            "return": [
                "bool",
                "Dict[str, str]",
                "dict",
                "bytes",
                "str"
            ],
            "arguments": {
                "values": [
                    "float",
                    "str",
                    "Union[int, float]",
                    "int",
                    "List[str]"
                ],
                "observed_rv": [
                    "float",
                    "int"
                ]
            }
        },
        "CompoundStep._merge_samplers.cmp_": {
            "name": "cmp_",
            "location": 557,
            "return": [
                "bool"
            ],
            "arguments": {
                "item1": [
                    "dict",
                    "Dict[str, Any]",
                    "Collection",
                    "Callable"
                ],
                "item2": [
                    "dict",
                    "Dict[int, Dict[str, Any]]",
                    "Collection",
                    "Callable",
                    "list"
                ]
            }
        },
        "CompoundStep._merge_samplers.get_set": {
            "name": "get_set",
            "location": 576,
            "return": [
                "str",
                "Dict[str, Any]",
                "int"
            ],
            "arguments": {
                "p": [
                    "Optional[str]",
                    "bool"
                ]
            }
        },
        "CompoundStep._merge_samplers.union_set": {
            "name": "union_set",
            "location": 579,
            "return": [
                "None"
            ],
            "arguments": {
                "p1": [
                    "int",
                    "str",
                    "list",
                    "List[Dict[str, Any]]"
                ],
                "p2": [
                    "int",
                    "str",
                    "list",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "build_logp_and_deterministic_functions.logpfn": {
            "name": "logpfn",
            "location": 787,
            "return": [
                "bool",
                "Set[str]",
                "List[List[str]]",
                "cmk.utils.type_defs.ServiceName",
                "cmk.utils.type_defs.HostName"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/pymc4/mcmc/tf_support.py": {
        "_target_log_prob_fn_part_compound": {
            "name": "_target_log_prob_fn_part_compound",
            "location": 12,
            "return": [
                "dict",
                "Dict[str, str]",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "_target_log_prob_fn_part_gibbs": {
            "name": "_target_log_prob_fn_part_gibbs",
            "location": 21,
            "return": [
                "dict",
                "Dict[str, str]",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "kernel_create_object": {
            "name": "kernel_create_object",
            "location": 28,
            "return": [
                "List[List[str]]"
            ],
            "arguments": {
                "sampleri": [
                    "bool"
                ],
                "curr_indx": [
                    "int"
                ],
                "setli": [
                    "int"
                ],
                "current_state": [
                    "int"
                ],
                "target_log_prob_fn": [
                    "int"
                ],
                "target_log_prob_fn_part": [
                    "int"
                ]
            }
        },
        "_CompoundGibbsStepTF.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "target_log_prob_fn": [
                    "str",
                    "int",
                    "Mapping",
                    "bool"
                ],
                "compound_samplers": [
                    "str",
                    "bool",
                    "Sequence[Sequence[float]]",
                    "int"
                ],
                "compound_set_lengths": [
                    "bool",
                    "float",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "name": [
                    "str",
                    "None",
                    "Optional[str]",
                    "Dict",
                    "Dict[str,Dict[str,Any]]",
                    "int",
                    "Dict[str,dict[str,Any]]",
                    "Optional[Dict[str,str]]",
                    "Dict[str,str]"
                ]
            }
        },
        "_CompoundGibbsStepTF.target_log_prob_fn": {
            "name": "target_log_prob_fn",
            "location": 84,
            "return": [
                "str",
                "numpy.ndarray",
                "List[Dict[str, Any]]",
                "tuple",
                "float",
                "list",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CompoundGibbsStepTF.parameters": {
            "name": "parameters",
            "location": 88,
            "return": [
                "int",
                "\"DGEList\"",
                "Type"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CompoundGibbsStepTF.name": {
            "name": "name",
            "location": 92,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CompoundGibbsStepTF.is_calibrated": {
            "name": "is_calibrated",
            "location": 96,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "_CompoundGibbsStepTF.one_step": {
            "name": "one_step",
            "location": 99,
            "return": [
                "List[Union[(CompoundGibbsStepResults, list)]]"
            ],
            "arguments": {
                "self": [],
                "current_state": [],
                "previous_kernel_results": [
                    "int",
                    "float"
                ],
                "seed": [
                    "None"
                ]
            }
        },
        "_CompoundGibbsStepTF.bootstrap_results": {
            "name": "bootstrap_results",
            "location": 130,
            "return": [
                "CompoundGibbsStepResults"
            ],
            "arguments": {
                "self": [],
                "init_state": [
                    "Union[int, numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "_CompoundStepTF.__init__": {
            "name": "__init__",
            "location": 158,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_GibbsStepTF.__init__": {
            "name": "__init__",
            "location": 167,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/pymc4/mcmc/utils.py": {
        "initialize_sampling_state": {
            "name": "initialize_sampling_state",
            "location": 14,
            "return": [
                "Tuple[(Any, list)]"
            ],
            "arguments": {
                "model": [
                    "Optional[dict]",
                    "str",
                    "Dict",
                    "None"
                ],
                "observed": [
                    "Optional[dict]",
                    "str",
                    "None",
                    "Dict"
                ],
                "state": [
                    "Optional[dict]",
                    "None",
                    "str",
                    "Optional[pymc4.flow.SamplingState]",
                    "Dict[str,float]",
                    "Dict"
                ]
            }
        },
        "initialize_state": {
            "name": "initialize_state",
            "location": 39,
            "return": [
                "Tuple[(Any, Any, list, list, Any, Any)]"
            ],
            "arguments": {
                "model": [
                    "int",
                    "Dict",
                    "bool"
                ],
                "observed": [
                    "None",
                    "Optional[dict]",
                    "Dict",
                    "Dict[str,Any]",
                    "Optional[Dict[str,Any]]"
                ],
                "state": [
                    "Optional[pymc4.flow.SamplingState]",
                    "None",
                    "Set[str]",
                    "Optional[dict]",
                    "Dict"
                ]
            }
        },
        "trace_to_arviz": {
            "name": "trace_to_arviz",
            "location": 95,
            "return": [
                "bool",
                "Dict[str, Dict[str, float]]",
                "bytes",
                "str",
                "Dict[str, str]",
                "int"
            ],
            "arguments": {
                "trace": [
                    "Dict",
                    "Optional[Union[AbstractSetIntStr,MappingIntStrAny]]",
                    "Optional[numpy.ndarray]",
                    "Optional[dict]",
                    "str",
                    "int",
                    "Optional[Tuple[Any]]"
                ],
                "sample_stats": [
                    "Dict",
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray",
                    "Optional[Dict]"
                ],
                "observed_data": [
                    "bool",
                    "None",
                    "Dict",
                    "Dict[str,Any]",
                    "numpy.ndarray",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ],
                "prior_predictive": [
                    "Optional[numpy.ndarray]",
                    "numpy.ndarray"
                ],
                "posterior_predictive": [
                    "bool",
                    "None",
                    "Optional[Dict]",
                    "Optional[numpy.array]",
                    "Dict"
                ],
                "log_likelihood": [
                    "Dict",
                    "bool",
                    "Optional[Dict]",
                    "Optional[float]"
                ],
                "inplace": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "TextIO",
                    "Optional[List[str]]"
                ]
            }
        },
        "scope_remove_transformed_part_if_required": {
            "name": "scope_remove_transformed_part_if_required",
            "location": 147,
            "return": [
                "Tuple[(str, Any)]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "bool",
                    "Dict[str,Any]"
                ],
                "transformed_values": [
                    "Dict[str,Any]",
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "pymc4-master/pymc4/mcmc/__init__.py": {},
    "pymc4-master/pymc4/plots/gp_plots.py": {
        "plot_gp_dist": {
            "name": "plot_gp_dist",
            "location": 5,
            "return": [
                "int",
                "Callable",
                "Dict[str,Any]",
                "str",
                "bytes"
            ],
            "arguments": {
                "ax": [
                    "int",
                    "Dict[str,Any]",
                    "bytes",
                    "bool"
                ],
                "samples": [
                    "Collection[int]",
                    "Collection",
                    "int",
                    "Union[int,float]",
                    "Sequence[int]",
                    "float"
                ],
                "x": [
                    "Tuple[int]",
                    "float",
                    "Sequence[int]",
                    "numpy.ndarray"
                ],
                "plot_samples": [
                    "bool",
                    "List[int]",
                    "Optional[float]",
                    "int"
                ],
                "palette": [
                    "Text",
                    "str",
                    "bool",
                    "int",
                    "numpy.ndarray"
                ],
                "fill_alpha": [
                    "float",
                    "numpy.ndarray",
                    "bool",
                    "int",
                    "bytes"
                ],
                "samples_alpha": [
                    "float",
                    "numpy.ndarray",
                    "Tuple[int]"
                ],
                "fill_kwargs": [
                    "None",
                    "Optional[Dict[str,numpy.ma.MaskedArray]]",
                    "int",
                    "Dict[str,numpy.ma.MaskedArray]",
                    "Optional[Callable]",
                    "Callable",
                    "Optional[float]",
                    "float",
                    "numpy.ndarray",
                    "Dict[str,str]",
                    "Optional[Dict[str,str]]",
                    "Optional[numpy.ndarray]"
                ],
                "samples_kwargs": [
                    "Optional[Dict[str,numpy.ma.MaskedArray]]",
                    "None",
                    "Optional[numpy.ndarray]",
                    "Dict[str,numpy.ma.MaskedArray]"
                ]
            }
        }
    },
    "pymc4-master/pymc4/plots/__init__.py": {},
    "pymc4-master/pymc4/variational/approximations.py": {
        "fit": {
            "name": "fit",
            "location": 176,
            "return": [
                "ADVIFit"
            ],
            "arguments": {
                "model": [
                    "int",
                    "None",
                    "str",
                    "Optional[int]",
                    "bool"
                ],
                "method": [
                    "Text",
                    "int",
                    "Optional[int]",
                    "bool",
                    "str"
                ],
                "num_steps": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "str"
                ],
                "sample_size": [
                    "int",
                    "Optional[int]",
                    "bool",
                    "str"
                ],
                "random_seed": [
                    "int",
                    "None",
                    "str",
                    "Optional[int]",
                    "bool"
                ],
                "optimizer": [
                    "int",
                    "None",
                    "str",
                    "Optional[int]",
                    "bool"
                ]
            }
        },
        "Approximation.__init__": {
            "name": "__init__",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Dict",
                    "None",
                    "cmk.utils.type_defs.HostName"
                ],
                "random_seed": [
                    "str",
                    "None",
                    "int",
                    "float",
                    "Optional[List[str]]",
                    "List[str]"
                ]
            }
        },
        "Approximation._build_logp_and_deterministic_fn": {
            "name": "_build_logp_and_deterministic_fn",
            "location": 51,
            "return": [
                "Tuple[(Callable, Callable)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Approximation._build_posterior": {
            "name": "_build_posterior",
            "location": 81,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "Approximation.sample": {
            "name": "sample",
            "location": 84,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int"
                ],
                "include_log_likelihood": [
                    "bool",
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "MeanField._build_posterior": {
            "name": "_build_posterior",
            "location": 118,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "FullRank._build_posterior": {
            "name": "_build_posterior",
            "location": 146,
            "return": [
                "str",
                "numpy.ndarray",
                "Optional[int]",
                "trezor.utils.Writer"
            ],
            "arguments": {
                "self": []
            }
        },
        "LowRank._build_posterior": {
            "name": "_build_posterior",
            "location": 172,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "fit.run_approximation": {
            "name": "run_approximation",
            "location": 245,
            "return": [
                "str",
                "int",
                "bool",
                "list"
            ],
            "arguments": {}
        },
        "Approximation._build_logp_and_deterministic_fn.logpfn": {
            "name": "logpfn",
            "location": 55,
            "return": [
                "bool",
                "Callable[[KT], VT]"
            ],
            "arguments": {}
        },
        "Approximation._build_logp_and_deterministic_fn.deterministics_callback": {
            "name": "deterministics_callback",
            "location": 61,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "q_samples": [
                    "int",
                    "Callable[[int], None]",
                    "float"
                ]
            }
        },
        "Approximation._build_logp_and_deterministic_fn.vectorize_function": {
            "name": "vectorize_function",
            "location": 73,
            "return": [
                "int",
                "bool",
                "Iterator"
            ],
            "arguments": {
                "function": [
                    "Callable",
                    "Exception",
                    "Callable[..., T]"
                ]
            }
        },
        "Approximation._build_logp_and_deterministic_fn.vectorize_function.vectorizedfn": {
            "name": "vectorizedfn",
            "location": 74,
            "return": [
                "Optional[str]",
                "bool"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/pymc4/variational/updates.py": {
        "adadelta": {
            "name": "adadelta",
            "location": 8,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "learning_rate": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "rho": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "adagrad": {
            "name": "adagrad",
            "location": 58,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "learning_rate": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "adam": {
            "name": "adam",
            "location": 96,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "learning_rate": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "beta_1": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "beta_2": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "adamax": {
            "name": "adamax",
            "location": 141,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "learning_rate": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "beta_1": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "beta_2": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ],
                "epsilon": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "sgd": {
            "name": "sgd",
            "location": 180,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "learning_rate": [
                    "float",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "pymc4-master/pymc4/variational/util.py": {
        "ArrayOrdering.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "free_rvs": [
                    "str",
                    "int"
                ]
            }
        },
        "ArrayOrdering.flatten": {
            "name": "flatten",
            "location": 31,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayOrdering.split": {
            "name": "split",
            "location": 36,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "flatten_tensor": [
                    "Optional[bytes]",
                    "bytes",
                    "List[str]",
                    "Dict",
                    "bool",
                    "None"
                ]
            }
        },
        "ArrayOrdering.split_samples": {
            "name": "split_samples",
            "location": 44,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "samples": [
                    "str",
                    "int",
                    "Dict",
                    "bool"
                ],
                "n": [
                    "int",
                    "Dict",
                    "str",
                    "bool"
                ]
            }
        }
    },
    "pymc4-master/pymc4/variational/__init__.py": {},
    "pymc4-master/tests/conftest.py": {
        "tf_seed": {
            "name": "tf_seed",
            "location": 21,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "simple_model": {
            "name": "simple_model",
            "location": 27,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "simple_model_with_deterministic": {
            "name": "simple_model_with_deterministic",
            "location": 37,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "simple_model": [
                    "Exception",
                    "bool",
                    "Dict",
                    "str"
                ]
            }
        },
        "simple_model_no_free_rvs": {
            "name": "simple_model_no_free_rvs",
            "location": 48,
            "return": [
                "bool",
                "str",
                "OrderedDict"
            ],
            "arguments": {}
        },
        "unvectorized_model": {
            "name": "unvectorized_model",
            "location": 64,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]",
                    "List",
                    "bool"
                ]
            }
        },
        "xla_fixture": {
            "name": "xla_fixture",
            "location": 78,
            "return": [
                "bool",
                "int",
                "List"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "deterministics_in_nested_models": {
            "name": "deterministics_in_nested_models",
            "location": 83,
            "return": [
                "Tuple[Union[set[Text],dict[Text,tuple[Union[list[Text],Callable]]]]]",
                "numpy.ndarray",
                "Optional[numpy.ndarray]",
                "Callable"
            ],
            "arguments": {}
        },
        "use_auto_batching_fixture": {
            "name": "use_auto_batching_fixture",
            "location": 129,
            "return": [
                "bool",
                "int",
                "float"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "vectorized_model_fixture": {
            "name": "vectorized_model_fixture",
            "location": 134,
            "return": [
                "Tuple[Union[bool,dict[Text,tuple[int]]]]",
                "bool",
                "Dict[str,Any]",
                "Dict"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]",
                    "List",
                    "bool"
                ]
            }
        },
        "get_batch_shape": {
            "name": "get_batch_shape",
            "location": 178,
            "return": [
                "int",
                "Optional[int]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "get_sample_shape": {
            "name": "get_sample_shape",
            "location": 183,
            "return": [
                "int",
                "Optional[int]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "get_feature_shape": {
            "name": "get_feature_shape",
            "location": 188,
            "return": [
                "int",
                "Optional[int]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "get_data": {
            "name": "get_data",
            "location": 193,
            "return": [
                "Tuple[Union[str,bool]]",
                "str",
                "Optional[Dict[str,Any]]",
                "int"
            ],
            "arguments": {
                "get_batch_shape": [
                    "str",
                    "bool",
                    "numpy.ndarray"
                ],
                "get_sample_shape": [
                    "str",
                    "bool",
                    "numpy.ndarray"
                ],
                "get_feature_shape": [
                    "str",
                    "bool",
                    "numpy.ndarray"
                ]
            }
        },
        "simple_model.simple_model": {
            "name": "simple_model",
            "location": 29,
            "return": [],
            "arguments": {}
        },
        "simple_model_with_deterministic.simple_model_with_deterministic": {
            "name": "simple_model_with_deterministic",
            "location": 39,
            "return": [],
            "arguments": {}
        },
        "simple_model_no_free_rvs.simple_model_no_free_rvs": {
            "name": "simple_model_no_free_rvs",
            "location": 50,
            "return": [],
            "arguments": {}
        },
        "unvectorized_model.unvectorized_model": {
            "name": "unvectorized_model",
            "location": 69,
            "return": [
                "tuple[]"
            ],
            "arguments": {}
        },
        "deterministics_in_nested_models.nested_model": {
            "name": "nested_model",
            "location": 85,
            "return": [
                "Generator",
                "Optional[str]",
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {
                "cond": [
                    "Optional[str]",
                    "tensorflow.train.Checkpoint",
                    "tensorflow.Variable",
                    "Callable"
                ]
            }
        },
        "deterministics_in_nested_models.outer_model": {
            "name": "outer_model",
            "location": 91,
            "return": [
                "Generator",
                "Optional[str]",
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {}
        },
        "vectorized_model_fixture.model": {
            "name": "model",
            "location": 169,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_8schools.py": {
        "schools_pm4": {
            "name": "schools_pm4",
            "location": 13,
            "return": [
                "Generator",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "test_model_logp": {
            "name": "test_model_logp",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sample_no_xla": {
            "name": "test_sample_no_xla",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_compound.py": {
        "simple_model": {
            "name": "simple_model",
            "location": 10,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "compound_model": {
            "name": "compound_model",
            "location": 20,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "categorical_same_shape": {
            "name": "categorical_same_shape",
            "location": 31,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "model_symmetric": {
            "name": "model_symmetric",
            "location": 42,
            "return": [],
            "arguments": {}
        },
        "categorical_different_shape": {
            "name": "categorical_different_shape",
            "location": 52,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "xla_fixture": {
            "name": "xla_fixture",
            "location": 63,
            "return": [
                "bool",
                "int",
                "List"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "seed": {
            "name": "seed",
            "location": 68,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "sampler_type": {
            "name": "sampler_type",
            "location": 73,
            "return": [
                "str",
                "int",
                "T"
            ],
            "arguments": {
                "request": [
                    "str",
                    "Callable"
                ]
            }
        },
        "discrete_support_sampler_type": {
            "name": "discrete_support_sampler_type",
            "location": 78,
            "return": [
                "int",
                "str",
                "Optional[Type[BaseException]]"
            ],
            "arguments": {
                "request": [
                    "str",
                    "Set[str]"
                ]
            }
        },
        "expanded_sampler_type": {
            "name": "expanded_sampler_type",
            "location": 83,
            "return": [
                "int",
                "str",
                "Optional[Type[BaseException]]"
            ],
            "arguments": {
                "request": [
                    "str"
                ]
            }
        },
        "test_samplers_on_compound_model": {
            "name": "test_samplers_on_compound_model",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "compound_model": [
                    "Type",
                    "bool",
                    "Exception",
                    "Iterable[str]",
                    "Type[Any]"
                ],
                "seed": [
                    "Type",
                    "bool",
                    "Exception",
                    "Iterable[str]",
                    "Type[Any]"
                ],
                "xla_fixture": [
                    "Type",
                    "bool",
                    "Exception",
                    "Iterable[str]",
                    "Type[Any]"
                ],
                "sampler_type": [
                    "Type",
                    "bool",
                    "Exception",
                    "Iterable[str]",
                    "Type[Any]"
                ]
            }
        },
        "test_compound_model_sampler_method": {
            "name": "test_compound_model_sampler_method",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "compound_model": [
                    "str",
                    "bool"
                ],
                "seed": [
                    "bool",
                    "Callable",
                    "str",
                    "Type[Any]",
                    "Type"
                ],
                "xla_fixture": [
                    "bool",
                    "Callable",
                    "str",
                    "Type[Any]",
                    "Type"
                ],
                "discrete_support_sampler_type": [
                    "bool",
                    "Callable",
                    "str",
                    "Type[Any]",
                    "Type"
                ]
            }
        },
        "test_samplers_on_simple_model": {
            "name": "test_samplers_on_simple_model",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model": [
                    "Callable"
                ],
                "xla_fixture": [
                    "str"
                ],
                "sampler_type": [
                    "str"
                ]
            }
        },
        "test_extended_samplers_on_simple_model": {
            "name": "test_extended_samplers_on_simple_model",
            "location": 131,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model": [
                    "str"
                ],
                "xla_fixture": [
                    "bool",
                    "Callable"
                ],
                "expanded_sampler_type": [
                    "bool",
                    "Callable"
                ]
            }
        },
        "test_simple_seed": {
            "name": "test_simple_seed",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model": [
                    "str"
                ],
                "seed": []
            }
        },
        "test_compound_seed": {
            "name": "test_compound_seed",
            "location": 149,
            "return": [
                "None"
            ],
            "arguments": {
                "compound_model": [
                    "str"
                ],
                "seed": []
            }
        },
        "test_sampler_merging": {
            "name": "test_sampler_merging",
            "location": 175,
            "return": [
                "None"
            ],
            "arguments": {
                "categorical_same_shape": [
                    "str",
                    "float"
                ],
                "categorical_different_shape": [
                    "str",
                    "float"
                ]
            }
        },
        "test_other_samplers": {
            "name": "test_other_samplers",
            "location": 239,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model": [
                    "int",
                    "str"
                ],
                "seed": []
            }
        },
        "test_compound_symmetric": {
            "name": "test_compound_symmetric",
            "location": 247,
            "return": [
                "None"
            ],
            "arguments": {
                "model_symmetric": [
                    "str",
                    "int"
                ],
                "seed": [
                    "str"
                ]
            }
        },
        "simple_model.simple_model": {
            "name": "simple_model",
            "location": 12,
            "return": [],
            "arguments": {}
        },
        "compound_model.compound_model": {
            "name": "compound_model",
            "location": 22,
            "return": [],
            "arguments": {}
        },
        "categorical_same_shape.categorical_same_shape": {
            "name": "categorical_same_shape",
            "location": 33,
            "return": [],
            "arguments": {}
        },
        "model_symmetric.model_symmetric": {
            "name": "model_symmetric",
            "location": 44,
            "return": [],
            "arguments": {}
        },
        "categorical_different_shape.categorical_different_shape": {
            "name": "categorical_different_shape",
            "location": 54,
            "return": [],
            "arguments": {}
        },
        "test_samplers_on_compound_model._execute": {
            "name": "_execute",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_discrete.py": {
        "model_with_discrete_categorical": {
            "name": "model_with_discrete_categorical",
            "location": 7,
            "return": [],
            "arguments": {}
        },
        "model_with_discrete_bernoulli": {
            "name": "model_with_discrete_bernoulli",
            "location": 17,
            "return": [],
            "arguments": {}
        },
        "model_with_discrete_and_continuous": {
            "name": "model_with_discrete_and_continuous",
            "location": 27,
            "return": [],
            "arguments": {}
        },
        "xla_fixture": {
            "name": "xla_fixture",
            "location": 38,
            "return": [
                "bool",
                "int",
                "List"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "seed": {
            "name": "seed",
            "location": 43,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "test_discrete_sampling_categorical": {
            "name": "test_discrete_sampling_categorical",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "model_with_discrete_categorical": [
                    "str",
                    "int"
                ],
                "xla_fixture": [
                    "int"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "test_discrete_sampling_bernoulli": {
            "name": "test_discrete_sampling_bernoulli",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "model_with_discrete_bernoulli": [
                    "str",
                    "int"
                ],
                "xla_fixture": [
                    "int"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "test_compound_sampling": {
            "name": "test_compound_sampling",
            "location": 63,
            "return": [
                "None"
            ],
            "arguments": {
                "model_with_discrete_and_continuous": [
                    "str",
                    "int"
                ],
                "xla_fixture": [
                    "int"
                ],
                "seed": [
                    "int"
                ]
            }
        },
        "model_with_discrete_categorical.model_with_discrete_categorical": {
            "name": "model_with_discrete_categorical",
            "location": 9,
            "return": [],
            "arguments": {}
        },
        "model_with_discrete_bernoulli.model_with_discrete_bernoulli": {
            "name": "model_with_discrete_bernoulli",
            "location": 19,
            "return": [],
            "arguments": {}
        },
        "model_with_discrete_and_continuous.model_with_discrete_and_continuous": {
            "name": "model_with_discrete_and_continuous",
            "location": 29,
            "return": [],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_distributions.py": {
        "distribution": {
            "name": "distribution",
            "location": 464,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "distribution_conditions": {
            "name": "distribution_conditions",
            "location": 473,
            "return": [
                "Tuple[dict[str,dict[str,Any]]]",
                "Iterable[str]",
                "Dict[str,Any]",
                "bool"
            ],
            "arguments": {
                "distribution": [
                    "Tuple[int]"
                ],
                "request": [
                    "Tuple[int]"
                ]
            }
        },
        "distribution_extra_parameters": {
            "name": "distribution_extra_parameters",
            "location": 485,
            "return": [
                "Tuple",
                "int",
                "List[Callable]",
                "List[str]"
            ],
            "arguments": {
                "distribution": [],
                "request": [
                    "Dict",
                    "Tuple[int]",
                    "Dict[str,Any]"
                ]
            }
        },
        "broadcast_distribution": {
            "name": "broadcast_distribution",
            "location": 496,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "check_broadcast": {
            "name": "check_broadcast",
            "location": 501,
            "return": [
                "Tuple",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "broadcast_distribution": [
                    "str",
                    "Dict"
                ],
                "request": [
                    "Optional[bytes]",
                    "bytes",
                    "None"
                ]
            }
        },
        "test_rvs_logp_and_forward_sample": {
            "name": "test_rvs_logp_and_forward_sample",
            "location": 511,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ],
                "distribution_conditions": [
                    "int",
                    "str"
                ]
            }
        },
        "test_rvs_test_point_are_valid": {
            "name": "test_rvs_test_point_are_valid",
            "location": 524,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [],
                "distribution_conditions": [
                    "int"
                ]
            }
        },
        "test_flat_halfflat_broadcast": {
            "name": "test_flat_halfflat_broadcast",
            "location": 543,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ],
                "check_broadcast": []
            }
        },
        "test_extra_parameters": {
            "name": "test_extra_parameters",
            "location": 552,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "str"
                ],
                "distribution_extra_parameters": []
            }
        }
    },
    "pymc4-master/tests/test_executor.py": {
        "fixture_batch_shapes": {
            "name": "fixture_batch_shapes",
            "location": 17,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "fixture_sample_shapes": {
            "name": "fixture_sample_shapes",
            "location": 22,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "fixture_distribution_parameters": {
            "name": "fixture_distribution_parameters",
            "location": 27,
            "return": [
                "Tuple[Union[float,int,str,tuple[Union[Literal,Literal,Literal]]]]",
                "int",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "fixture_batch_shapes": [
                    "float",
                    "int",
                    "str",
                    "Union[numpy.ndarray,xarray.DataArray]",
                    "Optional[int]"
                ],
                "fixture_sample_shapes": [
                    "float",
                    "int",
                    "str",
                    "Union[numpy.ndarray,xarray.DataArray]",
                    "Optional[int]"
                ]
            }
        },
        "fixture_pm_model_decorate": {
            "name": "fixture_pm_model_decorate",
            "location": 33,
            "return": [
                "bool",
                "Callable[[T],bool]",
                "str",
                "float",
                "Iterable[str]"
            ],
            "arguments": {
                "request": [
                    "str"
                ]
            }
        },
        "complex_model": {
            "name": "complex_model",
            "location": 38,
            "return": [
                "List[str]",
                "bool",
                "Tuple[int, Dict[str, Any]]",
                "List[object]"
            ],
            "arguments": {}
        },
        "complex_model_with_observed": {
            "name": "complex_model_with_observed",
            "location": 54,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "simple_model": {
            "name": "simple_model",
            "location": 72,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "transformed_model": {
            "name": "transformed_model",
            "location": 81,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "transformed_model_with_observed": {
            "name": "transformed_model_with_observed",
            "location": 90,
            "return": [
                "numpy.ndarray",
                "int",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "class_model": {
            "name": "class_model",
            "location": 99,
            "return": [
                "ClassModel",
                "List[str]",
                "bool"
            ],
            "arguments": {}
        },
        "fixture_model_with_stacks": {
            "name": "fixture_model_with_stacks",
            "location": 110,
            "return": [
                "Tuple[dict[Text,tuple]]",
                "str",
                "Dict",
                "OrderedDict",
                "Dict[str,Any]"
            ],
            "arguments": {
                "fixture_distribution_parameters": [
                    "bool",
                    "Iterable[str]",
                    "Optional[Iterable[str]]",
                    "None",
                    "str",
                    "int"
                ],
                "fixture_pm_model_decorate": [
                    "bool",
                    "str",
                    "Optional[Iterable[str]]",
                    "Iterable[str]",
                    "None",
                    "int"
                ]
            }
        },
        "model_with_deterministics": {
            "name": "model_with_deterministics",
            "location": 134,
            "return": [
                "Tuple[Union[list[Text],list[Callable],list[list[Text]]]]",
                "bool",
                "Union[AbstractSetIntStr,MappingIntStrAny]",
                "numpy.ndarray",
                "str",
                "Type[T]"
            ],
            "arguments": {}
        },
        "deterministics_in_nested_models": {
            "name": "deterministics_in_nested_models",
            "location": 151,
            "return": [
                "Tuple[Union[set[Text],dict[Text,tuple[Union[list[Text],Callable]]]]]",
                "numpy.ndarray",
                "Optional[numpy.ndarray]",
                "Callable"
            ],
            "arguments": {}
        },
        "test_class_model": {
            "name": "test_class_model",
            "location": 199,
            "return": [
                "None"
            ],
            "arguments": {
                "class_model": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "dict",
                    "str"
                ]
            }
        },
        "test_simple_model": {
            "name": "test_simple_model",
            "location": 207,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model": [
                    "int"
                ]
            }
        },
        "test_complex_model_keep_return": {
            "name": "test_complex_model_keep_return",
            "location": 214,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_complex_model_no_keep_return": {
            "name": "test_complex_model_no_keep_return",
            "location": 234,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model": [
                    "int"
                ]
            }
        },
        "test_transformed_model_untransformed_executor": {
            "name": "test_transformed_model_untransformed_executor",
            "location": 243,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model": [
                    "int"
                ]
            }
        },
        "test_transformed_model_transformed_executor": {
            "name": "test_transformed_model_transformed_executor",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model": [
                    "int"
                ]
            }
        },
        "test_transformed_model_transformed_executor_with_passed_value": {
            "name": "test_transformed_model_transformed_executor_with_passed_value",
            "location": 263,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model": []
            }
        },
        "test_transformed_executor_logp_tensorflow": {
            "name": "test_transformed_executor_logp_tensorflow",
            "location": 279,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model": [
                    "Union[int,float]",
                    "int",
                    "float"
                ]
            }
        },
        "test_executor_logp_tensorflow": {
            "name": "test_executor_logp_tensorflow",
            "location": 293,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model": [
                    "Dict[str,Any]",
                    "Dict"
                ]
            }
        },
        "test_single_distribution": {
            "name": "test_single_distribution",
            "location": 301,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_raise_if_return_distribution": {
            "name": "test_raise_if_return_distribution",
            "location": 306,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_observed_are_passed_correctly": {
            "name": "test_observed_are_passed_correctly",
            "location": 316,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model_with_observed": [
                    "int"
                ]
            }
        },
        "test_observed_are_set_to_none_for_posterior_predictive_correctly": {
            "name": "test_observed_are_set_to_none_for_posterior_predictive_correctly",
            "location": 326,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model_with_observed": [
                    "int"
                ]
            }
        },
        "test_observed_do_not_produce_transformed_values": {
            "name": "test_observed_do_not_produce_transformed_values",
            "location": 340,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model_with_observed": [
                    "int"
                ]
            }
        },
        "test_observed_do_not_produce_transformed_values_case_programmatic": {
            "name": "test_observed_do_not_produce_transformed_values_case_programmatic",
            "location": 347,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model": [
                    "Callable[[List,bool],None]",
                    "Dict[str,Any]",
                    "Callable[List,bool,None]"
                ]
            }
        },
        "test_observed_do_not_produce_transformed_values_case_override": {
            "name": "test_observed_do_not_produce_transformed_values_case_override",
            "location": 356,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model_with_observed": [
                    "int"
                ]
            }
        },
        "test_observed_do_not_produce_transformed_values_case_override_with_set_value": {
            "name": "test_observed_do_not_produce_transformed_values_case_override_with_set_value",
            "location": 367,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model_with_observed": []
            }
        },
        "test_observed_cant_mix_with_untransformed_and_raises_an_error_case_transformed_executor": {
            "name": "test_observed_cant_mix_with_untransformed_and_raises_an_error_case_transformed_executor",
            "location": 389,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model_with_observed": [
                    "Dict",
                    "Callable"
                ]
            }
        },
        "test_observed_cant_mix_with_untransformed_and_raises_an_error_case_untransformed_executor": {
            "name": "test_observed_cant_mix_with_untransformed_and_raises_an_error_case_untransformed_executor",
            "location": 400,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model_with_observed": [
                    "Dict",
                    "Dict[str,Any]"
                ]
            }
        },
        "test_observed_cant_mix_with_transformed_and_raises_an_error": {
            "name": "test_observed_cant_mix_with_transformed_and_raises_an_error",
            "location": 409,
            "return": [
                "None"
            ],
            "arguments": {
                "transformed_model_with_observed": []
            }
        },
        "test_as_sampling_state_works_observed_is_constrained": {
            "name": "test_as_sampling_state_works_observed_is_constrained",
            "location": 420,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model_with_observed": [
                    "int"
                ]
            }
        },
        "test_as_sampling_state_works_observed_is_set_to_none": {
            "name": "test_as_sampling_state_works_observed_is_set_to_none",
            "location": 428,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model_with_observed": [
                    "int",
                    "str",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "test_as_sampling_state_works_if_transformed_exec": {
            "name": "test_as_sampling_state_works_if_transformed_exec",
            "location": 438,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model_with_observed": []
            }
        },
        "test_as_sampling_state_does_not_works_if_untransformed_exec": {
            "name": "test_as_sampling_state_does_not_works_if_untransformed_exec",
            "location": 446,
            "return": [
                "None"
            ],
            "arguments": {
                "complex_model": [
                    "int"
                ]
            }
        },
        "test_sampling_state_clone": {
            "name": "test_sampling_state_clone",
            "location": 453,
            "return": [
                "None"
            ],
            "arguments": {
                "deterministics_in_nested_models": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "test_as_sampling_state_failure_on_empty": {
            "name": "test_as_sampling_state_failure_on_empty",
            "location": 467,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_as_sampling_state_failure_on_dangling_distribution": {
            "name": "test_as_sampling_state_failure_on_dangling_distribution",
            "location": 473,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_evaluate_model_failure_on_state_and_values": {
            "name": "test_evaluate_model_failure_on_state_and_values",
            "location": 479,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_executor_failure_on_invalid_state": {
            "name": "test_executor_failure_on_invalid_state",
            "location": 491,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_proceed_deterministic_failure_on_unnamed_deterministic": {
            "name": "test_proceed_deterministic_failure_on_unnamed_deterministic",
            "location": 497,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_unnamed_distribution": {
            "name": "test_unnamed_distribution",
            "location": 507,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_unnamed_distribution_to_prior": {
            "name": "test_unnamed_distribution_to_prior",
            "location": 514,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_initialized_distribution_cant_be_transformed_into_a_new_prior": {
            "name": "test_initialized_distribution_cant_be_transformed_into_a_new_prior",
            "location": 520,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_unable_to_create_duplicate_variable": {
            "name": "test_unable_to_create_duplicate_variable",
            "location": 526,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_unnamed_return": {
            "name": "test_unnamed_return",
            "location": 539,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_unnamed_return_2": {
            "name": "test_unnamed_return_2",
            "location": 556,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_uncatched_exception_works": {
            "name": "test_uncatched_exception_works",
            "location": 573,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_none_yield": {
            "name": "test_none_yield",
            "location": 591,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_differently_shaped_logp": {
            "name": "test_differently_shaped_logp",
            "location": 601,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_log_prob_elemwise": {
            "name": "test_log_prob_elemwise",
            "location": 610,
            "return": [
                "None"
            ],
            "arguments": {
                "fixture_model_with_stacks": [
                    "int",
                    "Dict[str,Sequence[Any]]"
                ]
            }
        },
        "test_deterministics": {
            "name": "test_deterministics",
            "location": 626,
            "return": [
                "None"
            ],
            "arguments": {
                "model_with_deterministics": [
                    "str",
                    "int"
                ]
            }
        },
        "test_deterministic_with_distribution_name_fails": {
            "name": "test_deterministic_with_distribution_name_fails",
            "location": 645,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_distribution_with_deterministic_name_fails": {
            "name": "test_distribution_with_deterministic_name_fails",
            "location": 656,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_deterministics_in_nested_model": {
            "name": "test_deterministics_in_nested_model",
            "location": 668,
            "return": [
                "None"
            ],
            "arguments": {
                "deterministics_in_nested_models": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_incompatible_observed_shape": {
            "name": "test_incompatible_observed_shape",
            "location": 687,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_unreduced_log_prob": {
            "name": "test_unreduced_log_prob",
            "location": 701,
            "return": [
                "None"
            ],
            "arguments": {
                "fixture_batch_shapes": [
                    "Callable"
                ]
            }
        },
        "test_executor_on_conditionally_independent": {
            "name": "test_executor_on_conditionally_independent",
            "location": 723,
            "return": [
                "None"
            ],
            "arguments": {
                "fixture_batch_shapes": [
                    "int"
                ]
            }
        },
        "test_meta_executor": {
            "name": "test_meta_executor",
            "location": 734,
            "return": [
                "None"
            ],
            "arguments": {
                "deterministics_in_nested_models": [
                    "bool"
                ],
                "fixture_batch_shapes": [
                    "int",
                    "List[str]",
                    "None",
                    "Optional[bool]",
                    "bool"
                ]
            }
        },
        "complex_model.nested_model": {
            "name": "nested_model",
            "location": 40,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "cond": []
            }
        },
        "complex_model.complex_model": {
            "name": "complex_model",
            "location": 45,
            "return": [],
            "arguments": {}
        },
        "complex_model_with_observed.nested_model": {
            "name": "nested_model",
            "location": 56,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "cond": []
            }
        },
        "complex_model_with_observed.complex_model": {
            "name": "complex_model",
            "location": 63,
            "return": [],
            "arguments": {}
        },
        "simple_model.simple_model": {
            "name": "simple_model",
            "location": 73,
            "return": [],
            "arguments": {}
        },
        "transformed_model.transformed_model": {
            "name": "transformed_model",
            "location": 82,
            "return": [],
            "arguments": {}
        },
        "transformed_model_with_observed.transformed_model_with_observed": {
            "name": "transformed_model_with_observed",
            "location": 91,
            "return": [],
            "arguments": {}
        },
        "fixture_model_with_stacks.model": {
            "name": "model",
            "location": 122,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "model_with_deterministics.model": {
            "name": "model",
            "location": 140,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "deterministics_in_nested_models.nested_model": {
            "name": "nested_model",
            "location": 153,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "cond": []
            }
        },
        "deterministics_in_nested_models.outer_model": {
            "name": "outer_model",
            "location": 159,
            "return": [
                "Generator",
                "Optional[str]",
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {}
        },
        "test_complex_model_keep_return.nested_model": {
            "name": "nested_model",
            "location": 216,
            "return": [
                "Generator",
                "Optional[str]",
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable"
            ],
            "arguments": {
                "cond": [
                    "Optional[str]",
                    "tensorflow.train.Checkpoint",
                    "tensorflow.Variable",
                    "Callable"
                ]
            }
        },
        "test_complex_model_keep_return.complex_model": {
            "name": "complex_model",
            "location": 221,
            "return": [
                "List[str]",
                "bool",
                "Tuple[int, Dict[str, Any]]",
                "List[object]"
            ],
            "arguments": {}
        },
        "test_raise_if_return_distribution.invalid_model": {
            "name": "invalid_model",
            "location": 307,
            "return": [
                "Generator",
                "int",
                "Dict",
                "float",
                "str"
            ],
            "arguments": {}
        },
        "test_evaluate_model_failure_on_state_and_values.model": {
            "name": "model",
            "location": 484,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_proceed_deterministic_failure_on_unnamed_deterministic.model": {
            "name": "model",
            "location": 499,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_unable_to_create_duplicate_variable.invdalid_model": {
            "name": "invdalid_model",
            "location": 527,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_unnamed_return.a_model": {
            "name": "a_model",
            "location": 541,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_unnamed_return_2.a_model": {
            "name": "a_model",
            "location": 558,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_uncatched_exception_works.a_model": {
            "name": "a_model",
            "location": 575,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_none_yield.model": {
            "name": "model",
            "location": 592,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_differently_shaped_logp.model": {
            "name": "model",
            "location": 602,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_deterministic_with_distribution_name_fails.model": {
            "name": "model",
            "location": 647,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_distribution_with_deterministic_name_fails.model": {
            "name": "model",
            "location": 658,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_incompatible_observed_shape.model": {
            "name": "model",
            "location": 689,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "observed": []
            }
        },
        "test_unreduced_log_prob.model": {
            "name": "model",
            "location": 705,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "test_executor_on_conditionally_independent.model": {
            "name": "model",
            "location": 725,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "class_model.ClassModel.class_model_method": {
            "name": "class_model_method",
            "location": 102,
            "return": [
                "Generator",
                "int",
                "Dict[str,Any]",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "pymc4-master/tests/test_forward_sampling.py": {
        "sample_shape_fixture": {
            "name": "sample_shape_fixture",
            "location": 12,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "n_draws_fixture": {
            "name": "n_draws_fixture",
            "location": 17,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "sample_from_observed_fixture": {
            "name": "sample_from_observed_fixture",
            "location": 22,
            "return": [
                "bool",
                "int",
                "List"
            ],
            "arguments": {
                "request": []
            }
        },
        "model_fixture": {
            "name": "model_fixture",
            "location": 27,
            "return": [
                "tuple[typing.Union[int,dict[, ],list[int],list[list[int]],str]]"
            ],
            "arguments": {}
        },
        "model_with_observed_fixture": {
            "name": "model_with_observed_fixture",
            "location": 42,
            "return": [
                "Tuple[Union[dict[Text,tuple[int]],bool]]",
                "str",
                "Optional[List[Any]]"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]"
                ]
            }
        },
        "use_auto_batching_fixture": {
            "name": "use_auto_batching_fixture",
            "location": 73,
            "return": [
                "bool",
                "int",
                "float"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "vectorized_model_fixture": {
            "name": "vectorized_model_fixture",
            "location": 78,
            "return": [
                "Tuple[Union[bool,dict[Text,tuple[int]]]]",
                "bool",
                "Dict[str,Any]",
                "Dict"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]",
                    "List",
                    "bool"
                ]
            }
        },
        "posterior_predictive_fixture": {
            "name": "posterior_predictive_fixture",
            "location": 123,
            "return": [
                "Tuple[Union[str,int,float,list[int]]]",
                "str",
                "float",
                "Callable[...,None]"
            ],
            "arguments": {
                "model_with_observed_fixture": [
                    "Union[Contributor,Coverage]",
                    "float",
                    "Optional[float]",
                    "None"
                ]
            }
        },
        "glm_model_fixture": {
            "name": "glm_model_fixture",
            "location": 140,
            "return": [
                "Tuple[Union[bool,dict[Text,tuple[int]]]]",
                "bool",
                "Dict[str,Any]",
                "Dict"
            ],
            "arguments": {
                "request": [
                    "Dict[str,Any]",
                    "List",
                    "bool"
                ]
            }
        },
        "test_sample_prior_predictive": {
            "name": "test_sample_prior_predictive",
            "location": 187,
            "return": [
                "None"
            ],
            "arguments": {
                "model_fixture": [
                    "bool",
                    "str"
                ],
                "sample_shape_fixture": [
                    "int"
                ],
                "sample_from_observed_fixture": [
                    "int"
                ]
            }
        },
        "test_sample_prior_predictive_var_names": {
            "name": "test_sample_prior_predictive_var_names",
            "location": 218,
            "return": [
                "None"
            ],
            "arguments": {
                "model_fixture": [
                    "str"
                ]
            }
        },
        "test_sample_prior_predictive_int_sample_shape": {
            "name": "test_sample_prior_predictive_int_sample_shape",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "model_fixture": [
                    "int",
                    "str",
                    "List[str]"
                ],
                "n_draws_fixture": [
                    "int",
                    "str",
                    "ashpy.losses.executor.Executor"
                ]
            }
        },
        "test_posterior_predictive_executor": {
            "name": "test_posterior_predictive_executor",
            "location": 266,
            "return": [
                "None"
            ],
            "arguments": {
                "model_with_observed_fixture": []
            }
        },
        "test_sample_posterior_predictive": {
            "name": "test_sample_posterior_predictive",
            "location": 291,
            "return": [
                "None"
            ],
            "arguments": {
                "posterior_predictive_fixture": [
                    "bool",
                    "Union[int,float]",
                    "float"
                ]
            }
        },
        "test_sample_ppc_var_names": {
            "name": "test_sample_ppc_var_names",
            "location": 315,
            "return": [
                "None"
            ],
            "arguments": {
                "model_fixture": [
                    "str"
                ]
            }
        },
        "test_sample_ppc_corrupt_trace": {
            "name": "test_sample_ppc_corrupt_trace",
            "location": 343,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_vectorized_sample_prior_predictive": {
            "name": "test_vectorized_sample_prior_predictive",
            "location": 363,
            "return": [
                "None"
            ],
            "arguments": {
                "vectorized_model_fixture": [
                    "str",
                    "int",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "None"
                ],
                "use_auto_batching_fixture": [
                    "int",
                    "bool"
                ],
                "sample_shape_fixture": [
                    "int",
                    "bool"
                ]
            }
        },
        "test_sample_prior_predictive_on_glm": {
            "name": "test_sample_prior_predictive_on_glm",
            "location": 383,
            "return": [
                "None"
            ],
            "arguments": {
                "glm_model_fixture": [
                    "str",
                    "int",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "None"
                ],
                "use_auto_batching_fixture": [
                    "str",
                    "bool"
                ],
                "sample_shape_fixture": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_vectorized_sample_posterior_predictive": {
            "name": "test_vectorized_sample_posterior_predictive",
            "location": 408,
            "return": [
                "None"
            ],
            "arguments": {
                "vectorized_model_fixture": [
                    "str",
                    "int",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "None"
                ],
                "use_auto_batching_fixture": [
                    "bool"
                ],
                "sample_shape_fixture": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_sample_posterior_predictive_on_glm": {
            "name": "test_sample_posterior_predictive_on_glm",
            "location": 441,
            "return": [
                "None"
            ],
            "arguments": {
                "glm_model_fixture": [
                    "str",
                    "int",
                    "Optional[Dict[str,Any]]",
                    "Dict[str,Any]",
                    "None"
                ],
                "use_auto_batching_fixture": [
                    "Dict[str,Any]"
                ],
                "sample_shape_fixture": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_posterior_predictive_on_root_variable": {
            "name": "test_posterior_predictive_on_root_variable",
            "location": 484,
            "return": [
                "None"
            ],
            "arguments": {
                "use_auto_batching_fixture": [
                    "int",
                    "float",
                    "Tuple[int,int]",
                    "Tuple[Union[int,int]]"
                ]
            }
        },
        "model_fixture.model": {
            "name": "model",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "model_with_observed_fixture.model": {
            "name": "model",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sample_ppc_corrupt_trace.model": {
            "name": "model",
            "location": 345,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_posterior_predictive_on_root_variable.model": {
            "name": "model",
            "location": 490,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "vectorized_model_fixture.model": {
            "name": "model",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "glm_model_fixture.model": {
            "name": "model",
            "location": 177,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_gp.py": {
        "get_gp_model": {
            "name": "get_gp_model",
            "location": 25,
            "return": [
                "int",
                "Optional[int]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "build_model": {
            "name": "build_model",
            "location": 29,
            "return": [
                "Pattern",
                "List[str]",
                "Tuple[Union[Literal,Literal]]",
                "str",
                "Type"
            ],
            "arguments": {
                "model_name": [
                    "str",
                    "int"
                ],
                "model_kwargs": [
                    "str",
                    "List[str]",
                    "Callable",
                    "Set[str]",
                    "Dict[str,str]"
                ],
                "feature_ndims": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        },
        "test_gp_models_prior": {
            "name": "test_gp_models_prior",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "Callable"
                ],
                "get_data": [],
                "get_gp_model": [
                    "bool"
                ]
            }
        },
        "test_gp_models_conditional": {
            "name": "test_gp_models_conditional",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "Callable"
                ],
                "get_data": [
                    "Callable"
                ],
                "get_gp_model": [
                    "Callable"
                ]
            }
        },
        "test_gp_models_conditional.model": {
            "name": "model",
            "location": 78,
            "return": [
                "typing.Generator[]"
            ],
            "arguments": {
                "gp": [
                    "T",
                    "int",
                    "Dict[str, Any]",
                    "bool",
                    "float",
                    "Union[int, float]"
                ],
                "X": [
                    "tensorflow.Tensor",
                    "Iterable[T]",
                    "int"
                ],
                "Xnew": [
                    "int",
                    "float"
                ]
            }
        }
    },
    "pymc4-master/tests/test_gp_cov.py": {
        "get_cov_func": {
            "name": "get_cov_func",
            "location": 158,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "get_unique_cov_func": {
            "name": "get_unique_cov_func",
            "location": 163,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "request": [
                    "str"
                ]
            }
        },
        "build_class_and_get_test_points": {
            "name": "build_class_and_get_test_points",
            "location": 167,
            "return": [
                "Tuple[(Any, Any, Any, Any, Any)]"
            ],
            "arguments": {
                "name": [
                    "str",
                    "Dict[str,str]"
                ],
                "kwargs": []
            }
        },
        "test_cov_funcs_matrix_shape_psd": {
            "name": "test_cov_funcs_matrix_shape_psd",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "Callable",
                    "str",
                    "Type",
                    "Callable[...,None]"
                ],
                "get_data": [
                    "Iterable[numpy.ndarray]"
                ],
                "get_unique_cov_func": [
                    "List[bytes]",
                    "Dict",
                    "str"
                ]
            }
        },
        "test_cov_funcs_point_eval_shape": {
            "name": "test_cov_funcs_point_eval_shape",
            "location": 190,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "Callable",
                    "str",
                    "Type",
                    "Callable[...,None]"
                ],
                "get_data": [
                    "Iterable[numpy.ndarray]"
                ],
                "get_unique_cov_func": [
                    "List[bytes]",
                    "Dict",
                    "str"
                ]
            }
        },
        "test_cov_funcs_matrix_no_ard": {
            "name": "test_cov_funcs_matrix_no_ard",
            "location": 204,
            "return": [
                "None"
            ],
            "arguments": {
                "get_cov_func": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "Callable[[Dict],None]",
                    "bool"
                ]
            }
        },
        "test_cov_funcs_point_eval_no_ard": {
            "name": "test_cov_funcs_point_eval_no_ard",
            "location": 222,
            "return": [
                "None"
            ],
            "arguments": {
                "get_cov_func": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "Callable[[Dict],None]"
                ]
            }
        },
        "test_cov_combination": {
            "name": "test_cov_combination",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {
                "get_cov_func": [
                    "str",
                    "Sequence[str]",
                    "int"
                ]
            }
        },
        "test_cov_non_cov_combination": {
            "name": "test_cov_non_cov_combination",
            "location": 266,
            "return": [
                "None"
            ],
            "arguments": {
                "get_cov_func": [
                    "Callable[[List, bool], None]",
                    "Callable[[list], None]"
                ]
            }
        },
        "test_cov_funcs_diag": {
            "name": "test_cov_funcs_diag",
            "location": 288,
            "return": [
                "None"
            ],
            "arguments": {
                "get_cov_func": [
                    "str",
                    "Sequence[str]",
                    "int"
                ]
            }
        },
        "test_cov_funcs_active_dims": {
            "name": "test_cov_funcs_active_dims",
            "location": 306,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        },
        "test_cov_funcs_invalid_feature_ndims": {
            "name": "test_cov_funcs_invalid_feature_ndims",
            "location": 334,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_cov_funcs_invalid_active_dims": {
            "name": "test_cov_funcs_invalid_active_dims",
            "location": 340,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_scaled_cov_kernel_shapes_and_psd": {
            "name": "test_scaled_cov_kernel_shapes_and_psd",
            "location": 350,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "bool"
                ],
                "get_data": [
                    "Iterable[Tuple[int, int]]"
                ]
            }
        },
        "test_scaled_cov": {
            "name": "test_scaled_cov",
            "location": 364,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_warped_cov_kernel_shapes_and_psd": {
            "name": "test_warped_cov_kernel_shapes_and_psd",
            "location": 375,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "bool"
                ],
                "get_data": [
                    "Iterable[Tuple[int, int]]"
                ]
            }
        },
        "test_warped_cov": {
            "name": "test_warped_cov",
            "location": 389,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_gp_mean.py": {
        "get_mean_func": {
            "name": "get_mean_func",
            "location": 31,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]"
                ]
            }
        },
        "test_mean_funcs": {
            "name": "test_mean_funcs",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "Callable"
                ],
                "get_data": [
                    "Iterable[numpy.ndarray]",
                    "Sequence[numpy.ndarray]"
                ],
                "get_mean_func": [
                    "List[Dict[str,str]]",
                    "List[dict[str,str]]"
                ]
            }
        },
        "test_mean_combination": {
            "name": "test_mean_combination",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "List[str]"
                ],
                "get_mean_func": [
                    "Callable[[list], None]",
                    "Callable",
                    "Optional[Union[bool, Any]]",
                    "Callable[[List, bool], None]"
                ]
            }
        }
    },
    "pymc4-master/tests/test_gp_util.py": {
        "test_stabilize_default_shift": {
            "name": "test_stabilize_default_shift",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_stabilize": {
            "name": "test_stabilize",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_inherit_docs": {
            "name": "test_inherit_docs",
            "location": 27,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_inherit_docs_exception": {
            "name": "test_inherit_docs_exception",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_build_docs": {
            "name": "test_build_docs",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_build_doc_warning": {
            "name": "test_build_doc_warning",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_inherit_docs.func": {
            "name": "func",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_inherit_docs.other_func": {
            "name": "other_func",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_inherit_docs_exception.func": {
            "name": "func",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_build_docs.func": {
            "name": "func",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_inherit_docs_exception.other_func": {
            "name": "other_func",
            "location": 48,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_build_doc_warning.func": {
            "name": "func",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_mixture.py": {
        "mixture_components": {
            "name": "mixture_components",
            "location": 48,
            "return": [
                "Tuple",
                "str",
                "Tuple[Tuple[int,...]]"
            ],
            "arguments": {
                "request": [
                    "str"
                ]
            }
        },
        "_mixture": {
            "name": "_mixture",
            "location": 53,
            "return": [
                "generator"
            ],
            "arguments": {
                "k": [
                    "str",
                    "int",
                    "Match",
                    "numpy.ndarray",
                    "Match[Any]"
                ],
                "p": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Mapping[str,Any]",
                    "Mapping"
                ],
                "loc": [
                    "float",
                    "Dict[str,Any]",
                    "str",
                    "List",
                    "tensorflow.keras.losses.Reduction"
                ],
                "scale": [
                    "float",
                    "Dict[str,Any]",
                    "str",
                    "List",
                    "tensorflow.keras.losses.Reduction"
                ],
                "dat": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        },
        "_mixture_same_family": {
            "name": "_mixture_same_family",
            "location": 62,
            "return": [
                "generator"
            ],
            "arguments": {
                "k": [
                    "str",
                    "int",
                    "KT"
                ],
                "p": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Mapping[str,Any]",
                    "Mapping"
                ],
                "loc": [
                    "float",
                    "int",
                    "str",
                    "bool",
                    "T"
                ],
                "scale": [
                    "float",
                    "int",
                    "str",
                    "bool",
                    "T"
                ],
                "dat": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        },
        "mixture": {
            "name": "mixture",
            "location": 72,
            "return": [
                "Tuple[Union[int,float,list,list[int]]]",
                "str",
                "Optional[str]",
                "Optional[Iterable[str]]"
            ],
            "arguments": {
                "mixture_components": [
                    "str",
                    "Dict[str,Any]",
                    "bytes"
                ],
                "request": [
                    "Tuple[int]"
                ]
            }
        },
        "test_wrong_distribution_argument_batched_fails": {
            "name": "test_wrong_distribution_argument_batched_fails",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_wrong_distribution_argument_in_list_fails": {
            "name": "test_wrong_distribution_argument_in_list_fails",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sampling": {
            "name": "test_sampling",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "mixture": [
                    "str",
                    "bool",
                    "int"
                ],
                "xla_fixture": []
            }
        },
        "test_prior_predictive": {
            "name": "test_prior_predictive",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "mixture": [
                    "bool"
                ]
            }
        },
        "test_posterior_predictive": {
            "name": "test_posterior_predictive",
            "location": 121,
            "return": [
                "None"
            ],
            "arguments": {
                "mixture": [
                    "bool"
                ]
            }
        }
    },
    "pymc4-master/tests/test_plots.py": {
        "test_gp_plot": {
            "name": "test_gp_plot",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "tf_seed": [
                    "str",
                    "Mapping[str,Any]",
                    "Mapping"
                ]
            }
        }
    },
    "pymc4-master/tests/test_sampling.py": {
        "test_sample_deterministics": {
            "name": "test_sample_deterministics",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model_with_deterministic": [],
                "xla_fixture": [
                    "str"
                ]
            }
        },
        "test_vectorize_log_prob_det_function": {
            "name": "test_vectorize_log_prob_det_function",
            "location": 23,
            "return": [
                "None"
            ],
            "arguments": {
                "unvectorized_model": [
                    "float",
                    "numpy.ndarray",
                    "str",
                    "int"
                ]
            }
        },
        "test_sampling_with_deterministics_in_nested_models": {
            "name": "test_sampling_with_deterministics_in_nested_models",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "deterministics_in_nested_models": [
                    "bool",
                    "float",
                    "Callable[...,Awaitable]",
                    "Callable[...,collections.abc.Awaitable]"
                ],
                "xla_fixture": [
                    "int"
                ]
            }
        },
        "test_sampling_with_no_free_rvs": {
            "name": "test_sampling_with_no_free_rvs",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model_no_free_rvs": [
                    "str"
                ]
            }
        },
        "test_sample_auto_batching": {
            "name": "test_sample_auto_batching",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "vectorized_model_fixture": [
                    "List[numpy.array]",
                    "bool",
                    "List[int]",
                    "str"
                ],
                "xla_fixture": [],
                "use_auto_batching_fixture": [
                    "int"
                ]
            }
        },
        "test_beta_sample": {
            "name": "test_beta_sample",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sampling_unknown_sampler": {
            "name": "test_sampling_unknown_sampler",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model": [
                    "str"
                ]
            }
        },
        "test_sampling_log_likelihood": {
            "name": "test_sampling_log_likelihood",
            "location": 144,
            "return": [
                "None"
            ],
            "arguments": {
                "vectorized_model_fixture": []
            }
        },
        "test_beta_sample.model": {
            "name": "model",
            "location": 128,
            "return": [
                "Generator",
                "tensorflow.train.Checkpoint",
                "tensorflow.Variable",
                "Callable",
                "Optional[str]",
                "Type"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_utils.py": {
        "mock_biwrap_functools_call": {
            "name": "mock_biwrap_functools_call",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "monkeypatch": [
                    "str",
                    "int",
                    "Dict",
                    "Dict[str,Callable]",
                    "bool"
                ]
            }
        },
        "test_biwrap_and_mocked_functools_raises_exception_with_called_decorator": {
            "name": "test_biwrap_and_mocked_functools_raises_exception_with_called_decorator",
            "location": 24,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_biwrap_functools_call": [
                    "mock.MagicMock",
                    "unittesmock.Mock",
                    "mock.Mock"
                ]
            }
        },
        "test_biwrap_with_uncalled_decorator": {
            "name": "test_biwrap_with_uncalled_decorator",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "mock_biwrap_functools_call": [
                    "mock.Mock",
                    "unittesmock.Mock",
                    "mock.MagicMock"
                ]
            }
        },
        "mock_biwrap_functools_call._partial": {
            "name": "_partial",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_biwrap_with_uncalled_decorator.fake_model": {
            "name": "fake_model",
            "location": 47,
            "return": [
                "typing.Generator[None]"
            ],
            "arguments": {}
        },
        "test_biwrap_and_mocked_functools_raises_exception_with_called_decorator.fake_model": {
            "name": "fake_model",
            "location": 32,
            "return": [
                "typing.Generator[None]"
            ],
            "arguments": {}
        }
    },
    "pymc4-master/tests/test_variational.py": {
        "conjugate_normal_model": {
            "name": "conjugate_normal_model",
            "location": 8,
            "return": [
                "dict",
                "Dict[str, Any]"
            ],
            "arguments": {}
        },
        "approximation": {
            "name": "approximation",
            "location": 50,
            "return": [
                "int",
                "list"
            ],
            "arguments": {
                "request": [
                    "Callable"
                ]
            }
        },
        "test_fit": {
            "name": "test_fit",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "approximation": [
                    "bool"
                ],
                "conjugate_normal_model": [
                    "bool"
                ]
            }
        },
        "bivariate_gaussian": {
            "name": "bivariate_gaussian",
            "location": 78,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "test_bivariate_shapes": {
            "name": "test_bivariate_shapes",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "bivariate_gaussian": [
                    "int",
                    "List[int]",
                    "str"
                ]
            }
        },
        "test_advi_with_deterministics": {
            "name": "test_advi_with_deterministics",
            "location": 98,
            "return": [
                "None"
            ],
            "arguments": {
                "simple_model_with_deterministic": [
                    "bool"
                ]
            }
        },
        "test_advi_with_deterministics_in_nested_models": {
            "name": "test_advi_with_deterministics_in_nested_models",
            "location": 106,
            "return": [
                "None"
            ],
            "arguments": {
                "deterministics_in_nested_models": [
                    "bool",
                    "List[Dict]",
                    "List[dict]"
                ]
            }
        },
        "conjugate_normal_model.model": {
            "name": "model",
            "location": 23,
            "return": [
                "Generator",
                "Callable",
                "Optional[str]",
                "Type"
            ],
            "arguments": {}
        },
        "bivariate_gaussian.bivariate_gaussian": {
            "name": "bivariate_gaussian",
            "location": 83,
            "return": [],
            "arguments": {}
        }
    },
    "pymc4-master/tests/__init__.py": {}
}
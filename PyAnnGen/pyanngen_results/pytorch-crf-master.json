{
    "pytorch-crf-master/pycrf/eval.py": {
        "iob_to_spans": {
            "name": "iob_to_spans",
            "location": 14,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "sequence": [
                    "bytes",
                    "List[str]",
                    "str",
                    "int",
                    "IO"
                ],
                "lut": [
                    "List[str]",
                    "bytes"
                ],
                "strict_iob2": [
                    "bool",
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "iobes_to_spans": {
            "name": "iobes_to_spans",
            "location": 60,
            "return": [
                "Set[str]"
            ],
            "arguments": {
                "sequence": [
                    "bytes",
                    "List[str]",
                    "str",
                    "int",
                    "IO"
                ],
                "lut": [
                    "List[str]",
                    "bytes"
                ],
                "strict_iob2": [
                    "bool",
                    "bytes",
                    "int",
                    "IO",
                    "List[str]",
                    "str"
                ]
            }
        },
        "_detect_label_scheme": {
            "name": "_detect_label_scheme",
            "location": 136,
            "return": [
                "int",
                "Sequence[Tuple[float, float]]",
                "Dict[str, str]",
                "bytes",
                "Callable[[str], bool]"
            ],
            "arguments": {
                "labels": [
                    "str",
                    "Set[str]",
                    "int",
                    "Optional[Callable]"
                ]
            }
        },
        "ModelStats.__init__": {
            "name": "__init__",
            "location": 149,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "labels_itos": [
                    "tuple",
                    "str",
                    "int",
                    "Optional[str]",
                    "float"
                ],
                "epoch": [
                    "int",
                    "str",
                    "bool",
                    "List[List[Any]]",
                    "Optional[str]"
                ],
                "loss": [
                    "float",
                    "str",
                    "bool",
                    "List[List[Any]]",
                    "Optional[str]"
                ]
            }
        },
        "ModelStats.score": {
            "name": "score",
            "location": 168,
            "return": [
                "Tuple[float]",
                "str",
                "Tuple",
                "int",
                "Dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelStats.__str__": {
            "name": "__str__",
            "location": 185,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelStats.reset": {
            "name": "reset",
            "location": 194,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ModelStats.update": {
            "name": "update",
            "location": 202,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "gold_labels": [
                    "str",
                    "List[str]",
                    "int"
                ],
                "predicted": [
                    "List[int]",
                    "List[tuple[Union[int,int]]]",
                    "bool",
                    "List[Tuple[int,int]]",
                    "Set[str]",
                    "Tuple[Union[int,int]]",
                    "str",
                    "Tuple[int,int]",
                    "int"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/exceptions.py": {
        "LearnerInitializationError.__init__": {
            "name": "__init__",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "missing_args": [
                    "str",
                    "Tuple[str,List[str],List[str]]",
                    "Tuple[Union[str,list[str],list[str]]]"
                ],
                "unknown_args": [
                    "str",
                    "Tuple[str,List[str],List[str]]",
                    "Tuple[Union[str,list[str],list[str]]]"
                ]
            }
        },
        "ArgParsingError.__init__": {
            "name": "__init__",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "str",
                    "bytes",
                    "ConnectionError",
                    "Callable"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/label.py": {
        "label_data": {
            "name": "label_data",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "opts": [
                    "str",
                    "argparse.Namespace",
                    "Dict",
                    "bool"
                ],
                "model": [
                    "bool",
                    "Dict[str, Any]"
                ],
                "device": [
                    "str",
                    "float",
                    "bytes",
                    "Union[str,bytes]",
                    "cmk.utils.type_defs.ServiceName",
                    "cmk.utils.type_defs.HostName"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 70,
            "return": [
                "None"
            ],
            "arguments": {
                "args": [
                    "None"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/logging.py": {
        "_format_duration": {
            "name": "_format_duration",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "seconds": [
                    "datetime.datetime",
                    "float",
                    "int",
                    "datetime.timedelta"
                ]
            }
        },
        "TrainLogger.__init__": {
            "name": "__init__",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_examples": [
                    "bool",
                    "List[int]",
                    "Union[Callable,str]",
                    "Callable",
                    "List[float]",
                    "str",
                    "int"
                ],
                "log_interval": [
                    "int",
                    "str",
                    "bool",
                    "List[str]"
                ],
                "verbose": [
                    "bool",
                    "Union[Callable,str]",
                    "List[int]",
                    "int",
                    "List[float]"
                ],
                "log_dir": [
                    "str",
                    "None",
                    "List",
                    "bool",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "results_file": [
                    "str",
                    "None",
                    "int",
                    "float",
                    "bool",
                    "Optional[bool]",
                    "Optional[str]"
                ],
                "log_weights": [
                    "bool",
                    "str",
                    "List[str]",
                    "int"
                ]
            }
        },
        "TrainLogger.scalar_summary": {
            "name": "scalar_summary",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "int"
                ],
                "value": [
                    "str",
                    "int"
                ],
                "step": [
                    "str",
                    "Dict[str,Any]",
                    "bool"
                ]
            }
        },
        "TrainLogger.histo_summary": {
            "name": "histo_summary",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "tag": [
                    "str",
                    "int",
                    "Iterable",
                    "Optional[Scope]",
                    "None"
                ],
                "values": [
                    "str",
                    "Tuple[int]",
                    "Union[List[str], List[Any]]",
                    "vimiv.utils.customtypes.NumberStr"
                ],
                "step": [
                    "str",
                    "Dict[str,Any]",
                    "bool"
                ],
                "bins": [
                    "int",
                    "str",
                    "float"
                ]
            }
        },
        "TrainLogger.start_epoch": {
            "name": "start_epoch",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "str"
                ]
            }
        },
        "TrainLogger.end_epoch": {
            "name": "end_epoch",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TrainLogger.end_train": {
            "name": "end_train",
            "location": 138,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "validation": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "TrainLogger.record": {
            "name": "record",
            "location": 176,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "metrics": [
                    "Dict[str,object]",
                    "Dict[str,dict[str,int]]",
                    "Dict[str,str]",
                    "Dict[str,Any]",
                    "Dict[str,Dict[str,int]]",
                    "Optional[Dict[str,Any]]"
                ],
                "iteration": [
                    "Match",
                    "hackathon.utils.utils.DataMessage",
                    "bool",
                    "Dict",
                    "str"
                ]
            }
        },
        "TrainLogger.append_eval_stats": {
            "name": "append_eval_stats",
            "location": 181,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "eval_stats": [
                    "str",
                    "int"
                ],
                "validation": [
                    "bool",
                    "int",
                    "str",
                    "Iterable[Context]",
                    "Dict"
                ]
            }
        },
        "TrainLogger.update": {
            "name": "update",
            "location": 198,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "str",
                    "int",
                    "float",
                    "datetime.timedelta",
                    "bool"
                ],
                "iteration": [
                    "Dict[str, Any]",
                    "dict"
                ],
                "loss": [
                    "Dict[str, float]",
                    "str",
                    "Iterable[T]"
                ],
                "params": [
                    "str",
                    "int",
                    "Optional[bool]",
                    "bool"
                ],
                "lrs": [
                    "str",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "LRFinderLogger.__init__": {
            "name": "__init__",
            "location": 237,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n": [
                    "int",
                    "List",
                    "List[int]",
                    "bool"
                ]
            }
        },
        "LRFinderLogger.__del__": {
            "name": "__del__",
            "location": 244,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "LRFinderLogger.update": {
            "name": "update",
            "location": 247,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lr": [
                    "str",
                    "int"
                ],
                "loss": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/optim.py": {
        "CLOptim.lr": {
            "name": "lr",
            "location": 22,
            "return": [
                "tuple[]"
            ],
            "arguments": {
                "self": [],
                "values": []
            }
        },
        "CLOptim.cl_opts": {
            "name": "cl_opts",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "bool",
                    "typing.Callable[argparse.ArgumentParser, None]"
                ],
                "require": [
                    "bool"
                ]
            }
        },
        "CLOptim.cl_init": {
            "name": "cl_init",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "cls": [
                    "list[dict[, ]]",
                    "dict[, ]",
                    "typing.Type"
                ],
                "params": [
                    "list[dict[, ]]",
                    "dict[, ]",
                    "typing.Type"
                ],
                "opts": [
                    "list[dict[, ]]",
                    "dict[, ]",
                    "typing.Type"
                ]
            }
        },
        "CLOptim.iteration_update": {
            "name": "iteration_update",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "i": [
                    "int"
                ]
            }
        },
        "CLOptim.epoch_update": {
            "name": "epoch_update",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "loss": [
                    "float",
                    "dict[, ]",
                    "int",
                    "list[]"
                ]
            }
        },
        "CLOptim.epoch_prepare": {
            "name": "epoch_prepare",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "training_size": [
                    "int",
                    "list[]",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "list[]",
                    "float"
                ]
            }
        },
        "CLOptim.update_param_groups": {
            "name": "update_param_groups",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "params": [],
                "opts": [
                    "float",
                    "str",
                    "int"
                ]
            }
        },
        "AdaGrad.cl_opts": {
            "name": "cl_opts",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "AdaGrad.cl_init": {
            "name": "cl_init",
            "location": 98,
            "return": [
                "AdaGrad"
            ],
            "arguments": {
                "cls": [
                    "Type[_TAdaGrad]"
                ],
                "params": [
                    "list[dict[, ]]"
                ],
                "opts": [
                    "list[dict[, ]]"
                ]
            }
        },
        "AdaDelta.cl_opts": {
            "name": "cl_opts",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "AdaDelta.cl_init": {
            "name": "cl_init",
            "location": 147,
            "return": [
                "AdaDelta"
            ],
            "arguments": {
                "cls": [
                    "Type[_TAdaDelta]"
                ],
                "params": [
                    "list[dict[, ]]"
                ],
                "opts": [
                    "list[dict[, ]]"
                ]
            }
        },
        "RMSProp.cl_opts": {
            "name": "cl_opts",
            "location": 160,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "RMSProp.cl_init": {
            "name": "cl_init",
            "location": 208,
            "return": [
                "RMSProp"
            ],
            "arguments": {
                "cls": [
                    "Type[_TRMSProp]"
                ],
                "params": [
                    "list[dict[, ]]"
                ],
                "opts": [
                    "list[dict[, ]]"
                ]
            }
        },
        "Adam.cl_opts": {
            "name": "cl_opts",
            "location": 223,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "Adam.cl_init": {
            "name": "cl_init",
            "location": 272,
            "return": [
                "Adam"
            ],
            "arguments": {
                "cls": [
                    "Type[_TAdam]"
                ],
                "params": [
                    "list[dict[, ]]"
                ],
                "opts": [
                    "list[dict[, ]]"
                ]
            }
        },
        "SparseAdam.cl_opts": {
            "name": "cl_opts",
            "location": 286,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "SparseAdam.cl_init": {
            "name": "cl_init",
            "location": 324,
            "return": [
                "SparseAdam"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSparseAdam]"
                ],
                "params": [
                    "list[dict[, ]]"
                ],
                "opts": [
                    "list[dict[, ]]"
                ]
            }
        },
        "SGD.__init__": {
            "name": "__init__",
            "location": 335,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "dict[str, typing.Any]",
                    "list[]",
                    "list[torch.nn.utils.rnn.PackedSequence]"
                ],
                "cycle_len": [
                    "None",
                    "int",
                    "float"
                ],
                "cycle_mult": [
                    "float"
                ]
            }
        },
        "SGD.cl_opts": {
            "name": "cl_opts",
            "location": 352,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "SGD.cl_init": {
            "name": "cl_init",
            "location": 400,
            "return": [
                "SGD"
            ],
            "arguments": {
                "cls": [
                    "Type[_TSGD]"
                ],
                "params": [
                    "list[dict[, ]]"
                ],
                "opts": [
                    "dict[, ]",
                    "None",
                    "bytes",
                    "typing.Type",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "SGD._cyclic_decay": {
            "name": "_cyclic_decay",
            "location": 416,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "i": [
                    "int"
                ]
            }
        },
        "SGD.iteration_update": {
            "name": "iteration_update",
            "location": 444,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "i": [
                    "str",
                    "float",
                    "list[int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "SGD.epoch_update": {
            "name": "epoch_update",
            "location": 449,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "loss": [
                    "float",
                    "dict[, ]",
                    "int",
                    "list[]"
                ]
            }
        },
        "SGD.epoch_prepare": {
            "name": "epoch_prepare",
            "location": 467,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "training_size": [
                    "int"
                ],
                "batch_size": [
                    "int"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/opts.py": {
        "help_opts": {
            "name": "help_opts",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ]
            }
        },
        "base_opts": {
            "name": "base_opts",
            "location": 29,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ]
            }
        },
        "label_opts": {
            "name": "label_opts",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ],
                "require": [
                    "bool",
                    "argparse.ArgumentParser"
                ]
            }
        },
        "train_opts": {
            "name": "train_opts",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ],
                "require": [
                    "bool",
                    "argparse.ArgumentParser",
                    "Callable[[argparse.ArgumentParser],None]",
                    "argparse._SubParsersAction"
                ]
            }
        },
        "get_parser": {
            "name": "get_parser",
            "location": 185,
            "return": [
                "Tuple[(argparse.Namespace, ArgumentParser)]"
            ],
            "arguments": {
                "args": [],
                "options": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "parse_all": {
            "name": "parse_all",
            "location": 201,
            "return": [
                "int",
                "str",
                "Set[str]"
            ],
            "arguments": {
                "args": [],
                "initial_opts": [
                    "str",
                    "bool"
                ],
                "parser": [
                    "argparse.ArgumentParser",
                    "argparse._SubParsersAction"
                ]
            }
        },
        "get_device": {
            "name": "get_device",
            "location": 213,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "opts": [
                    "bytes",
                    "Dict",
                    "List[int]",
                    "int",
                    "Optional[bool]",
                    "None"
                ]
            }
        },
        "ArgumentParser.error": {
            "name": "error",
            "location": 180,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "message": [
                    "str",
                    "Dict"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/train.py": {
        "_get_checkpoint_path": {
            "name": "_get_checkpoint_path",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "path": [
                    "str",
                    "int"
                ],
                "epoch": [
                    "int"
                ]
            }
        },
        "save_checkpoint": {
            "name": "save_checkpoint",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [],
                "optimizer": [],
                "path": [
                    "str",
                    "int"
                ],
                "epoch": [
                    "bool",
                    "list[str]"
                ]
            }
        },
        "load_checkpoint": {
            "name": "load_checkpoint",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "str",
                    "typing.IO",
                    "typing.Type"
                ],
                "path": [
                    "str",
                    "int"
                ],
                "epoch": [
                    "str",
                    "int"
                ],
                "optimizer": [
                    "None",
                    "str",
                    "dict[, ]"
                ]
            }
        },
        "save_model": {
            "name": "save_model",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "str",
                    "None",
                    "dict[str, str]"
                ],
                "path": [
                    "str"
                ],
                "epoch": [
                    "int",
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 406,
            "return": [
                "None"
            ],
            "arguments": {
                "args": [
                    "None"
                ]
            }
        },
        "Learner.__init__": {
            "name": "__init__",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "args": [
                    "None"
                ]
            }
        },
        "Learner.reset_model": {
            "name": "reset_model",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Learner.save_train_state": {
            "name": "save_train_state",
            "location": 166,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "path": [
                    "str"
                ]
            }
        },
        "Learner.build": {
            "name": "build",
            "location": 177,
            "return": [
                "Learner"
            ],
            "arguments": {
                "cls": [
                    "Type[_TLearner]"
                ]
            }
        },
        "Learner.__getattr__": {
            "name": "__getattr__",
            "location": 195,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "Learner.__setattr__": {
            "name": "__setattr__",
            "location": 198,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "dict[, ]",
                    "str",
                    "dict[str, typing.Any]",
                    "None",
                    "dict[str, dict[str, typing.Any]]",
                    "dict[str, str]"
                ],
                "value": [
                    "str",
                    "int"
                ]
            }
        },
        "Learner.fit_epoch": {
            "name": "fit_epoch",
            "location": 206,
            "return": [
                "Generator[(Any, Any, None)]"
            ],
            "arguments": {
                "self": [],
                "optimizer": [],
                "dataset": [],
                "epoch": [
                    "int"
                ],
                "logger": [
                    "None",
                    "int"
                ],
                "n": [
                    "None",
                    "int",
                    "typing.Sequence[]",
                    "list[]"
                ]
            }
        },
        "Learner.fit": {
            "name": "fit",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Learner.find_lr": {
            "name": "find_lr",
            "location": 345,
            "return": [
                "Tuple[(Any, np.ndarray)]"
            ],
            "arguments": {
                "self": [],
                "bounds": [
                    "tuple[float]"
                ],
                "iterations": [
                    "int"
                ],
                "smoothing": [
                    "float"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/utils.py": {
        "_parse_data_path": {
            "name": "_parse_data_path",
            "location": 6,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "path": [
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "in_ipynb": {
            "name": "in_ipynb",
            "location": 15,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {}
        }
    },
    "pytorch-crf-master/pycrf/__init__.py": {},
    "pytorch-crf-master/pycrf/io/dataset.py": {
        "Dataset.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "is_test": [
                    "bool",
                    "Optional[str]",
                    "Optional[List[Any]]",
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "Dataset.__getitem__": {
            "name": "__getitem__",
            "location": 24,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "bytes"
                ]
            }
        },
        "Dataset.__iter__": {
            "name": "__iter__",
            "location": 27,
            "return": [
                "Generator[(Tuple[(nothing, nothing)], Any, None)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.__len__": {
            "name": "__len__",
            "location": 31,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.__bool__": {
            "name": "__bool__",
            "location": 34,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.append": {
            "name": "append",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "src": [
                    "str",
                    "List[str]",
                    "vocab.Vocab",
                    "torch.device"
                ],
                "tgt": [
                    "str",
                    "Dict[str,int]",
                    "bool",
                    "List[str]"
                ],
                "vocab": [
                    "str",
                    "List[str]",
                    "int",
                    "vocab.Vocab",
                    "torch.device"
                ],
                "device": [
                    "str",
                    "None",
                    "List[str]",
                    "int",
                    "vocab.Vocab",
                    "torch.device"
                ],
                "sent_context": [
                    "str",
                    "None",
                    "List[str]",
                    "vocab.Vocab",
                    "torch.device"
                ]
            }
        },
        "Dataset.shuffle": {
            "name": "shuffle",
            "location": 52,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "Dataset.read_file": {
            "name": "read_file",
            "location": 59,
            "return": [
                "Generator[(Tuple[(Any, Any, List[str], List[str])], Any, None)]"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "bool",
                    "float",
                    "Optional[bool]"
                ],
                "vocab": [
                    "vocab.Vocab",
                    "bool",
                    "torch.device",
                    "str",
                    "Optional[int]",
                    "Optional[str]",
                    "int"
                ],
                "device": [
                    "None",
                    "bool",
                    "str",
                    "vocab.Vocab",
                    "torch.device",
                    "Optional[int]",
                    "Optional[str]",
                    "int"
                ],
                "sent_context": [
                    "str",
                    "None",
                    "bool",
                    "float",
                    "random.Random"
                ],
                "test": [
                    "bool",
                    "vocab.Vocab",
                    "torch.device",
                    "str",
                    "Optional[int]",
                    "Optional[str]",
                    "int"
                ]
            }
        },
        "Dataset.load_file": {
            "name": "load_file",
            "location": 121,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fname": [
                    "str",
                    "bool"
                ],
                "vocab": [
                    "IO[Any]",
                    "str",
                    "IO",
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "limit": [
                    "int",
                    "None",
                    "str",
                    "Iterable[str]",
                    "Optional[int]",
                    "Optional[str]",
                    "Optional[Iterable[str]]",
                    "torch.optim.Optimizer"
                ],
                "device": [
                    "IO[Any]",
                    "None",
                    "str",
                    "int",
                    "IO",
                    "Optional[int]"
                ],
                "sent_context": [
                    "IO[Any]",
                    "None",
                    "str",
                    "int",
                    "IO",
                    "Optional[int]"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/io/vectors.py": {
        "load_pretrained": {
            "name": "load_pretrained",
            "location": 8,
            "return": [
                "Tuple[(Any, Dict[(int, str)], Dict[(str, int)])]"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/io/vocab.py": {
        "Vocab.__init__": {
            "name": "__init__",
            "location": 85,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "words_stoi": [
                    "int",
                    "str",
                    "Sequence[str]",
                    "float",
                    "Optional[str]",
                    "None",
                    "List[Dict[str,Any]]",
                    "List[dict[str,Any]]"
                ],
                "words_itos": [
                    "int",
                    "str",
                    "Sequence[str]",
                    "float",
                    "Optional[str]",
                    "None",
                    "List[Dict[str,Any]]",
                    "List[dict[str,Any]]"
                ],
                "labels": [
                    "List[str]",
                    "bool",
                    "None",
                    "str"
                ],
                "default_label": [
                    "Text",
                    "List[int]",
                    "bool"
                ],
                "default_context": [
                    "Text",
                    "str",
                    "int",
                    "List[Product]",
                    "Dict[str,int]"
                ],
                "unk_term": [
                    "Text",
                    "bool",
                    "Callable",
                    "int",
                    "Optional[List[str]]",
                    "float"
                ],
                "pad_char": [
                    "Text",
                    "int",
                    "Tuple[int,int]"
                ],
                "unk_char": [
                    "Text",
                    "int",
                    "Tuple[int,int]"
                ]
            }
        },
        "Vocab.n_words": {
            "name": "n_words",
            "location": 119,
            "return": [
                "int",
                "float",
                "str",
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocab.n_chars": {
            "name": "n_chars",
            "location": 124,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocab.n_labels": {
            "name": "n_labels",
            "location": 129,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "Vocab.sent2tensor": {
            "name": "sent2tensor",
            "location": 133,
            "return": [
                "Tuple[Union[int,float,list,str,Deque,Callable[Callable[...,Any],Callable[...,Any]],list[tuple[Union[Any,bool]]],None]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "sent": [
                    "List[str]",
                    "Dict",
                    "bool",
                    "Callable",
                    "int",
                    "str"
                ],
                "device": [
                    "torch.device",
                    "None",
                    "List[str]",
                    "Optional[List[int]]",
                    "List[int]",
                    "Optional[Dict]",
                    "Dict"
                ],
                "sent_context": [
                    "None",
                    "bool",
                    "raiden.utils.Optional[raiden.network.rpc.clienTransactionSent]",
                    "float",
                    "raiden.utils.BlockNumber",
                    "Optional[float]"
                ],
                "test": [
                    "bool",
                    "List[str]",
                    "Callable",
                    "Dict",
                    "int",
                    "str"
                ]
            }
        },
        "Vocab.labs2tensor": {
            "name": "labs2tensor",
            "location": 213,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "labs": [
                    "str",
                    "List[str]",
                    "int",
                    "bool"
                ],
                "device": [
                    "str",
                    "None",
                    "Optional[str]",
                    "Optional[Tuple[float,float]]",
                    "Tuple[Union[float,float]]"
                ],
                "test": [
                    "bool",
                    "int",
                    "str",
                    "List[str]"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/io/__init__.py": {},
    "pytorch-crf-master/pycrf/modules/char_cnn.py": {
        "CharCNN.__init__": {
            "name": "__init__",
            "location": 57,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_chars": [
                    "int",
                    "Tuple[int]",
                    "List"
                ],
                "channels": [
                    "int"
                ],
                "kernel_size": [
                    "int",
                    "Tuple[int]",
                    "bool"
                ],
                "embedding_size": [
                    "int",
                    "bool"
                ],
                "padding": [
                    "int",
                    "Tuple[int]",
                    "bool"
                ],
                "padding_idx": [
                    "int",
                    "str",
                    "float"
                ],
                "dropout": [
                    "float",
                    "int",
                    "str"
                ]
            }
        },
        "CharCNN.forward": {
            "name": "forward",
            "location": 80,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "Callable",
                    "str"
                ],
                "lengths": [
                    "int",
                    "str",
                    "Iterable[C]",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ],
                "indices": [
                    "Sequence[Sequence[T]]",
                    "torch.Tensor"
                ]
            }
        },
        "CharCNN.cl_opts": {
            "name": "cl_opts",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ],
                "require": [
                    "bool",
                    "argparse.ArgumentParser",
                    "utils.parser.BinaryParser",
                    "argparse._SubParsersAction",
                    "Callable[[argparse.ArgumentParser],None]"
                ]
            }
        },
        "CharCNN.cl_init": {
            "name": "cl_init",
            "location": 152,
            "return": [
                "CharCNN"
            ],
            "arguments": {
                "cls": [
                    "Type[_TCharCNN]"
                ],
                "opts": [
                    "int",
                    "argparse.Namespace",
                    "Tuple",
                    "Dict[str,str]",
                    "Set[str]",
                    "float",
                    "Tuple[Union[int,int,str]]",
                    "Tuple[int,int,str]"
                ],
                "vocab": [
                    "int",
                    "argparse.Namespace",
                    "Tuple",
                    "Dict[str,str]",
                    "Set[str]",
                    "float",
                    "Tuple[Union[int,int,str]]",
                    "Tuple[int,int,str]"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/modules/char_embedding.py": {
        "CharEmbedding.__init__": {
            "name": "__init__",
            "location": 39,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_chars": [
                    "int",
                    "Tuple[int,int,int]",
                    "Tuple[Union[int,int,int]]"
                ],
                "embedding_size": [
                    "int",
                    "str"
                ],
                "dropout": [
                    "float",
                    "str",
                    "bool",
                    "Optional[int]",
                    "Optional[bool]",
                    "int"
                ],
                "padding_idx": [
                    "int",
                    "str"
                ]
            }
        },
        "CharEmbedding.forward": {
            "name": "forward",
            "location": 55,
            "return": [
                "int",
                "str",
                "Callable",
                "List[str]"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "CharEmbedding.cl_opts": {
            "name": "cl_opts",
            "location": 83,
            "return": [
                "None"
            ],
            "arguments": {
                "group": [
                    "bool",
                    "List[str]"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/modules/char_lstm.py": {
        "CharLSTM.__init__": {
            "name": "__init__",
            "location": 59,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_chars": [
                    "int",
                    "Tuple[int,int,int]",
                    "Tuple[Union[int,int,int]]",
                    "List[List[int]]",
                    "List[list[int]]"
                ],
                "hidden_size": [
                    "int",
                    "float",
                    "List[float]",
                    "List[str]",
                    "bool"
                ],
                "bidirectional": [
                    "bool",
                    "int",
                    "float",
                    "List[float]",
                    "List[str]"
                ],
                "embedding_size": [
                    "int",
                    "str",
                    "float"
                ],
                "layers": [
                    "int",
                    "float",
                    "bool",
                    "List[float]",
                    "List[str]"
                ],
                "dropout": [
                    "float",
                    "int",
                    "str"
                ],
                "padding_idx": [
                    "int",
                    "float"
                ]
            }
        },
        "CharLSTM.forward": {
            "name": "forward",
            "location": 89,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "int",
                    "str",
                    "bool"
                ],
                "lengths": [
                    "bool",
                    "float",
                    "int"
                ],
                "indices": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "CharLSTM.cl_opts": {
            "name": "cl_opts",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [
                    "argparse.ArgumentParser"
                ],
                "require": [
                    "bool",
                    "argparse.ArgumentParser",
                    "utils.parser.BinaryParser",
                    "argparse._SubParsersAction",
                    "Callable[[argparse.ArgumentParser],None]"
                ]
            }
        },
        "CharLSTM.cl_init": {
            "name": "cl_init",
            "location": 154,
            "return": [
                "CharLSTM"
            ],
            "arguments": {
                "cls": [
                    "Type[_TCharLSTM]"
                ],
                "opts": [
                    "int",
                    "argparse.Namespace",
                    "io.TextIO"
                ],
                "vocab": [
                    "int",
                    "argparse.Namespace",
                    "io.TextIO"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/modules/crf.py": {
        "logsumexp": {
            "name": "logsumexp",
            "location": 25,
            "return": [
                "Any"
            ],
            "arguments": {
                "tensor": [
                    "bool",
                    "float"
                ],
                "dim": [
                    "int"
                ],
                "keepdim": [
                    "bool"
                ]
            }
        },
        "viterbi_decode": {
            "name": "viterbi_decode",
            "location": 54,
            "return": [
                "Tuple[(List[int], Any)]"
            ],
            "arguments": {
                "tag_sequence": [],
                "transition_matrix": [],
                "tag_observations": []
            }
        },
        "allowed_transitions": {
            "name": "allowed_transitions",
            "location": 147,
            "return": [
                "List[Tuple[(Any, Any)]]"
            ],
            "arguments": {
                "constraint_type": [
                    "str"
                ],
                "tokens": []
            }
        },
        "ConditionalRandomField.__init__": {
            "name": "__init__",
            "location": 257,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "num_tags": [
                    "str",
                    "list[str]",
                    "None",
                    "int"
                ],
                "constraints": [
                    "None",
                    "list[tuple[typing.Union[int,int]]]",
                    "bool",
                    "str"
                ],
                "include_start_end_transitions": [
                    "bool"
                ]
            }
        },
        "ConditionalRandomField.reset_parameters": {
            "name": "reset_parameters",
            "location": 287,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ConditionalRandomField._input_likelihood": {
            "name": "_input_likelihood",
            "location": 294,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "logits": [],
                "mask": []
            }
        },
        "ConditionalRandomField._joint_likelihood": {
            "name": "_joint_likelihood",
            "location": 347,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "logits": [
                    "str",
                    "None",
                    "int"
                ],
                "tags": [
                    "dict[str, typing.Any]",
                    "typing.Mapping",
                    "str",
                    "None",
                    "tuple[typing.Union[list[str],typing.Any,None]]",
                    "list[str]"
                ],
                "mask": [
                    "float"
                ]
            }
        },
        "ConditionalRandomField.forward": {
            "name": "forward",
            "location": 422,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "str",
                    "bool",
                    "None",
                    "dict[, ]"
                ],
                "tags": [],
                "mask": [
                    "None",
                    "bool",
                    "str",
                    "typing.Any",
                    "list[str]"
                ]
            }
        },
        "ConditionalRandomField.viterbi_tags": {
            "name": "viterbi_tags",
            "location": 436,
            "return": [
                "List[Tuple[(List[int], Any)]]"
            ],
            "arguments": {
                "self": [],
                "logits": [],
                "mask": [
                    "str",
                    "Exception"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/modules/lstm_crf.py": {
        "LSTMCRF.__init__": {
            "name": "__init__",
            "location": 89,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "int",
                    "typing.Mapping",
                    "bytes",
                    "None"
                ],
                "char_feats_layer": [
                    "int",
                    "typing.Mapping",
                    "bytes",
                    "None",
                    "float",
                    "str"
                ],
                "crf": [
                    "str",
                    "None"
                ],
                "pretrained_word_vecs": [],
                "sent_context_embedding": [
                    "int"
                ],
                "hidden_dim": [
                    "int"
                ],
                "layers": [
                    "int"
                ],
                "dropout": [
                    "float"
                ],
                "bidirectional": [
                    "bool"
                ],
                "freeze_embeddings": [
                    "bool"
                ]
            }
        },
        "LSTMCRF.get_trainable_params": {
            "name": "get_trainable_params",
            "location": 154,
            "return": [
                "List[Dict[(str, Any)]]"
            ],
            "arguments": {
                "self": [],
                "lrs": [
                    "None",
                    "str",
                    "int"
                ]
            }
        },
        "LSTMCRF._feats": {
            "name": "_feats",
            "location": 185,
            "return": [
                "Any"
            ],
            "arguments": {
                "self": [],
                "words": [],
                "word_lengths": [
                    "float"
                ],
                "word_indices": [
                    "float"
                ],
                "word_idxs": [
                    "int"
                ],
                "sent_context": []
            }
        },
        "LSTMCRF.predict": {
            "name": "predict",
            "location": 279,
            "return": [
                "str",
                "bool",
                "dict[int, str]"
            ],
            "arguments": {
                "self": [],
                "words": [],
                "word_lengths": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "word_indices": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "word_idxs": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "sent_context": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "lens": [
                    "None",
                    "int"
                ]
            }
        },
        "LSTMCRF.forward": {
            "name": "forward",
            "location": 332,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "words": [],
                "word_lengths": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "word_indices": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "word_idxs": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "sent_context": [
                    "int",
                    "list[float]",
                    "typing.Sequence[int]",
                    "list[list[str]]"
                ],
                "labs": [],
                "lens": [
                    "None",
                    "int"
                ]
            }
        },
        "LSTMCRF.cl_opts": {
            "name": "cl_opts",
            "location": 393,
            "return": [
                "None"
            ],
            "arguments": {
                "parser": [],
                "require": [
                    "bool"
                ]
            }
        },
        "LSTMCRF.cl_init": {
            "name": "cl_init",
            "location": 418,
            "return": [
                "LSTMCRF"
            ],
            "arguments": {
                "cls": [
                    "Type[_TLSTMCRF]"
                ],
                "opts": [
                    "str",
                    "bool"
                ],
                "vocab": [
                    "str",
                    "dict[, ]"
                ],
                "char_feats_layer": [
                    "str",
                    "bool"
                ],
                "word_vecs": [
                    "str",
                    "bool"
                ]
            }
        }
    },
    "pytorch-crf-master/pycrf/modules/__init__.py": {},
    "pytorch-crf-master/pycrf/nn/utils.py": {
        "sequence_mask": {
            "name": "sequence_mask",
            "location": 8,
            "return": [
                "bool",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "lens": [
                    "int",
                    "Dict[str, Any]",
                    "float",
                    "bytes",
                    "List[Tuple[int, int]]"
                ],
                "max_len": [
                    "int",
                    "None",
                    "List[int]",
                    "Dict",
                    "Optional[int]",
                    "torch.LongTensor"
                ]
            }
        },
        "pad": {
            "name": "pad",
            "location": 41,
            "return": [
                "str"
            ],
            "arguments": {
                "tensor": [
                    "None",
                    "torch.Tensor",
                    "bool",
                    "float",
                    "Optional[torch.Tensor]"
                ],
                "length": [
                    "None",
                    "torch.Tensor",
                    "bool",
                    "float",
                    "Optional[torch.Tensor]"
                ]
            }
        },
        "sort_and_pad": {
            "name": "sort_and_pad",
            "location": 48,
            "return": [
                "Tuple[(Any, Any, Any)]"
            ],
            "arguments": {
                "tensors": [
                    "int",
                    "Sequence[int]",
                    "float",
                    "str"
                ],
                "lengths": [
                    "int",
                    "bytes",
                    "str",
                    "Optional[float]",
                    "float"
                ]
            }
        },
        "unsort": {
            "name": "unsort",
            "location": 80,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "tensor": [
                    "int",
                    "float"
                ],
                "indices": [
                    "int",
                    "str"
                ]
            }
        },
        "assert_equal": {
            "name": "assert_equal",
            "location": 87,
            "return": [
                "None"
            ],
            "arguments": {
                "tensor_a": [
                    "int",
                    "torch.Tensor",
                    "List[torch.Tensor]",
                    "Dict",
                    "float",
                    "List[int]"
                ],
                "tensor_b": [
                    "int",
                    "torch.Tensor",
                    "List[torch.Tensor]",
                    "Dict",
                    "float",
                    "List[int]"
                ]
            }
        }
    },
    "pytorch-crf-master/test/conftest.py": {
        "extract_vecs": {
            "name": "extract_vecs",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "fname": [
                    "str",
                    "List[str]"
                ],
                "dest": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        },
        "download_vecs": {
            "name": "download_vecs",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "glove": {
            "name": "glove",
            "location": 53,
            "return": [
                "Dict[Text,Union[int,dict,list[int],list[list[int]],str]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "vocab_dataset": {
            "name": "vocab_dataset",
            "location": 66,
            "return": [
                "Tuple[Union[Vocab,Dataset]]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "glove": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "vocab": {
            "name": "vocab",
            "location": 74,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "vocab_dataset": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "dataset": {
            "name": "dataset",
            "location": 79,
            "return": [
                "str",
                "int",
                "Callable"
            ],
            "arguments": {
                "vocab_dataset": [
                    "str",
                    "int",
                    "Iterable[Context]",
                    "Dict",
                    "bool"
                ]
            }
        },
        "dataset_dev": {
            "name": "dataset_dev",
            "location": 84,
            "return": [
                "Dataset",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "vocab": [
                    "str",
                    "bytes",
                    "Dict",
                    "bool"
                ]
            }
        },
        "crf": {
            "name": "crf",
            "location": 91,
            "return": [
                "ConditionalRandomField",
                "Optional[int]",
                "Callable",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "vocab_dataset": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "char_lstm": {
            "name": "char_lstm",
            "location": 96,
            "return": [
                "CharLSTM",
                "str",
                "bool"
            ],
            "arguments": {
                "vocab_dataset": [
                    "str",
                    "int",
                    "Tuple[Union[str,int]]",
                    "Tuple[str,int]"
                ]
            }
        },
        "char_cnn": {
            "name": "char_cnn",
            "location": 101,
            "return": [
                "CharCNN",
                "str",
                "bool"
            ],
            "arguments": {
                "vocab_dataset": [
                    "str",
                    "int",
                    "Tuple[Union[str,int]]",
                    "Tuple[str,int]"
                ]
            }
        },
        "lstm_crf": {
            "name": "lstm_crf",
            "location": 106,
            "return": [
                "str",
                "LSTMCRF"
            ],
            "arguments": {
                "vocab_dataset": [
                    "str",
                    "bool",
                    "List[list[str]]",
                    "List[str]",
                    "int",
                    "float",
                    "List[List[str]]"
                ],
                "char_lstm": [
                    "bool",
                    "str",
                    "float",
                    "List[str]",
                    "int",
                    "List[list[str]]",
                    "List[List[str]]"
                ],
                "crf": [
                    "bool",
                    "str",
                    "float",
                    "List[str]",
                    "int",
                    "List[list[str]]",
                    "List[List[str]]"
                ],
                "glove": [
                    "str",
                    "bool",
                    "List[list[str]]",
                    "List[str]",
                    "int",
                    "float",
                    "List[List[str]]"
                ]
            }
        },
        "get_model_stats": {
            "name": "get_model_stats",
            "location": 111,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "vocab_dataset": [
                    "bool",
                    "int"
                ]
            }
        },
        "get_model_stats._get_model_stats": {
            "name": "_get_model_stats",
            "location": 113,
            "return": [
                "str",
                "Dict",
                "ModelStats"
            ],
            "arguments": {
                "items": [
                    "List[Dict[str, Any]]",
                    "str",
                    "Type[object]",
                    "Sequence[str]",
                    "Tuple[Sequence[Any], Sequence[str], Sequence[Any]]"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_char_cnn.py": {
        "test_forward": {
            "name": "test_forward",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {
                "char_cnn": [
                    "str"
                ],
                "vocab_dataset": [
                    "str"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_char_lstm.py": {
        "test_forward": {
            "name": "test_forward",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {
                "char_lstm": [
                    "str"
                ],
                "vocab_dataset": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_dataset.py": {
        "test_size": {
            "name": "test_size",
            "location": 8,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "int",
                    "float",
                    "Tuple[float,float,float,float,float]",
                    "Tuple[Union[float,float,float,float,float]]"
                ]
            }
        },
        "test_source": {
            "name": "test_source",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Dict",
                    "Dict[str,Any]",
                    "utils.JobsType"
                ]
            }
        },
        "test_target": {
            "name": "test_target",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "dataset": [
                    "Iterable"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_eval.py": {
        "test_iob_to_spans": {
            "name": "test_iob_to_spans",
            "location": 49,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab_dataset": [
                    "int",
                    "str",
                    "Callable",
                    "Optional[str]",
                    "None"
                ],
                "tags": [
                    "str"
                ],
                "lab_itos": [
                    "str"
                ],
                "chunks": [
                    "str"
                ]
            }
        },
        "test_iobes_to_spans": {
            "name": "test_iobes_to_spans",
            "location": 110,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab_dataset": [
                    "int",
                    "str",
                    "Callable",
                    "Optional[str]",
                    "None"
                ],
                "tags": [
                    "str"
                ],
                "lab_itos": [
                    "str"
                ],
                "chunks": [
                    "str"
                ]
            }
        },
        "test_detect_label_scheme": {
            "name": "test_detect_label_scheme",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {
                "labels": [
                    "List[Callable]",
                    "str",
                    "Iterator[str]",
                    "int",
                    "Iterator",
                    "Dict[str,str]",
                    "List[Exception]"
                ],
                "check": [
                    "List[Callable]",
                    "str",
                    "Iterator[str]",
                    "int",
                    "Iterator",
                    "Dict[str,str]",
                    "List[Exception]"
                ]
            }
        },
        "test_detect_label_scheme_errors": {
            "name": "test_detect_label_scheme_errors",
            "location": 139,
            "return": [
                "None"
            ],
            "arguments": {
                "labels": [
                    "Sequence[Sequence[str]]",
                    "Sequence[str]",
                    "Callable",
                    "List",
                    "int",
                    "Sequence[Tuple[str,int]]",
                    "Sequence[tuple[Union[str,int]]]"
                ]
            }
        },
        "test_eval_stats": {
            "name": "test_eval_stats",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "get_model_stats": [
                    "int",
                    "Callable",
                    "Dict[str,str]"
                ],
                "sentences": [
                    "int",
                    "Callable",
                    "Dict[str,str]"
                ],
                "f1": [
                    "int",
                    "str",
                    "List[str]",
                    "Dict[str,Union[str,int]]",
                    "bool"
                ],
                "precision": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "bool"
                ],
                "recall": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "bool"
                ],
                "accuracy": [
                    "str",
                    "int",
                    "Sequence[str]",
                    "bool"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_lstm_crf.py": {
        "test_feats": {
            "name": "test_feats",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {
                "lstm_crf": [
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "vocab_dataset": [
                    "str",
                    "float"
                ]
            }
        },
        "test_predict": {
            "name": "test_predict",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "lstm_crf": [
                    "List[Tuple[int,int,float]]",
                    "List[tuple[Union[int,int,float]]]"
                ],
                "vocab_dataset": [
                    "str",
                    "float"
                ]
            }
        },
        "test_forward": {
            "name": "test_forward",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "lstm_crf": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "vocab_dataset": [
                    "str",
                    "float"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_sgd.py": {
        "test_cyclic_lr": {
            "name": "test_cyclic_lr",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "lstm_crf": [
                    "int",
                    "bool"
                ],
                "training_size": [
                    "int",
                    "float"
                ],
                "batch_size": [
                    "int",
                    "float"
                ],
                "epochs": [
                    "int",
                    "List[int]",
                    "Union[str,float]",
                    "str",
                    "float"
                ],
                "cycle_len": [
                    "int",
                    "bool"
                ],
                "cycle_mult": [
                    "int",
                    "bool"
                ],
                "checks": [
                    "str",
                    "List[str]",
                    "bool",
                    "int"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_utils.py": {
        "test_check_equal": {
            "name": "test_check_equal",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_sequence_mask": {
            "name": "test_sequence_mask",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "inp": [
                    "int",
                    "float",
                    "str"
                ],
                "chk": [
                    "List[str]",
                    "List[int]"
                ],
                "max_len": [
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "test_pad": {
            "name": "test_pad",
            "location": 67,
            "return": [
                "None"
            ],
            "arguments": {
                "inputs": [
                    "int",
                    "Iterable"
                ],
                "check": [
                    "int",
                    "Iterable"
                ]
            }
        },
        "test_sort_and_pad": {
            "name": "test_sort_and_pad",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "inputs": [
                    "str",
                    "float"
                ],
                "check": []
            }
        },
        "test_unsort": {
            "name": "test_unsort",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "inputs": [
                    "int",
                    "Iterable"
                ],
                "check": [
                    "int",
                    "Iterable"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_vectors.py": {
        "test_load_pretrained": {
            "name": "test_load_pretrained",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "glove": [
                    "int",
                    "float",
                    "Tuple[float,float,float,float,float]",
                    "Tuple[Union[float,float,float,float,float]]"
                ]
            }
        }
    },
    "pytorch-crf-master/test/test_vocab.py": {
        "test_labels": {
            "name": "test_labels",
            "location": 9,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab": [
                    "Dict[str,Sequence[Any]]"
                ]
            }
        },
        "test_chars": {
            "name": "test_chars",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab": [
                    "int",
                    "Type",
                    "IO[bytes]",
                    "str",
                    "IO",
                    "List[str]"
                ]
            }
        },
        "test_words": {
            "name": "test_words",
            "location": 30,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab": [
                    "int",
                    "Callable"
                ]
            }
        },
        "test_sent2tensor": {
            "name": "test_sent2tensor",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab": [
                    "float",
                    "int"
                ],
                "sent": [
                    "int"
                ]
            }
        },
        "test_labs2tensor": {
            "name": "test_labs2tensor",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {
                "vocab": [
                    "str"
                ],
                "labs": [
                    "str"
                ],
                "is_test": [
                    "str"
                ],
                "check": [
                    "Callable",
                    "Sequence[str]"
                ]
            }
        }
    }
}
{
    "scikit-keras-master/setup.py": {},
    "scikit-keras-master/scikit_keras/__init__.py": {},
    "scikit-keras-master/scikit_keras/keras/batches.py": {
        "ArrayBatchGenerator.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "list[dict[str, typing.Any]]",
                    "bool",
                    "List[Dict[str, Any]]",
                    "list[str]",
                    "List[str]",
                    "int"
                ],
                "y": [
                    "int",
                    "float",
                    "str",
                    "dict[str, int]",
                    "bool",
                    "dict[int, str]",
                    "Dict[str, int]",
                    "Dict[int, str]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "ArrayBatchGenerator.__len__": {
            "name": "__len__",
            "location": 19,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayBatchGenerator.__getitem__": {
            "name": "__getitem__",
            "location": 24,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "list",
                    "List[Tuple[int, int]]"
                ]
            }
        }
    },
    "scikit-keras-master/scikit_keras/keras/timing.py": {
        "_n": {
            "name": "_n",
            "location": 10,
            "return": [
                "str",
                "List[str]",
                "List[int]",
                "Optional[str]"
            ],
            "arguments": {
                "num_or_tuple": [
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "total_latency": {
            "name": "total_latency",
            "location": 19,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "relative_latencies": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "absolute_latencies": {
            "name": "absolute_latencies",
            "location": 37,
            "return": [
                "List[Tuple[(Any, Any)]]"
            ],
            "arguments": {
                "relative_latencies": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "layer_latency": {
            "name": "layer_latency",
            "location": 61,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "layer": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "model_latency": {
            "name": "model_latency",
            "location": 98,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "model": []
            }
        },
        "model_output_length": {
            "name": "model_output_length",
            "location": 118,
            "return": [
                "int"
            ],
            "arguments": {
                "model": [
                    "int"
                ],
                "input_shape": [
                    "int",
                    "list",
                    "str",
                    "List[List[Any]]"
                ]
            }
        }
    },
    "scikit-keras-master/scikit_keras/keras/utils.py": {
        "iterlayers": {
            "name": "iterlayers",
            "location": 8,
            "return": [
                "Iterable"
            ],
            "arguments": {
                "model": [
                    "int",
                    "float",
                    "keras.engine.Layer"
                ]
            }
        },
        "fix_model_duplicate_layers_by_name": {
            "name": "fix_model_duplicate_layers_by_name",
            "location": 22,
            "return": [
                "tuple[typing.Union[bool,None,str,typing.Callable[..., collections.abc.Coroutine],list[str],dict[, ]]]",
                "bool",
                "flask_appbuilder.models.sqla.Model",
                "Callable",
                "List[app.models.Question]",
                "app.models.Question",
                "deeplearning.ml4pl.models.classifier_base.ClassifierBase"
            ],
            "arguments": {
                "model": [
                    "bool",
                    "keras.engine.Layer",
                    "db.models.Region"
                ],
                "substitutions": [
                    "str",
                    "None",
                    "Callable[..., Coroutine[Any, Any, Any]]",
                    "pringles.models.Model",
                    "typing.Callable[..., collections.abc.Coroutine]",
                    "List[str]",
                    "list[str]"
                ],
                "return_substitutions": [
                    "bool",
                    "List[str]",
                    "Dict[str, str]",
                    "Type",
                    "faustypes.models.ModelOptions",
                    "faustypes.models.FieldDescriptorT"
                ]
            }
        },
        "fix_multimodel_duplicate_layers_by_name": {
            "name": "fix_multimodel_duplicate_layers_by_name",
            "location": 43,
            "return": [
                "tuple[typing.Union[dict[, ],None,str,bool]]",
                "int",
                "dict[, ]",
                "Optional[str]",
                "str"
            ],
            "arguments": {
                "multimodel": [
                    "Dict[(str, Any)]"
                ],
                "substitutions": [
                    "str",
                    "bool",
                    "None"
                ],
                "return_substitutions": [
                    "bool",
                    "str",
                    "db.models.Region"
                ]
            }
        },
        "serialize_model": {
            "name": "serialize_model",
            "location": 63,
            "return": [
                "Optional[bytes]"
            ],
            "arguments": {
                "model": [
                    "dict[, ]",
                    "esm.models.service_type.ServiceType",
                    "esm.models.plan.Plan",
                    "dict",
                    "models.Model"
                ]
            }
        },
        "deserialize_model": {
            "name": "deserialize_model",
            "location": 73,
            "return": [
                "str",
                "None",
                "bytes"
            ],
            "arguments": {
                "model_str": [
                    "Optional[bytes]"
                ],
                "fix_duplicates": [
                    "bool",
                    "str",
                    "list",
                    "Tuple[str, str]"
                ]
            }
        }
    },
    "scikit-keras-master/scikit_keras/keras/wrapper.py": {
        "BaseWrapper.__init__": {
            "name": "__init__",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.__model__": {
            "name": "__model__",
            "location": 67,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.__callbacks__": {
            "name": "__callbacks__",
            "location": 71,
            "return": [
                "List[nothing]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper._init_model": {
            "name": "_init_model",
            "location": 75,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.model": {
            "name": "model",
            "location": 79,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.callbacks": {
            "name": "callbacks",
            "location": 85,
            "return": [
                "float",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.check_params": {
            "name": "check_params",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "BaseWrapper.get_params": {
            "name": "get_params",
            "location": 110,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.set_params": {
            "name": "set_params",
            "location": 122,
            "return": [
                "BaseWrapper"
            ],
            "arguments": {
                "self": [
                    "_TBaseWrapper"
                ]
            }
        },
        "BaseWrapper.fit": {
            "name": "fit",
            "location": 135,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "GPy.models.GPRegression",
                    "float",
                    "slice",
                    "Union[int, slice]"
                ],
                "y": [
                    "int",
                    "GPy.models.GPRegression",
                    "float",
                    "slice",
                    "Union[int, slice]"
                ],
                "init": [
                    "Union[numpy.ndarray, numpy.void]",
                    "bool",
                    "Iterable[int]",
                    "Iterable[float]",
                    "List[float]",
                    "float",
                    "numpy.ndarray"
                ]
            }
        },
        "BaseWrapper.fit_generator": {
            "name": "fit_generator",
            "location": 163,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "generator": [
                    "str",
                    "int",
                    "Dict[int, Any]",
                    "Optional[List[int]]"
                ],
                "init": [
                    "Callable",
                    "bool",
                    "dict",
                    "numpy.ndarray",
                    "type"
                ]
            }
        },
        "BaseWrapper.predict": {
            "name": "predict",
            "location": 191,
            "return": [
                "bool",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "BaseWrapper.score": {
            "name": "score",
            "location": 208,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ],
                "y": [
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "BaseWrapper.filter_sk_params": {
            "name": "filter_sk_params",
            "location": 230,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "Dict[str, Any]",
                    "List[str]",
                    "jobs.models.Job",
                    "list"
                ],
                "override": [
                    "Dict[str, Any]",
                    "cmk.utils.type_defs.EventRule",
                    "bool"
                ]
            }
        },
        "BaseWrapper.__getstate__": {
            "name": "__getstate__",
            "location": 249,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BaseWrapper.__setstate__": {
            "name": "__setstate__",
            "location": 256,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "str",
                    "Iterable[bytes]",
                    "bool"
                ]
            }
        },
        "KerasClassifier.fit": {
            "name": "fit",
            "location": 266,
            "return": [
                "numpy.ndarray",
                "trezor.utils.Writer",
                "utils.Node",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "numpy.array",
                    "float",
                    "int"
                ],
                "y": [
                    "int",
                    "numpy.ndarray",
                    "tuple",
                    "numpy.ma.MaskedArray"
                ],
                "sample_weight": [
                    "Optional[dict]",
                    "Optional[float]",
                    "Optional[T]",
                    "int",
                    "numpy.ndarray",
                    "Optional[int]"
                ]
            }
        },
        "KerasClassifier.predict": {
            "name": "predict",
            "location": 305,
            "return": [
                "Optional[BaseException]",
                "List[zerver.models.DefaultStreamGroup]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "int"
                ]
            }
        },
        "KerasClassifier.predict_proba": {
            "name": "predict_proba",
            "location": 331,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "int"
                ]
            }
        },
        "KerasClassifier.score": {
            "name": "score",
            "location": 358,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "numpy.ndarray",
                    "Optional[numpy.ndarray]",
                    "Union[pandas.Series, numpy.ndarray]"
                ],
                "y": [
                    "numpy.ndarray",
                    "int",
                    "Union[pandas.Series, numpy.ndarray]"
                ]
            }
        },
        "KerasRegressor.predict": {
            "name": "predict",
            "location": 407,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "float",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "int"
                ]
            }
        }
    },
    "scikit-keras-master/scikit_keras/keras/__init__.py": {},
    "scikit-keras-master/scikit_keras/utils/functools.py": {
        "get_default_args": {
            "name": "get_default_args",
            "location": 4,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "func": [
                    "bytes",
                    "str",
                    "Callable",
                    "typing.Callable[, ]",
                    "bool",
                    "Dict[str, Optional[str]]",
                    "dict[str, typing.Union[str,None]]"
                ]
            }
        }
    },
    "scikit-keras-master/scikit_keras/utils/pickle.py": {
        "dumpf": {
            "name": "dumpf",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "obj": [
                    "str",
                    "bytes",
                    "Optional[List[str]]",
                    "list[str]",
                    "None",
                    "BinaryIO",
                    "typing.BinaryIO"
                ],
                "filename": [
                    "str"
                ]
            }
        },
        "loadf": {
            "name": "loadf",
            "location": 13,
            "return": [
                "int",
                "dict[, ]",
                "str",
                "Callable",
                "dict[str, str]"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        }
    },
    "scikit-keras-master/scikit_keras/utils/__init__.py": {},
    "scikit-keras-master/tests/conftest.py": {
        "random": {
            "name": "random",
            "location": 11,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "scikit-keras-master/tests/__init__.py": {},
    "scikit-keras-master/tests/test_keras/test_keras_wrapper.py": {
        "test_base_class_illegal_param": {
            "name": "test_base_class_illegal_param",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_base_class_not_implemented_model": {
            "name": "test_base_class_not_implemented_model",
            "location": 36,
            "return": [
                "NoReturn"
            ],
            "arguments": {}
        },
        "test_base_class_get_set_params": {
            "name": "test_base_class_get_set_params",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "data_for_classification": {
            "name": "data_for_classification",
            "location": 51,
            "return": [
                "Tuple[(Tuple[(Any, Any)], Tuple[(Any, Any)])]"
            ],
            "arguments": {
                "num_classes": [
                    "int",
                    "bool",
                    "Optional[float]",
                    "List[str]"
                ],
                "one_hot": [
                    "bool",
                    "models.Model",
                    "str"
                ]
            }
        },
        "data_for_regression": {
            "name": "data_for_regression",
            "location": 67,
            "return": [
                "Tuple[(Tuple[(Any, Any)], Tuple[(Any, Any)])]"
            ],
            "arguments": {}
        },
        "assert_classification_works": {
            "name": "assert_classification_works",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "clf": [
                    "int",
                    "Callable",
                    "zerver.models.UserProfile",
                    "str"
                ],
                "data": [
                    "int",
                    "None",
                    "bool",
                    "Optional[int]"
                ],
                "generator": [
                    "bool",
                    "str"
                ]
            }
        },
        "assert_string_classification_works": {
            "name": "assert_string_classification_works",
            "location": 163,
            "return": [
                "None"
            ],
            "arguments": {
                "clf": [
                    "bytes",
                    "rl_algorithms.utils.config.ConfigDict",
                    "int"
                ],
                "data": [
                    "str",
                    "int",
                    "tracim.models.data.Workspace",
                    "bool"
                ]
            }
        },
        "assert_regression_works": {
            "name": "assert_regression_works",
            "location": 188,
            "return": [
                "None"
            ],
            "arguments": {
                "reg": [
                    "int",
                    "Sequence[str]",
                    "raiden.utils.FeeAmount"
                ],
                "data": [
                    "int",
                    "None",
                    "bool",
                    "Optional[int]"
                ],
                "generator": [
                    "bool",
                    "str"
                ]
            }
        },
        "assert_models_equal": {
            "name": "assert_models_equal",
            "location": 209,
            "return": [
                "None"
            ],
            "arguments": {
                "first": [
                    "int",
                    "Optional[Dict]"
                ],
                "second": [
                    "int",
                    "Optional[Dict]"
                ]
            }
        },
        "assert_wrappers_equal": {
            "name": "assert_wrappers_equal",
            "location": 221,
            "return": [
                "None"
            ],
            "arguments": {
                "first": [
                    "bool",
                    "List[magic.models.Deck]",
                    "list[D]"
                ],
                "second": [
                    "bool",
                    "List[magic.models.Deck]",
                    "list[D]"
                ]
            }
        },
        "assert_predictions_equal": {
            "name": "assert_predictions_equal",
            "location": 231,
            "return": [
                "None"
            ],
            "arguments": {
                "first": [
                    "numpy.array",
                    "float",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "List[AnyStr]",
                    "numpy.ndarray",
                    "int"
                ],
                "second": [
                    "numpy.array",
                    "float",
                    "Union[numpy.ndarray, pandas.DataFrame]",
                    "List[AnyStr]",
                    "numpy.ndarray",
                    "int"
                ],
                "x": [
                    "int",
                    "str",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "assert_pickling_works": {
            "name": "assert_pickling_works",
            "location": 238,
            "return": [
                "None"
            ],
            "arguments": {
                "wrpr": [
                    "bytes",
                    "dict[, ]",
                    "dict",
                    "int",
                    "tartare.core.contexContext",
                    "dict[str, typing.Any]",
                    "Union[int, numpy.ndarray]",
                    "Dict[str, Any]"
                ],
                "data": [
                    "bytes",
                    "str",
                    "Dict[str, Any]",
                    "Optional[Dict[str, Any]]",
                    "Dict[str, raiden.utils.Any]"
                ]
            }
        },
        "test_classifiers_generator": {
            "name": "test_classifiers_generator",
            "location": 256,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "clf_cls": [
                    "int",
                    "float",
                    "typing.Callable[, ]",
                    "Callable",
                    "raiden.utils.List[raiden.raiden_service.RaidenService]"
                ],
                "num_classes": [
                    "typing.Callable[, ]",
                    "bool",
                    "raiden.utils.List[raiden.raiden_service.RaidenService]",
                    "Callable"
                ],
                "one_hot": [
                    "int",
                    "typing.Callable[, ]",
                    "Callable",
                    "list[str]",
                    "List[str]",
                    "set[str]",
                    "Set[str]",
                    "django.contrib.auth.models.User"
                ],
                "generator": []
            }
        },
        "test_classifiers": {
            "name": "test_classifiers",
            "location": 290,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "clf_cls": [
                    "daylighdb.models.User",
                    "deeplearning.ml4pl.models.logger.Logger",
                    "daylighdb.models.Photo",
                    "app.models.user.User",
                    "megatron.models.PlatformUser"
                ],
                "num_classes": [
                    "str",
                    "int",
                    "daylighdb.models.User",
                    "daylighdb.models.Photo",
                    "deeplearning.ml4pl.models.logger.Logger",
                    "raiden.utils.Address"
                ],
                "one_hot": [
                    "int",
                    "typing.Callable[, ]",
                    "Callable",
                    "raiden.utils.NetworkTimeout",
                    "bool"
                ],
                "generator": []
            }
        },
        "test_classifier_losses": {
            "name": "test_classifier_losses",
            "location": 326,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "loss": [
                    "int",
                    "core.models.Grouping"
                ],
                "generator": []
            }
        },
        "test_regression_subclass": {
            "name": "test_regression_subclass",
            "location": 346,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "metrics": [
                    "int",
                    "core.models.Grouping"
                ],
                "generator": []
            }
        },
        "test_classifier_no_compiled_accuracy": {
            "name": "test_classifier_no_compiled_accuracy",
            "location": 373,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "clf_cls": [
                    "int",
                    "typing.Callable[, ]",
                    "Callable",
                    "bool"
                ],
                "num_classes": [
                    "int",
                    "typing.Callable[, ]",
                    "Callable",
                    "bool"
                ]
            }
        },
        "test_invalid_y_shape": {
            "name": "test_invalid_y_shape",
            "location": 387,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "BinaryClassifierSubClass.__model__": {
            "name": "__model__",
            "location": 79,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "List[src.autoks.core.gp_model.GPModel]",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": [],
                "hidden_dims": [
                    "int",
                    "Tuple[int]",
                    "numpy.ndarray",
                    "dict",
                    "bool"
                ],
                "num_classes": [
                    "int",
                    "Optional[str]",
                    "Optional[app.models.User]",
                    "Tuple[List[Any], int]",
                    "Type['BaseModel']",
                    "Optional['User']"
                ],
                "loss": [
                    "typing.Text",
                    "str",
                    "Callable"
                ],
                "metrics": [
                    "str",
                    "None",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "SoftmaxClassifierSubClass.__model__": {
            "name": "__model__",
            "location": 99,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "List[src.autoks.core.gp_model.GPModel]",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": [],
                "hidden_dims": [
                    "int",
                    "Tuple[int]",
                    "numpy.ndarray",
                    "dict",
                    "bool"
                ],
                "num_classes": [
                    "int",
                    "List[Type]",
                    "bool"
                ],
                "loss": [
                    "typing.Text",
                    "str",
                    "Callable"
                ],
                "metrics": [
                    "str",
                    "None",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "RegressionSubClass.__model__": {
            "name": "__model__",
            "location": 118,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "List[src.autoks.core.gp_model.GPModel]",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": [],
                "hidden_dims": [
                    "int",
                    "T",
                    "VT"
                ],
                "metrics": [
                    "str",
                    "None",
                    "List[str]",
                    "float",
                    "dict",
                    "list[str]",
                    "dict[, ]"
                ]
            }
        }
    },
    "scikit-keras-master/tests/test_keras/test_keras_wrapper_temporal.py": {
        "test_sequence_binary_classifier_predict_shape": {
            "name": "test_sequence_binary_classifier_predict_shape",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "n_timesteps": [
                    "int",
                    "Optional[int]",
                    "float",
                    "None",
                    "list",
                    "list[]"
                ],
                "kernel_size": [
                    "int",
                    "float",
                    "list",
                    "list[]",
                    "Optional[int]",
                    "None"
                ],
                "stride": [
                    "int",
                    "float",
                    "list",
                    "list[]",
                    "Optional[int]",
                    "None"
                ],
                "padding": [
                    "int",
                    "float",
                    "list",
                    "list[]",
                    "Optional[int]",
                    "None"
                ],
                "n_labels_expected": [
                    "float",
                    "str",
                    "numpy.ndarray"
                ],
                "n_channels": [
                    "int",
                    "list[float]",
                    "bool",
                    "List[float]"
                ]
            }
        },
        "SequenceBinaryClassifier.__model__": {
            "name": "__model__",
            "location": 14,
            "return": [
                "Model",
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {
                "self": [],
                "n_channels": [
                    "int",
                    "float",
                    "Optional[int]",
                    "bool"
                ],
                "kernel_size": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str",
                    "bool",
                    "float"
                ],
                "strides": [
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str",
                    "bool",
                    "float"
                ],
                "padding": [
                    "typing.Text",
                    "int",
                    "Union[Tuple[int, int], int]",
                    "str",
                    "bool",
                    "float"
                ]
            }
        }
    },
    "scikit-keras-master/tests/test_keras/test_utils.py": {
        "model_single_layer": {
            "name": "model_single_layer",
            "location": 11,
            "return": [
                "Dense",
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_sequential": {
            "name": "model_sequential",
            "location": 16,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_compiled": {
            "name": "model_compiled",
            "location": 23,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "model_with_shared_layer": {
            "name": "model_with_shared_layer",
            "location": 31,
            "return": [
                "Model",
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_with_submodel": {
            "name": "model_with_submodel",
            "location": 40,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_with_shared_in_submodel": {
            "name": "model_with_shared_in_submodel",
            "location": 50,
            "return": [
                "str",
                "Model"
            ],
            "arguments": {}
        },
        "TestIterLayers.test_model": {
            "name": "test_model",
            "location": 71,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str"
                ],
                "n_layers": [
                    "float"
                ]
            }
        },
        "TestSerializeModel.test_none": {
            "name": "test_none",
            "location": 79,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSerializeModel.test_model": {
            "name": "test_model",
            "location": 95,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "model_func": []
            }
        },
        "TestSerializeModel.test_model_gradients": {
            "name": "test_model_gradients",
            "location": 115,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "model_func": []
            }
        }
    },
    "scikit-keras-master/tests/test_keras/__init__.py": {},
    "scikit-keras-master/tests/test_utils/test_functools.py": {
        "func1": {
            "name": "func1",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "str",
                    "int",
                    "bool"
                ],
                "b": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "func2": {
            "name": "func2",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "func3": {
            "name": "func3",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "str",
                    "int",
                    "bool"
                ],
                "b": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "func4": {
            "name": "func4",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "typing.Text",
                    "str",
                    "int",
                    "bool"
                ],
                "b": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "test_get_default_args": {
            "name": "test_get_default_args",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "func": [
                    "str",
                    "bool",
                    "List[str]",
                    "list[str]",
                    "float",
                    "Callable[..., Coroutine[Any, Any, Any]]",
                    "typing.Callable[..., collections.abc.Coroutine]"
                ],
                "args": []
            }
        }
    },
    "scikit-keras-master/tests/test_utils/test_pickle.py": {
        "assert_is": {
            "name": "assert_is",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float"
                ],
                "b": [
                    "int",
                    "float"
                ]
            }
        },
        "assert_eq": {
            "name": "assert_eq",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float",
                    "list[int]",
                    "bool",
                    "List[int]"
                ],
                "b": [
                    "int",
                    "float",
                    "list[int]",
                    "bool",
                    "List[int]"
                ]
            }
        },
        "assert_lambda_eq": {
            "name": "assert_lambda_eq",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float",
                    "Sequence[T]",
                    "typing.Sequence[T]"
                ],
                "b": [
                    "int",
                    "float",
                    "Sequence[T]",
                    "typing.Sequence[T]"
                ]
            }
        },
        "test_pickle": {
            "name": "test_pickle",
            "location": 32,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "obj": [
                    "int"
                ],
                "compare": [
                    "str",
                    "float"
                ]
            }
        }
    }
}
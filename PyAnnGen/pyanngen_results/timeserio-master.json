{
    "timeserio-master/setup.py": {},
    "timeserio-master/docs/source/conf.py": {},
    "timeserio-master/tests/conftest.py": {
        "random": {
            "name": "random",
            "location": 8,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {}
        },
        "use_tensor_extension": {
            "name": "use_tensor_extension",
            "location": 18,
            "return": [
                "int",
                "float",
                "raiden.utils.Optional[int]",
                "bool"
            ],
            "arguments": {
                "request": [
                    "Iterable[int]",
                    "typing.Iterable[int]"
                ]
            }
        }
    },
    "timeserio-master/tests/test_externals.py": {
        "test_absent_imports": {
            "name": "test_absent_imports",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_version.py": {
        "test_version": {
            "name": "test_version",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_batches/conftest.py": {
        "dask_client": {
            "name": "dask_client",
            "location": 7,
            "return": [
                "typing.Generator[typing.Union[typing.Any,None,None]]"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_batches/test_utils.py": {
        "test_ceiling_division": {
            "name": "test_ceiling_division",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "dividend": [
                    "str"
                ],
                "divisor": [
                    "str"
                ],
                "result": [
                    "str"
                ]
            }
        }
    },
    "timeserio-master/tests/test_batches/__init__.py": {},
    "timeserio-master/tests/test_batches/test_chunked/test_dask.py": {
        "TestSequenceForecastBatchGeneratorMultiID.test_n_subgens": {
            "name": "test_n_subgens",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_customers": [
                    "int",
                    "List[int]",
                    "list[int]",
                    "Union[float, List[float]]",
                    "float",
                    "list[float]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_subgen_lengths": {
            "name": "test_subgen_lengths",
            "location": 41,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_customers": [
                    "int",
                    "str",
                    "Callable[[str, str], float]",
                    "typing.Callable[str,str, float]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "np.ndarray",
                    "numpy.ndarray"
                ],
                "exp_sg_len": [
                    "bool",
                    "str",
                    "int"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_find_batch_in_subgens": {
            "name": "test_find_batch_in_subgens",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int",
                    "float",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "batch_idx": [
                    "str",
                    "bool",
                    "float",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "exp_subgen_idx": [
                    "tuple[typing.Union[int,int]]",
                    "int",
                    "Tuple[int, int]",
                    "str",
                    "bytes",
                    "list[str]",
                    "Optional[List[str]]",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "exp_idx_in_subgen": [
                    "bool",
                    "str",
                    "None",
                    "int",
                    "Optional[str]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_find_batch_raises_outside_subgens": {
            "name": "test_find_batch_raises_outside_subgens",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_aggregate_ids": {
            "name": "test_aggregate_ids",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "timeserio-master/tests/test_batches/test_chunked/test_pandas.py": {
        "TestRowBatchGenerator.test_nb_batches": {
            "name": "test_nb_batches",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "int",
                    "Iterable[str]",
                    "typing.Iterable[str]"
                ],
                "batch_size": [
                    "int",
                    "Sequence[Any]",
                    "typing.Sequence[typing.Any]"
                ],
                "batch_aggregator": [
                    "int",
                    "Sequence[Any]",
                    "typing.Sequence[typing.Any]"
                ],
                "expected_nb_batches": [
                    "float",
                    "str",
                    "numpy.ndarray",
                    "typing.Callable[str,str, float]",
                    "Callable[[str, str], float]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_n_subgens": {
            "name": "test_n_subgens",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_customers": [
                    "int",
                    "bytearray",
                    "numpy.ndarray",
                    "bytes",
                    "list[dict[, ]]",
                    "list[int]",
                    "numpy.ma.MaskedArray",
                    "List[Dict]",
                    "List[int]"
                ],
                "use_tensor_extension": [
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_subgen_lengths": {
            "name": "test_subgen_lengths",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_customers": [
                    "typing.Callable[, ]",
                    "int",
                    "Callable",
                    "bool"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Optional[int]",
                    "None",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]"
                ],
                "exp_sg_len": [
                    "int",
                    "float",
                    "tuple[int]",
                    "bool",
                    "None",
                    "Tuple[int]",
                    "Optional[float]"
                ],
                "use_tensor_extension": [
                    "str",
                    "int",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_find_batch_in_subgens": {
            "name": "test_find_batch_in_subgens",
            "location": 97,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int",
                    "float",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "batch_idx": [
                    "str",
                    "bool",
                    "float",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "exp_subgen_idx": [
                    "tuple[typing.Union[int,int]]",
                    "int",
                    "Tuple[int, int]",
                    "str",
                    "bytes",
                    "list[str]",
                    "Optional[List[str]]",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "exp_idx_in_subgen": [
                    "bool",
                    "str",
                    "None",
                    "int",
                    "Optional[str]"
                ],
                "use_tensor_extension": [
                    "bool",
                    "Optional[bool]",
                    "str",
                    "None"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_find_batch_raises_outside_subgens": {
            "name": "test_find_batch_raises_outside_subgens",
            "location": 118,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "use_tensor_extension": [
                    "int",
                    "str"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorMultiID.test_aggregate_ids": {
            "name": "test_aggregate_ids",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "use_tensor_extension": [
                    "Dict[int, dict]",
                    "dict[int, dict[, ]]"
                ]
            }
        }
    },
    "timeserio-master/tests/test_batches/test_chunked/test_parquet.py": {
        "local_writable_url": {
            "name": "local_writable_url",
            "location": 17,
            "return": [
                "",
                "typing.Generator[typing.Text]"
            ],
            "arguments": {
                "tmpdir": [
                    "str",
                    "float"
                ]
            }
        },
        "s3_writable_url": {
            "name": "s3_writable_url",
            "location": 22,
            "return": [
                "",
                "typing.Generator[typing.Text]"
            ],
            "arguments": {}
        },
        "_ddf_to_parquet": {
            "name": "_ddf_to_parquet",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "ddf": [
                    "bool",
                    "str",
                    "list[str]",
                    "int",
                    "List[str]"
                ],
                "path": [
                    "str"
                ]
            }
        },
        "TestRowBatchGenerator.test_nb_batches": {
            "name": "test_nb_batches",
            "location": 49,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "int",
                    "Iterable[str]",
                    "typing.Iterable[str]"
                ],
                "batch_size": [
                    "typing.Callable[, ]",
                    "Callable",
                    "float",
                    "typing.Iterable[]",
                    "int",
                    "Callable[[str, str], None]",
                    "Exception",
                    "Iterable",
                    "bool"
                ],
                "batch_aggregator": [
                    "typing.Callable[, ]",
                    "Callable",
                    "float",
                    "typing.Iterable[]",
                    "int",
                    "Callable[[str, str], None]",
                    "Exception",
                    "Iterable",
                    "bool"
                ],
                "expected_nb_batches": [
                    "float",
                    "str",
                    "numpy.ndarray",
                    "typing.Callable[str,str, float]",
                    "Callable[[str, str], float]"
                ],
                "writable_url": [
                    "dict[str, str]",
                    "bool",
                    "Dict[str, str]",
                    "str",
                    "None",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorFromParquet.test_n_subgens": {
            "name": "test_n_subgens",
            "location": 78,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_customers": [
                    "list[int]",
                    "int",
                    "List[int]",
                    "dict[str, int]",
                    "Dict[str, int]",
                    "list[dict[, ]]",
                    "List[Dict]",
                    "numpy.ma.MaskedArray"
                ],
                "writable_url": [
                    "dict",
                    "dict[, ]",
                    "str",
                    "Optional[str]",
                    "None",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorFromParquet.test_subgen_lengths": {
            "name": "test_subgen_lengths",
            "location": 96,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "writable_url": [
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorFromParquet.test_find_batch_in_subgens": {
            "name": "test_find_batch_in_subgens",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "str",
                    "Optional[str]",
                    "int",
                    "None"
                ],
                "batch_idx": [
                    "str",
                    "bool",
                    "float",
                    "None",
                    "Optional[int]",
                    "int"
                ],
                "exp_subgen_idx": [
                    "tuple[typing.Union[int,int]]",
                    "int",
                    "Tuple[int, int]",
                    "str",
                    "bytes",
                    "list[str]",
                    "Optional[List[str]]",
                    "None",
                    "Optional[int]",
                    "bool"
                ],
                "exp_idx_in_subgen": [
                    "bool",
                    "str",
                    "None",
                    "int",
                    "Optional[str]"
                ],
                "writable_url": [
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorFromParquet.test_find_batch_raises_outside_subgens": {
            "name": "test_find_batch_raises_outside_subgens",
            "location": 148,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "writable_url": [
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "TestSequenceForecastBatchGeneratorFromParquet.test_aggregate_ids": {
            "name": "test_aggregate_ids",
            "location": 167,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_aggregator": [],
                "exp_gen_len": [
                    "str"
                ],
                "writable_url": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "timeserio-master/tests/test_batches/test_single/test_row.py": {
        "TestRowBatchGenerator.test_nb_batches": {
            "name": "test_nb_batches",
            "location": 20,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "str",
                    "bool",
                    "list[str]",
                    "int",
                    "List[str]"
                ],
                "batch_size": [
                    "Sequence[Any]",
                    "int",
                    "typing.Sequence[typing.Any]",
                    "float",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]",
                    "List[List[int]]",
                    "list[list[int]]"
                ],
                "expected_nb_batches": [
                    "Type[Exception]",
                    "typing.Type",
                    "int",
                    "Optional[int]",
                    "float",
                    "List[List[int]]",
                    "None",
                    "list[list[int]]"
                ]
            }
        },
        "TestRowBatchGenerator.test_batch_size": {
            "name": "test_batch_size",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "bool",
                    "str",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Sequence[Any]",
                    "typing.Sequence[typing.Any]"
                ],
                "expected_last_batch_size": [
                    "int",
                    "Type[Exception]",
                    "typing.Type"
                ]
            }
        }
    },
    "timeserio-master/tests/test_batches/test_single/test_sequence.py": {
        "TestSamplingForecastBatchGenerator.test_get_sequence_values": {
            "name": "test_get_sequence_values",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "use_tensor_extension": [
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Optional[Dict]",
                    "dict[, ]",
                    "None"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_num_examples": {
            "name": "test_num_examples",
            "location": 43,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "int",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "seq_length": [
                    "float",
                    "bytes",
                    "typing.Mapping",
                    "numpy.array",
                    "Mapping[str, Tuple[float, float, float]]"
                ],
                "fc_max": [
                    "float",
                    "bytes",
                    "typing.Mapping",
                    "numpy.array",
                    "Mapping[str, Tuple[float, float, float]]"
                ],
                "n_sequences_expected": [
                    "int",
                    "float",
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ],
                "use_tensor_extension": [
                    "int",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_columns": {
            "name": "test_columns",
            "location": 78,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "id_column": [
                    "bool",
                    "float",
                    "None",
                    "str",
                    "Optional[int]",
                    "int",
                    "Optional[float]"
                ],
                "sequence_columns": [
                    "bool",
                    "float",
                    "None",
                    "str",
                    "Optional[int]",
                    "int",
                    "Optional[float]"
                ],
                "last_step_columns": [
                    "bool",
                    "float",
                    "None",
                    "str",
                    "Optional[int]",
                    "int",
                    "Optional[float]"
                ],
                "expected_columns": [
                    "List[str]",
                    "list[str]",
                    "int",
                    "Dict[str, int]",
                    "dict[str, int]",
                    "Set[str]",
                    "str",
                    "set[str]",
                    "tuple",
                    "tuple[]",
                    "List[Tuple[int, int, int]]",
                    "list[tuple[typing.Union[int,int,int]]]",
                    "Tuple[int]",
                    "tuple[int]"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_start_time": {
            "name": "test_start_time",
            "location": 108,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "start_time_idx": [
                    "int",
                    "Union[int, str]",
                    "str",
                    "Optional[float]",
                    "float",
                    "None"
                ],
                "expected_start_time_idx": [
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "use_tensor_extension": [
                    "int",
                    "str",
                    "Optional[str]",
                    "Optional[Dict[str, str]]",
                    "None",
                    "dict[str, str]"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_invalid_start_time": {
            "name": "test_invalid_start_time",
            "location": 132,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "use_tensor_extension": [
                    "str",
                    "bool",
                    "int"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_random_offset": {
            "name": "test_random_offset",
            "location": 148,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "random": [
                    "str",
                    "bool",
                    "Set[str]",
                    "set[str]",
                    "Optional[bool]",
                    "None"
                ],
                "use_tensor_extension": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_random_offset_value_with_period": {
            "name": "test_random_offset_value_with_period",
            "location": 169,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "random": [
                    "List[Tuple[str, str]]",
                    "list[tuple[typing.Union[str,str]]]"
                ],
                "seq_len": [
                    "Dict[str, Any]",
                    "bool",
                    "dict[str, typing.Any]"
                ],
                "period": [
                    "bool",
                    "int"
                ],
                "expected_max_offset": [
                    "str",
                    "bool",
                    "Type[Exception]",
                    "typing.Type"
                ],
                "use_tensor_extension": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "None",
                    "Mapping[str, Any]",
                    "typing.Mapping"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_incompatible_period": {
            "name": "test_incompatible_period",
            "location": 191,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "seq_len": [],
                "period": []
            }
        },
        "TestSequenceForecastBatchGenerator.test_n_batches": {
            "name": "test_n_batches",
            "location": 210,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None"
                ],
                "seq_length": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "fc_max": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "batch_size": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "n_batches_expected": [
                    "int",
                    "str",
                    "None",
                    "pandas.DataFrame",
                    "Optional[int]"
                ],
                "use_tensor_extension": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_n_batches_with_offset": {
            "name": "test_n_batches_with_offset",
            "location": 234,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None"
                ],
                "seq_length": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "fc_max": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "batch_size": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "n_batches_expected": [
                    "int",
                    "str",
                    "None",
                    "pandas.DataFrame",
                    "Optional[int]"
                ],
                "use_tensor_extension": [
                    "int",
                    "str",
                    "Optional[float]",
                    "float",
                    "bool",
                    "None"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_batch_size": {
            "name": "test_batch_size",
            "location": 259,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "int",
                    "float",
                    "bool"
                ],
                "seq_length": [
                    "int",
                    "numpy.ndarray"
                ],
                "fc_max": [
                    "int",
                    "numpy.ndarray"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray"
                ],
                "expected_last_batch_size": [
                    "int",
                    "Type[Exception]",
                    "typing.Type",
                    "list",
                    "list[]"
                ],
                "use_tensor_extension": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_single_batch": {
            "name": "test_single_batch",
            "location": 281,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "use_tensor_extension": [
                    "int"
                ]
            }
        },
        "TestSequenceForecastBatchGenerator.test_single_batch_with_last_step": {
            "name": "test_single_batch_with_last_step",
            "location": 313,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "use_tensor_extension": [
                    "int",
                    "bool"
                ]
            }
        }
    },
    "timeserio-master/tests/test_batches/test_single/__init__.py": {},
    "timeserio-master/tests/test_data/test_datasets.py": {
        "test_load_iris_df": {
            "name": "test_load_iris_df",
            "location": 4,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_data/test_mock.py": {
        "test_single_user_fit_df_sets_id": {
            "name": "test_single_user_fit_df_sets_id",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "embed_dim": [],
                "seq_len": []
            }
        }
    },
    "timeserio-master/tests/test_data/__init__.py": {},
    "timeserio-master/tests/test_keras/conftest.py": {
        "multimodel": {
            "name": "multimodel",
            "location": 9,
            "return": [
                "dict[typing.Text, Model]",
                "str",
                "float",
                "bytearray",
                "bool"
            ],
            "arguments": {}
        },
        "multimodel_num_layers": {
            "name": "multimodel_num_layers",
            "location": 71,
            "return": [
                "int",
                "dict[typing.Text, int]"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_keras/test_batches.py": {
        "x_y_data": {
            "name": "x_y_data",
            "location": 8,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "n_points": [
                    "int",
                    "List[List[int]]",
                    "list[list[int]]"
                ]
            }
        },
        "TestArrayBatchGenerator.test_nb_batches": {
            "name": "test_nb_batches",
            "location": 24,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "str"
                ],
                "batch_size": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "None",
                    "Optional[float]",
                    "Optional[int]"
                ],
                "expected_nb_batches": [
                    "Type[Exception]",
                    "typing.Type",
                    "int",
                    "Optional[int]",
                    "float",
                    "List[List[int]]",
                    "None",
                    "list[list[int]]"
                ]
            }
        },
        "TestArrayBatchGenerator.test_batch_size": {
            "name": "test_batch_size",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_points": [
                    "str"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "numpy.ndarray"
                ],
                "expected_last_batch_size": [
                    "bytes",
                    "List[int]",
                    "list[int]",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "timeserio-master/tests/test_keras/test_callbacks.py": {
        "TestFormatting.test_get_log_metrics": {
            "name": "test_get_log_metrics",
            "location": 34,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFormatting.test_format_epoch_metric": {
            "name": "test_format_epoch_metric",
            "location": 40,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestFormatting.test_format_epoch_summary": {
            "name": "test_format_epoch_summary",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestTimeLogger.test_epoch_stats": {
            "name": "test_epoch_stats",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mocker": [
                    "str",
                    "float"
                ]
            }
        },
        "TestTimeLogger.test_train_": {
            "name": "test_train_",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "mocker": [
                    "str",
                    "float"
                ]
            }
        }
    },
    "timeserio-master/tests/test_keras/test_multinetwork.py": {
        "test_reproducibility": {
            "name": "test_reproducibility",
            "location": 208,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "MinimalSubClass._model": {
            "name": "_model",
            "location": 28,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SimpleMultiNetwork._model": {
            "name": "_model",
            "location": 35,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "forecaster_features": [
                    "int",
                    "app.models.Question",
                    "Exception",
                    "dict",
                    "str"
                ],
                "forecaster_hidden_units": [
                    "tuple[int]",
                    "float",
                    "str",
                    "list"
                ],
                "lr": [
                    "float",
                    "tensorflow.train.Checkpoint",
                    "tensorflow.Variable",
                    "Callable",
                    "Optional[str]",
                    "Type"
                ]
            }
        },
        "SimpleMultiNetwork._callbacks": {
            "name": "_callbacks",
            "location": 66,
            "return": [
                "Dict[(str, list)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "BatchNormNetwork._model": {
            "name": "_model",
            "location": 78,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbedderForecasterNetwork._model": {
            "name": "_model",
            "location": 101,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "EmbedderForecasterNetwork._callbacks": {
            "name": "_callbacks",
            "location": 159,
            "return": [
                "Dict[(str, list)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBaseClass.test_base_class_abstract": {
            "name": "test_base_class_abstract",
            "location": 186,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBaseClass.test_sub_class_illegal_param": {
            "name": "test_sub_class_illegal_param",
            "location": 190,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBaseClass.test_sub_class_not_implemented_model": {
            "name": "test_sub_class_not_implemented_model",
            "location": 194,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestBaseClass.test_sub_class_get_set_params": {
            "name": "test_sub_class_get_set_params",
            "location": 199,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSubClass.testclass": {
            "name": "testclass",
            "location": 225,
            "return": [
                "SimpleMultiNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSubClass.multinetwork": {
            "name": "multinetwork",
            "location": 229,
            "return": [
                "SimpleMultiNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "random": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestSubClass.test_default_params": {
            "name": "test_default_params",
            "location": 232,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "str"
                ]
            }
        },
        "TestSubClass.test_history_is_appended": {
            "name": "test_history_is_appended",
            "location": 236,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "numpy.ndarray",
                    "int",
                    "float",
                    "str"
                ]
            }
        },
        "TestSubClass.test_history_is_reset": {
            "name": "test_history_is_reset",
            "location": 246,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "TestSubClass.test_model_names": {
            "name": "test_model_names",
            "location": 261,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "int",
                    "django.db.models.QuerySet"
                ]
            }
        },
        "TestSubClass.test_model_subnets": {
            "name": "test_model_subnets",
            "location": 264,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "TestSubClass.test_predict_defaut": {
            "name": "test_predict_defaut",
            "location": 269,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "List[numpy.ndarray]",
                    "numpy.ndarray",
                    "Mapping[str, Any]",
                    "bool",
                    "int"
                ]
            }
        },
        "TestSubClass.test_predict_set_params": {
            "name": "test_predict_set_params",
            "location": 274,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "numpy.ndarray",
                    "bool",
                    "str"
                ]
            }
        },
        "TestSubClass.test_fit_default": {
            "name": "test_fit_default",
            "location": 280,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "List[numpy.ndarray]",
                    "numpy.ndarray",
                    "int"
                ]
            }
        },
        "TestSubClass.test_fit_generator": {
            "name": "test_fit_generator",
            "location": 290,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "Optional[int]",
                    "float",
                    "int"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Optional[int]"
                ]
            }
        },
        "TestSubClass.test_validation_data": {
            "name": "test_validation_data",
            "location": 300,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "TestSubClass.test_score": {
            "name": "test_score",
            "location": 319,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "int",
                    "List[Dict[str, Any]]",
                    "numpy.ndarray"
                ]
            }
        },
        "TestSubClass.test_evaluate": {
            "name": "test_evaluate",
            "location": 330,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "int",
                    "List[Dict[str, Any]]"
                ]
            }
        },
        "TestSubClass.test_evaluate_generator": {
            "name": "test_evaluate_generator",
            "location": 347,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "ajapaik.ajapaik_face_recognition.models.FaceRecognitionRectangle",
                    "str",
                    "List[numpy.ndarray]"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Optional[float]",
                    "None",
                    "Optional[int]"
                ]
            }
        },
        "TestSubClass.test_trainable_models_sets_internal_state": {
            "name": "test_trainable_models_sets_internal_state",
            "location": 359,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "bool",
                    "keanu.Model",
                    "TestModule.Model",
                    "models.cf_recommend_models.ICfRecommendationModel"
                ],
                "models": [
                    "bool",
                    "keanu.Model",
                    "TestModule.Model",
                    "models.cf_recommend_models.ICfRecommendationModel"
                ]
            }
        },
        "TestSubClass.test__freeze_sets_trainable_none": {
            "name": "test__freeze_sets_trainable_none",
            "location": 364,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "keanu.Model",
                    "core.models.Grouping",
                    "bool",
                    "models.cf_recommend_models.ICfRecommendationModel"
                ],
                "model": [
                    "list[D]",
                    "keanu.Model",
                    "core.models.Grouping",
                    "List[src.main.core.models.display.Display]"
                ]
            }
        },
        "TestSubClass.test__freeze_sets_trainable_all": {
            "name": "test__freeze_sets_trainable_all",
            "location": 371,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "int",
                    "TestModule.Model",
                    "models.cf_recommend_models.ICfRecommendationModel"
                ]
            }
        },
        "TestSubClass.test__freeze_sets_trainable_except": {
            "name": "test__freeze_sets_trainable_except",
            "location": 378,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "Callable"
                ]
            }
        },
        "TestSubClass.test_freeze": {
            "name": "test_freeze",
            "location": 390,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "Iterable"
                ],
                "mocker": []
            }
        },
        "TestSubClass.test_freeze_with_arg": {
            "name": "test_freeze_with_arg",
            "location": 397,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "Iterable"
                ],
                "mocker": []
            }
        },
        "TestSubClass.test_unfreeze": {
            "name": "test_unfreeze",
            "location": 405,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "Iterable"
                ],
                "mocker": []
            }
        },
        "TestSubClass.test_training_context": {
            "name": "test_training_context",
            "location": 412,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [],
                "mocker": []
            }
        },
        "TestSubClass.test_training_context_with_trainable_models": {
            "name": "test_training_context_with_trainable_models",
            "location": 423,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [],
                "mocker": []
            }
        },
        "TestSubClass.test_training_context_preserves_loss_and_metrics": {
            "name": "test_training_context_preserves_loss_and_metrics",
            "location": 438,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "keanu.Model",
                    "bool",
                    "core.models.Grouping",
                    "List[src.main.core.models.display.Display]"
                ]
            }
        },
        "TestSubClass.test_fit_frozen": {
            "name": "test_fit_frozen",
            "location": 451,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "TestModule.Model",
                    "tartare.core.models.Process",
                    "str",
                    "models.Category"
                ]
            }
        },
        "TestSubClass.test_fit_frozen_via_kwarg": {
            "name": "test_fit_frozen_via_kwarg",
            "location": 469,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [
                    "TestModule.Model",
                    "str"
                ]
            }
        },
        "TestMultiNetworkSerialization.multinetwork": {
            "name": "multinetwork",
            "location": 497,
            "return": [
                "SimpleMultiNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "random": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestMultiNetworkSerialization.bn_multinetwork": {
            "name": "bn_multinetwork",
            "location": 501,
            "return": [
                "BatchNormNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "random": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestMultiNetworkSerialization.ef_multinetwork": {
            "name": "ef_multinetwork",
            "location": 505,
            "return": [
                "EmbedderForecasterNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "random": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "TestMultiNetworkSerialization.assert_models_same": {
            "name": "assert_models_same",
            "location": 508,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "Optional[Any]",
                    "typing.Any",
                    "dict",
                    "None",
                    "models.Payment",
                    "dict[, ]"
                ],
                "model2": [
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "TestMultiNetworkSerialization.assert_model_dicts_same": {
            "name": "assert_model_dicts_same",
            "location": 519,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_dict": [
                    "dict",
                    "Iterable[Tuple[Hashable, Any]]"
                ],
                "model_dict_2": [
                    "dict",
                    "Dict[str, Dict[str, Any]]",
                    "Dict[str, Any]",
                    "Optional[Dict[object, Any]]",
                    "Dict[str, str]"
                ]
            }
        },
        "TestMultiNetworkSerialization.test_deserialized_params": {
            "name": "test_deserialized_params",
            "location": 527,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ef_multinetwork": [
                    "lms.lmsdb.models.Comment"
                ]
            }
        },
        "TestMultiNetworkSerialization.test_deserialized_batch_norm": {
            "name": "test_deserialized_batch_norm",
            "location": 534,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "bn_multinetwork": [
                    "str",
                    "float"
                ]
            }
        },
        "TestMultiNetworkSerialization.test_layer_sharing": {
            "name": "test_layer_sharing",
            "location": 543,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "ef_multinetwork": [
                    "str",
                    "float"
                ]
            }
        },
        "TestMultiNetworkSerialization.test_history_preserved": {
            "name": "test_history_preserved",
            "location": 551,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": []
            }
        },
        "TestMultiNetworkSerialization.test_optimizer_state": {
            "name": "test_optimizer_state",
            "location": 558,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": []
            }
        },
        "TestMultiNetworkSerialization.test_serialize_no_keras": {
            "name": "test_serialize_no_keras",
            "location": 572,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "multinetwork": [],
                "mocker": []
            }
        }
    },
    "timeserio-master/tests/test_keras/test_utils.py": {
        "model_single_layer": {
            "name": "model_single_layer",
            "location": 9,
            "return": [
                "Dense",
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_sequential": {
            "name": "model_sequential",
            "location": 14,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_compiled": {
            "name": "model_compiled",
            "location": 21,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "Optional[str]"
            ],
            "arguments": {}
        },
        "model_with_shared_layer": {
            "name": "model_with_shared_layer",
            "location": 29,
            "return": [
                "Model",
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_with_submodel": {
            "name": "model_with_submodel",
            "location": 38,
            "return": [
                "List[app.models.Question]",
                "app.models.Question",
                "allennlp.models.model.Model"
            ],
            "arguments": {}
        },
        "model_with_shared_in_submodel": {
            "name": "model_with_shared_in_submodel",
            "location": 48,
            "return": [
                "str",
                "Model"
            ],
            "arguments": {}
        },
        "TestIterLayers.test_model": {
            "name": "test_model",
            "location": 69,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str"
                ],
                "n_layers": [
                    "float"
                ]
            }
        },
        "TestIterLayers.test_multimodel": {
            "name": "test_multimodel",
            "location": 73,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "multimodel": [
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "dict[, ]",
                    "dict",
                    "bool"
                ],
                "multimodel_num_layers": [
                    "cmk.utils.type_defs.EventRule",
                    "BaseException",
                    "bool",
                    "dict"
                ]
            }
        }
    },
    "timeserio-master/tests/test_keras/__init__.py": {},
    "timeserio-master/tests/test_model_selection/test_time_series_split.py": {
        "input_df": {
            "name": "input_df",
            "location": 8,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "teams": [
                    "int",
                    "Optional[int]",
                    "numpy.ndarray"
                ],
                "index_offset": [
                    "int",
                    "numpy.array",
                    "List[int]"
                ],
                "num_days": [
                    "int",
                    "pandas.DataFrame",
                    "str",
                    "float"
                ]
            }
        },
        "test_pandas_time_series_split": {
            "name": "test_pandas_time_series_split",
            "location": 33,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "str"
                ]
            }
        },
        "test_raises_nonunique": {
            "name": "test_raises_nonunique",
            "location": 55,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_raises_non_ascending": {
            "name": "test_raises_non_ascending",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_different_series_lengths": {
            "name": "test_different_series_lengths",
            "location": 81,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_model_selection/__init__.py": {},
    "timeserio-master/tests/test_multimodel/test_base.py": {
        "multinetwork": {
            "name": "multinetwork",
            "location": 59,
            "return": [
                "SimpleMultiNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "random": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "multipipeline": {
            "name": "multipipeline",
            "location": 64,
            "return": [
                "MultiPipeline",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {}
        },
        "manifold": {
            "name": "manifold",
            "location": 75,
            "return": [
                "dict[typing.Text, tuple[typing.Text]]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {}
        },
        "multimodel": {
            "name": "multimodel",
            "location": 81,
            "return": [
                "MultiModel",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "multinetwork": [
                    "str",
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ],
                "multipipeline": [
                    "str",
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ],
                "manifold": [
                    "str",
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ]
            }
        },
        "multimodel_validation": {
            "name": "multimodel_validation",
            "location": 91,
            "return": [
                "MultiModel",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "multinetwork": [
                    "str",
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ]
            }
        },
        "df": {
            "name": "df",
            "location": 113,
            "return": [
                "str",
                "Tuple[str, str]"
            ],
            "arguments": {}
        },
        "validation_df": {
            "name": "validation_df",
            "location": 118,
            "return": [
                "str",
                "Tuple[str, str]"
            ],
            "arguments": {}
        },
        "test_fit": {
            "name": "test_fit",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "keanu.Model"
                ],
                "df": [
                    "keanu.Model"
                ]
            }
        },
        "test_fit_generator": {
            "name": "test_fit_generator",
            "location": 130,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "int",
                    "raiden.utils.ProportionalFeeAmount"
                ],
                "df": [
                    "int",
                    "str",
                    "Optional[int]",
                    "None",
                    "List[int]",
                    "list[int]"
                ],
                "batch_size": [
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "test_fit_with_validation_data": {
            "name": "test_fit_with_validation_data",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "keanu.Model",
                    "int"
                ],
                "df": [
                    "int",
                    "keanu.Model"
                ],
                "validation_df": [
                    "int",
                    "keanu.Model"
                ]
            }
        },
        "test_fit_with_validation_data_none": {
            "name": "test_fit_with_validation_data_none",
            "location": 153,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "keanu.Model",
                    "TestModule.Model",
                    "int"
                ],
                "df": [
                    "int",
                    "keanu.Model",
                    "TestModule.Model"
                ]
            }
        },
        "test_fit_generator_with_validation_data": {
            "name": "test_fit_generator_with_validation_data",
            "location": 168,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "core.models.Grouping"
                ],
                "df": [
                    "int"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "str"
                ],
                "num_epochs": [
                    "int",
                    "core.models.Grouping"
                ]
            }
        },
        "test_fit_generator_with_validation_gen": {
            "name": "test_fit_generator_with_validation_gen",
            "location": 186,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "int",
                    "float",
                    "bool"
                ],
                "df": [
                    "int",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "Optional[int]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "Optional[int]",
                    "None"
                ],
                "num_epochs": [
                    "int",
                    "float"
                ]
            }
        },
        "test_evaluate": {
            "name": "test_evaluate",
            "location": 202,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "str",
                    "keanu.Model"
                ],
                "df": [
                    "int",
                    "str",
                    "core.models.Grouping"
                ]
            }
        },
        "test_evaluate_generator": {
            "name": "test_evaluate_generator",
            "location": 210,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "multimodel": [
                    "int",
                    "List[str]",
                    "TestModule.Model"
                ],
                "df": [
                    "int",
                    "float",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "None"
                ],
                "batch_size": [
                    "int",
                    "float",
                    "Optional[Tuple[int, ...]]",
                    "tuple[typing.Union[int,...]]",
                    "None"
                ]
            }
        },
        "test_fit_frozen": {
            "name": "test_fit_frozen",
            "location": 220,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": [],
                "df": [
                    "keanu.Model"
                ]
            }
        },
        "test_fit_un_frozen": {
            "name": "test_fit_un_frozen",
            "location": 228,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": [],
                "df": [
                    "keanu.Model"
                ]
            }
        },
        "test_multimodel_pipeline_validation": {
            "name": "test_multimodel_pipeline_validation",
            "location": 236,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel_validation": [
                    "str"
                ]
            }
        },
        "test_multimodel_pickle_pipeline": {
            "name": "test_multimodel_pickle_pipeline",
            "location": 252,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel_validation": [
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "SimpleMultiNetwork._model": {
            "name": "_model",
            "location": 26,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "forecaster_features": [
                    "int",
                    "app.models.Question",
                    "Exception",
                    "dict",
                    "str"
                ],
                "forecaster_hidden_units": [
                    "tuple[int]",
                    "float",
                    "str",
                    "list"
                ]
            }
        },
        "SimpleMultiNetwork._callbacks": {
            "name": "_callbacks",
            "location": 54,
            "return": [
                "Dict[(str, List[nothing])]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "timeserio-master/tests/test_multimodel/__init__.py": {},
    "timeserio-master/tests/test_pipeline/test_column_checks.py": {
        "test_pipeline_required": {
            "name": "test_pipeline_required",
            "location": 109,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "str"
                ],
                "required_columns": [
                    "str"
                ]
            }
        },
        "test_pipeline_transformed": {
            "name": "test_pipeline_transformed",
            "location": 121,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "input_columns": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "transformed_columns": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ]
            }
        },
        "test_feature_union_required_columns": {
            "name": "test_feature_union_required_columns",
            "location": 132,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [],
                "required_columns": []
            }
        },
        "test_feature_union_transformed_columns": {
            "name": "test_feature_union_transformed_columns",
            "location": 143,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ],
                "transformed_columns": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ],
                "input_columns": [
                    "int",
                    "str",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "test_pandas_numpy_mixed_pipeline": {
            "name": "test_pandas_numpy_mixed_pipeline",
            "location": 158,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pipeline": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "input_columns": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "expected": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ]
            }
        },
        "test_pipeline_no_attributes_required_or_transformed": {
            "name": "test_pipeline_no_attributes_required_or_transformed",
            "location": 181,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pipeline": [
                    "list",
                    "int",
                    "list[]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "required_columns": [
                    "list",
                    "int",
                    "list[]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "transformed_columns": [
                    "str",
                    "bool",
                    "dict",
                    "dict[, ]",
                    "List[int]",
                    "list[int]",
                    "Tuple[Tuple[int, int]]",
                    "tuple[tuple[typing.Union[int,int]]]"
                ]
            }
        },
        "test_invalid_pipeline": {
            "name": "test_invalid_pipeline",
            "location": 189,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_grouped_pipeline_required": {
            "name": "test_grouped_pipeline_required",
            "location": 210,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "str"
                ],
                "required_columns": [
                    "str"
                ]
            }
        },
        "test_grouped_pipeline_transformed": {
            "name": "test_grouped_pipeline_transformed",
            "location": 224,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "input_columns": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ],
                "transformed_columns": [
                    "str",
                    "int",
                    "Union[str, float]",
                    "float"
                ]
            }
        }
    },
    "timeserio-master/tests/test_pipeline/test_grouped_pipeline.py": {
        "input_df": {
            "name": "input_df",
            "location": 16,
            "return": [
                "int",
                "list[]",
                "str",
                "Callable"
            ],
            "arguments": {}
        },
        "test_grouped_returns_numpy": {
            "name": "test_grouped_returns_numpy",
            "location": 42,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pipeline": [
                    "str",
                    "int",
                    "Iterable[Tuple[int, int]]",
                    "typing.Iterable[tuple[typing.Union[int,int]]]"
                ],
                "groupby": [
                    "str",
                    "int",
                    "Iterable[Tuple[int, int]]",
                    "typing.Iterable[tuple[typing.Union[int,int]]]"
                ],
                "is_estimator": [
                    "list[str]",
                    "bool",
                    "List[str]",
                    "raiden.utils.List[raiden.raiden_service.RaidenService]"
                ],
                "input_df": [
                    "int",
                    "bool",
                    "set[str]",
                    "Optional[Set[str]]",
                    "None",
                    "List[Dict[str, str]]",
                    "list[dict[str, str]]"
                ]
            }
        },
        "test_grouped_returns_pandas": {
            "name": "test_grouped_returns_pandas",
            "location": 60,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pipeline": [
                    "Iterable[Tuple[int, int]]",
                    "typing.Iterable[tuple[typing.Union[int,int]]]"
                ],
                "groupby": [
                    "Iterable[Tuple[int, int]]",
                    "typing.Iterable[tuple[typing.Union[int,int]]]"
                ],
                "input_df": [
                    "int",
                    "str"
                ]
            }
        },
        "test_grouped_with_y": {
            "name": "test_grouped_with_y",
            "location": 77,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pipeline": [
                    "Union[int, slice]",
                    "int"
                ],
                "groupby": [
                    "Union[int, slice]",
                    "int"
                ],
                "y": [
                    "int",
                    "float",
                    "str",
                    "Optional[int]"
                ],
                "input_df": [
                    "list[int]",
                    "int",
                    "List[int]",
                    "float"
                ],
                "y_mode": [
                    "str",
                    "bool"
                ]
            }
        },
        "test_grouped_order": {
            "name": "test_grouped_order",
            "location": 103,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "pipeline": [
                    "str",
                    "int",
                    "typing.Iterable[tuple[typing.Union[int,int]]]",
                    "Iterable[Tuple[int, int]]",
                    "bool",
                    "raiden.utils.TokenAmount"
                ],
                "groupby": [
                    "str",
                    "int",
                    "typing.Iterable[tuple[typing.Union[int,int]]]",
                    "Iterable[Tuple[int, int]]",
                    "bool",
                    "raiden.utils.TokenAmount"
                ],
                "is_estimator": [
                    "list[str]",
                    "bool",
                    "List[str]",
                    "list[tuple[typing.Union[str,typing.Any]]]",
                    "List[Tuple[str, Any]]",
                    "int"
                ],
                "input_df": [
                    "list[dict[str, str]]",
                    "int",
                    "Optional[float]",
                    "Optional[int]",
                    "float",
                    "Optional[Set[str]]",
                    "List[Dict[str, str]]",
                    "Callable"
                ]
            }
        },
        "test_grouped_values": {
            "name": "test_grouped_values",
            "location": 127,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "mocker": [
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]"
                ],
                "pipeline": [
                    "typing.Iterable[tuple[typing.Union[int,int]]]",
                    "int",
                    "Iterable[Tuple[int, int]]",
                    "str",
                    "raiden.utils.TokenAmount"
                ],
                "groupby": [
                    "bool"
                ],
                "is_estimator": [
                    "bool",
                    "List[List[int]]",
                    "list[list[int]]"
                ],
                "input_df": [
                    "int",
                    "bool",
                    "Optional[Set[str]]"
                ]
            }
        },
        "test_raises_when_missing_key": {
            "name": "test_raises_when_missing_key",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "input_df": [
                    "str"
                ]
            }
        },
        "test_one_group_missing_return_none": {
            "name": "test_one_group_missing_return_none",
            "location": 148,
            "return": [
                "None"
            ],
            "arguments": {
                "input_df": []
            }
        },
        "test_one_groups_missing_return_df": {
            "name": "test_one_groups_missing_return_df",
            "location": 161,
            "return": [
                "None"
            ],
            "arguments": {
                "input_df": [
                    "str",
                    "int",
                    "Callable",
                    "typing.Callable[, ]",
                    "Type",
                    "typing.Type"
                ]
            }
        },
        "test_all_groups_missing_raises": {
            "name": "test_all_groups_missing_raises",
            "location": 179,
            "return": [
                "None"
            ],
            "arguments": {
                "input_df": [
                    "Dict[str, float]",
                    "bool",
                    "dict[str, float]",
                    "str"
                ]
            }
        },
        "test_iter_groups_non_consecutive_index": {
            "name": "test_iter_groups_non_consecutive_index",
            "location": 192,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "index": [
                    "str",
                    "List[str]",
                    "float",
                    "numpy.ndarray",
                    "list",
                    "int"
                ]
            }
        },
        "test_iter_groups_non_consecutive_index_target_series": {
            "name": "test_iter_groups_non_consecutive_index_target_series",
            "location": 208,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "index": [
                    "numpy.ndarray",
                    "list",
                    "Callable",
                    "List[str]",
                    "float"
                ]
            }
        }
    },
    "timeserio-master/tests/test_pipeline/test_multipipeline.py": {
        "multipipeline": {
            "name": "multipipeline",
            "location": 11,
            "return": [
                "MultiPipeline",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "multipipeline_validation": {
            "name": "multipipeline_validation",
            "location": 22,
            "return": [
                "MultiPipeline",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "test_get_param_names": {
            "name": "test_get_param_names",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "multipipeline": []
            }
        },
        "test_get_params": {
            "name": "test_get_params",
            "location": 45,
            "return": [
                "None"
            ],
            "arguments": {
                "multipipeline": [
                    "str"
                ]
            }
        },
        "test_set_params": {
            "name": "test_set_params",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "multipipeline": [
                    "str"
                ]
            }
        },
        "test_get_attr": {
            "name": "test_get_attr",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "multipipeline": [
                    "str"
                ]
            }
        },
        "test_get_item": {
            "name": "test_get_item",
            "location": 65,
            "return": [
                "None"
            ],
            "arguments": {
                "multipipeline": [
                    "str",
                    "int",
                    "Dict[str, float]",
                    "dict[str, float]"
                ]
            }
        },
        "test_pipeline_validation": {
            "name": "test_pipeline_validation",
            "location": 73,
            "return": [
                "None"
            ],
            "arguments": {
                "multipipeline_validation": []
            }
        }
    },
    "timeserio-master/tests/test_pipeline/test_utils.py": {
        "df": {
            "name": "df",
            "location": 9,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {}
        },
        "test_fit_decorator": {
            "name": "test_fit_decorator",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "float"
                ]
            }
        },
        "test_fit_decorator.fit": {
            "name": "fit",
            "location": 19,
            "return": [
                "str",
                "Tuple[str]"
            ],
            "arguments": {
                "df": [
                    "str"
                ],
                "y": [
                    "str"
                ]
            }
        }
    },
    "timeserio-master/tests/test_pipeline/__init__.py": {},
    "timeserio-master/tests/test_preprocessing/test_aggregate.py": {
        "test_flatten_columns": {
            "name": "test_flatten_columns",
            "location": 44,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "column_tuples": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ],
                "names": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None"
                ],
                "expected": [
                    "int",
                    "str",
                    "bytes",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "test_flatten_column_ignores_flat": {
            "name": "test_flatten_column_ignores_flat",
            "location": 50,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_cartesian_product": {
            "name": "test_cartesian_product",
            "location": 63,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df_1_dict": [
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "df_2_dict": [
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "expected_dict": [
                    "int",
                    "str",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_aggregate_values": {
            "name": "test_aggregate_values",
            "location": 90,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "bytes",
                    "bytearray",
                    "int",
                    "numpy.ndarray"
                ],
                "agg_dict": [
                    "int",
                    "bytes"
                ],
                "groupby": [
                    "int",
                    "bytes"
                ],
                "expected": [
                    "str",
                    "int",
                    "float",
                    "List[str]",
                    "list[str]",
                    "List[int]",
                    "list[int]",
                    "Dict[str, int]",
                    "dict[str, int]"
                ]
            }
        },
        "test_aggregate_col_names": {
            "name": "test_aggregate_col_names",
            "location": 120,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "int",
                    "float",
                    "Union[str, float]",
                    "None",
                    "Optional[bool]",
                    "bool"
                ],
                "agg_dict": [
                    "str",
                    "int",
                    "float",
                    "Union[str, float]",
                    "None",
                    "Optional[bool]",
                    "bool"
                ],
                "groupby": [],
                "expected": [
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "test_required_columns": {
            "name": "test_required_columns",
            "location": 137,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "agg_dict": [
                    "str"
                ],
                "groupby": [
                    "str"
                ],
                "required_columns": [
                    "str"
                ]
            }
        }
    },
    "timeserio-master/tests/test_preprocessing/test_datetime_features.py": {
        "df": {
            "name": "df",
            "location": 26,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "featurizer": {
            "name": "featurizer",
            "location": 31,
            "return": [
                "PandasDateTimeFeaturizer",
                "datetime.datetime",
                "str",
                "int",
                "Optional[datetime.tzinfo]"
            ],
            "arguments": {}
        },
        "test_get_fractional_hour_from_series": {
            "name": "test_get_fractional_hour_from_series",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_get_fractional_day_from_series": {
            "name": "test_get_fractional_day_from_series",
            "location": 44,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_get_fractional_year_from_series": {
            "name": "test_get_fractional_year_from_series",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_get_is_holiday_from_series": {
            "name": "test_get_is_holiday_from_series",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_get_is_holiday_from_series_with_country": {
            "name": "test_get_is_holiday_from_series_with_country",
            "location": 71,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "country": [
                    "str",
                    "Sequence[int]",
                    "typing.Sequence[int]",
                    "Optional[str]",
                    "None"
                ],
                "expected": [
                    "int",
                    "str",
                    "Dict[str, int]",
                    "dict[str, int]"
                ]
            }
        },
        "test_get_zero_indexed_month_from_series": {
            "name": "test_get_zero_indexed_month_from_series",
            "location": 78,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "test_truncate_series": {
            "name": "test_truncate_series",
            "location": 104,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "series_data": [
                    "dict",
                    "int",
                    "dict[, ]",
                    "str",
                    "List[Tuple[Any, Dict]]",
                    "list[tuple[typing.Union[typing.Any,dict[, ]]]]"
                ],
                "truncation_period": [
                    "dict",
                    "int",
                    "dict[, ]",
                    "str",
                    "List[Tuple[Any, Dict]]",
                    "list[tuple[typing.Union[typing.Any,dict[, ]]]]"
                ],
                "expected_data": [
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Optional[Dict[str, Any]]",
                    "int",
                    "None",
                    "bytes",
                    "dict",
                    "str",
                    "dict[, ]"
                ]
            }
        },
        "test_set_get_params": {
            "name": "test_set_get_params",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "featurizer": [
                    "dict"
                ]
            }
        },
        "test_with_unknown_attribute": {
            "name": "test_with_unknown_attribute",
            "location": 122,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "float"
                ],
                "featurizer": [
                    "str",
                    "float"
                ]
            }
        },
        "test_with_unknown_column": {
            "name": "test_with_unknown_column",
            "location": 128,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [],
                "featurizer": [
                    "pandas.DataFrame",
                    "datetime.date.time"
                ]
            }
        },
        "test_with_non_dt_column": {
            "name": "test_with_non_dt_column",
            "location": 134,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [],
                "featurizer": [
                    "str",
                    "pandas.DataFrame",
                    "typing.Sequence[numpy.ndarray]",
                    "Sequence[numpy.ndarray]"
                ]
            }
        },
        "test_featurizer": {
            "name": "test_featurizer",
            "location": 140,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "dict",
                    "dict[, ]",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "featurizer": [
                    "str",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "test_featurizer_callable": {
            "name": "test_featurizer_callable",
            "location": 148,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame"
                ],
                "featurizer": [
                    "str",
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "test_seq_datetime": {
            "name": "test_seq_datetime",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "Iterable[str]",
                    "typing.Iterable[str]"
                ],
                "featurizer": [
                    "pandas.DataFrame",
                    "datetime.date.time"
                ]
            }
        },
        "test_get_time_is_in_interval_from_series": {
            "name": "test_get_time_is_in_interval_from_series",
            "location": 172,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "periods": [
                    "dict[, ]",
                    "bool",
                    "dict",
                    "int"
                ]
            }
        },
        "test_featurize_is_in_interval": {
            "name": "test_featurize_is_in_interval",
            "location": 187,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "featurizer": [
                    "int",
                    "pandas.DataFrame",
                    "bool"
                ],
                "periods": []
            }
        },
        "test_get_is_morning_peak_from_series": {
            "name": "test_get_is_morning_peak_from_series",
            "location": 204,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "featurizer": [
                    "datetime.date.time"
                ],
                "periods": []
            }
        },
        "test_required_columns": {
            "name": "test_required_columns",
            "location": 230,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "int",
                    "str"
                ],
                "required_columns": [
                    "int",
                    "str"
                ]
            }
        },
        "test_transformed_columns_from_required": {
            "name": "test_transformed_columns_from_required",
            "location": 246,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "pandas.DataFrame",
                    "Dict[str, Sequence[Any]]"
                ],
                "transformed_columns": [
                    "pandas.DataFrame"
                ]
            }
        },
        "test_transformed_columns": {
            "name": "test_transformed_columns",
            "location": 272,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "str",
                    "bool",
                    "Callable"
                ],
                "transformed_columns": [
                    "int",
                    "float"
                ],
                "input_columns": [
                    "str",
                    "bool",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "test_invalid_columns": {
            "name": "test_invalid_columns",
            "location": 277,
            "return": [
                "None"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_preprocessing/test_datetime_lag.py": {
        "df": {
            "name": "df",
            "location": 14,
            "return": [
                "bool"
            ],
            "arguments": {}
        },
        "test_fit_single_lag": {
            "name": "test_fit_single_lag",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "int",
                    "pandas.DataFrame"
                ]
            }
        },
        "test_dont_refit": {
            "name": "test_dont_refit",
            "location": 35,
            "return": [
                "None"
            ],
            "arguments": {
                "df": []
            }
        },
        "test_fit_multiple_lags": {
            "name": "test_fit_multiple_lags",
            "location": 60,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "test_transform_from_datetime": {
            "name": "test_transform_from_datetime",
            "location": 71,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "pandas.DataFrame",
                    "Sequence[numpy.ndarray]",
                    "Iterable[Tuple[int, int]]"
                ]
            }
        },
        "test_columns": {
            "name": "test_columns",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "df": []
            }
        },
        "test_transform_with_duplicates": {
            "name": "test_transform_with_duplicates",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "df": []
            }
        },
        "test_fit_with_duplicates_raises": {
            "name": "test_fit_with_duplicates_raises",
            "location": 114,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "bool"
                ]
            }
        },
        "test_fit_with_duplicates_with_agg": {
            "name": "test_fit_with_duplicates_with_agg",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "bool"
                ]
            }
        },
        "test_fit_rolling_mean_single_window": {
            "name": "test_fit_rolling_mean_single_window",
            "location": 143,
            "return": [
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "pandas.DataFrame"
                ]
            }
        }
    },
    "timeserio-master/tests/test_preprocessing/test_encoding.py": {
        "TestFeatureIndexEncoder.test_feature_encoder": {
            "name": "test_feature_encoder",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_labels": [
                    "int",
                    "List[int]",
                    "list[int]",
                    "list",
                    "list[]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]",
                    "List[List[int]]",
                    "list[list[int]]"
                ],
                "expected_encoding": [
                    "str",
                    "int",
                    "Iterable[str]",
                    "typing.Iterable[str]",
                    "Iterable[int]",
                    "typing.Iterable[int]"
                ]
            }
        },
        "TestStatelessOneHotEncoder.test_invalid_n_values": {
            "name": "test_invalid_n_values",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestStatelessOneHotEncoder.test_same_as_stateful": {
            "name": "test_same_as_stateful",
            "location": 46,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_features": [
                    "int",
                    "bool"
                ],
                "n_values": [
                    "int",
                    "bool"
                ],
                "categories": [
                    "int",
                    "bytes",
                    "list[int]",
                    "str",
                    "List[int]",
                    "numpy.ndarray"
                ],
                "random": [
                    "int",
                    "bool"
                ]
            }
        },
        "TestStatelessOneHotEncoder.test_same_as_stateful_for_multiple_n_values": {
            "name": "test_same_as_stateful_for_multiple_n_values",
            "location": 71,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_features": [
                    "bool",
                    "dict[int, dict[int, typing.Any]]",
                    "numpy.ndarray",
                    "Dict[int, Dict[int, Any]]"
                ],
                "n_values": [
                    "bytearray",
                    "int",
                    "numpy.ndarray",
                    "IO[str]"
                ],
                "categories": [
                    "bool",
                    "str",
                    "float"
                ],
                "random": [
                    "int",
                    "bytearray",
                    "typing.IO",
                    "str",
                    "numpy.ndarray",
                    "IO[str]"
                ]
            }
        },
        "TestStatelessTemporalOneHotEncoder.test_invalid_n_values": {
            "name": "test_invalid_n_values",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "n_values": [
                    "int",
                    "numpy.ndarray",
                    "float",
                    "None",
                    "Optional[int]",
                    "list[float]",
                    "List[float]"
                ]
            }
        },
        "TestStatelessTemporalOneHotEncoder.test_temporal_onehot": {
            "name": "test_temporal_onehot",
            "location": 100,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestPeriodicEncoder.array": {
            "name": "array",
            "location": 126,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "n_features": [
                    "int"
                ]
            }
        },
        "TestPeriodicEncoder.test_single_column_no_transform": {
            "name": "test_single_column_no_transform",
            "location": 133,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "periodic_features": []
            }
        },
        "TestPeriodicEncoder.test_single_column": {
            "name": "test_single_column",
            "location": 140,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "periodic_features": [
                    "Tuple[int, int]",
                    "tuple[typing.Union[int,int]]"
                ]
            }
        },
        "TestPeriodicEncoder.test_multi_column": {
            "name": "test_multi_column",
            "location": 150,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_features": [
                    "int",
                    "float",
                    "Optional[str]",
                    "str",
                    "List[list]",
                    "None",
                    "list[list[]]"
                ],
                "periodic_features": [
                    "float",
                    "int"
                ]
            }
        },
        "TestStatelessPeriodicEncoder.test_same_as_stateful": {
            "name": "test_same_as_stateful",
            "location": 167,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "n_features": [
                    "int"
                ],
                "periodic_features": [
                    "int",
                    "Optional[int]",
                    "None"
                ],
                "period": [
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        }
    },
    "timeserio-master/tests/test_preprocessing/test_pandas_array_utils.py": {
        "df": {
            "name": "df",
            "location": 18,
            "return": [
                "str",
                "Any",
                "Optional[Any]",
                "Optional[str]",
                "Optional[Dict[str, Any]]",
                "bool"
            ],
            "arguments": {}
        },
        "arr1d": {
            "name": "arr1d",
            "location": 22,
            "return": [
                "numpy.ndarray",
                "int",
                "BinaryIO",
                "str",
                "float"
            ],
            "arguments": {}
        },
        "arr2d": {
            "name": "arr2d",
            "location": 26,
            "return": [
                "int",
                "bytes"
            ],
            "arguments": {}
        },
        "test_create_df_from_array": {
            "name": "test_create_df_from_array",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "arr": [
                    "float",
                    "str"
                ],
                "n_dims": [
                    "typing.Sequence[numpy.ndarray]",
                    "Sequence[numpy.ndarray]",
                    "numpy.ndarray"
                ]
            }
        },
        "test_insert_into_flat_idx_df": {
            "name": "test_insert_into_flat_idx_df",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "Optional[Tuple[numpy.ndarray, numpy.ndarray]]",
                    "tuple[typing.Union[numpy.ndarray,numpy.ndarray]]"
                ],
                "arr": [
                    "int"
                ],
                "n_dims": [
                    "typing.Sequence[numpy.ndarray]",
                    "str",
                    "Sequence[numpy.ndarray]",
                    "float",
                    "numpy.ndarray",
                    "typing.Iterable[int]",
                    "Iterable[int]",
                    "tuple",
                    "list"
                ]
            }
        },
        "test_insert_into_multi_idx_df": {
            "name": "test_insert_into_multi_idx_df",
            "location": 56,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "bool",
                    "numpy.ndarray",
                    "float"
                ],
                "arr": [
                    "int"
                ],
                "n_dims": [
                    "typing.Sequence[numpy.ndarray]",
                    "str",
                    "Sequence[numpy.ndarray]",
                    "float",
                    "numpy.ndarray",
                    "typing.Iterable[int]",
                    "Iterable[int]",
                    "tuple",
                    "list"
                ]
            }
        }
    },
    "timeserio-master/tests/test_preprocessing/test_pandas_feature_selector.py": {
        "df": {
            "name": "df",
            "location": 18,
            "return": [
                "int",
                "List[str]",
                "bytes"
            ],
            "arguments": {
                "use_tensor_extension": [
                    "bool",
                    "float",
                    "typing.Sequence[typing.Sequence[int]]",
                    "int",
                    "Sequence[Sequence[int]]"
                ]
            }
        },
        "indexed_df": {
            "name": "indexed_df",
            "location": 23,
            "return": [
                "bool",
                "str",
                "int"
            ],
            "arguments": {}
        },
        "test_column_selector": {
            "name": "test_column_selector",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "int",
                    "List[str]",
                    "list[str]",
                    "list",
                    "list[]",
                    "List[List[Any]]",
                    "list[list[typing.Any]]"
                ],
                "columns": [
                    "str",
                    "tuple[typing.Union[int,int]]",
                    "float",
                    "Tuple[int, int]",
                    "list[]",
                    "list",
                    "pandas.DataFrame"
                ],
                "num_columns": [
                    "int",
                    "str",
                    "None",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "test_value_selector": {
            "name": "test_value_selector",
            "location": 62,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "int",
                    "List[Dict[str, Any]]",
                    "List[List[int]]"
                ],
                "columns": [
                    "str",
                    "Union[Mapping[str, Any], str]",
                    "typing.Mapping",
                    "Callable[[], Any]",
                    "typing.Callable[[], typing.Any]"
                ],
                "shape1": [
                    "int",
                    "str",
                    "dict[, ]",
                    "numpy.ndarray",
                    "dict"
                ]
            }
        },
        "test_value_selector_dtype": {
            "name": "test_value_selector_dtype",
            "location": 70,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "df": [
                    "str",
                    "dict",
                    "dict[, ]"
                ],
                "dtype": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "test_index_value_selector": {
            "name": "test_index_value_selector",
            "location": 85,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "indexed_df": [],
                "levels": [],
                "shape1": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "test_index_value_selector_dtype": {
            "name": "test_index_value_selector_dtype",
            "location": 93,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "indexed_df": [
                    "bool"
                ],
                "dtype": [
                    "bool"
                ]
            }
        },
        "test_single_transformer_required_columns": {
            "name": "test_single_transformer_required_columns",
            "location": 108,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [],
                "required_columns": []
            }
        },
        "test_single_transformer_transformed_from_required_only": {
            "name": "test_single_transformer_transformed_from_required_only",
            "location": 125,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "pandas.DataFrame",
                    "Dict[str, Sequence[Any]]"
                ],
                "transformed_columns": [
                    "pandas.DataFrame"
                ]
            }
        },
        "test_single_transformer_transformed_columns": {
            "name": "test_single_transformer_transformed_columns",
            "location": 139,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": [
                    "str",
                    "int",
                    "Dict[str, Any]",
                    "bool",
                    "numpy.array"
                ],
                "input_columns": [
                    "str",
                    "int",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]",
                    "bool",
                    "numpy.array"
                ],
                "transformed_columns": [
                    "int",
                    "float",
                    "Iterable[Any]",
                    "typing.Iterable[typing.Any]"
                ]
            }
        },
        "test_missing_required_columns": {
            "name": "test_missing_required_columns",
            "location": 150,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "transformer": []
            }
        }
    },
    "timeserio-master/tests/test_preprocessing/test_utils.py": {
        "test_as_list_of_str": {
            "name": "test_as_list_of_str",
            "location": 18,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "columns_in": [
                    "bytes",
                    "int",
                    "str",
                    "typing.Sequence[str]",
                    "bool",
                    "typing.Any",
                    "Sequence[str]",
                    "None",
                    "T",
                    "Optional[Union[str, Any]]"
                ],
                "columns_out": [
                    "bytes",
                    "int",
                    "str",
                    "typing.Sequence[str]",
                    "bool",
                    "typing.Any",
                    "Sequence[str]",
                    "None",
                    "T",
                    "Optional[Union[str, Any]]"
                ]
            }
        },
        "test_identity_regressor_fit": {
            "name": "test_identity_regressor_fit",
            "location": 27,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        },
        "test_identity_regressor_predict": {
            "name": "test_identity_regressor_predict",
            "location": 31,
            "return": [
                "",
                "None"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/tests/test_preprocessing/__init__.py": {},
    "timeserio-master/tests/test_utils/conftest.py": {
        "test_bucket_name": {
            "name": "test_bucket_name",
            "location": 8,
            "return": [
                "Mapping[str, Any]",
                "typing.Text"
            ],
            "arguments": {}
        },
        "s3": {
            "name": "s3",
            "location": 13,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "test_bucket_name": [
                    "str"
                ]
            }
        }
    },
    "timeserio-master/tests/test_utils/test_functools.py": {
        "func1": {
            "name": "func1",
            "location": 6,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "str",
                    "int",
                    "bool"
                ],
                "b": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "func2": {
            "name": "func2",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "str",
                    "int",
                    "bool"
                ]
            }
        },
        "func3": {
            "name": "func3",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "str",
                    "int",
                    "bool"
                ],
                "b": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "func4": {
            "name": "func4",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "typing.Text",
                    "str",
                    "int",
                    "bool"
                ],
                "b": [
                    "int",
                    "str",
                    "bool"
                ]
            }
        },
        "test_get_default_args": {
            "name": "test_get_default_args",
            "location": 35,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "func": [
                    "str",
                    "bool",
                    "List[str]",
                    "list[str]",
                    "float",
                    "Callable[..., Coroutine[Any, Any, Any]]",
                    "typing.Callable[..., collections.abc.Coroutine]"
                ],
                "args": []
            }
        }
    },
    "timeserio-master/tests/test_utils/test_pickle.py": {
        "assert_is": {
            "name": "assert_is",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float"
                ],
                "b": [
                    "int",
                    "float"
                ]
            }
        },
        "assert_eq": {
            "name": "assert_eq",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float",
                    "list[int]",
                    "bool",
                    "List[int]"
                ],
                "b": [
                    "int",
                    "float",
                    "list[int]",
                    "bool",
                    "List[int]"
                ]
            }
        },
        "assert_lambda_eq": {
            "name": "assert_lambda_eq",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "a": [
                    "int",
                    "float",
                    "Sequence[T]",
                    "typing.Sequence[T]"
                ],
                "b": [
                    "int",
                    "float",
                    "Sequence[T]",
                    "typing.Sequence[T]"
                ]
            }
        },
        "TestPickling.test_pickle_to_string": {
            "name": "test_pickle_to_string",
            "location": 34,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "obj": [
                    "str",
                    "bool",
                    "Optional[Dict[str, Any]]",
                    "dict[str, typing.Any]",
                    "None"
                ],
                "assert_object_same": []
            }
        },
        "TestPickling.test_pickle_to_file": {
            "name": "test_pickle_to_file",
            "location": 39,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "obj": [
                    "Tuple[int, int]",
                    "str",
                    "tuple[typing.Union[int,int]]"
                ],
                "assert_object_same": [
                    "set",
                    "set[]"
                ]
            }
        },
        "TestPickling.test_pickle_to_s3": {
            "name": "test_pickle_to_s3",
            "location": 45,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "s3": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None",
                    "List[str]",
                    "list[str]"
                ],
                "test_bucket_name": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "obj": [
                    "str"
                ],
                "assert_object_same": [
                    "Optional[int]",
                    "int",
                    "List[str]",
                    "str",
                    "None",
                    "Dict[str, List[str]]",
                    "list[str]",
                    "dict[str, list[str]]"
                ]
            }
        }
    },
    "timeserio-master/tests/test_utils/__init__.py": {},
    "timeserio-master/tests/test_validation/test_pipeline_validation.py": {
        "multinetwork": {
            "name": "multinetwork",
            "location": 50,
            "return": [
                "SimpleMultiNetwork",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {}
        },
        "multimodel": {
            "name": "multimodel",
            "location": 55,
            "return": [
                "MultiModel",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "multinetwork": [
                    "str",
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ]
            }
        },
        "invalid_multimodel": {
            "name": "invalid_multimodel",
            "location": 73,
            "return": [
                "MultiModel",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "multinetwork": [
                    "str",
                    "List[float]",
                    "float",
                    "list[float]",
                    "List[Dict[str, Any]]",
                    "list[dict[str, typing.Any]]"
                ]
            }
        },
        "test_valid_multimodel": {
            "name": "test_valid_multimodel",
            "location": 95,
            "return": [
                "None"
            ],
            "arguments": {
                "multimodel": []
            }
        },
        "test_invalid_multimodel": {
            "name": "test_invalid_multimodel",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "invalid_multimodel": [
                    "str",
                    "float"
                ]
            }
        },
        "SimpleMultiNetwork._model": {
            "name": "_model",
            "location": 17,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "forecaster_features": [
                    "int",
                    "app.models.Question",
                    "Exception",
                    "dict",
                    "str"
                ],
                "forecaster_hidden_units": [
                    "tuple[int]",
                    "float",
                    "str",
                    "list"
                ]
            }
        },
        "SimpleMultiNetwork._callbacks": {
            "name": "_callbacks",
            "location": 45,
            "return": [
                "Dict[(str, List[nothing])]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "timeserio-master/tests/test_validation/__init__.py": {},
    "timeserio-master/timeserio/externals.py": {
        "optional_import": {
            "name": "optional_import",
            "location": 44,
            "return": [
                "Tuple[(module, bool)]"
            ],
            "arguments": {
                "module_name": [
                    "Tuple[int, int]",
                    "OSError",
                    "tuple[typing.Union[int,int]]",
                    "T",
                    "typing.IO",
                    "IO",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "NotFoundModule.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "name": [
                    "str"
                ]
            }
        },
        "NotFoundModule.__getattr__": {
            "name": "__getattr__",
            "location": 24,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "attr": [
                    "str"
                ]
            }
        },
        "NotFoundModule.__str__": {
            "name": "__str__",
            "location": 37,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "NotFoundModule.__repr__": {
            "name": "__repr__",
            "location": 40,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "timeserio-master/timeserio/ini.py": {},
    "timeserio-master/timeserio/version.py": {
        "get_home_dir": {
            "name": "get_home_dir",
            "location": 10,
            "return": [
                "Union[(str, _T0)]"
            ],
            "arguments": {
                "home_dir": [
                    "_T0"
                ]
            }
        },
        "get_git_dir": {
            "name": "get_git_dir",
            "location": 16,
            "return": [
                "str"
            ],
            "arguments": {
                "home_dir": [
                    "None"
                ]
            }
        },
        "get_release_version_file": {
            "name": "get_release_version_file",
            "location": 21,
            "return": [
                "str"
            ],
            "arguments": {
                "home_dir": [
                    "None"
                ]
            }
        },
        "call_git_describe": {
            "name": "call_git_describe",
            "location": 26,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "abbrev": [],
                "home_dir": [
                    "None"
                ]
            }
        },
        "read_release_version": {
            "name": "read_release_version",
            "location": 51,
            "return": [
                "Optional[str]"
            ],
            "arguments": {
                "home_dir": [
                    "None"
                ]
            }
        },
        "write_release_version": {
            "name": "write_release_version",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "version": [],
                "home_dir": [
                    "None"
                ]
            }
        },
        "get_git_version": {
            "name": "get_git_version",
            "location": 67,
            "return": [
                "str"
            ],
            "arguments": {
                "abbrev": [
                    "int"
                ],
                "home_dir": [
                    "None"
                ]
            }
        }
    },
    "timeserio-master/timeserio/__init__.py": {},
    "timeserio-master/timeserio/batches/utils.py": {
        "ceiling_division": {
            "name": "ceiling_division",
            "location": 1,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "dividend": [
                    "int",
                    "Callable",
                    "str"
                ],
                "divisor": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/__init__.py": {},
    "timeserio-master/timeserio/batches/chunked/base.py": {
        "ChunkedBatchGenerator.__init__": {
            "name": "__init__",
            "location": 17,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_size": [
                    "int",
                    "None",
                    "bool"
                ]
            }
        },
        "ChunkedBatchGenerator.chunks": {
            "name": "chunks",
            "location": 22,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChunkedBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 30,
            "return": [
                "timeserio.batches.single.base.BatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "ChunkedBatchGenerator._subgen_length": {
            "name": "_subgen_length",
            "location": 36,
            "return": [
                "int"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "ChunkedBatchGenerator.subgen_lengths": {
            "name": "subgen_lengths",
            "location": 44,
            "return": [
                "int",
                "str",
                "Callable",
                "dict[int, typing.Any]",
                "list[int]",
                "list[]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChunkedBatchGenerator.subgen_index_bounds": {
            "name": "subgen_index_bounds",
            "location": 54,
            "return": [
                "int",
                "str",
                "Iterable[T]"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChunkedBatchGenerator.num_subbatches": {
            "name": "num_subbatches",
            "location": 63,
            "return": [
                "bool",
                "int",
                "numpy.ndarray",
                "str",
                "deque"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChunkedBatchGenerator.__len__": {
            "name": "__len__",
            "location": 66,
            "return": [
                "float",
                "str",
                "T"
            ],
            "arguments": {
                "self": []
            }
        },
        "ChunkedBatchGenerator.find_subbatch_in_subgens": {
            "name": "find_subbatch_in_subgens",
            "location": 69,
            "return": [
                "Tuple[(int, Any)]"
            ],
            "arguments": {
                "self": [],
                "subbatch_idx": [
                    "int",
                    "float",
                    "Dict[str, int]",
                    "List[str]",
                    "str",
                    "pandas.DataFrame"
                ]
            }
        },
        "ChunkedBatchGenerator.__getitem__": {
            "name": "__getitem__",
            "location": 76,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch_idx": [
                    "bytes",
                    "int",
                    "numpy.ndarray",
                    "str"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/chunked/dask.py": {
        "SequenceForecastBatchGenerator.__init__": {
            "name": "__init__",
            "location": 14,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.chunks": {
            "name": "chunks",
            "location": 52,
            "return": [
                "list[]",
                "List[Dict]",
                "List[str]",
                "List[int]",
                "str",
                "List[List[Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 55,
            "return": [
                "single_sequence.SequenceForecastBatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "int",
                    "Callable",
                    "str"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/chunked/pandas.py": {
        "RowBatchGenerator.__init__": {
            "name": "__init__",
            "location": 11,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator.chunks": {
            "name": "chunks",
            "location": 29,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 32,
            "return": [
                "single_row.RowBatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "List[List[str]]",
                    "list[list[str]]",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "SamplingForecastBatchGenerator.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingForecastBatchGenerator.chunks": {
            "name": "chunks",
            "location": 77,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingForecastBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 80,
            "return": [
                "single_sequence.SamplingForecastBatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "List[List[str]]",
                    "list[list[str]]",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "SequenceForecastBatchGenerator.__init__": {
            "name": "__init__",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.chunks": {
            "name": "chunks",
            "location": 138,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 141,
            "return": [
                "single_sequence.SequenceForecastBatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "List[List[str]]",
                    "list[list[str]]",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/chunked/parquet.py": {
        "RowBatchGenerator.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator.chunks": {
            "name": "chunks",
            "location": 31,
            "return": [
                "str",
                "TextIO",
                "BinaryIO"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 34,
            "return": [
                "single_row.RowBatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "str",
                    "bytes",
                    "bool",
                    "Union[str, List[str]]",
                    "list[str]"
                ]
            }
        },
        "SequenceForecastBatchGenerator.__init__": {
            "name": "__init__",
            "location": 46,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.chunks": {
            "name": "chunks",
            "location": 87,
            "return": [
                "str",
                "TextIO",
                "BinaryIO"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.make_subgen": {
            "name": "make_subgen",
            "location": 90,
            "return": [
                "single_sequence.SequenceForecastBatchGenerator"
            ],
            "arguments": {
                "self": [],
                "chunk": [
                    "str",
                    "bytes",
                    "bool",
                    "Union[str, List[str]]",
                    "list[str]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/chunked/__init__.py": {},
    "timeserio-master/timeserio/batches/single/base.py": {},
    "timeserio-master/timeserio/batches/single/row.py": {
        "RowBatchGenerator.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator._eff_batch_size": {
            "name": "_eff_batch_size",
            "location": 22,
            "return": [
                "int",
                "str",
                "List[float]",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator.__len__": {
            "name": "__len__",
            "location": 25,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "RowBatchGenerator.__getitem__": {
            "name": "__getitem__",
            "location": 28,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch_idx": [
                    "int",
                    "bytes",
                    "dict",
                    "Dict[str, Any]",
                    "IO[str]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/single/sequence.py": {
        "ForecastBatchGeneratorBase.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ForecastBatchGeneratorBase.num_points": {
            "name": "num_points",
            "location": 63,
            "return": [
                "int",
                "numpy.ndarray",
                "str",
                "deque"
            ],
            "arguments": {
                "self": []
            }
        },
        "ForecastBatchGeneratorBase.__len__": {
            "name": "__len__",
            "location": 68,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "ForecastBatchGeneratorBase.batch_seq_start_indices": {
            "name": "batch_seq_start_indices",
            "location": 72,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "batch_idx": [
                    "str",
                    "bool"
                ]
            }
        },
        "ForecastBatchGeneratorBase._get_sequence_values": {
            "name": "_get_sequence_values",
            "location": 75,
            "return": [
                "Type[T]",
                "str",
                "dict",
                "Dict[Tuple[str, str], Tuple[float, float]]",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "column": [
                    "str",
                    "float",
                    "Optional[int]",
                    "int",
                    "None"
                ],
                "start_indices": [
                    "float",
                    "int",
                    "str",
                    "T"
                ]
            }
        },
        "ForecastBatchGeneratorBase.__getitem__": {
            "name": "__getitem__",
            "location": 83,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "batch_idx": [
                    "int",
                    "Optional[List[Any]]",
                    "bytes"
                ]
            }
        },
        "SamplingForecastBatchGenerator.__init__": {
            "name": "__init__",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingForecastBatchGenerator.num_examples": {
            "name": "num_examples",
            "location": 159,
            "return": [
                "int",
                "Callable[[T], List[T]]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingForecastBatchGenerator._eff_batch_size": {
            "name": "_eff_batch_size",
            "location": 168,
            "return": [
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingForecastBatchGenerator.__len__": {
            "name": "__len__",
            "location": 171,
            "return": [
                "str",
                "int",
                "dict",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SamplingForecastBatchGenerator.batch_seq_start_indices": {
            "name": "batch_seq_start_indices",
            "location": 174,
            "return": [
                "int",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "batch_idx": [
                    "str",
                    "bool"
                ]
            }
        },
        "SequenceForecastBatchGenerator.__init__": {
            "name": "__init__",
            "location": 193,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.first_index": {
            "name": "first_index",
            "location": 235,
            "return": [
                "int",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.num_examples": {
            "name": "num_examples",
            "location": 245,
            "return": [
                "int",
                "Callable[[T], List[T]]",
                "bool",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator._eff_batch_size": {
            "name": "_eff_batch_size",
            "location": 257,
            "return": [
                "bool",
                "float",
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.__len__": {
            "name": "__len__",
            "location": 260,
            "return": [
                "str",
                "int",
                "dict",
                "List[Dict[str, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator.batch_seq_start_indices": {
            "name": "batch_seq_start_indices",
            "location": 263,
            "return": [
                "int",
                "Optional[bool]",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "batch_idx": [
                    "int",
                    "float",
                    "rl_algorithms.utils.config.ConfigDict",
                    "str",
                    "bytes"
                ]
            }
        },
        "SequenceForecastBatchGenerator.random_offset_value": {
            "name": "random_offset_value",
            "location": 273,
            "return": [
                "int",
                "float",
                "str",
                "Tuple[int, int]",
                "numpy.ndarray",
                "Tuple[str, int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "SequenceForecastBatchGenerator._get_sequence_values": {
            "name": "_get_sequence_values",
            "location": 285,
            "return": [
                "Type[T]",
                "str",
                "dict",
                "Dict[Tuple[str, str], Tuple[float, float]]",
                "int",
                "bool"
            ],
            "arguments": {
                "self": [],
                "column": [
                    "int",
                    "str"
                ],
                "start_indices": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "timeserio-master/timeserio/batches/single/__init__.py": {},
    "timeserio-master/timeserio/data/datasets.py": {
        "load_iris_df": {
            "name": "load_iris_df",
            "location": 5,
            "return": [
                "str",
                "bool",
                "pandas._FilePathOrBuffer"
            ],
            "arguments": {}
        }
    },
    "timeserio-master/timeserio/data/mock.py": {
        "mock_datetime_range": {
            "name": "mock_datetime_range",
            "location": 17,
            "return": [
                "datetime.datetime",
                "int",
                "Union[str, int]",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "periods": [
                    "int",
                    "datetime.datetime",
                    "Sequence[util.datetime.range.DateTimeRange]",
                    "Optional[str]"
                ],
                "start": [
                    "None",
                    "int",
                    "datetime.datetime",
                    "pandas.Series"
                ]
            }
        },
        "_single_user_fit_df": {
            "name": "_single_user_fit_df",
            "location": 24,
            "return": [
                "int",
                "str",
                "bool",
                "float",
                "datetime.date"
            ],
            "arguments": {
                "periods": [
                    "int",
                    "Optional[int]",
                    "tuple",
                    "str"
                ],
                "start_date": [
                    "None",
                    "int",
                    "datetime.datetime",
                    "str",
                    "Optional[\"UserProvidedIdentifiers\"]"
                ],
                "id": [
                    "int",
                    "Optional[List[str]]",
                    "List[str]",
                    "Optional[str]",
                    "Tuple[numpy.ndarray]",
                    "bool",
                    "Optional[bool]"
                ],
                "embedding_dim": [
                    "int",
                    "Optional[int]",
                    "str",
                    "Optional[str]"
                ],
                "seq_length": [
                    "int",
                    "float",
                    "Tuple[int, int]",
                    "Optional[datetime.datetime]",
                    "Optional[int]",
                    "datetime.date"
                ],
                "use_tensor_extension": [
                    "bool",
                    "str",
                    "float",
                    "Optional[bool]",
                    "int"
                ]
            }
        },
        "mock_fit_data": {
            "name": "mock_fit_data",
            "location": 69,
            "return": [
                "bool",
                "str",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "periods": [
                    "int",
                    "Optional[str]",
                    "datetime.datetime",
                    "datetime.date",
                    "str"
                ],
                "start_date": [
                    "None",
                    "str",
                    "Optional[str]",
                    "datetime.datetime",
                    "datetime.date"
                ],
                "ids": [
                    "list[int]",
                    "Optional[str]",
                    "datetime.datetime",
                    "datetime.date",
                    "str"
                ],
                "embedding_dim": [
                    "int",
                    "Optional[str]",
                    "datetime.datetime",
                    "datetime.date",
                    "str"
                ],
                "seq_length": [
                    "int",
                    "Optional[str]",
                    "datetime.datetime",
                    "datetime.date",
                    "str"
                ],
                "use_tensor_extension": [
                    "bool",
                    "Optional[str]",
                    "datetime.datetime",
                    "datetime.date",
                    "str"
                ],
                "index": [
                    "bool",
                    "str",
                    "Optional[bool]",
                    "int",
                    "float"
                ]
            }
        },
        "mock_dask_fit_data": {
            "name": "mock_dask_fit_data",
            "location": 96,
            "return": [
                "int",
                "str",
                "bool",
                "Optional[int]"
            ],
            "arguments": {
                "periods": [
                    "str",
                    "int"
                ],
                "start_date": [
                    "str",
                    "None"
                ],
                "ids": [
                    "str",
                    "list[int]"
                ],
                "embedding_dim": [
                    "str",
                    "int"
                ],
                "seq_length": [
                    "str",
                    "int"
                ]
            }
        },
        "_single_user_raw_df": {
            "name": "_single_user_raw_df",
            "location": 118,
            "return": [
                "int",
                "str",
                "bool",
                "float",
                "datetime.date"
            ],
            "arguments": {
                "periods": [
                    "int",
                    "str"
                ],
                "start_date": [
                    "str",
                    "int",
                    "None"
                ],
                "id": [
                    "int",
                    "str"
                ]
            }
        },
        "mock_raw_data": {
            "name": "mock_raw_data",
            "location": 134,
            "return": [
                "bool",
                "str",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "periods": [
                    "int",
                    "str",
                    "datetime.date",
                    "Optional[int]",
                    "Tuple[str, str]"
                ],
                "start_date": [
                    "int",
                    "None",
                    "str",
                    "datetime.date",
                    "tuple[typing.Union[str,str]]",
                    "Optional[int]",
                    "Tuple[str, str]"
                ],
                "ids": [
                    "list[int]",
                    "int",
                    "str",
                    "datetime.date",
                    "Optional[int]",
                    "Tuple[str, str]"
                ]
            }
        },
        "mock_dask_raw_data": {
            "name": "mock_dask_raw_data",
            "location": 148,
            "return": [
                "int",
                "str",
                "bool",
                "Optional[int]"
            ],
            "arguments": {
                "periods": [
                    "str",
                    "int"
                ],
                "start_date": [
                    "str",
                    "None"
                ],
                "ids": [
                    "str",
                    "list[int]"
                ]
            }
        },
        "mock_predict_data": {
            "name": "mock_predict_data",
            "location": 162,
            "return": [
                "bool",
                "str",
                "int",
                "Optional[int]"
            ],
            "arguments": {
                "periods": [
                    "int",
                    "str",
                    "datetime.datetime",
                    "Union[str, int, float]"
                ],
                "start_date": [
                    "str",
                    "None",
                    "datetime.datetime",
                    "Union[str, int, float]",
                    "int",
                    "float"
                ],
                "use_tensor_extension": [
                    "bool",
                    "str",
                    "datetime.datetime",
                    "Union[str, int, float]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/data/__init__.py": {},
    "timeserio-master/timeserio/keras/batches.py": {
        "ArrayBatchGenerator.__init__": {
            "name": "__init__",
            "location": 10,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "list[dict[str, typing.Any]]",
                    "bool",
                    "List[Dict[str, Any]]",
                    "list[str]",
                    "List[str]",
                    "int"
                ],
                "y": [
                    "int",
                    "float",
                    "str",
                    "dict[str, int]",
                    "bool",
                    "dict[int, str]",
                    "Dict[str, int]",
                    "Dict[int, str]"
                ],
                "batch_size": [
                    "int",
                    "bool",
                    "Optional[int]"
                ]
            }
        },
        "ArrayBatchGenerator.__len__": {
            "name": "__len__",
            "location": 19,
            "return": [
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "ArrayBatchGenerator.__getitem__": {
            "name": "__getitem__",
            "location": 24,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "list",
                    "List[Tuple[int, int]]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/keras/callbacks.py": {
        "_now": {
            "name": "_now",
            "location": 11,
            "return": [
                "float"
            ],
            "arguments": {}
        },
        "_get_log_metrics": {
            "name": "_get_log_metrics",
            "location": 16,
            "return": [
                "list"
            ],
            "arguments": {
                "history": [
                    "str",
                    "List[str]",
                    "Tuple[str, str, str, str, str, str, str]",
                    "Tuple[str]"
                ],
                "exclude": [
                    "tuple[typing.Text]",
                    "str",
                    "List[str]",
                    "Tuple[str, str, str, str, str, str, str]",
                    "Tuple[str]"
                ]
            }
        },
        "_format_epoch_metric": {
            "name": "_format_epoch_metric",
            "location": 21,
            "return": [
                "Union[(KeyError, str)]"
            ],
            "arguments": {
                "history": [
                    "str",
                    "Optional[str]",
                    "Optional[bool]",
                    "Optional[Dict]"
                ],
                "metric": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Callable[[], int]"
                ],
                "fmt": [
                    "typing.Text",
                    "str",
                    "int",
                    "Optional[List[int]]"
                ],
                "errors": [
                    "bool",
                    "str",
                    "Optional[int]",
                    "int",
                    "List[str]",
                    "Dict[str, Tuple[str, int, int]]"
                ],
                "idx": [
                    "int",
                    "bool",
                    "str",
                    "Optional[List[int]]",
                    "Dict[str, Any]",
                    "Optional[Dict[str, Any]]"
                ],
                "with_name": [
                    "bool",
                    "str",
                    "Optional[str]"
                ]
            }
        },
        "_format_epoch_summary": {
            "name": "_format_epoch_summary",
            "location": 44,
            "return": [
                "str"
            ],
            "arguments": {
                "history": [
                    "bool",
                    "str"
                ],
                "fmt": [
                    "typing.Text",
                    "bytes",
                    "Optional[bytes]",
                    "int"
                ],
                "idx": [
                    "int",
                    "bytes",
                    "Optional[bytes]"
                ]
            }
        },
        "HistoryLogger.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batches": [
                    "bool",
                    "int",
                    "float"
                ]
            }
        },
        "HistoryLogger.on_train_begin": {
            "name": "on_train_begin",
            "location": 68,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "logs": [
                    "Optional[dict]",
                    "None",
                    "int",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "HistoryLogger.on_epoch_begin": {
            "name": "on_epoch_begin",
            "location": 72,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "None",
                    "bool",
                    "List[float]",
                    "list[float]"
                ],
                "logs": [
                    "int",
                    "None",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "bool",
                    "List[float]",
                    "list[float]"
                ]
            }
        },
        "HistoryLogger.on_train_batch_end": {
            "name": "on_train_batch_end",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "batch": [
                    "int",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "None",
                    "bool",
                    "List[float]",
                    "list[float]"
                ],
                "logs": [
                    "dict[, ]",
                    "dict",
                    "logging.Logger",
                    "int",
                    "Union[int, str]",
                    "bytes"
                ]
            }
        },
        "HistoryLogger.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 84,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "dict",
                    "dict[, ]",
                    "Dict[str, str]",
                    "dict[str, str]"
                ],
                "logs": [
                    "int",
                    "None",
                    "str",
                    "dict",
                    "list",
                    "dict[, ]",
                    "list[]"
                ]
            }
        },
        "HistoryLogger._log_training_metric_improvement": {
            "name": "_log_training_metric_improvement",
            "location": 94,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fmt": [
                    "Union[str, List[str], None]",
                    "typing.Text"
                ]
            }
        },
        "HistoryLogger._log_training_time": {
            "name": "_log_training_time",
            "location": 111,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "fmt": [
                    "typing.Text",
                    "str",
                    "int",
                    "logging.Logger"
                ]
            }
        },
        "HistoryLogger.on_train_end": {
            "name": "on_train_end",
            "location": 121,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "logs": [
                    "Optional[dict]",
                    "None",
                    "int",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "TimeLogger.__init__": {
            "name": "__init__",
            "location": 136,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TimeLogger.on_train_begin": {
            "name": "on_train_begin",
            "location": 142,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "logs": [
                    "Optional[dict]",
                    "None",
                    "int",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "TimeLogger.on_train_end": {
            "name": "on_train_end",
            "location": 146,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "logs": [
                    "Optional[dict]",
                    "None",
                    "int",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "TimeLogger._get_stats": {
            "name": "_get_stats",
            "location": 155,
            "return": [
                "Tuple[(Any, Any, Any, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "TimeLogger.on_epoch_begin": {
            "name": "on_epoch_begin",
            "location": 162,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "int",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "None",
                    "bool",
                    "List[float]",
                    "list[float]"
                ],
                "logs": [
                    "int",
                    "None",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "bool",
                    "List[float]",
                    "list[float]"
                ]
            }
        },
        "TimeLogger.on_epoch_end": {
            "name": "on_epoch_end",
            "location": 165,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch": [
                    "str",
                    "dict[, ]",
                    "Optional[dict]",
                    "int",
                    "None",
                    "Union[int, str]",
                    "dict",
                    "dict[str, typing.Any]",
                    "Dict[str, Any]"
                ],
                "logs": [
                    "int",
                    "None",
                    "str",
                    "Optional[dict]",
                    "dict[, ]",
                    "bool",
                    "List[float]",
                    "list[float]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/keras/multinetwork.py": {
        "make_history_logger": {
            "name": "make_history_logger",
            "location": 12,
            "return": [
                "timeserio.keras.callbacks.HistoryLogger"
            ],
            "arguments": {}
        },
        "MultiNetworkBase.__init__": {
            "name": "__init__",
            "location": 53,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._model": {
            "name": "_model",
            "location": 62,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._callbacks": {
            "name": "_callbacks",
            "location": 66,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._funcs_with_legal_params": {
            "name": "_funcs_with_legal_params",
            "location": 73,
            "return": [
                "str",
                "cmk.utils.type_defs.HostName",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._funcs_with_default_params": {
            "name": "_funcs_with_default_params",
            "location": 88,
            "return": [
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._default_params": {
            "name": "_default_params",
            "location": 92,
            "return": [
                "Callable[[Mapping], T]",
                "int",
                "float"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._filter_hyperparams": {
            "name": "_filter_hyperparams",
            "location": 99,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": [],
                "fn": [
                    "str",
                    "Dict[str, float]",
                    "Exception"
                ],
                "override": [
                    "Dict[str, Any]",
                    "cmk.utils.type_defs.EventRule",
                    "bool"
                ]
            }
        },
        "MultiNetworkBase.check_params": {
            "name": "check_params",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "int",
                    "str",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "MultiNetworkBase.hyperparams": {
            "name": "hyperparams",
            "location": 149,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "Dict[str, Union[int, bool]]",
                    "Callable",
                    "Optional[str]"
                ]
            }
        },
        "MultiNetworkBase.get_params": {
            "name": "get_params",
            "location": 155,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase.set_params": {
            "name": "set_params",
            "location": 167,
            "return": [
                "MultiNetworkBase"
            ],
            "arguments": {
                "self": [
                    "_TMultiNetworkBase"
                ]
            }
        },
        "MultiNetworkBase._init_model": {
            "name": "_init_model",
            "location": 181,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "self": [],
                "reset_weights": [
                    "int",
                    "Tuple[int, int, int, int]",
                    "dict",
                    "Optional[BaseException]"
                ],
                "reset_optimizers": [
                    "int",
                    "Tuple[int, int, int, int]",
                    "dict",
                    "Optional[BaseException]"
                ]
            }
        },
        "MultiNetworkBase.model": {
            "name": "model",
            "location": 196,
            "return": [
                "src.autoks.callbacks.CallbackList"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase.model_names": {
            "name": "model_names",
            "location": 202,
            "return": [
                "List[str]",
                "List[int]",
                "Callable[[None], None]",
                "List[List[str]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase.check_model_name": {
            "name": "check_model_name",
            "location": 205,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str"
                ]
            }
        },
        "MultiNetworkBase.callbacks": {
            "name": "callbacks",
            "location": 213,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._get_weights": {
            "name": "_get_weights",
            "location": 221,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._set_weights": {
            "name": "_set_weights",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "weights": [
                    "dict"
                ]
            }
        },
        "MultiNetworkBase._get_optimizers_config": {
            "name": "_get_optimizers_config",
            "location": 235,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._set_optimizers_config": {
            "name": "_set_optimizers_config",
            "location": 246,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "optimizers_config": [
                    "dict"
                ]
            }
        },
        "MultiNetworkBase.trainable_models": {
            "name": "trainable_models",
            "location": 266,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "value": [
                    "dict",
                    "bool",
                    "Dict[str, utils.types.A]"
                ]
            }
        },
        "MultiNetworkBase._set_model_trainable": {
            "name": "_set_model_trainable",
            "location": 281,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "str",
                    "Type[T]"
                ],
                "trainable": [
                    "Union['Contributor', 'Coverage']",
                    "Optional[float]"
                ]
            }
        },
        "MultiNetworkBase._compile_all_models": {
            "name": "_compile_all_models",
            "location": 288,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._freeze_models_except": {
            "name": "_freeze_models_except",
            "location": 305,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": []
            }
        },
        "MultiNetworkBase._freeze": {
            "name": "_freeze",
            "location": 322,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "trainable_models": [
                    "int",
                    "src.autoks.callbacks.CallbackList"
                ]
            }
        },
        "MultiNetworkBase._unfreeze": {
            "name": "_unfreeze",
            "location": 332,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._model_context": {
            "name": "_model_context",
            "location": 337,
            "return": [
                ""
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._training_context": {
            "name": "_training_context",
            "location": 363,
            "return": [
                "contextlib._GeneratorContextManager"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase._prediction_context": {
            "name": "_prediction_context",
            "location": 381,
            "return": [
                "contextlib._GeneratorContextManager"
            ],
            "arguments": {
                "self": [],
                "persist_model": [
                    "str",
                    "Callable[[str], str]",
                    "Mapping[str, int]"
                ]
            }
        },
        "MultiNetworkBase._add_history_record": {
            "name": "_add_history_record",
            "location": 392,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase.fit": {
            "name": "fit",
            "location": 402,
            "return": [
                "timeserio.keras.callbacks.HistoryLogger"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "float"
                ],
                "y": [
                    "int",
                    "float"
                ],
                "model": [
                    "raiden.utils.Dict[str, raiden.utils.Any]",
                    "Dict[str, Any]"
                ],
                "reset_weights": [
                    "Dict[str, Any]"
                ],
                "reset_optimizers": [
                    "Dict[str, Any]"
                ],
                "reset_history": [
                    "Dict[str, Any]"
                ]
            }
        },
        "MultiNetworkBase.fit_generator": {
            "name": "fit_generator",
            "location": 441,
            "return": [
                "timeserio.keras.callbacks.HistoryLogger"
            ],
            "arguments": {
                "self": [],
                "generator": [
                    "int",
                    "float",
                    "str"
                ],
                "model": [
                    "Dict[str, Any]",
                    "Mapping[str, Any]",
                    "Union[object, type]",
                    "purplship.providers.ups.utils.Settings",
                    "Optional['models.LTI1p3Provider']"
                ],
                "reset_weights": [
                    "dict",
                    "bool"
                ],
                "reset_optimizers": [
                    "dict",
                    "bool"
                ],
                "reset_history": [
                    "dict",
                    "bool"
                ]
            }
        },
        "MultiNetworkBase.predict": {
            "name": "predict",
            "location": 495,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [],
                "model": [
                    "str"
                ]
            }
        },
        "MultiNetworkBase.predict_generator": {
            "name": "predict_generator",
            "location": 517,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "generator": [
                    "keras.engine.Layer",
                    "List[List[Any]]",
                    "str"
                ],
                "model": [
                    "str"
                ]
            }
        },
        "MultiNetworkBase.evaluate": {
            "name": "evaluate",
            "location": 542,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "x": [
                    "int",
                    "bool",
                    "Collection[int]"
                ],
                "y": [
                    "int",
                    "bool",
                    "Collection[int]"
                ],
                "model": [
                    "int"
                ]
            }
        },
        "MultiNetworkBase.score": {
            "name": "score",
            "location": 568,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase.evaluate_generator": {
            "name": "evaluate_generator",
            "location": 577,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "generator": [
                    "keras.engine.Layer",
                    "List[List[Any]]",
                    "str"
                ],
                "model": [
                    "str",
                    "int"
                ]
            }
        },
        "MultiNetworkBase.__getstate__": {
            "name": "__getstate__",
            "location": 604,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiNetworkBase.__setstate__": {
            "name": "__setstate__",
            "location": 613,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "state": [
                    "dict"
                ]
            }
        }
    },
    "timeserio-master/timeserio/keras/timing.py": {
        "_n": {
            "name": "_n",
            "location": 12,
            "return": [
                "str",
                "List[str]",
                "List[int]",
                "Optional[str]"
            ],
            "arguments": {
                "num_or_tuple": [
                    "str",
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "total_latency": {
            "name": "total_latency",
            "location": 21,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "relative_latencies": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "absolute_latencies": {
            "name": "absolute_latencies",
            "location": 39,
            "return": [
                "List[Tuple[(Any, Any)]]"
            ],
            "arguments": {
                "relative_latencies": [
                    "int",
                    "numpy.ndarray"
                ]
            }
        },
        "layer_latency": {
            "name": "layer_latency",
            "location": 63,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "layer": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "model_latency": {
            "name": "model_latency",
            "location": 100,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "model": [
                    "keras.engine.Layer"
                ]
            }
        },
        "model_output_length": {
            "name": "model_output_length",
            "location": 120,
            "return": [
                "int"
            ],
            "arguments": {
                "model": [
                    "int"
                ],
                "input_shape": [
                    "int",
                    "list",
                    "str",
                    "List[List[Any]]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/keras/utils.py": {
        "iterlayers": {
            "name": "iterlayers",
            "location": 11,
            "return": [
                "Iterable"
            ],
            "arguments": {
                "model": [
                    "int",
                    "float",
                    "keras.engine.Layer"
                ]
            }
        },
        "has_arg": {
            "name": "has_arg",
            "location": 25,
            "return": [
                "bool"
            ],
            "arguments": {
                "fn": [
                    "int",
                    "bool"
                ],
                "name": [
                    "List[Type]",
                    "list[typing.Type]",
                    "Optional[Callable[..., None]]",
                    "float",
                    "typing.Callable[..., None]",
                    "tuple",
                    "None",
                    "tuple[]"
                ],
                "accept_all": [
                    "bool",
                    "Optional[str]",
                    "Optional[List[str]]",
                    "str",
                    "Type"
                ]
            }
        },
        "seed_random": {
            "name": "seed_random",
            "location": 45,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "seed": [
                    "int",
                    "list",
                    "bool",
                    "str"
                ]
            }
        }
    },
    "timeserio-master/timeserio/keras/__init__.py": {},
    "timeserio-master/timeserio/model_selection/time_series_split.py": {
        "PandasTimeSeriesSplit.__init__": {
            "name": "__init__",
            "location": 31,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "groupby": [
                    "Union[(str, List[str])]"
                ],
                "datetime_col": [
                    "str"
                ],
                "n_splits": [
                    "int"
                ],
                "max_train_size": [
                    "int"
                ]
            }
        },
        "PandasTimeSeriesSplit.split": {
            "name": "split",
            "location": 43,
            "return": [
                "Generator[(Tuple[(Any, Any)], Any, None)]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "dict"
                ],
                "y": [
                    "bool",
                    "Optional[int]",
                    "List[str]",
                    "Optional[str]",
                    "str",
                    "int",
                    "Optional[List[Any]]",
                    "Dict[str, Any]"
                ],
                "groups": [
                    "str",
                    "Type[T]",
                    "bool"
                ]
            }
        },
        "PandasTimeSeriesSplit._validate_df": {
            "name": "_validate_df",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "int"
                ]
            }
        }
    },
    "timeserio-master/timeserio/model_selection/__init__.py": {},
    "timeserio-master/timeserio/multimodel/base.py": {
        "make_pipeline_generator": {
            "name": "make_pipeline_generator",
            "location": 10,
            "return": [
                "timeserio.multimodel.pipegen._PipelineGenerator"
            ],
            "arguments": {}
        },
        "MultiModel.__init__": {
            "name": "__init__",
            "location": 19,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiModel.model_names": {
            "name": "model_names",
            "location": 28,
            "return": [
                "str",
                "List[str]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiModel.trainable_models": {
            "name": "trainable_models",
            "location": 36,
            "return": [
                ""
            ],
            "arguments": {
                "self": [],
                "value": [
                    "str",
                    "bool",
                    "float",
                    "Union[int, float]"
                ]
            }
        },
        "MultiModel.history": {
            "name": "history",
            "location": 40,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiModel.get_model_pipes": {
            "name": "get_model_pipes",
            "location": 43,
            "return": [
                "Tuple[(list, list)]"
            ],
            "arguments": {
                "self": [],
                "model_name": [
                    "str"
                ]
            }
        },
        "MultiModel.get_transformed": {
            "name": "get_transformed",
            "location": 64,
            "return": [
                "list"
            ],
            "arguments": {
                "pipes": [
                    "str",
                    "Optional[int]",
                    "float"
                ],
                "df": [
                    "str",
                    "float",
                    "Optional[int]",
                    "int",
                    "None"
                ]
            }
        },
        "MultiModel.get_fit_transformed": {
            "name": "get_fit_transformed",
            "location": 68,
            "return": [
                "list"
            ],
            "arguments": {
                "pipes": [
                    "tuple[int]",
                    "int",
                    "Tuple[int]",
                    "float"
                ],
                "df": [
                    "int",
                    "float",
                    "Tuple[int]",
                    "tuple[int]"
                ]
            }
        },
        "MultiModel.fit": {
            "name": "fit",
            "location": 71,
            "return": [
                "timeserio.keras.callbacks.HistoryLogger"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "bool",
                    "str",
                    "list[str]",
                    "Optional[List[str]]",
                    "None",
                    "Optional[str]",
                    "Optional[int]"
                ],
                "model": [
                    "str",
                    "None"
                ]
            }
        },
        "MultiModel.predict": {
            "name": "predict",
            "location": 84,
            "return": [
                "bool"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "int",
                    "str",
                    "list",
                    "list[]"
                ],
                "model": [
                    "list",
                    "None",
                    "dict",
                    "list[]",
                    "dict[, ]"
                ]
            }
        },
        "MultiModel.predict_generator": {
            "name": "predict_generator",
            "location": 90,
            "return": [
                "str"
            ],
            "arguments": {
                "self": [],
                "df_generator": [
                    "List[int]",
                    "str",
                    "list[int]",
                    "int"
                ],
                "model": [
                    "str",
                    "None"
                ]
            }
        },
        "MultiModel.fit_generator": {
            "name": "fit_generator",
            "location": 100,
            "return": [
                "timeserio.keras.callbacks.HistoryLogger"
            ],
            "arguments": {
                "self": [],
                "df_generator": [
                    "List[int]",
                    "str",
                    "list[int]",
                    "int"
                ],
                "model": [
                    "int",
                    "None",
                    "float",
                    "Dict[int, dict]",
                    "dict[int, dict[, ]]",
                    "bool",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "MultiModel.evaluate": {
            "name": "evaluate",
            "location": 128,
            "return": [
                "int",
                "str",
                "Callable",
                "typing.Callable[[], float]",
                "list[]",
                "dict[str, set[str]]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str"
                ],
                "model": [
                    "str",
                    "None"
                ]
            }
        },
        "MultiModel.evaluate_generator": {
            "name": "evaluate_generator",
            "location": 136,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df_generator": [
                    "List[int]",
                    "str",
                    "list[int]",
                    "int"
                ],
                "model": [
                    "bool",
                    "None"
                ]
            }
        },
        "MultiModel.freeze_models_except": {
            "name": "freeze_models_except",
            "location": 149,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model": [
                    "float",
                    "str",
                    "None",
                    "bytes"
                ]
            }
        },
        "MultiModel.freeze": {
            "name": "freeze",
            "location": 156,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiModel.unfreeze": {
            "name": "unfreeze",
            "location": 160,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "timeserio-master/timeserio/multimodel/pipegen.py": {
        "_PipelineGenerator.__init__": {
            "name": "__init__",
            "location": 5,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "_PipelineGenerator.__len__": {
            "name": "__len__",
            "location": 10,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "_PipelineGenerator.__getitem__": {
            "name": "__getitem__",
            "location": 13,
            "return": [
                "Tuple[(list, list)]"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "list[dict[str, typing.Any]]",
                    "List[Dict[str, Any]]",
                    "list[str]",
                    "Iterable[str]",
                    "List[str]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/multimodel/__init__.py": {},
    "timeserio-master/timeserio/pipeline/multipipeline.py": {
        "MultiPipeline.__init__": {
            "name": "__init__",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "pipelines": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MultiPipeline._get_param_names": {
            "name": "_get_param_names",
            "location": 17,
            "return": [
                "list[]",
                "str",
                "Optional[str]",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiPipeline.__setattr__": {
            "name": "__setattr__",
            "location": 21,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "dict",
                    "dict[, ]",
                    "list",
                    "list[]"
                ],
                "value": [
                    "dict[, ]",
                    "dict",
                    "list[]",
                    "Iterable[T]",
                    "typing.OrderedDict",
                    "list",
                    "OrderedDict"
                ]
            }
        },
        "MultiPipeline.__getattr__": {
            "name": "__getattr__",
            "location": 27,
            "return": [
                "list",
                "List[T]",
                "List[float]",
                "int"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "dict[, ]",
                    "dict",
                    "Iterable[T]"
                ]
            }
        },
        "MultiPipeline.__getitem__": {
            "name": "__getitem__",
            "location": 34,
            "return": [
                "list",
                "List[T]",
                "List[float]",
                "int"
            ],
            "arguments": {
                "self": [],
                "item": [
                    "list",
                    "str",
                    "list[]"
                ]
            }
        },
        "MultiPipeline.required_columns": {
            "name": "required_columns",
            "location": 42,
            "return": [
                "set[]",
                "List[int]",
                "int",
                "List[dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MultiPipeline.transformed_columns": {
            "name": "transformed_columns",
            "location": 48,
            "return": [
                "set[]",
                "List[int]",
                "int",
                "List[dict]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "Sequence[Dict]",
                    "typing.Sequence[dict[, ]]",
                    "str",
                    "List[str]",
                    "list[str]",
                    "dict",
                    "dict[, ]",
                    "Dict[str, List[Any]]",
                    "dict[str, list[typing.Any]]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/pipeline/pipeline.py": {
        "_parse_df_y": {
            "name": "_parse_df_y",
            "location": 11,
            "return": [
                "Tuple[(_T0, Any)]"
            ],
            "arguments": {
                "df": [
                    "_T0"
                ],
                "y": [
                    "int",
                    "list",
                    "str",
                    "numpy.ndarray"
                ]
            }
        },
        "FeatureUnion.__init__": {
            "name": "__init__",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "transformer_list": [
                    "int",
                    "Union[int, float]",
                    "float"
                ],
                "n_jobs": [
                    "int",
                    "Union[int, float]"
                ],
                "transformer_weights": [
                    "int",
                    "None",
                    "Union[int, float]",
                    "float"
                ]
            }
        },
        "FeatureUnion.required_columns": {
            "name": "required_columns",
            "location": 34,
            "return": [
                "set[]",
                "List[int]",
                "int",
                "List[dict]"
            ],
            "arguments": {
                "self": []
            }
        },
        "FeatureUnion.transformed_columns": {
            "name": "transformed_columns",
            "location": 40,
            "return": [
                "Optional[set]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "int",
                    "float",
                    "Optional[List[str]]",
                    "list[str]",
                    "None"
                ]
            }
        },
        "Pipeline.__init__": {
            "name": "__init__",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "steps": [
                    "bool",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "Callable[[Any, Any], bool]",
                    "typing.Callable[Any,Any, bool]"
                ],
                "memory": [
                    "bool",
                    "None",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]",
                    "dict[str, typing.Any]",
                    "typing.Callable[Any,Any, bool]"
                ]
            }
        },
        "Pipeline.required_columns": {
            "name": "required_columns",
            "location": 58,
            "return": [
                "set[None]",
                "Optional[int]",
                "Optional[float]",
                "Optional[bool]"
            ],
            "arguments": {
                "self": []
            }
        },
        "Pipeline.transformed_columns": {
            "name": "transformed_columns",
            "location": 81,
            "return": [
                "List[int]",
                "int",
                "set[None]",
                "List[dict]",
                "list[str]",
                "None",
                "float"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "int",
                    "float",
                    "Optional[List[str]]",
                    "list[str]",
                    "None"
                ]
            }
        },
        "GroupedPipeline.__init__": {
            "name": "__init__",
            "location": 120,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "groupby": [
                    "bool",
                    "float",
                    "Union[float, Tuple[float, float]]",
                    "tuple[typing.Union[float,float]]",
                    "Optional[Callable[[Any], None]]",
                    "typing.Callable[typing.Any, None]",
                    "None"
                ],
                "pipeline": [
                    "bool",
                    "float",
                    "Union[float, Tuple[float, float]]",
                    "tuple[typing.Union[float,float]]",
                    "Optional[Callable[[Any], None]]",
                    "typing.Callable[typing.Any, None]",
                    "None"
                ],
                "errors": [
                    "typing.Text",
                    "bool",
                    "float",
                    "Union[float, Tuple[float, float]]",
                    "Optional[Callable[[Any], None]]"
                ]
            }
        },
        "GroupedPipeline._iter_groups": {
            "name": "_iter_groups",
            "location": 125,
            "return": [
                "Generator[(Tuple[(Any, Any, Any)], Any, None)]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "int",
                    "str"
                ],
                "y": [
                    "bool",
                    "None",
                    "List[numpy.ndarray]",
                    "list[numpy.ndarray]"
                ]
            }
        },
        "GroupedPipeline.fit": {
            "name": "fit",
            "location": 137,
            "return": [
                "GroupedPipeline"
            ],
            "arguments": {
                "self": [
                    "_TGroupedPipeline"
                ],
                "df": [
                    "Set[str]",
                    "set[str]",
                    "Dict[str, Callable[[], None]]",
                    "dict[str, typing.Callable[[], None]]"
                ],
                "y": [
                    "Set[str]",
                    "None",
                    "Dict[str, Callable[[], None]]",
                    "set[str]",
                    "dict[str, typing.Callable[[], None]]"
                ]
            }
        },
        "GroupedPipeline._fit_subdf": {
            "name": "_fit_subdf",
            "location": 146,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "sub_df": [
                    "list[int]",
                    "List[int]",
                    "str",
                    "list[]",
                    "float",
                    "pandas.DataFrame",
                    "list"
                ],
                "y": [
                    "List[int]",
                    "None",
                    "pandas.DataFrame",
                    "str",
                    "list[int]",
                    "float",
                    "list",
                    "list[]"
                ]
            }
        },
        "GroupedPipeline.transform": {
            "name": "transform",
            "location": 149,
            "return": [
                "list",
                "Iterable[str]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "GroupedPipeline.predict": {
            "name": "predict",
            "location": 152,
            "return": [
                "list",
                "Iterable[str]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ]
            }
        },
        "GroupedPipeline.fit_predict": {
            "name": "fit_predict",
            "location": 155,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "BaseException"
                ],
                "y": [
                    "BaseException",
                    "None"
                ]
            }
        },
        "GroupedPipeline._call_pipeline": {
            "name": "_call_pipeline",
            "location": 158,
            "return": [
                "str",
                "int",
                "Type",
                "boto3.resources.base.ServiceResource",
                "float",
                "Optional[Callable]",
                "list[]"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "dict[, ]",
                    "dict",
                    "dict[str, str]",
                    "pandas.DataFrame",
                    "Dict[str, str]"
                ],
                "y": [
                    "dict",
                    "None",
                    "pandas.DataFrame",
                    "dict[, ]"
                ],
                "attr": [
                    "dict",
                    "None",
                    "pandas.DataFrame",
                    "dict[, ]"
                ]
            }
        },
        "GroupedPipeline._call_pipeline_subdf": {
            "name": "_call_pipeline_subdf",
            "location": 173,
            "return": [
                "str",
                "None",
                "bytes",
                "int",
                "List[Dict[str, Any]]",
                "Mapping"
            ],
            "arguments": {
                "self": [],
                "key": [
                    "str",
                    "bool",
                    "Optional[str]",
                    "None"
                ],
                "sub_df": [
                    "str",
                    "Optional[str]",
                    "None"
                ],
                "attr": [
                    "str",
                    "None"
                ]
            }
        },
        "GroupedPipeline.required_columns": {
            "name": "required_columns",
            "location": 192,
            "return": [
                "bool",
                "int",
                "Dict[str, Any]",
                "geostream.base.Feature",
                "pandas.DataFrame"
            ],
            "arguments": {
                "self": []
            }
        },
        "GroupedPipeline.transformed_columns": {
            "name": "transformed_columns",
            "location": 196,
            "return": [
                "int",
                "float",
                "str",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "int",
                    "float",
                    "Optional[List[str]]",
                    "list[str]",
                    "None"
                ]
            }
        }
    },
    "timeserio-master/timeserio/pipeline/__init__.py": {},
    "timeserio-master/timeserio/preprocessing/aggregate.py": {
        "_flatten_columns": {
            "name": "_flatten_columns",
            "location": 71,
            "return": [
                "str",
                "bool",
                "\"CollectionList\"",
                "float",
                "pandas.Series",
                "dict[str, str]",
                "Dict[str, Any]",
                "typing.Callable[, ]",
                "list[typing.Text]"
            ],
            "arguments": {
                "columns": [
                    "bool",
                    "pandas.Index",
                    "str",
                    "float",
                    "pandas.DataFrame",
                    "dict[str, str]",
                    "typing.Callable[, ]",
                    "int",
                    "Dict[str, str]",
                    "Callable"
                ]
            }
        },
        "_cartesian_product": {
            "name": "_cartesian_product",
            "location": 87,
            "return": [
                "int",
                "float",
                "trezor.utils.Writer"
            ],
            "arguments": {
                "df_1": [
                    "dict[, ]",
                    "pandas.DataFrame",
                    "bool",
                    "dict"
                ],
                "df_2": [
                    "dict[, ]",
                    "pandas.DataFrame",
                    "bool",
                    "dict"
                ]
            }
        },
        "AggregateFeaturizer.__init__": {
            "name": "__init__",
            "location": 28,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "AggregateFeaturizer.fit": {
            "name": "fit",
            "location": 35,
            "return": [
                "AggregateFeaturizer"
            ],
            "arguments": {
                "self": [
                    "_TAggregateFeaturizer"
                ],
                "df": [
                    "int",
                    "Callable",
                    "str"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable[C]",
                    "dict",
                    "bool"
                ]
            }
        },
        "AggregateFeaturizer._agg": {
            "name": "_agg",
            "location": 43,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "list[]",
                    "int",
                    "list",
                    "pandas.DataFrame"
                ]
            }
        },
        "AggregateFeaturizer.transform": {
            "name": "transform",
            "location": 59,
            "return": [
                "bool",
                "hackathon.utils.utils.DataMessage",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "DefaultDict[int, List[Any]]",
                    "typing.DefaultDict",
                    "OrderedDict",
                    "str",
                    "typing.OrderedDict",
                    "Dict[Tuple[cmk.utils.type_defs.UserId, DashboardName], DashboardConfig]",
                    "dict[tuple[typing.Union[cmk.utils.type_defs.UserId,DashboardName]], C]"
                ]
            }
        },
        "AggregateFeaturizer.required_columns": {
            "name": "required_columns",
            "location": 64,
            "return": [
                "set[]",
                "int",
                "List[int]",
                "List[dict]"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "timeserio-master/timeserio/preprocessing/base.py": {},
    "timeserio-master/timeserio/preprocessing/batches.py": {},
    "timeserio-master/timeserio/preprocessing/datetime.py": {
        "get_fractional_hour_from_series": {
            "name": "get_fractional_hour_from_series",
            "location": 24,
            "return": [
                "bool",
                "str"
            ],
            "arguments": {
                "series": [
                    "dict[str, typing.Any]",
                    "pandas.Series",
                    "Dict[str, Any]"
                ]
            }
        },
        "get_fractional_day_from_series": {
            "name": "get_fractional_day_from_series",
            "location": 35,
            "return": [
                "int",
                "bool",
                "str"
            ],
            "arguments": {
                "series": [
                    "pandas.Series",
                    "dict[, ]",
                    "dict",
                    "list[str]",
                    "List[str]",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "get_fractional_year_from_series": {
            "name": "get_fractional_year_from_series",
            "location": 45,
            "return": [
                "float",
                "str"
            ],
            "arguments": {
                "series": [
                    "dict[str, typing.Any]",
                    "pandas.Series",
                    "Dict[str, Any]"
                ]
            }
        },
        "get_is_holiday_from_series": {
            "name": "get_is_holiday_from_series",
            "location": 54,
            "return": [
                "dict",
                "recidiviz.calculator.pipeline.utils.incarceration_period_index.IncarcerationPeriodIndex",
                "str"
            ],
            "arguments": {
                "series": [
                    "str",
                    "pandas.Series",
                    "dict[, ]",
                    "int",
                    "dict",
                    "recidiviz.calculator.pipeline.utils.incarceration_period_index.IncarcerationPeriodIndex"
                ],
                "country": [
                    "str"
                ]
            }
        },
        "get_zero_indexed_month_from_series": {
            "name": "get_zero_indexed_month_from_series",
            "location": 68,
            "return": [
                "int",
                "raiden.utils.ChannelID",
                "float",
                "str",
                "Optional[str]",
                "bool"
            ],
            "arguments": {
                "series": [
                    "str",
                    "bool",
                    "pandas.Series"
                ]
            }
        },
        "get_is_weekday_from_series": {
            "name": "get_is_weekday_from_series",
            "location": 73,
            "return": [
                "pandas.Series",
                "str",
                "bool",
                "pandas._AnyArrayLike"
            ],
            "arguments": {
                "series": [
                    "str",
                    "bool",
                    "pandas.Series",
                    "pandas._AnyArrayLike"
                ]
            }
        },
        "get_time_is_in_interval_from_series": {
            "name": "get_time_is_in_interval_from_series",
            "location": 79,
            "return": [
                "int",
                "str",
                "Tuple[int, int, int]",
                "Dict[str, Any]"
            ],
            "arguments": {
                "series": [
                    "float",
                    "pandas.Series",
                    "bool",
                    "str"
                ]
            }
        },
        "get_is_peak_hour_from_series": {
            "name": "get_is_peak_hour_from_series",
            "location": 107,
            "return": [
                "Optional[Dict[str, Any]]",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "series": [
                    "int",
                    "pandas.Series",
                    "bool"
                ]
            }
        },
        "get_is_daytime_from_series": {
            "name": "get_is_daytime_from_series",
            "location": 115,
            "return": [
                "bool",
                "Optional['User']"
            ],
            "arguments": {
                "series": [
                    "str",
                    "pandas.Series",
                    "dict[, ]",
                    "dict",
                    "recidiviz.calculator.pipeline.utils.incarceration_period_index.IncarcerationPeriodIndex"
                ]
            }
        },
        "get_is_morning_peak_from_series": {
            "name": "get_is_morning_peak_from_series",
            "location": 123,
            "return": [
                "Optional[Dict[str, Any]]",
                "Dict[str, Any]",
                "bool"
            ],
            "arguments": {
                "series": [
                    "int",
                    "pandas.Series",
                    "bool"
                ]
            }
        },
        "truncate_series": {
            "name": "truncate_series",
            "location": 131,
            "return": [
                "Callable",
                "List[str]",
                "dict",
                "str",
                "List[int]"
            ],
            "arguments": {
                "series": [
                    "str",
                    "pandas.Series",
                    "int",
                    "float",
                    "tuple[typing.Union[float,float]]",
                    "Tuple[float, float]"
                ],
                "truncation_period": [
                    "str"
                ]
            }
        },
        "PandasDateTimeFeaturizer.__init__": {
            "name": "__init__",
            "location": 168,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "column": [
                    "int",
                    "str",
                    "Union[str, float]",
                    "float",
                    "List[str]"
                ],
                "attributes": [
                    "list[typing.Text]",
                    "int",
                    "str",
                    "Union[str, float]",
                    "float",
                    "List[str]"
                ],
                "kwargs": [
                    "None"
                ]
            }
        },
        "PandasDateTimeFeaturizer.attributes_": {
            "name": "attributes_",
            "location": 179,
            "return": [
                "Type[T]",
                "float",
                "Optional[dict]",
                "str",
                "type"
            ],
            "arguments": {
                "self": []
            }
        },
        "PandasDateTimeFeaturizer.fit": {
            "name": "fit",
            "location": 183,
            "return": [
                "PandasDateTimeFeaturizer"
            ],
            "arguments": {
                "self": [
                    "_TPandasDateTimeFeaturizer"
                ],
                "df": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable[C]",
                    "dict",
                    "bool"
                ]
            }
        },
        "PandasDateTimeFeaturizer.transform": {
            "name": "transform",
            "location": 186,
            "return": [
                "float",
                "int",
                "typing.Callable[, ]",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "pandas.DataFrame",
                    "bool",
                    "int",
                    "float",
                    "Mapping[str, Any]"
                ]
            }
        },
        "PandasDateTimeFeaturizer.required_columns": {
            "name": "required_columns",
            "location": 212,
            "return": [
                "set[]",
                "List[str]",
                "Set[str]",
                "str",
                "bool",
                "Dict[str, Set[str]]",
                "Type[Union[Any, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PandasDateTimeFeaturizer.transformed_columns": {
            "name": "transformed_columns",
            "location": 215,
            "return": [
                "set"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "_T0"
                ]
            }
        },
        "_BaseLagFeaturizer.__init__": {
            "name": "__init__",
            "location": 229,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "datetime_column": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ],
                "columns": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ],
                "lags": [
                    "int",
                    "str",
                    "float",
                    "bool"
                ],
                "refit": [
                    "bool",
                    "int",
                    "str",
                    "float"
                ],
                "duplicate_agg": [
                    "typing.Text",
                    "int",
                    "str",
                    "float",
                    "bool"
                ]
            }
        },
        "_BaseLagFeaturizer.fit": {
            "name": "fit",
            "location": 243,
            "return": [
                "BaseLagFeaturizer"
            ],
            "arguments": {
                "self": [
                    "_T_BaseLagFeaturizer"
                ],
                "df": [
                    "str",
                    "int",
                    "typing.Callable[, ]",
                    "float",
                    "Callable",
                    "bool"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable[C]",
                    "dict",
                    "bool"
                ]
            }
        },
        "_BaseLagFeaturizer._lag_df": {
            "name": "_lag_df",
            "location": 259,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "lag": [
                    "int",
                    "str",
                    "typing.Iterable[C]",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "_BaseLagFeaturizer.transform": {
            "name": "transform",
            "location": 263,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "Optional[int]",
                    "int",
                    "None"
                ]
            }
        },
        "_BaseLagFeaturizer.required_columns": {
            "name": "required_columns",
            "location": 277,
            "return": [
                "set[]",
                "List[str]",
                "Set[str]",
                "str",
                "bool",
                "Dict[str, Set[str]]",
                "Type[Union[Any, Any]]"
            ],
            "arguments": {
                "self": []
            }
        },
        "_BaseLagFeaturizer.transformed_columns": {
            "name": "transformed_columns",
            "location": 281,
            "return": [
                "set"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "_T0"
                ]
            }
        },
        "LagFeaturizer._lag_df": {
            "name": "_lag_df",
            "location": 316,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "lag": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "RollingMeanFeaturizer.__init__": {
            "name": "__init__",
            "location": 355,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "datetime_column": [
                    "str"
                ],
                "columns": [
                    "Union[(str, List[str])]"
                ],
                "windows": [
                    "list"
                ],
                "min_periods": [
                    "int"
                ],
                "center": [
                    "bool"
                ],
                "win_type": [
                    "str"
                ],
                "closed": [
                    "str"
                ],
                "refit": [
                    "bool"
                ],
                "duplicate_agg": [
                    "str"
                ]
            }
        },
        "RollingMeanFeaturizer.windows": {
            "name": "windows",
            "location": 384,
            "return": [
                "",
                "str",
                "dict[str, typing.Any]",
                "dict[, ]",
                "int"
            ],
            "arguments": {
                "self": [],
                "windows": [
                    "int",
                    "Optional[float]",
                    "bool",
                    "Optional[Dict]",
                    "Type[T]",
                    "str",
                    "Tuple[List, List, List]"
                ]
            }
        },
        "RollingMeanFeaturizer._lag_df": {
            "name": "_lag_df",
            "location": 387,
            "return": [
                "List[str]",
                "int",
                "str"
            ],
            "arguments": {
                "self": [],
                "lag": [
                    "str",
                    "rl_algorithms.utils.config.ConfigDict",
                    "dict[, ]",
                    "bytes",
                    "pandas.DataFrame",
                    "dict"
                ]
            }
        }
    },
    "timeserio-master/timeserio/preprocessing/encoding.py": {
        "FeatureIndexEncoder.n_classes_": {
            "name": "n_classes_",
            "location": 20,
            "return": [
                "int",
                "str"
            ],
            "arguments": {
                "self": []
            }
        },
        "FeatureIndexEncoder.fit": {
            "name": "fit",
            "location": 24,
            "return": [
                "FeatureIndexEncoder"
            ],
            "arguments": {
                "self": [
                    "_TFeatureIndexEncoder"
                ],
                "X": [
                    "int",
                    "float",
                    "numpy.ndarray",
                    "str",
                    "T"
                ],
                "y": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ]
            }
        },
        "FeatureIndexEncoder.transform": {
            "name": "transform",
            "location": 29,
            "return": [
                "str",
                "List[str]",
                "dict"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "numpy.array"
                ],
                "y": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ]
            }
        },
        "StatelessOneHotEncoder.__init__": {
            "name": "__init__",
            "location": 42,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessOneHotEncoder.get_categories": {
            "name": "get_categories",
            "location": 64,
            "return": [
                "List[range]"
            ],
            "arguments": {
                "n_features": [
                    "int",
                    "str"
                ],
                "n_values": [
                    "int",
                    "str",
                    "list",
                    "list[]"
                ]
            }
        },
        "StatelessOneHotEncoder._init_stateless": {
            "name": "_init_stateless",
            "location": 77,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessOneHotEncoder.required_columns": {
            "name": "required_columns",
            "location": 82,
            "return": [
                "set[None]",
                "Optional[str]",
                "Optional[float]",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessOneHotEncoder.transformed_columns": {
            "name": "transformed_columns",
            "location": 85,
            "return": [
                "Set[None]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "list[str]",
                    "bool",
                    "List[str]",
                    "str",
                    "None",
                    "Iterable",
                    "Optional[List[str]]"
                ]
            }
        },
        "StatelessTemporalOneHotEncoder.__init__": {
            "name": "__init__",
            "location": 96,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessTemporalOneHotEncoder._reshape_temporal": {
            "name": "_reshape_temporal",
            "location": 116,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "y": [
                    "int",
                    "numpy.array",
                    "numpy.ndarray"
                ],
                "n_features": [
                    "int",
                    "Union[int, float]",
                    "float"
                ]
            }
        },
        "StatelessTemporalOneHotEncoder.transform": {
            "name": "transform",
            "location": 123,
            "return": [
                "str",
                "bool",
                "List[float]",
                "float",
                "Union[int, float]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "str",
                    "int",
                    "None",
                    "bool",
                    "dict[str, typing.Any]",
                    "Optional[str]",
                    "Optional[Dict[str, Any]]"
                ]
            }
        },
        "PeriodicEncoder.__init__": {
            "name": "__init__",
            "location": 159,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeriodicEncoder.fit": {
            "name": "fit",
            "location": 170,
            "return": [
                "PeriodicEncoder"
            ],
            "arguments": {
                "self": [
                    "_TPeriodicEncoder"
                ],
                "X": [
                    "float",
                    "int",
                    "bytes",
                    "numpy.ndarray"
                ],
                "y": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ]
            }
        },
        "PeriodicEncoder._check_value_per_feature": {
            "name": "_check_value_per_feature",
            "location": 174,
            "return": [
                "Union[(np.ndarray, _T0)]"
            ],
            "arguments": {
                "self": [],
                "value": [
                    "_T0"
                ],
                "n_features": [
                    "int",
                    "str",
                    "Optional[T]",
                    "None",
                    "Sequence[T]",
                    "typing.Sequence[T]",
                    "list",
                    "list[]",
                    "List[int]",
                    "list[int]"
                ]
            }
        },
        "PeriodicEncoder._transform": {
            "name": "_transform",
            "location": 185,
            "return": [
                "str",
                "Optional[int]",
                "Optional[List[int]]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "numpy.ndarray"
                ],
                "y": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ]
            }
        },
        "PeriodicEncoder.transform": {
            "name": "transform",
            "location": 194,
            "return": [
                "utils.Node",
                "str",
                "numpy.ndarray",
                "Optional[int]"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "float",
                    "int",
                    "numpy.ndarray",
                    "numpy.array"
                ],
                "y": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ]
            }
        },
        "PeriodicEncoder.required_columns": {
            "name": "required_columns",
            "location": 210,
            "return": [
                "set[None]",
                "Optional[str]",
                "Optional[float]",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PeriodicEncoder.transformed_columns": {
            "name": "transformed_columns",
            "location": 213,
            "return": [
                "Set[None]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "list[str]",
                    "bool",
                    "List[str]",
                    "str",
                    "None",
                    "Iterable",
                    "Optional[List[str]]"
                ]
            }
        },
        "StatelessPeriodicEncoder.__init__": {
            "name": "__init__",
            "location": 251,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessPeriodicEncoder._init_stateless": {
            "name": "_init_stateless",
            "location": 267,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessPeriodicEncoder.required_columns": {
            "name": "required_columns",
            "location": 272,
            "return": [
                "set[None]",
                "Optional[str]",
                "Optional[float]",
                "Optional[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "StatelessPeriodicEncoder.transformed_columns": {
            "name": "transformed_columns",
            "location": 275,
            "return": [
                "Set[None]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "list[str]",
                    "bool",
                    "List[str]",
                    "str",
                    "None",
                    "Iterable",
                    "Optional[List[str]]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/preprocessing/multipipeline.py": {},
    "timeserio-master/timeserio/preprocessing/pandas.py": {
        "array_to_dataframe": {
            "name": "array_to_dataframe",
            "location": 8,
            "return": [
                "str",
                "int",
                "bytes",
                "None",
                "IO",
                "List[str]",
                "cmk.utils.type_defs.HostAddress"
            ],
            "arguments": {
                "array": [
                    "np.ndarray"
                ],
                "column": [
                    "str"
                ],
                "df": [
                    "None",
                    "int",
                    "numpy.ndarray",
                    "str",
                    "Optional[str]",
                    "typing.Callable[, ]",
                    "Optional[int]",
                    "Optional[Callable]"
                ]
            }
        },
        "_join_multilevel_dataframes": {
            "name": "_join_multilevel_dataframes",
            "location": 34,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "df_list": [
                    "list[tuple[typing.Union[str,str]]]",
                    "List[Tuple[str, str]]",
                    "list[]",
                    "list[str]",
                    "Sequence[dict]",
                    "list",
                    "List[str]",
                    "Iterator[tuple]",
                    "bool"
                ]
            }
        },
        "_get_column_as_tensor": {
            "name": "_get_column_as_tensor",
            "location": 76,
            "return": [
                "str",
                "bool",
                "List[str]",
                "Optional[str]"
            ],
            "arguments": {
                "s": [
                    "str",
                    "int",
                    "Optional[str]",
                    "None",
                    "bytes",
                    "Dict[str, float]",
                    "dict[str, float]"
                ]
            }
        },
        "PandasColumnSelector.__init__": {
            "name": "__init__",
            "location": 54,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "columns": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Union[str, float]",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "PandasColumnSelector.fit": {
            "name": "fit",
            "location": 57,
            "return": [
                "PandasColumnSelector"
            ],
            "arguments": {
                "self": [
                    "_TPandasColumnSelector"
                ],
                "df": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "PandasColumnSelector.transform": {
            "name": "transform",
            "location": 60,
            "return": [
                "dict[str, str]",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "str",
                    "int",
                    "Callable"
                ]
            }
        },
        "PandasColumnSelector.required_columns": {
            "name": "required_columns",
            "location": 66,
            "return": [
                "set[]",
                "int",
                "Dict[str, Iterable[Any]]",
                "Dict[str, Union[str, Any]]",
                "cmk.utils.type_defs.CheckVariables",
                "Optional[Match]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PandasColumnSelector.transformed_columns": {
            "name": "transformed_columns",
            "location": 69,
            "return": [
                "set"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "Optional[str]",
                    "None",
                    "Optional[Sequence[str]]",
                    "typing.Sequence[str]",
                    "Pattern[str]",
                    "typing.Pattern",
                    "Set[str]",
                    "set[str]"
                ]
            }
        },
        "PandasValueSelector.__init__": {
            "name": "__init__",
            "location": 90,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "columns": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Union[str, float]",
                    "List[str]",
                    "list[str]"
                ],
                "dtype": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Union[str, float]",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "PandasValueSelector.fit": {
            "name": "fit",
            "location": 94,
            "return": [
                "PandasValueSelector"
            ],
            "arguments": {
                "self": [
                    "_TPandasValueSelector"
                ],
                "df": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "PandasValueSelector.transform": {
            "name": "transform",
            "location": 97,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "typing.Any",
                    "Any",
                    "bool",
                    "typing.Callable[, ]",
                    "callable",
                    "pandas.DataFrame"
                ]
            }
        },
        "PandasValueSelector.required_columns": {
            "name": "required_columns",
            "location": 110,
            "return": [
                "set[]",
                "int",
                "Dict[str, Iterable[Any]]",
                "Dict[str, Union[str, Any]]",
                "cmk.utils.type_defs.CheckVariables",
                "Optional[Match]"
            ],
            "arguments": {
                "self": []
            }
        },
        "PandasValueSelector.transformed_columns": {
            "name": "transformed_columns",
            "location": 113,
            "return": [
                "Set[None]"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "List[str]",
                    "str",
                    "list[str]",
                    "Optional[str]",
                    "None",
                    "Optional[Sequence[str]]",
                    "typing.Sequence[str]",
                    "Pattern[str]",
                    "typing.Pattern",
                    "Set[str]",
                    "set[str]"
                ]
            }
        },
        "PandasIndexValueSelector.__init__": {
            "name": "__init__",
            "location": 126,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "levels": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ],
                "dtype": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ]
            }
        },
        "PandasIndexValueSelector.fit": {
            "name": "fit",
            "location": 130,
            "return": [
                "PandasIndexValueSelector"
            ],
            "arguments": {
                "self": [
                    "_TPandasIndexValueSelector"
                ],
                "df": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "PandasIndexValueSelector.transform": {
            "name": "transform",
            "location": 133,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "list"
                ]
            }
        },
        "PandasSequenceSplitter.__init__": {
            "name": "__init__",
            "location": 154,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "columns": [
                    "int",
                    "None",
                    "str",
                    "float",
                    "Union[str, float]",
                    "List[str]",
                    "list[str]"
                ],
                "index": [
                    "int",
                    "str",
                    "Union[str, float]",
                    "float",
                    "List[str]"
                ]
            }
        },
        "PandasSequenceSplitter.fit": {
            "name": "fit",
            "location": 158,
            "return": [
                "PandasSequenceSplitter"
            ],
            "arguments": {
                "self": [
                    "_TPandasSequenceSplitter"
                ],
                "df": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ],
                "y": [
                    "int",
                    "None",
                    "str",
                    "Iterable['Context']",
                    "typing.Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "PandasSequenceSplitter.transform": {
            "name": "transform",
            "location": 161,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "df": [
                    "pandas.Series",
                    "int",
                    "metrics_backend.utils.Address",
                    "Dict[str, str]"
                ]
            }
        },
        "PandasSequenceSplitter.required_columns": {
            "name": "required_columns",
            "location": 171,
            "return": [
                "set[]",
                "int",
                "pandas.DataFrame",
                "List[str]",
                "Dict[int, int]",
                "str",
                "OrderedDict"
            ],
            "arguments": {
                "self": []
            }
        },
        "PandasSequenceSplitter.transformed_columns": {
            "name": "transformed_columns",
            "location": 175,
            "return": [
                "set"
            ],
            "arguments": {
                "self": [],
                "input_columns": [
                    "bytes",
                    "str",
                    "int",
                    "Optional[str]",
                    "None",
                    "List[str]",
                    "list[str]",
                    "List[torch.nn.utils.rnn.PackedSequence]",
                    "list[P]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/preprocessing/utils.py": {
        "_as_list_of_str": {
            "name": "_as_list_of_str",
            "location": 9,
            "return": [
                "Union[(List[_T0], _T0)]"
            ],
            "arguments": {
                "columns": [
                    "_T0"
                ]
            }
        },
        "transform_selected": {
            "name": "transform_selected",
            "location": 38,
            "return": [
                "int",
                "bool",
                "float"
            ],
            "arguments": {
                "X": [
                    "bool",
                    "T",
                    "dict[, ]",
                    "dict"
                ],
                "transform": [
                    "float",
                    "int",
                    "numpy.ndarray"
                ],
                "dtype": [
                    "bool",
                    "str",
                    "dict",
                    "dict[, ]"
                ],
                "selected": [
                    "str",
                    "int"
                ],
                "copy": [
                    "bool",
                    "int",
                    "str",
                    "Callable[[None], bool]"
                ],
                "retain_order": [
                    "bool",
                    "float",
                    "int",
                    "numpy.ndarray",
                    "bytes"
                ]
            }
        },
        "CallableMixin.__call__": {
            "name": "__call__",
            "location": 20,
            "return": [
                "Sequence['cirq.Qid']",
                "bool",
                "Iterable[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "IdentityRegressor.fit": {
            "name": "fit",
            "location": 27,
            "return": [
                "IdentityRegressor"
            ],
            "arguments": {
                "self": [
                    "_TIdentityRegressor"
                ],
                "X": [
                    "bool",
                    "float",
                    "str",
                    "typing.Iterable[typing.Iterable[float]]",
                    "bytes",
                    "numpy.ndarray",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ],
                "y": [
                    "bool",
                    "None",
                    "float",
                    "str",
                    "bytes",
                    "numpy.ndarray",
                    "typing.Iterable[typing.Iterable[float]]",
                    "Iterable[Iterable[float]]",
                    "list",
                    "T"
                ]
            }
        },
        "IdentityRegressor.predict": {
            "name": "predict",
            "location": 30,
            "return": [
                "_T0"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "_T0"
                ]
            }
        },
        "IdentityRegressor.fit_predict": {
            "name": "fit_predict",
            "location": 33,
            "return": [
                "_T0"
            ],
            "arguments": {
                "self": [],
                "X": [
                    "_T0"
                ],
                "y": [
                    "int",
                    "float",
                    "None"
                ]
            }
        }
    },
    "timeserio-master/timeserio/preprocessing/__init__.py": {},
    "timeserio-master/timeserio/utils/functools.py": {
        "get_default_args": {
            "name": "get_default_args",
            "location": 4,
            "return": [
                "Dict[(str, Any)]"
            ],
            "arguments": {
                "func": [
                    "bytes",
                    "str",
                    "Callable",
                    "typing.Callable[, ]",
                    "bool",
                    "Dict[str, Optional[str]]",
                    "dict[str, typing.Union[str,None]]"
                ]
            }
        }
    },
    "timeserio-master/timeserio/utils/pickle.py": {
        "dumpf": {
            "name": "dumpf",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "obj": [
                    "int",
                    "str",
                    "bool"
                ],
                "filename": [
                    "str",
                    "Optional[List[str]]",
                    "list[str]",
                    "Callable[[str], None]",
                    "None",
                    "typing.Callable[str, None]"
                ]
            }
        },
        "loadf": {
            "name": "loadf",
            "location": 13,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "filename": [
                    "str"
                ]
            }
        },
        "dumps": {
            "name": "dumps",
            "location": 20,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "obj": [
                    "dict",
                    "str",
                    "dict[, ]",
                    "T",
                    "int",
                    "Optional[int]",
                    "None"
                ]
            }
        },
        "loads": {
            "name": "loads",
            "location": 25,
            "return": [
                "str",
                "bytes"
            ],
            "arguments": {
                "s": [
                    "bytes",
                    "str"
                ]
            }
        }
    },
    "timeserio-master/timeserio/utils/__init__.py": {},
    "timeserio-master/timeserio/validation/validation.py": {
        "is_valid_transformer": {
            "name": "is_valid_transformer",
            "location": 11,
            "return": [
                "bool"
            ],
            "arguments": {
                "transformer": [
                    "str",
                    "float"
                ]
            }
        },
        "is_valid_pipeline": {
            "name": "is_valid_pipeline",
            "location": 21,
            "return": [
                "bool"
            ],
            "arguments": {
                "pipeline": [
                    "Dict[str, Any]",
                    "dict[str, typing.Any]",
                    "float",
                    "Optional[Union[str, Any, Any, Any]]",
                    "str",
                    "int",
                    "typing.Any",
                    "None",
                    "Dict[str, Set[str]]",
                    "Mapping[str, Any]",
                    "Iterable[Type]",
                    "dict[str, set[str]]",
                    "dict",
                    "typing.Mapping",
                    "dict[, ]"
                ]
            }
        },
        "is_valid_multipipeline": {
            "name": "is_valid_multipipeline",
            "location": 33,
            "return": [
                "bool",
                "str",
                "dict",
                "Dict[str, Any]",
                "raiden.utils.Dict[str, raiden.utils.Any]"
            ],
            "arguments": {
                "multipipeline": [
                    "Dict[Hashable, Any]",
                    "dict[typing.Hashable, typing.Any]",
                    "Dict[str, Set[str]]",
                    "int",
                    "dict[str, set[str]]",
                    "Dict[str, float]",
                    "dict[str, float]",
                    "dict",
                    "dict[, ]"
                ]
            }
        },
        "is_valid_multimodel": {
            "name": "is_valid_multimodel",
            "location": 44,
            "return": [
                "str",
                "bool",
                "int"
            ],
            "arguments": {
                "multimodel": [
                    "str"
                ]
            }
        },
        "is_valid_pickle": {
            "name": "is_valid_pickle",
            "location": 50,
            "return": [
                "bool"
            ],
            "arguments": {
                "path": [
                    "str"
                ]
            }
        }
    },
    "timeserio-master/timeserio/validation/__init__.py": {}
}
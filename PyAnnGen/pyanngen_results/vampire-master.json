{
    "vampire-master/environments/datasets.py": {},
    "vampire-master/environments/environments.py": {},
    "vampire-master/environments/random_search.py": {
        "RandomSearch.random_choice": {
            "name": "random_choice",
            "location": 10,
            "return": [
                "Callable[([], Any)]"
            ],
            "arguments": {}
        },
        "RandomSearch.random_integer": {
            "name": "random_integer",
            "location": 17,
            "return": [
                "Callable[([], Any)]"
            ],
            "arguments": {
                "low": [
                    "int",
                    "float",
                    "bool"
                ],
                "high": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "RandomSearch.random_loguniform": {
            "name": "random_loguniform",
            "location": 21,
            "return": [
                "Callable[([], Any)]"
            ],
            "arguments": {
                "low": [
                    "Optional[int]",
                    "int",
                    "List[int]",
                    "None",
                    "list[int]"
                ],
                "high": [
                    "Optional[int]",
                    "int",
                    "List[int]",
                    "None",
                    "list[int]"
                ]
            }
        },
        "RandomSearch.random_subset": {
            "name": "random_subset",
            "location": 25,
            "return": [
                "Callable[([], Any)]"
            ],
            "arguments": {}
        },
        "RandomSearch.random_pair": {
            "name": "random_pair",
            "location": 33,
            "return": [
                "Callable[([], Any)]"
            ],
            "arguments": {}
        },
        "RandomSearch.random_uniform": {
            "name": "random_uniform",
            "location": 41,
            "return": [
                "Callable[([], Any)]"
            ],
            "arguments": {
                "low": [
                    "float",
                    "int"
                ],
                "high": [
                    "float",
                    "int"
                ]
            }
        },
        "HyperparameterSearch.__init__": {
            "name": "__init__",
            "location": 47,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "HyperparameterSearch.parse": {
            "name": "parse",
            "location": 53,
            "return": [
                "int",
                "Callable",
                "str",
                "float",
                "None",
                "dict[typing.Any, int]",
                "typing.Counter"
            ],
            "arguments": {
                "self": [],
                "val": [
                    "Mapping[str, Any]",
                    "Iterable[Any]"
                ]
            }
        },
        "HyperparameterSearch.sample": {
            "name": "sample",
            "location": 76,
            "return": [
                "dict"
            ],
            "arguments": {
                "self": []
            }
        },
        "HyperparameterSearch.update_environment": {
            "name": "update_environment",
            "location": 82,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "sample": [
                    "dict",
                    "dict[, ]",
                    "Dict[str, str]",
                    "dict[str, str]",
                    "Dict[str, Dict[str, Any]]",
                    "dict[str, dict[str, typing.Any]]",
                    "Dict[str, int]",
                    "dict[str, int]"
                ]
            }
        }
    },
    "vampire-master/environments/__init__.py": {},
    "vampire-master/scripts/preprocess_data.py": {
        "load_data": {
            "name": "load_data",
            "location": 19,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "data_path": [
                    "str"
                ],
                "tokenize": [
                    "bool"
                ],
                "tokenizer_type": [
                    "str"
                ]
            }
        },
        "main": {
            "name": "main",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "write_list_to_file": {
            "name": "write_list_to_file",
            "location": 127,
            "return": [
                "None"
            ],
            "arguments": {
                "ls": [
                    "str",
                    "int",
                    "bool"
                ],
                "save_path": [
                    "str",
                    "bytes",
                    "Iterable[str]"
                ]
            }
        }
    },
    "vampire-master/scripts/train.py": {
        "main": {
            "name": "main",
            "location": 17,
            "return": [
                "None"
            ],
            "arguments": {}
        },
        "main.append_seed_to_config": {
            "name": "append_seed_to_config",
            "location": 64,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "seed": [
                    "argparse.Namespace",
                    "Callable",
                    "Dict[str, Any]",
                    "Callable[..., None]"
                ],
                "serialization_dir": [
                    "Dict[str, Any]",
                    "str",
                    "List[str]",
                    "bool"
                ]
            }
        }
    },
    "vampire-master/scripts/verify.py": {
        "main": {
            "name": "main",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "arguments": [
                    "str",
                    "int"
                ]
            }
        }
    },
    "vampire-master/scripts/__init__.py": {},
    "vampire-master/scripts/figures/curve_plot.py": {},
    "vampire-master/scripts/figures/misc.py": {},
    "vampire-master/scripts/figures/regplot.py": {},
    "vampire-master/vampire/__init__.py": {},
    "vampire-master/vampire/common/allennlp_bridge.py": {
        "ExtendedVocabulary.from_files": {
            "name": "from_files",
            "location": 29,
            "return": [
                "str",
                "list[]",
                "typing.Sequence[str]",
                "dict[str, str]",
                "int"
            ],
            "arguments": {
                "cls": [
                    "type",
                    "str",
                    "typing.Type",
                    "Optional[str]",
                    "None",
                    "Union[int, bytes]",
                    "int",
                    "Mapping[str, T]",
                    "bytes",
                    "Dict[str, Iterable[Any]]",
                    "typing.Mapping",
                    "dict[str, typing.Iterable[typing.Any]]"
                ],
                "directory": [
                    "str"
                ]
            }
        },
        "ExtendedVocabulary.save_to_files": {
            "name": "save_to_files",
            "location": 61,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "directory": [
                    "str"
                ]
            }
        },
        "VocabularyWithPretrainedVAE.from_params": {
            "name": "from_params",
            "location": 96,
            "return": [
                "str",
                "Callable",
                "Callable[[None, None], bool]"
            ],
            "arguments": {
                "cls": [
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ],
                "params": [
                    "dict[, ]",
                    "dict[str, str]",
                    "allennlp.common.params.Params",
                    "dict",
                    "str",
                    "Dict[str, str]",
                    "bool"
                ],
                "instances": [
                    "str",
                    "None",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        }
    },
    "vampire-master/vampire/common/util.py": {
        "compute_background_log_frequency": {
            "name": "compute_background_log_frequency",
            "location": 13,
            "return": [
                "\"ImmutableSet[T]\"",
                "str",
                "Optional[str]",
                "Tuple[str]"
            ],
            "arguments": {
                "vocab": [
                    "numpy.ndarray",
                    "os.PathLike",
                    "Union[str, TextIO]"
                ],
                "vocab_namespace": [
                    "str"
                ],
                "precomputed_bg_file": [
                    "str",
                    "Optional[str]",
                    "None",
                    "Callable[[numpy.ndarray], numpy.ndarray]",
                    "Optional[Sequence[str]]"
                ]
            }
        },
        "log_standard_categorical": {
            "name": "log_standard_categorical",
            "location": 40,
            "return": [
                "str",
                "numpy.ndarray",
                "List[bytes]",
                "Iterable[float]",
                "int",
                "float"
            ],
            "arguments": {
                "logits": [
                    "str",
                    "float"
                ]
            }
        },
        "separate_labeled_unlabeled_instances": {
            "name": "separate_labeled_unlabeled_instances",
            "location": 58,
            "return": [
                "Tuple[(Dict[(str, Any)], Dict[(str, Any)])]"
            ],
            "arguments": {
                "text": [
                    "str",
                    "list[str]",
                    "List[str]",
                    "int"
                ],
                "classifier_text": [
                    "str",
                    "bytes",
                    "int"
                ],
                "label": [
                    "str",
                    "int"
                ],
                "metadata": [
                    "List[Dict[(str, Any)]]"
                ]
            }
        },
        "schedule": {
            "name": "schedule",
            "location": 83,
            "return": [
                "float",
                "int",
                "str",
                "torch.FloatTensor",
                "T"
            ],
            "arguments": {
                "batch_num": [
                    "float",
                    "str",
                    "int",
                    "Union[float, int]"
                ],
                "anneal_type": [
                    "typing.Text",
                    "bool",
                    "int",
                    "Callable[[int], Any]",
                    "Callable[[str], Any]",
                    "Optional[Any]"
                ]
            }
        },
        "makedirs": {
            "name": "makedirs",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "directory": [
                    "str",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "write_to_json": {
            "name": "write_to_json",
            "location": 104,
            "return": [
                "None"
            ],
            "arguments": {
                "data": [
                    "str",
                    "bytes",
                    "bool"
                ],
                "output_filename": [
                    "str",
                    "Union[bytes, str]",
                    "bytes"
                ],
                "indent": [
                    "int",
                    "str",
                    "bytes",
                    "bool"
                ],
                "sort_keys": [
                    "bool",
                    "str",
                    "bytes"
                ]
            }
        },
        "read_json": {
            "name": "read_json",
            "location": 109,
            "return": [
                "str",
                "Optional[float]",
                "int",
                "List[Dict[str, Any]]",
                "Dict[str, str]",
                "bool"
            ],
            "arguments": {
                "input_filename": [
                    "str",
                    "List[str]",
                    "int",
                    "list[str]",
                    "Callable[[str], str]",
                    "typing.Callable[str, str]"
                ]
            }
        },
        "read_jsonlist": {
            "name": "read_jsonlist",
            "location": 115,
            "return": [
                "list"
            ],
            "arguments": {
                "input_filename": [
                    "str",
                    "List[str]",
                    "int",
                    "list[str]",
                    "Callable[[str], str]",
                    "typing.Callable[str, str]"
                ]
            }
        },
        "write_jsonlist": {
            "name": "write_jsonlist",
            "location": 123,
            "return": [
                "None"
            ],
            "arguments": {
                "list_of_json_objects": [
                    "str",
                    "bool",
                    "Sequence[str]",
                    "Optional[str]"
                ],
                "output_filename": [
                    "str",
                    "float",
                    "Optional[List[str]]",
                    "list[str]",
                    "Union[int, str]",
                    "None",
                    "int"
                ],
                "sort_keys": [
                    "bool",
                    "str",
                    "Optional[str]",
                    "Set[str]",
                    "Pattern"
                ]
            }
        },
        "pickle_data": {
            "name": "pickle_data",
            "location": 129,
            "return": [
                "None"
            ],
            "arguments": {
                "data": [
                    "bytes",
                    "int",
                    "Callable",
                    "typing.Callable[, ]",
                    "Optional[bytes]",
                    "None",
                    "Optional[str]",
                    "str",
                    "Dict[str, Any]",
                    "dict[str, typing.Any]"
                ],
                "output_filename": [
                    "str",
                    "int"
                ]
            }
        },
        "unpickle_data": {
            "name": "unpickle_data",
            "location": 134,
            "return": [
                "Dict[str, List[int]]",
                "dict",
                "str",
                "Optional[float]",
                "bytes"
            ],
            "arguments": {
                "input_filename": [
                    "str"
                ]
            }
        },
        "read_text": {
            "name": "read_text",
            "location": 140,
            "return": [
                "List[str]"
            ],
            "arguments": {
                "input_filename": [
                    "str",
                    "bool"
                ]
            }
        },
        "write_list_to_text": {
            "name": "write_list_to_text",
            "location": 146,
            "return": [
                "None"
            ],
            "arguments": {
                "lines": [
                    "str"
                ],
                "output_filename": [
                    "str",
                    "bool",
                    "float",
                    "Optional[List[str]]",
                    "list[str]",
                    "Union[int, str]",
                    "None"
                ],
                "add_newlines": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any, Any]]",
                    "str"
                ],
                "add_final_newline": [
                    "bool",
                    "int",
                    "Optional[str]",
                    "Optional[Union[Any, Any]]",
                    "str"
                ]
            }
        },
        "save_sparse": {
            "name": "save_sparse",
            "location": 160,
            "return": [
                "None"
            ],
            "arguments": {
                "sparse_matrix": [
                    "int",
                    "bytes",
                    "torch.utils.data.DataLoader",
                    "bool",
                    "Iterable[Iterable]",
                    "Iterable"
                ],
                "output_filename": [
                    "int",
                    "str",
                    "Optional[str]",
                    "None"
                ]
            }
        },
        "load_sparse": {
            "name": "load_sparse",
            "location": 173,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "input_filename": [
                    "str",
                    "dict",
                    "dict[, ]"
                ]
            }
        }
    },
    "vampire-master/vampire/common/__init__.py": {},
    "vampire-master/vampire/common/testing/test_case.py": {
        "VAETestCase.setUp": {
            "name": "setUp",
            "location": 36,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VAETestCase.set_up_model": {
            "name": "set_up_model",
            "location": 51,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "param_file": [
                    "str",
                    "pathlib.Path",
                    "Callable[[float], None]"
                ],
                "dataset_file": [
                    "int",
                    "pathlib.Path",
                    "bool",
                    "str"
                ]
            }
        },
        "VAETestCase.ensure_model_can_train_save_and_load": {
            "name": "ensure_model_can_train_save_and_load",
            "location": 75,
            "return": [
                "Tuple[(Any, Any)]"
            ],
            "arguments": {
                "self": [],
                "param_file": [
                    "str"
                ],
                "tolerance": [
                    "float"
                ],
                "cuda_device": [
                    "int"
                ],
                "gradients_to_ignore": [
                    "Set[str]"
                ],
                "overrides": [
                    "str"
                ]
            }
        },
        "VAETestCase.assert_fields_equal": {
            "name": "assert_fields_equal",
            "location": 181,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "field1": [
                    "str",
                    "float"
                ],
                "field2": [
                    "str",
                    "float"
                ],
                "name": [
                    "str"
                ],
                "tolerance": [
                    "float"
                ]
            }
        },
        "VAETestCase.check_model_computes_gradients_correctly": {
            "name": "check_model_computes_gradients_correctly",
            "location": 210,
            "return": [
                "None"
            ],
            "arguments": {
                "model": [
                    "str",
                    "Dict[str, Dict[str, str]]",
                    "dict"
                ],
                "model_batch": [
                    "Dict[(str, Any)]"
                ],
                "params_to_ignore": [
                    "Set[str]"
                ]
            }
        },
        "VAETestCase.ensure_batch_predictions_are_consistent": {
            "name": "ensure_batch_predictions_are_consistent",
            "location": 242,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "keys_to_ignore": [
                    "Iterable[str]"
                ]
            }
        },
        "VAETestCase.tearDown": {
            "name": "tearDown",
            "location": 286,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "vampire-master/vampire/common/testing/__init__.py": {},
    "vampire-master/vampire/data/__init__.py": {},
    "vampire-master/vampire/data/dataset_readers/semisupervised_text_classification_json.py": {
        "SemiSupervisedTextClassificationJsonReader.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "token_indexers": [
                    "bool",
                    "None",
                    "int",
                    "dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "dict[str, int]",
                    "allennlp.data.tokenizers.Tokenizer",
                    "Dict[str, int]"
                ],
                "tokenizer": [
                    "bool",
                    "None",
                    "int",
                    "dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "dict[str, int]",
                    "allennlp.data.tokenizers.Tokenizer",
                    "Dict[str, int]"
                ],
                "max_sequence_length": [
                    "bool",
                    "None",
                    "int",
                    "dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "dict[str, int]",
                    "allennlp.data.tokenizers.Tokenizer",
                    "Dict[str, int]"
                ],
                "ignore_labels": [
                    "bool",
                    "numpy.ndarray",
                    "str",
                    "Optional[float]",
                    "List[numpy.ndarray]",
                    "List[str]"
                ],
                "sample": [
                    "application.domain.common.TenantProvider",
                    "None"
                ],
                "skip_label_indexing": [
                    "bool",
                    "int",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "allennlp.data.tokenizers.Tokenizer",
                    "Dict[str, int]"
                ],
                "lazy": [
                    "bool",
                    "int",
                    "Dict[str, allennlp.data.token_indexers.TokenIndexer]",
                    "allennlp.data.tokenizers.Tokenizer",
                    "Dict[str, int]"
                ]
            }
        },
        "SemiSupervisedTextClassificationJsonReader._reservoir_sampling": {
            "name": "_reservoir_sampling",
            "location": 87,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "file_": [
                    "bool",
                    "List[str]",
                    "list[str]",
                    "Optional[str]",
                    "str",
                    "None"
                ],
                "sample": [
                    "int",
                    "bytes"
                ]
            }
        },
        "SemiSupervisedTextClassificationJsonReader._read": {
            "name": "_read",
            "location": 129,
            "return": [
                "",
                "typing.Generator[]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "SemiSupervisedTextClassificationJsonReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 145,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "text": [
                    "str"
                ],
                "label": [
                    "str",
                    "None",
                    "Union[str, int]",
                    "Optional[Union[Any, Any]]",
                    "int",
                    "Optional[str]",
                    "typing.Any"
                ]
            }
        }
    },
    "vampire-master/vampire/data/dataset_readers/vampire_reader.py": {
        "VampireReader.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "lazy": [
                    "bool",
                    "denite.util.Nvim",
                    "deoplete.util.Nvim",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ],
                "sample": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ],
                "min_sequence_length": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "VampireReader._read": {
            "name": "_read",
            "location": 46,
            "return": [
                "",
                "typing.Generator[list[]]"
            ],
            "arguments": {
                "self": [],
                "file_path": [
                    "str"
                ]
            }
        },
        "VampireReader.text_to_instance": {
            "name": "text_to_instance",
            "location": 64,
            "return": [
                "Instance",
                "List[str]",
                "List[Tuple[str, str]]",
                "str",
                "Set[str]",
                "List[Tuple[str, Any]]"
            ],
            "arguments": {
                "self": [],
                "vec": [
                    "List[str]",
                    "None",
                    "List[Tuple[str, str]]",
                    "list[str]",
                    "str",
                    "list",
                    "list[tuple[typing.Union[str,str]]]",
                    "list[]",
                    "List[int]",
                    "List[shromazdeni.reports.utils.Field]",
                    "list[int]",
                    "list[F]"
                ]
            }
        }
    },
    "vampire-master/vampire/data/dataset_readers/__init__.py": {},
    "vampire-master/vampire/models/classifier.py": {
        "Classifier.__init__": {
            "name": "__init__",
            "location": 22,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "bool",
                    "allennlp.data.Vocabulary",
                    "int"
                ],
                "input_embedder": [
                    "int",
                    "float",
                    "bool"
                ],
                "encoder": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ],
                "dropout": [
                    "int",
                    "None",
                    "float",
                    "bool"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Classifier.forward": {
            "name": "forward",
            "location": 62,
            "return": [
                "dict[typing.Text, typing.Union[int,dict[typing.Any, dict[str, str]],str,dict[int, typing.Any],dict[, ],dict[str, str],list[],list[tuple[typing.Union[typing.Any,typing.Any]]]]]",
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "str"
                ],
                "label": [
                    "Collection[int]",
                    "None",
                    "torch.Tensor",
                    "typing.Collection",
                    "Union[str, Callable[[], str]]",
                    "str",
                    "typing.Callable[[], str]"
                ]
            }
        },
        "Classifier.get_metrics": {
            "name": "get_metrics",
            "location": 108,
            "return": [
                "dict[typing.Text, ]",
                "str",
                "bool"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "str",
                    "dict",
                    "Optional[int]"
                ]
            }
        }
    },
    "vampire-master/vampire/models/vampire.py": {
        "VAMPIRE.__init__": {
            "name": "__init__",
            "location": 69,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "int",
                    "str",
                    "float",
                    "typing.Iterable[str]",
                    "bool",
                    "Union[Iterable[str], str]"
                ],
                "bow_embedder": [
                    "int",
                    "float",
                    "bool"
                ],
                "vae": [
                    "int",
                    "float",
                    "bool"
                ],
                "kl_weight_annealing": [
                    "str",
                    "typing.Text"
                ],
                "linear_scaling": [
                    "float",
                    "int",
                    "Union[float, int]",
                    "str",
                    "Union[str, type]",
                    "Union[float, Tuple[float, float]]",
                    "Tuple[int]"
                ],
                "sigmoid_weight_1": [
                    "float",
                    "int",
                    "Union[float, int]",
                    "str",
                    "Union[str, type]",
                    "Union[float, Tuple[float, float]]",
                    "Tuple[int]"
                ],
                "sigmoid_weight_2": [
                    "int",
                    "Union[float, int]",
                    "str",
                    "float",
                    "Union[str, type]",
                    "Union[float, Tuple[float, float]]",
                    "Tuple[int]"
                ],
                "reference_counts": [
                    "int",
                    "None"
                ],
                "reference_vocabulary": [
                    "int",
                    "str",
                    "None",
                    "Optional[IO[str]]",
                    "typing.IO"
                ],
                "background_data_path": [
                    "str",
                    "None",
                    "Optional[Iterable[Any]]",
                    "typing.Iterable[typing.Any]"
                ],
                "update_background_freq": [
                    "bool",
                    "List[List[int]]",
                    "bytes",
                    "Dict[str, str]",
                    "List[str]"
                ],
                "track_topics": [
                    "bool",
                    "int",
                    "float"
                ],
                "track_npmi": [
                    "bool",
                    "int",
                    "float"
                ],
                "initializer": [
                    "InitializerApplicator",
                    "int",
                    "bool",
                    "float"
                ],
                "regularizer": [
                    "None",
                    "bool",
                    "denite.util.Nvim",
                    "dict[str, typing.Any]",
                    "deoplete.util.Nvim",
                    "typing.Callable[A, bool]",
                    "Dict[str, Any]",
                    "Callable[[Any, Any], bool]"
                ]
            }
        },
        "VAMPIRE.initialize_bg_from_file": {
            "name": "initialize_bg_from_file",
            "location": 148,
            "return": [
                "float"
            ],
            "arguments": {
                "self": [],
                "file_": [
                    "str",
                    "None",
                    "int",
                    "bool",
                    "Optional[str]"
                ]
            }
        },
        "VAMPIRE.bow_reconstruction_loss": {
            "name": "bow_reconstruction_loss",
            "location": 161,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "reconstructed_bow": [
                    "str",
                    "bytes"
                ],
                "target_bow": [
                    "str",
                    "bool",
                    "float",
                    "Union[int, float]",
                    "Optional[str]"
                ]
            }
        },
        "VAMPIRE.update_kld_weight": {
            "name": "update_kld_weight",
            "location": 182,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch_num": [
                    "str",
                    "int",
                    "bool",
                    "Union[str, float]"
                ]
            }
        },
        "VAMPIRE.update_topics": {
            "name": "update_topics",
            "location": 209,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "epoch_num": [
                    "str",
                    "int",
                    "bool",
                    "Union[str, float]"
                ]
            }
        },
        "VAMPIRE.update_npmi": {
            "name": "update_npmi",
            "location": 236,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VAMPIRE.extract_topics": {
            "name": "extract_topics",
            "location": 254,
            "return": [
                "list[tuple[typing.Union[typing.Text,tuple[int],list[],dict[str, int],dict[, ],frozenset]]]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "weights": [
                    "int",
                    "Sequence",
                    "common.SVGBoundaries",
                    "str"
                ],
                "k": [
                    "int",
                    "str",
                    "numpy.ndarray",
                    "float"
                ]
            }
        },
        "VAMPIRE.generate_npmi_vals": {
            "name": "generate_npmi_vals",
            "location": 295,
            "return": [
                "tuple[]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "interactions": [
                    "bool",
                    "numpy.matrix",
                    "int",
                    "list"
                ],
                "document_sums": [
                    "int",
                    "numpy.array",
                    "bool"
                ]
            }
        },
        "VAMPIRE.compute_npmi": {
            "name": "compute_npmi",
            "location": 324,
            "return": [
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "topics": [
                    "int",
                    "gluonts.model.forecasForecast",
                    "numpy.ndarray"
                ],
                "num_words": [
                    "int",
                    "Optional[int]"
                ]
            }
        },
        "VAMPIRE.freeze_weights": {
            "name": "freeze_weights",
            "location": 359,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "VAMPIRE.forward": {
            "name": "forward",
            "location": 368,
            "return": [
                "dict[typing.Text, str]",
                "Dict[str, Any]",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "bool",
                    "dict",
                    "dict[, ]"
                ],
                "epoch_num": [
                    "int",
                    "None",
                    "float",
                    "Dict[str, int]",
                    "str",
                    "dict[str, int]",
                    "Mapping[str, Any]",
                    "Tuple[int, int, int]",
                    "typing.Mapping",
                    "tuple[typing.Union[int,int,int]]"
                ]
            }
        },
        "VAMPIRE.get_metrics": {
            "name": "get_metrics",
            "location": 441,
            "return": [
                "dict[, float]",
                "str",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "reset": [
                    "bool",
                    "deoplete.util.UserContext",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "vampire-master/vampire/models/__init__.py": {},
    "vampire-master/vampire/modules/encoder.py": {
        "Encoder.__init__": {
            "name": "__init__",
            "location": 20,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "architecture": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "Encoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 24,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Encoder.forward": {
            "name": "forward",
            "location": 27,
            "return": [
                "torch.FloatTensor",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "MLP.__init__": {
            "name": "__init__",
            "location": 33,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "architecture": [
                    "str",
                    "bool",
                    "dict[, ]",
                    "apps.common.coininfo.CoinInfo",
                    "Union[str, dict]"
                ]
            }
        },
        "MLP.forward": {
            "name": "forward",
            "location": 38,
            "return": [
                "Iterable[int]"
            ],
            "arguments": {
                "self": []
            }
        },
        "MaxPoolEncoder.__init__": {
            "name": "__init__",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "embedding_dim": [
                    "int",
                    "float",
                    "bool"
                ]
            }
        },
        "MaxPoolEncoder.get_input_dim": {
            "name": "get_input_dim",
            "location": 48,
            "return": [
                "str",
                "bool"
            ],
            "arguments": {
                "self": []
            }
        },
        "MaxPoolEncoder.get_output_dim": {
            "name": "get_output_dim",
            "location": 51,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "MaxPoolEncoder.forward": {
            "name": "forward",
            "location": 54,
            "return": [
                "str",
                "int",
                "Callable[[Mapping], T]",
                "List[int]"
            ],
            "arguments": {
                "self": [],
                "tokens": [
                    "List[allennlp.data.tokenizers.token.Token]",
                    "str",
                    "int",
                    "Sequence[Sequence[str]]",
                    "Sequence[str]"
                ],
                "mask": [
                    "str",
                    "int",
                    "list[int]",
                    "allennlp.models.semantic_parsing.nlvr.nlvr_decoder_state.NlvrDecoderState",
                    "List[int]"
                ]
            }
        },
        "Seq2Vec.__init__": {
            "name": "__init__",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "architecture": [
                    "str",
                    "bytes",
                    "apps.common.coininfo.CoinInfo",
                    "typing.Iterable[str]",
                    "Iterable[str]"
                ]
            }
        },
        "Seq2Vec.forward": {
            "name": "forward",
            "location": 69,
            "return": [],
            "arguments": {
                "self": []
            }
        },
        "Seq2Seq.__init__": {
            "name": "__init__",
            "location": 76,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "architecture": [
                    "str",
                    "bytes",
                    "apps.common.coininfo.CoinInfo",
                    "typing.Iterable[str]",
                    "Iterable[str]"
                ],
                "aggregations": [
                    "int",
                    "bool",
                    "float"
                ]
            }
        },
        "Seq2Seq.get_output_dim": {
            "name": "get_output_dim",
            "location": 85,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "Seq2Seq.forward": {
            "name": "forward",
            "location": 89,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "vampire-master/vampire/modules/pretrained_vae.py": {
        "_PretrainedVAE.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_archive": [
                    "str"
                ],
                "device": [
                    "int"
                ],
                "background_frequency": [
                    "str"
                ],
                "requires_grad": [
                    "bool"
                ]
            }
        },
        "PretrainedVAE.__init__": {
            "name": "__init__",
            "location": 37,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_archive": [
                    "str"
                ],
                "device": [
                    "int"
                ],
                "background_frequency": [
                    "str"
                ],
                "requires_grad": [
                    "bool"
                ],
                "scalar_mix": [
                    "List[int]"
                ],
                "dropout": [
                    "float"
                ]
            }
        },
        "PretrainedVAE.get_output_dim": {
            "name": "get_output_dim",
            "location": 68,
            "return": [
                "int"
            ],
            "arguments": {
                "self": []
            }
        },
        "PretrainedVAE.forward": {
            "name": "forward",
            "location": 73,
            "return": [
                "dict[typing.Text, typing.Union[bytes,str,frozenset]]",
                "int",
                "Callable",
                "models.Question",
                "str"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bool",
                    "str",
                    "torch.Tensor",
                    "models.characters.states.StatusEffect"
                ]
            }
        },
        "PretrainedVAE.from_params": {
            "name": "from_params",
            "location": 103,
            "return": [
                "PretrainedVAE"
            ],
            "arguments": {
                "cls": [
                    "Type[_TPretrainedVAE]"
                ],
                "params": [
                    "Optional[str]",
                    "str",
                    "allennlp.common.params.Params",
                    "NamedTuple"
                ]
            }
        }
    },
    "vampire-master/vampire/modules/__init__.py": {},
    "vampire-master/vampire/modules/token_embedders/vampire_token_embedder.py": {
        "VampireTokenEmbedder.__init__": {
            "name": "__init__",
            "location": 41,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "model_archive": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "device": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "background_frequency": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "scalar_mix": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "dropout": [
                    "bool",
                    "None",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "requires_grad": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ],
                "projection_dim": [
                    "List[int]",
                    "str",
                    "None",
                    "list[int]"
                ],
                "expand_dim": [
                    "bool",
                    "int",
                    "Optional[Union[\"IPUtilityFunction\", \"UtilityDistribution\"]]"
                ]
            }
        },
        "VampireTokenEmbedder.get_output_dim": {
            "name": "get_output_dim",
            "location": 67,
            "return": [
                "str",
                "bool",
                "bytes"
            ],
            "arguments": {
                "self": []
            }
        },
        "VampireTokenEmbedder.forward": {
            "name": "forward",
            "location": 70,
            "return": [
                "int",
                "str",
                "Callable",
                "list[str]",
                "float",
                "frozenset"
            ],
            "arguments": {
                "self": [],
                "inputs": [
                    "bytes",
                    "torch.LongTensor",
                    "int",
                    "str",
                    "tuple[typing.Union[int,slice,int,slice]]",
                    "Tuple[Union[int, slice], Union[int, slice]]",
                    "list[]",
                    "list"
                ]
            }
        },
        "VampireTokenEmbedder.from_params": {
            "name": "from_params",
            "location": 99,
            "return": [
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "cls": [
                    "dict[str, typing.Any]",
                    "allennlp.common.Params",
                    "Dict[str, Any]"
                ],
                "vocab": [
                    "int",
                    "dict[str, typing.Any]",
                    "allennlp.data.Vocabulary",
                    "bool",
                    "Dict[str, Any]",
                    "allennlp.common.Params"
                ],
                "params": [
                    "allennlp.common.params.Params",
                    "str",
                    "dict",
                    "Dict[str, Any]"
                ]
            }
        }
    },
    "vampire-master/vampire/modules/token_embedders/__init__.py": {},
    "vampire-master/vampire/modules/vae/logistic_normal.py": {
        "LogisticNormal.__init__": {
            "name": "__init__",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "bool",
                    "int"
                ],
                "encoder": [
                    "bool",
                    "Optional[Any]",
                    "typing.Any",
                    "Callable[[str], bool]",
                    "None",
                    "int",
                    "typing.Callable[str, bool]",
                    "Union[float, Tuple[float, float]]",
                    "float",
                    "tuple[typing.Union[float,float]]"
                ],
                "mean_projection": [
                    "bool",
                    "int",
                    "Optional[float]"
                ],
                "log_variance_projection": [
                    "str",
                    "bool",
                    "List[Dict]",
                    "list[dict[, ]]"
                ],
                "decoder": [
                    "Optional[float]",
                    "allennlp.modules.FeedForward"
                ],
                "kld_clamp": [
                    "bool",
                    "None",
                    "Optional[Any]",
                    "Callable[[str], bool]",
                    "typing.Any",
                    "int",
                    "typing.Callable[str, bool]",
                    "Union[float, Tuple[float, float]]",
                    "float",
                    "tuple[typing.Union[float,float]]"
                ],
                "z_dropout": [
                    "float",
                    "bool",
                    "Optional[Any]",
                    "Callable[[str], bool]",
                    "int",
                    "Union[float, Tuple[float, float]]"
                ]
            }
        },
        "LogisticNormal.forward": {
            "name": "forward",
            "location": 35,
            "return": [
                "str",
                "int",
                "Optional[str]"
            ],
            "arguments": {
                "self": [],
                "input_repr": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "LogisticNormal.estimate_params": {
            "name": "estimate_params",
            "location": 56,
            "return": [
                "dict[typing.Text, typing.Union[int,str,typing.Final,float,list[],tuple[typing.Union[typing.Any,int]],list[list[int]]]]",
                "Callable",
                "torch.Tensor",
                "Optional[torch.Tensor]",
                "torch.nn.utils.rnn.PackedSequence",
                "torch.FloatTensor",
                "str",
                "Dict[str, Any]"
            ],
            "arguments": {
                "self": [],
                "input_repr": [
                    "str",
                    "bool",
                    "List[str]",
                    "list[str]"
                ]
            }
        },
        "LogisticNormal.compute_negative_kld": {
            "name": "compute_negative_kld",
            "location": 70,
            "return": [
                "float",
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "str",
                    "dict",
                    "bool",
                    "Dict[str, Any]",
                    "Dict[str, str]"
                ]
            }
        },
        "LogisticNormal.generate_latent_code": {
            "name": "generate_latent_code",
            "location": 84,
            "return": [
                "dict[typing.Text, typing.Union[str,list[str]]]",
                "Optional[str]",
                "str",
                "IO[Any]",
                "Callable"
            ],
            "arguments": {
                "self": [],
                "input_repr": [
                    "str",
                    "Optional[str]",
                    "None",
                    "IO[Any]",
                    "typing.IO",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "LogisticNormal.encode": {
            "name": "encode",
            "location": 125,
            "return": [
                "int",
                "Callable",
                "str"
            ],
            "arguments": {
                "self": [],
                "input_vector": [
                    "int",
                    "str",
                    "Callable",
                    "typing.Callable[, ]"
                ]
            }
        },
        "LogisticNormal.get_beta": {
            "name": "get_beta",
            "location": 129,
            "return": [
                "int",
                "bytes",
                "str"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "vampire-master/vampire/modules/vae/vae.py": {
        "VAE.__init__": {
            "name": "__init__",
            "location": 7,
            "return": [
                "None"
            ],
            "arguments": {
                "self": [],
                "vocab": [
                    "str",
                    "bool",
                    "Union[str, dict]",
                    "dict[, ]"
                ]
            }
        },
        "VAE.estimate_params": {
            "name": "estimate_params",
            "location": 10,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "input_repr": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "VAE.compute_negative_kld": {
            "name": "compute_negative_kld",
            "location": 26,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "params": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        },
        "VAE.generate_latent_code": {
            "name": "generate_latent_code",
            "location": 32,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "input_repr": [
                    "list[tuple[typing.Union[int,int,str]]]",
                    "torch.Tensor",
                    "List[Tuple[int, int, str]]"
                ]
            }
        },
        "VAE.get_beta": {
            "name": "get_beta",
            "location": 57,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": []
            }
        },
        "VAE.encode": {
            "name": "encode",
            "location": 65,
            "return": [
                "NoReturn"
            ],
            "arguments": {
                "self": [],
                "input_vector": [
                    "int",
                    "str",
                    "typing.Iterable['Context']",
                    "Iterable['Context']",
                    "dict",
                    "bool"
                ]
            }
        }
    },
    "vampire-master/vampire/modules/vae/__init__.py": {},
    "vampire-master/vampire/tests/__init__.py": {},
    "vampire-master/vampire/tests/data/dataset_readers/semisupervised_text_classification_json_test.py": {
        "TestSemiSupervisedTextClassificationJsonReader.test_read_from_file": {
            "name": "test_read_from_file",
            "location": 14,
            "return": [
                "",
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSemiSupervisedTextClassificationJsonReader.test_read_from_file_and_truncates_properly": {
            "name": "test_read_from_file_and_truncates_properly",
            "location": 99,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSemiSupervisedTextClassificationJsonReader.test_samples_properly": {
            "name": "test_samples_properly",
            "location": 124,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSemiSupervisedTextClassificationJsonReader.test_sampling_fails_when_sample_size_larger_than_file_size": {
            "name": "test_sampling_fails_when_sample_size_larger_than_file_size",
            "location": 138,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSemiSupervisedTextClassificationJsonReader.test_samples_according_to_seed_properly": {
            "name": "test_samples_according_to_seed_properly",
            "location": 145,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestSemiSupervisedTextClassificationJsonReader.test_ignores_label_properly": {
            "name": "test_ignores_label_properly",
            "location": 173,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "vampire-master/vampire/tests/models/classifier_test.py": {
        "TestClassifiers.setUp": {
            "name": "setUp",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClassifiers.test_seq2seq_clf_with_vae_token_embedder_can_train_save_and_load": {
            "name": "test_seq2seq_clf_with_vae_token_embedder_can_train_save_and_load",
            "location": 16,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClassifiers.test_seq2seq_clf_with_vae_token_embedder_batch_predictions_are_consistent": {
            "name": "test_seq2seq_clf_with_vae_token_embedder_batch_predictions_are_consistent",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClassifiers.test_seq2vec_clf_with_vae_token_embedder_can_train_save_and_load": {
            "name": "test_seq2vec_clf_with_vae_token_embedder_can_train_save_and_load",
            "location": 26,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClassifiers.test_seq2seq_clf_with_vae_token_embedder_forward_pass_runs_correctly": {
            "name": "test_seq2seq_clf_with_vae_token_embedder_forward_pass_runs_correctly",
            "location": 32,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestClassifiers.test_seq2vec_clf_with_vae_token_embedder_forward_pass_runs_correctly": {
            "name": "test_seq2vec_clf_with_vae_token_embedder_forward_pass_runs_correctly",
            "location": 43,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "vampire-master/vampire/tests/models/vampire_test.py": {
        "TestVampire.setUp": {
            "name": "setUp",
            "location": 13,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampire.test_model_can_train_save_and_load_unsupervised": {
            "name": "test_model_can_train_save_and_load_unsupervised",
            "location": 18,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampire.test_npmi_computed_correctly": {
            "name": "test_npmi_computed_correctly",
            "location": 21,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    },
    "vampire-master/vampire/tests/modules/token_embedders/vampire_token_embedder_test.py": {
        "TestVampireTokenEmbedder.setUp": {
            "name": "setUp",
            "location": 12,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampireTokenEmbedder.test_forward_works_with_encoder_output_and_projection": {
            "name": "test_forward_works_with_encoder_output_and_projection",
            "location": 15,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampireTokenEmbedder.test_forward_encoder_output_with_expansion_works": {
            "name": "test_forward_encoder_output_with_expansion_works",
            "location": 38,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampireTokenEmbedder.test_projection_works_with_encoder_weight_representations": {
            "name": "test_projection_works_with_encoder_weight_representations",
            "location": 64,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampireTokenEmbedder.test_forward_works_with_encoder_weight_and_projection": {
            "name": "test_forward_works_with_encoder_weight_and_projection",
            "location": 88,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        },
        "TestVampireTokenEmbedder.test_forward_works_with_encoder_output_expand_and_projection": {
            "name": "test_forward_works_with_encoder_output_expand_and_projection",
            "location": 112,
            "return": [
                "None"
            ],
            "arguments": {
                "self": []
            }
        }
    }
}